{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS\n\n\nLaxarJS helps to create maintainable AngularJS apps by assembling them from small, isolated parts.\nThink of it as \nmiddleware for your web client\n.\n\n\nWhy LaxarJS?\n\n\nFind out \nwhy\n you would use LaxarJS and if it's the right tool for you.\nThen, explore the \ncore concepts\n and browse the \nmanuals\n in the \ndocumentation\n.\n\n\nHave a look at the \nLaxarJS homepage\n for demos and more information.\n\n\nGetting Started\n\n\nThe following is a very minimal getting started guide.\nIt helps you to set up your first LaxarJS application and to create your first LaxarJS widget.\n\n\nGet the Prerequisites\n\n\nThe node package manager \nnpm\n is required to get started with LaxarJS.\nFirst we use it to obtain some basic development tools (\ngrunt-cli\n and \ngrunt-init\n), as well as templates for the main LaxarJS artifact types:\n\n\nnpm install -g grunt-cli grunt-init\ngit clone https://github.com/LaxarJS/grunt-init-laxar-application.git ~/.grunt-init/laxar-application\ngit clone https://github.com/LaxarJS/grunt-init-laxar-widget.git ~/.grunt-init/laxar-widget\ngit clone https://github.com/LaxarJS/grunt-init-laxar-activity.git ~/.grunt-init/laxar-activity\n\n\n\n\n\nNote that\n, depending on your workstation setup, you might have to use \nsudo\n when running \nnpm install\n with the \n-g\n option.\nMake sure that your \nPATH\n includes the \n.../node_modules/bin\n directory.\nFor additional information and troubleshooting, consult the documentation of \nnpm\n and \ngrunt-init\n respectively. \n\n\nCreate a LaxarJS Application from Our Template\n\n\nThe scaffolding tool \ngrunt-init\n can now be used to create artifacts from the LaxarJS templates:\n\n\nmkdir tryout\n\ncd \ntryout\ngrunt-init laxar-application\nnpm install\nnpm start\n\n\n\n\n\nVisit your empty application at \nhttp://localhost:8000/debug.html\n.\n\n\nPress \nCtrl-C\n to stop the server for now.\n\n\nCreate your first LaxarJS widget\n\n\nCreate a widget which simply displays \nHello, world!\n:\n\n\nmkdir -p includes/widgets/tryout/my_first_widget\n\ncd \nincludes/widgets/tryout/my_first_widget\ngrunt-init laxar-widget\n\n\n\n\n\nAdd some widget-HTML:\n\n\necho\n \nh1\nHello, world!\n/h1\n \n default.theme/my_first_widget.html\n\n\n\n\n\nReference the widget from your page:\n\n\ncd\n -\n\necho\n \n{\n\n\n   \nlayout\n: \none_column\n,\n\n\n   \nareas\n: {\n\n\n      \nactivities\n: [ ],\n\n\n      \nheader\n: [ ],\n\n\n      \ncontent\n: [\n\n\n          {\n\n\n             \nwidget\n: \ntryout/my_first_widget\n\n\n          }\n\n\n      ],\n\n\n      \nfooter\n: [ ]\n\n\n   }\n\n\n}\n\n\n \n application/pages/page1.json\nnpm start\n\n\n\n\n\nSee your widget in action at \nhttp://localhost:8000/debug.html\n\n\nCreate a Compressed Release-Ready Version of Your Application\n\n\nFirst, stop the development server using \nCtrl-C\n.\n\n\ngrunt optimize\nnpm start\n\n\n\n\n\nNow your production-ready application can be visited at \nhttp://localhost:8000/index.html\n.\nYou can also use \ngrunt dist\n to get a zip archive containing the application without development server and build tools.\n\n\nNext Steps\n\n\nHave fun developing your first LaxarJS application.\n\n\nMake sure to have a look at the \nmanuals\n and and check out the demo applications on the \nLaxarJS website\n.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs", 
            "text": "LaxarJS helps to create maintainable AngularJS apps by assembling them from small, isolated parts.\nThink of it as  middleware for your web client .", 
            "title": "LaxarJS"
        }, 
        {
            "location": "/#why-laxarjs", 
            "text": "Find out  why  you would use LaxarJS and if it's the right tool for you.\nThen, explore the  core concepts  and browse the  manuals  in the  documentation .  Have a look at the  LaxarJS homepage  for demos and more information.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/#getting-started", 
            "text": "The following is a very minimal getting started guide.\nIt helps you to set up your first LaxarJS application and to create your first LaxarJS widget.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#get-the-prerequisites", 
            "text": "The node package manager  npm  is required to get started with LaxarJS.\nFirst we use it to obtain some basic development tools ( grunt-cli  and  grunt-init ), as well as templates for the main LaxarJS artifact types:  npm install -g grunt-cli grunt-init\ngit clone https://github.com/LaxarJS/grunt-init-laxar-application.git ~/.grunt-init/laxar-application\ngit clone https://github.com/LaxarJS/grunt-init-laxar-widget.git ~/.grunt-init/laxar-widget\ngit clone https://github.com/LaxarJS/grunt-init-laxar-activity.git ~/.grunt-init/laxar-activity  Note that , depending on your workstation setup, you might have to use  sudo  when running  npm install  with the  -g  option.\nMake sure that your  PATH  includes the  .../node_modules/bin  directory.\nFor additional information and troubleshooting, consult the documentation of  npm  and  grunt-init  respectively.", 
            "title": "Get the Prerequisites"
        }, 
        {
            "location": "/#create-a-laxarjs-application-from-our-template", 
            "text": "The scaffolding tool  grunt-init  can now be used to create artifacts from the LaxarJS templates:  mkdir tryout cd  tryout\ngrunt-init laxar-application\nnpm install\nnpm start  Visit your empty application at  http://localhost:8000/debug.html .  Press  Ctrl-C  to stop the server for now.", 
            "title": "Create a LaxarJS Application from Our Template"
        }, 
        {
            "location": "/#create-your-first-laxarjs-widget", 
            "text": "Create a widget which simply displays  Hello, world! :  mkdir -p includes/widgets/tryout/my_first_widget cd  includes/widgets/tryout/my_first_widget\ngrunt-init laxar-widget  Add some widget-HTML:  echo   h1 Hello, world! /h1    default.theme/my_first_widget.html  Reference the widget from your page:  cd  - echo   {      layout :  one_column ,      areas : {         activities : [ ],         header : [ ],         content : [            {                widget :  tryout/my_first_widget            }        ],         footer : [ ]     }  }     application/pages/page1.json\nnpm start  See your widget in action at  http://localhost:8000/debug.html", 
            "title": "Create your first LaxarJS widget"
        }, 
        {
            "location": "/#create-a-compressed-release-ready-version-of-your-application", 
            "text": "First, stop the development server using  Ctrl-C .  grunt optimize\nnpm start  Now your production-ready application can be visited at  http://localhost:8000/index.html .\nYou can also use  grunt dist  to get a zip archive containing the application without development server and build tools.", 
            "title": "Create a Compressed Release-Ready Version of Your Application"
        }, 
        {
            "location": "/#next-steps", 
            "text": "Have fun developing your first LaxarJS application.  Make sure to have a look at the  manuals  and and check out the demo applications on the  LaxarJS website .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv0.26.0\n\n\n\n\n#172\n: documentation: fixed dead link\n\n\n#166\n: cleanup: removed distribution-related configuration and files\n\n\n#163\n: EventBus: fixed request topic matching\n\n\n\n\nv0.25.0\n\n\n\n\n\n\n#160\n: refactoring: prepared for normalization of AngularJS artifact names (v1.x)\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#156\n: i18n: by default, use relaxed matching for language tags\n\n\n\n\n\n\nv0.24.0\n\n\n\n\n#102\n: testing: deleted deprecated warning of \ntestBed.useWidgetJson\n\n\n#157\n: portal: angular-adapter: fixed error reporting\n\n\n#145\n: testing: added missing cancel-method to mock-$timeout\n\n\n#155\n: visibility: page controller now unsubscribes on tear-down\n\n\n#152\n: documentation: added widget installation manual\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv0.23.0\n\n\n\n\n\n\n#153\n: portal: angular-adapter: simplified widget and controller naming\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#151\n: EventBus: fixed cycle count for zero subscribers\n\n\n\n\n#148\n: documentation: more detailed information on the event bus, link to api doc\n\n\n\n\nv0.22.0\n\n\n\n\n#146\n: documentation: improved the prerequisites in the \nREADME.md\n and writing style\n\n\n#143\n: documentation: fixed testing configuration example (\nandCallFake\n, not \nandCallThrough\n)\n\n\n#142\n: documentation: fixed task alias for development server (\nstart\n, not \ndevelop\n)\n\n\n#144\n: EventBus: reject publishAndGatherReplies-promise after timeout\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv0.21.0\n\n\n\n\n#137\n: flow: warn on empty place\n\n\n#140\n: EventBus: make timeout configurable\n\n\n#126\n: testing: \naxEventBus\n injection available to widget controllers during testing\n\n\n\n\nv0.20.0\n\n\n\n\n#138\n: logging: the instance id is now generated by the log context and transmitted using an $http interceptor\n\n\n#134\n: storage: fixed storage in iOS Safari private browsing\n\n\n\n\nv0.19.0\n\n\n\n\n\n\n#125\n: axLayout: emit AngularJS event when loaded\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#113\n: documentation: manual on tools\n\n\n\n\n\n\n#122\n: testing: allow to inject dependencies\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#123\n: portal: preload widget assets on page load\n\n\n\n\n#117\n: portal: implemented a flow service that provides place urls usable as hyperlinks.\n\n\n#121\n: documentation: have README.md next steps point to manuals\n\n\n#118\n: performance: removed $timeout from axPageFade\n\n\n#120\n: portal: fixed flaky timestamp test\n\n\n#119\n: portal: fixed race condition in page loader\n\n\n\n\nv0.18.0\n\n\n\n\n#114\n: configuration: fixed mapping of deprecated fileListing entry.\n\n\n#97\n: documentation: manual on themes\n\n\n#112\n: documentation: removed colloquial style\n\n\n\n\nv0.17.0\n\n\n\n\n#108\n: documentation: unify code-snippet format, and some polish\n\n\n#109\n: documentation: added manual on providing controls\n\n\n#107\n: angular widget adapter: added widget specific event bus service.\n\n\n#106\n: documentation: fixed manuals, improved introduction in README.md\n\n\n#93\n: refactoring: extracted page related services into own files.\n\n\n#98\n: documentation: added manual on events and pub/sub\n\n\n#100\n: widget loader: added angular widget as default integration.\n\n\n#105\n: moved resumable timer handling from flow to timer.\n\n\n#104\n: configuration: deprecated configuration keys are no handled at one place.\n\n\n#101\n: documentation: use \"\u00ab\" rather than \"\n\" for backwards navigation links\n\n\n#76\n: documentation: widgets and activities\n\n\n#75\n: documentation: flow and places.\n\n\n#96\n: documentation: restructured existing documents and added stubs for missing ones.\n\n\n#95\n: documentation: wrote a motivational article for LaxarJS.\n\n\n#94\n: footprint: removed the outdated app stub in favor of grunt-init (see README.md)\n\n\n#38\n: documentation: pages and compositions.\n\n\n#91\n: portal: make sure that widget DOM is attached when linking\n\n\n\n\n#90\n: documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#89\n: documentation: primary concepts of LaxarJS\n\n\n\n\n#84\n: storage: storing \nundefined\n now causes the entry to be removed\n\n\n\n\nv0.16.0\n\n\n\n\n#87\n: portal: Ensure anonymization of logged events.\n\n\n#86\n: logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.\n\n\n\n\n#85\n: utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#83\n: portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#81\n: added check for duplicate area definitions in layouts\n\n\n\n\n\n\nv0.15.0\n\n\n\n\n\n\n#82\n: implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#80\n: storage: Improved detection of WebStorage API for Internet Explorer\n\n\n\n\n#79\n: assert: details given as object are now serialized\n\n\n#77\n: flow: the log tag \nPLCE\n with the current place name is set after navigation\n\n\n\n\nv0.14.0\n\n\n\n\n#73\n: portal: fixed lookup of merged CSS file\n\n\n#69\n: portal: moved setting widget root element IDs to widget loader\n\n\n#68\n: fixed wrongly global assert in jshintrc.\n\n\n#67\n: re-added missing widget root element IDs.\n\n\n#65\n: fixed navigation being broken when parameter values were missing.\n\n\n#66\n: prevented endless navigation ping pong in flow controller\n\n\n#63\n: axVisibilityService: use scope.$id to identify handlers, not scope.id\n\n\n#62\n: fixed endless recursion on navigation when place and target have the same name.\n\n\n\n\nv0.13.0\n\n\n\n\n\n\n#61\n: added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#60\n: tests: make sure PhantomJS is installed properly, before running spec tests.\n\n\n\n\n\n\n#52\n: portal, testing: added visibility events and the \naxVisibilityService\n\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#59\n: portal: fixed dangling comma in timer imports\n\n\n\n\n#58\n: portal, json: fixed copyright headers\n\n\n#57\n: portal: fixed double-navigation problem which can lead to skipping places\n\n\n#56\n: object: removed all direct calls of hasOwnProperty.\n\n\n#55\n: run_spec: disable loading the \nwidget.json\n if the \nspec_runner.js\n contains \nwidgetJson: false\n\n\n#54\n: testing: fixed broken testBed injection of $q and $timeout\n\n\n#50\n: performance: decoupled instantiation of widget controllers from their DOM\n\n\n\n\nv0.12.0\n\n\n\n\n\n\n#49\n: added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#48\n: Promises generated by the event bus are now scheduled by the event bus, not by AngularJS \n$apply\n.\n\n\n\n\n#51\n: Remove some obsolete NPM \ndevDependencies\n.\n\n\n#47\n: Do not schedule another full event-bus tick while one is already being processed.\n\n\n#46\n: fixed misinterpretation of falsy required attribute in json schema converter.\n\n\n#45\n: i18n: adjusted localizer.format specs to changes from \n#43\n.\n\n\n\n\n#43\n: string: added new function \nstring.format\n as simpler replacement for \ntext\n library.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#42\n: portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#40\n: portal: fixed 'flag-topic' pattern.\n\n\n\n\n\n\nv0.11.0\n\n\n\n\n\n\n#39\n: portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#37\n: improved browsing of existing api doc and fixed some syntactical errors.\n\n\n\n\n#36\n: jshintrc: disabled enforcement of dot notation for object property access.\n\n\n\n\n#34\n: Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#33\n: EventBus: added event object to the information sent to inspectors on deliver actions.\n\n\n\n\n\n\n#31\n: Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#32\n: Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#30\n: PageLoader: added missing check for duplicate composition ids.\n\n\n\n\n\n\nv0.10.0\n\n\n\n\n#27\n: Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick\n\n\n#28\n: Fixed null values in widget features within compositions being turned into empty objects.\n\n\n#29\n: PageLoader: composition features that are not configured do not result in undefined values for widget features.\n\n\n#25\n: Only the page relevant for the current place is loaded now.\n\n\n\n\n#17\n: Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#26\n: Testing: Fixed the responseTransform option for http-mock\n\n\n\n\n\n\n#22\n: FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#15\n: FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings\n\n\n\n\n\n\n#24\n: Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#23\n: FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.\n\n\n\n\n#21\n: The file resource provider now normalizes its root path.\n\n\n#20\n: Fixed event bus inspectors not being notified on unsubscription.\n\n\n#14\n: Fixed navigation being broken after successive navigation to the current location.\n\n\n#13\n: The current place is now send as part of the didNavigate event.\n\n\n#12\n: Testing: Get the LaxarJS tests running in Karma again.\n\n\n#11\n: Testing: Handle \nspec_runner.js\n that are not in a subdirectory of the RequireJS' \nbaseUrl\n.\n\n\n#10\n: Testing: Loading controls during tests now works in Karma.\n\n\n#9\n: Update Bower from ~1.2.8 to ~1.3.3.\n\n\n#8\n: Fixed the cleanup mechanism for generated widget areas.\n\n\n#6\n: The Portal now initializes an i18n object on the application's \n$rootScope\n\n\n#5\n: Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json\n\n\n#4\n: PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys\n\n\n#3\n: Added url formatting for links in Readme.md\n\n\n#2\n: Fixed grunt-init step in Getting-Started docs\n\n\n#1\n: Added initial Getting-Started documentation", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v0260", 
            "text": "#172 : documentation: fixed dead link  #166 : cleanup: removed distribution-related configuration and files  #163 : EventBus: fixed request topic matching", 
            "title": "v0.26.0"
        }, 
        {
            "location": "/CHANGELOG/#v0250", 
            "text": "#160 : refactoring: prepared for normalization of AngularJS artifact names (v1.x)\n        + NEW FEATURE: see ticket for details    #156 : i18n: by default, use relaxed matching for language tags", 
            "title": "v0.25.0"
        }, 
        {
            "location": "/CHANGELOG/#v0240", 
            "text": "#102 : testing: deleted deprecated warning of  testBed.useWidgetJson  #157 : portal: angular-adapter: fixed error reporting  #145 : testing: added missing cancel-method to mock-$timeout  #155 : visibility: page controller now unsubscribes on tear-down  #152 : documentation: added widget installation manual\n        + NEW FEATURE: see ticket for details", 
            "title": "v0.24.0"
        }, 
        {
            "location": "/CHANGELOG/#v0230", 
            "text": "#153 : portal: angular-adapter: simplified widget and controller naming\n        + NEW FEATURE: see ticket for details    #151 : EventBus: fixed cycle count for zero subscribers   #148 : documentation: more detailed information on the event bus, link to api doc", 
            "title": "v0.23.0"
        }, 
        {
            "location": "/CHANGELOG/#v0220", 
            "text": "#146 : documentation: improved the prerequisites in the  README.md  and writing style  #143 : documentation: fixed testing configuration example ( andCallFake , not  andCallThrough )  #142 : documentation: fixed task alias for development server ( start , not  develop )  #144 : EventBus: reject publishAndGatherReplies-promise after timeout\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v0.22.0"
        }, 
        {
            "location": "/CHANGELOG/#v0210", 
            "text": "#137 : flow: warn on empty place  #140 : EventBus: make timeout configurable  #126 : testing:  axEventBus  injection available to widget controllers during testing", 
            "title": "v0.21.0"
        }, 
        {
            "location": "/CHANGELOG/#v0200", 
            "text": "#138 : logging: the instance id is now generated by the log context and transmitted using an $http interceptor  #134 : storage: fixed storage in iOS Safari private browsing", 
            "title": "v0.20.0"
        }, 
        {
            "location": "/CHANGELOG/#v0190", 
            "text": "#125 : axLayout: emit AngularJS event when loaded\n        + NEW FEATURE: see ticket for details    #113 : documentation: manual on tools    #122 : testing: allow to inject dependencies\n        + NEW FEATURE: see ticket for details    #123 : portal: preload widget assets on page load   #117 : portal: implemented a flow service that provides place urls usable as hyperlinks.  #121 : documentation: have README.md next steps point to manuals  #118 : performance: removed $timeout from axPageFade  #120 : portal: fixed flaky timestamp test  #119 : portal: fixed race condition in page loader", 
            "title": "v0.19.0"
        }, 
        {
            "location": "/CHANGELOG/#v0180", 
            "text": "#114 : configuration: fixed mapping of deprecated fileListing entry.  #97 : documentation: manual on themes  #112 : documentation: removed colloquial style", 
            "title": "v0.18.0"
        }, 
        {
            "location": "/CHANGELOG/#v0170", 
            "text": "#108 : documentation: unify code-snippet format, and some polish  #109 : documentation: added manual on providing controls  #107 : angular widget adapter: added widget specific event bus service.  #106 : documentation: fixed manuals, improved introduction in README.md  #93 : refactoring: extracted page related services into own files.  #98 : documentation: added manual on events and pub/sub  #100 : widget loader: added angular widget as default integration.  #105 : moved resumable timer handling from flow to timer.  #104 : configuration: deprecated configuration keys are no handled at one place.  #101 : documentation: use \"\u00ab\" rather than \" \" for backwards navigation links  #76 : documentation: widgets and activities  #75 : documentation: flow and places.  #96 : documentation: restructured existing documents and added stubs for missing ones.  #95 : documentation: wrote a motivational article for LaxarJS.  #94 : footprint: removed the outdated app stub in favor of grunt-init (see README.md)  #38 : documentation: pages and compositions.  #91 : portal: make sure that widget DOM is attached when linking   #90 : documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details    #89 : documentation: primary concepts of LaxarJS   #84 : storage: storing  undefined  now causes the entry to be removed", 
            "title": "v0.17.0"
        }, 
        {
            "location": "/CHANGELOG/#v0160", 
            "text": "#87 : portal: Ensure anonymization of logged events.  #86 : logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.   #85 : utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details    #83 : portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details    #81 : added check for duplicate area definitions in layouts", 
            "title": "v0.16.0"
        }, 
        {
            "location": "/CHANGELOG/#v0150", 
            "text": "#82 : implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details    #80 : storage: Improved detection of WebStorage API for Internet Explorer   #79 : assert: details given as object are now serialized  #77 : flow: the log tag  PLCE  with the current place name is set after navigation", 
            "title": "v0.15.0"
        }, 
        {
            "location": "/CHANGELOG/#v0140", 
            "text": "#73 : portal: fixed lookup of merged CSS file  #69 : portal: moved setting widget root element IDs to widget loader  #68 : fixed wrongly global assert in jshintrc.  #67 : re-added missing widget root element IDs.  #65 : fixed navigation being broken when parameter values were missing.  #66 : prevented endless navigation ping pong in flow controller  #63 : axVisibilityService: use scope.$id to identify handlers, not scope.id  #62 : fixed endless recursion on navigation when place and target have the same name.", 
            "title": "v0.14.0"
        }, 
        {
            "location": "/CHANGELOG/#v0130", 
            "text": "#61 : added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details    #60 : tests: make sure PhantomJS is installed properly, before running spec tests.    #52 : portal, testing: added visibility events and the  axVisibilityService \n        + NEW FEATURE: see ticket for details    #59 : portal: fixed dangling comma in timer imports   #58 : portal, json: fixed copyright headers  #57 : portal: fixed double-navigation problem which can lead to skipping places  #56 : object: removed all direct calls of hasOwnProperty.  #55 : run_spec: disable loading the  widget.json  if the  spec_runner.js  contains  widgetJson: false  #54 : testing: fixed broken testBed injection of $q and $timeout  #50 : performance: decoupled instantiation of widget controllers from their DOM", 
            "title": "v0.13.0"
        }, 
        {
            "location": "/CHANGELOG/#v0120", 
            "text": "#49 : added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details    #48 : Promises generated by the event bus are now scheduled by the event bus, not by AngularJS  $apply .   #51 : Remove some obsolete NPM  devDependencies .  #47 : Do not schedule another full event-bus tick while one is already being processed.  #46 : fixed misinterpretation of falsy required attribute in json schema converter.  #45 : i18n: adjusted localizer.format specs to changes from  #43 .   #43 : string: added new function  string.format  as simpler replacement for  text  library.\n        + NEW FEATURE: see ticket for details    #42 : portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details    #40 : portal: fixed 'flag-topic' pattern.", 
            "title": "v0.12.0"
        }, 
        {
            "location": "/CHANGELOG/#v0110", 
            "text": "#39 : portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details    #37 : improved browsing of existing api doc and fixed some syntactical errors.   #36 : jshintrc: disabled enforcement of dot notation for object property access.   #34 : Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details    #33 : EventBus: added event object to the information sent to inspectors on deliver actions.    #31 : Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details    #32 : Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details    #30 : PageLoader: added missing check for duplicate composition ids.", 
            "title": "v0.11.0"
        }, 
        {
            "location": "/CHANGELOG/#v0100", 
            "text": "#27 : Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick  #28 : Fixed null values in widget features within compositions being turned into empty objects.  #29 : PageLoader: composition features that are not configured do not result in undefined values for widget features.  #25 : Only the page relevant for the current place is loaded now.   #17 : Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details    #26 : Testing: Fixed the responseTransform option for http-mock    #22 : FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details    #15 : FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings    #24 : Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details    #23 : FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.   #21 : The file resource provider now normalizes its root path.  #20 : Fixed event bus inspectors not being notified on unsubscription.  #14 : Fixed navigation being broken after successive navigation to the current location.  #13 : The current place is now send as part of the didNavigate event.  #12 : Testing: Get the LaxarJS tests running in Karma again.  #11 : Testing: Handle  spec_runner.js  that are not in a subdirectory of the RequireJS'  baseUrl .  #10 : Testing: Loading controls during tests now works in Karma.  #9 : Update Bower from ~1.2.8 to ~1.3.3.  #8 : Fixed the cleanup mechanism for generated widget areas.  #6 : The Portal now initializes an i18n object on the application's  $rootScope  #5 : Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json  #4 : PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys  #3 : Added url formatting for links in Readme.md  #2 : Fixed grunt-init step in Getting-Started docs  #1 : Added initial Getting-Started documentation", 
            "title": "v0.10.0"
        }, 
        {
            "location": "/concepts/", 
            "text": "LaxarJS Concepts\n\n\nIn order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.\n\n\nA LaxarJS Application\n\n\nTo the visitor running a web browser, an \napplication\n is a set of URLs and associated pages which are loaded by the browser to provide some information or functionality.\nAn application may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.\n\n\nFrom a developer point of view, an application primarily consists of:\n\n\n* a set of LaxarJS _widgets_ and _activities_ providing the functionality\n* the _pages_ and _layouts_ assembling these widgets and activities\n* a _flow_ that connects the individual pages\n* one or more _themes_ to define the look and feel of the application.\n\n\n\n\n\nIn order to run the application, there are additional secondary resources:\n\n\n* the _LaxarJS runtime_ loads flow and pages, sets up the widgets and connects them to the _event bus_\n* _controls_ which are used by the widgets to provide advanced user interface functionality, such as those provided by _LaxarJS UiKit_\n* _libraries_ used by widgets and activities, such as _moment.js_, _jQuery_, and _LaxarJS patterns_.\n\n\n\n\n\nThe following two sections first explain the primary application components, and than the underlying secondary components.\n\n\nPrimary Application Parts\n\n\nWidgets\n\n\nA \nLaxarJS widget\n is a rectangular part of the browser viewport which \nallows the user to perform some task\n.\nIt usually consists of several HTML elements, but might in some cases use only a single element, for example a \ncanvas\n to provide a painting surface.\n\n\nThe important distinction between a LaxarJS widget and a plain HTML control (such as a \nselect\n box or an \ninput\n field) is that a widget is written with a specific \nuser-goal\n in mind, whereas a control is general-purpose and its role in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a name, or a password), a widget might combine these input controls in a box to allow the same user to \nlog in\n to the application, and another widget might allow the user to \nregister\n a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.\n\n\nTo illustrate this with further examples, possible widgets \nwith their specific goals\n include:\n\n\n* a ToDo list, _to check and plan what is to do_\n* a shopping cart, _to review and edit purchase items_\n* a route planner displayed as a map, _to plan a journey_\n* a calendar displaying various events, _to schedule and check appointments_\n* the details editor for a specific event, _to reschedule or cancel an appointment_\n* a social buttons bar, _to share content_.\n\n\n\n\n\nIn contrast, these are controls:\n\n\n* an input field, _to display/edit any text_\n* a date picker, _to display/edit any date_\n* a select box, _to choose from any list of options_\n* an accordion control or a tab control, _to navigate any set of contents_.\n\n\n\n\n\nAnother way to think of it is that \nwidgets are made of controls\n, and  \ncontrols are HTML elements\n which may be user-defined (for example through AngularJS directives).\nThe program logic of an individual widget is implemented in JavaScript (as an AngularJS controller) while the presentation is defined as an (AngularJS) HTML template, optionally accompanied by CSS styling information.\nAnother important property of widgets is that they always can be \nloaded and tested in isolation\n.\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) might already be there.\n\n\nActivities\n\n\nA \nLaxarJS activity\n is a widget without a visual representation, performing a task for the user \nbehind the scenes\n.\nTo build upon the previous example, a \nlogin widget\n might talk to an authentication service itself, but it might also delegate this task to an \nauthentication activity\n using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS login to OAuth) only the activity needs to be exchanged, while the widget might remain untouched.\nIn contrast to libraries and regular AngularJS services, activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe. \n\n\nAnother possible example would be a \nweb search widget\n offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just \nsubscribes\n to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching any of the other implementations.\n\n\nAnother way to think of it is that \nwidgets have to run in the browser, while activities might run in any JavaScript environment\n.\nIn contrast to visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.\n\n\nPages\n\n\nA \nLaxarJS page\n combines and configures widgets and activities that should be displayed together by embedding them in an HTML skeleton (the layout).\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions. \n\n\nAn individual widget is still somewhat generic in that it allows to perform a specific task \nin any context\n.\nFor example, a social buttons bar might allow to share \nany content\n, and the specific list of social sites to share on might be \nconfigurable\n.\nThe page establishes this context, for example \nby placing\n the social buttons below a news article (rendered from markdown by another widget), and \nby configuring\n that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nBut it means that reuse is supported for those widgets where it makes sense.\n\n\nWhile widgets and activities are implemented in JavaScript and HTML, pages are written using JSON in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.\nUsually, each page occupies its own \"screen\" in your application, but there are mechanisms to divide pages into fragments and to \ncompose\n them back together.\n\n\nLayouts\n\n\nLaxarJS layouts\n are skeleton HTML documents, which contain placeholders (called \nwidget areas\n) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nA layout can contain all the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.\n\n\nFor each \nwidget areas\n, the layout defines a width in grid columns, and widgets within these areas may not exceed their available number of columns.\nThe LaxarJS UiKit ships with \nBootstrap\n to implement the grid layout in CSS.\nLike widgets, layouts are accompanied by CSS styles, for example to define a background color.\n\n\nYou might think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.\n\n\nThe Flow\n\n\nThe flow defines \nURL patterns\n that may be used to navigate to the pages of an application, and \nrelations between pages\n.\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, the flow defines semantic relations between pages, such as what is considered the \nnext\n page from a given page in the application.\n\n\nThemes\n\n\nWidgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.\n\n\nThe LaxarJS UiKit is based on Compass/SCSS to simplify the generation of user defined themes. However, any way to generate Bootstrap-like CSS styles is a valid way to create a theme.\n\n\nSecondary Application Parts \u2013 Under the Hood\n\n\nThe LaxarJS Runtime\n\n\nThe \nruntime\n handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.\nOnce everything is set up, the runtime gets out of the way: it lets the widgets perform their tasks and communicate through the event bus as needed. \n\n\nThe LaxarJS Event Bus\n\n\nThe \nevent bus\n allows widgets to talk about common topics, without knowing \nanything\n about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or expect resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.\n\n\nControls\n\n\nControls\n are (user-defined) HTML elements and attributes, usually implemented as AngularJS directives.\nThey are available to widgets as reusable UI components, and are styled using \nBootstrap 3.2\n for interoperability and theme support.\nA useful set of controls to get started is provided by the \nAngular UI Bootstrap\n project.\n\n\nLibraries\n\n\nWidgets may use \nlibraries\n such as \njQuery\n or \nmoment.js\n just like in any JavaScript web application.\nLaxarJS currently provides a development workflow based on \ngrunt\n, \nbower\n, and \nRequireJS\n in order to install and load widgets with their assets as well as libraries, but other tool-chains are not out of the question.\n\n\nTo establish a useful common base vocabulary for use with the event bus, the \nLaxarJS Patterns\n library is provided.\nIt contains helpers that make it easy for widgets to talk about user actions, common (REST) resources and boolean flags.\n\n\nNext Steps\n\n\nAfter this quick tour through the building blocks of a LaxarJS application, have a look at the \nmanuals\n for in-depth information on individual topics.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#laxarjs-concepts", 
            "text": "In order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#a-laxarjs-application", 
            "text": "To the visitor running a web browser, an  application  is a set of URLs and associated pages which are loaded by the browser to provide some information or functionality.\nAn application may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.  From a developer point of view, an application primarily consists of:  * a set of LaxarJS _widgets_ and _activities_ providing the functionality\n* the _pages_ and _layouts_ assembling these widgets and activities\n* a _flow_ that connects the individual pages\n* one or more _themes_ to define the look and feel of the application.  In order to run the application, there are additional secondary resources:  * the _LaxarJS runtime_ loads flow and pages, sets up the widgets and connects them to the _event bus_\n* _controls_ which are used by the widgets to provide advanced user interface functionality, such as those provided by _LaxarJS UiKit_\n* _libraries_ used by widgets and activities, such as _moment.js_, _jQuery_, and _LaxarJS patterns_.  The following two sections first explain the primary application components, and than the underlying secondary components.", 
            "title": "A LaxarJS Application"
        }, 
        {
            "location": "/concepts/#primary-application-parts", 
            "text": "", 
            "title": "Primary Application Parts"
        }, 
        {
            "location": "/concepts/#widgets", 
            "text": "A  LaxarJS widget  is a rectangular part of the browser viewport which  allows the user to perform some task .\nIt usually consists of several HTML elements, but might in some cases use only a single element, for example a  canvas  to provide a painting surface.  The important distinction between a LaxarJS widget and a plain HTML control (such as a  select  box or an  input  field) is that a widget is written with a specific  user-goal  in mind, whereas a control is general-purpose and its role in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a name, or a password), a widget might combine these input controls in a box to allow the same user to  log in  to the application, and another widget might allow the user to  register  a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.  To illustrate this with further examples, possible widgets  with their specific goals  include:  * a ToDo list, _to check and plan what is to do_\n* a shopping cart, _to review and edit purchase items_\n* a route planner displayed as a map, _to plan a journey_\n* a calendar displaying various events, _to schedule and check appointments_\n* the details editor for a specific event, _to reschedule or cancel an appointment_\n* a social buttons bar, _to share content_.  In contrast, these are controls:  * an input field, _to display/edit any text_\n* a date picker, _to display/edit any date_\n* a select box, _to choose from any list of options_\n* an accordion control or a tab control, _to navigate any set of contents_.  Another way to think of it is that  widgets are made of controls , and   controls are HTML elements  which may be user-defined (for example through AngularJS directives).\nThe program logic of an individual widget is implemented in JavaScript (as an AngularJS controller) while the presentation is defined as an (AngularJS) HTML template, optionally accompanied by CSS styling information.\nAnother important property of widgets is that they always can be  loaded and tested in isolation .\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) might already be there.", 
            "title": "Widgets"
        }, 
        {
            "location": "/concepts/#activities", 
            "text": "A  LaxarJS activity  is a widget without a visual representation, performing a task for the user  behind the scenes .\nTo build upon the previous example, a  login widget  might talk to an authentication service itself, but it might also delegate this task to an  authentication activity  using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS login to OAuth) only the activity needs to be exchanged, while the widget might remain untouched.\nIn contrast to libraries and regular AngularJS services, activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe.   Another possible example would be a  web search widget  offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just  subscribes  to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching any of the other implementations.  Another way to think of it is that  widgets have to run in the browser, while activities might run in any JavaScript environment .\nIn contrast to visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.", 
            "title": "Activities"
        }, 
        {
            "location": "/concepts/#pages", 
            "text": "A  LaxarJS page  combines and configures widgets and activities that should be displayed together by embedding them in an HTML skeleton (the layout).\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions.   An individual widget is still somewhat generic in that it allows to perform a specific task  in any context .\nFor example, a social buttons bar might allow to share  any content , and the specific list of social sites to share on might be  configurable .\nThe page establishes this context, for example  by placing  the social buttons below a news article (rendered from markdown by another widget), and  by configuring  that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nBut it means that reuse is supported for those widgets where it makes sense.  While widgets and activities are implemented in JavaScript and HTML, pages are written using JSON in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.\nUsually, each page occupies its own \"screen\" in your application, but there are mechanisms to divide pages into fragments and to  compose  them back together.", 
            "title": "Pages"
        }, 
        {
            "location": "/concepts/#layouts", 
            "text": "LaxarJS layouts  are skeleton HTML documents, which contain placeholders (called  widget areas ) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nA layout can contain all the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.  For each  widget areas , the layout defines a width in grid columns, and widgets within these areas may not exceed their available number of columns.\nThe LaxarJS UiKit ships with  Bootstrap  to implement the grid layout in CSS.\nLike widgets, layouts are accompanied by CSS styles, for example to define a background color.  You might think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.", 
            "title": "Layouts"
        }, 
        {
            "location": "/concepts/#the-flow", 
            "text": "The flow defines  URL patterns  that may be used to navigate to the pages of an application, and  relations between pages .\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, the flow defines semantic relations between pages, such as what is considered the  next  page from a given page in the application.", 
            "title": "The Flow"
        }, 
        {
            "location": "/concepts/#themes", 
            "text": "Widgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.  The LaxarJS UiKit is based on Compass/SCSS to simplify the generation of user defined themes. However, any way to generate Bootstrap-like CSS styles is a valid way to create a theme.", 
            "title": "Themes"
        }, 
        {
            "location": "/concepts/#secondary-application-parts-under-the-hood", 
            "text": "", 
            "title": "Secondary Application Parts \u2013 Under the Hood"
        }, 
        {
            "location": "/concepts/#the-laxarjs-runtime", 
            "text": "The  runtime  handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.\nOnce everything is set up, the runtime gets out of the way: it lets the widgets perform their tasks and communicate through the event bus as needed.", 
            "title": "The LaxarJS Runtime"
        }, 
        {
            "location": "/concepts/#the-laxarjs-event-bus", 
            "text": "The  event bus  allows widgets to talk about common topics, without knowing  anything  about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or expect resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.", 
            "title": "The LaxarJS Event Bus"
        }, 
        {
            "location": "/concepts/#controls", 
            "text": "Controls  are (user-defined) HTML elements and attributes, usually implemented as AngularJS directives.\nThey are available to widgets as reusable UI components, and are styled using  Bootstrap 3.2  for interoperability and theme support.\nA useful set of controls to get started is provided by the  Angular UI Bootstrap  project.", 
            "title": "Controls"
        }, 
        {
            "location": "/concepts/#libraries", 
            "text": "Widgets may use  libraries  such as  jQuery  or  moment.js  just like in any JavaScript web application.\nLaxarJS currently provides a development workflow based on  grunt ,  bower , and  RequireJS  in order to install and load widgets with their assets as well as libraries, but other tool-chains are not out of the question.  To establish a useful common base vocabulary for use with the event bus, the  LaxarJS Patterns  library is provided.\nIt contains helpers that make it easy for widgets to talk about user actions, common (REST) resources and boolean flags.", 
            "title": "Libraries"
        }, 
        {
            "location": "/concepts/#next-steps", 
            "text": "After this quick tour through the building blocks of a LaxarJS application, have a look at the  manuals  for in-depth information on individual topics.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/why_laxar/", 
            "text": "Why LaxarJS?\n\n\nIt is difficult to build large applications using AngularJS.\nEven the creators \ntell you\n not to do that.\nUnfortunately your customer has not read that article and now you are trying to manage twenty controllers on the same page.\nWe therefore developed LaxarJS as a way to handle this complexity by splitting your application into isolated, manageable components that may be reused in different contexts.\nBecause LaxarJS allows components to collaborate without prior knowledge of each other by using publish/subscribe, you may think of it as the missing \nmiddleware for the web client\n.\n\n\nWhy is it Difficult to Use AngularJS in Large Applications?\n\n\nAngularJS already tries to address some of the issues arising with larger applications such as end-to-end testability, encapsulation through directives and controller/view-separation.\nAlso there already exist \nbest practices\n on the organization of larger applications.\nHowever it is not obvious how to isolate and possibly even reuse larger blocks of functionality as perceived by the application user.\nAngularJS offers many ways to \ncouple\n your components, but only few ways to reliably \ndecouple\n them:\n\n\n\n\nbinding to shared scope properties harms stability due to side effects\n\n\nshared state via services may quickly lead to similar problems\n\n\nbindings to directive controllers introduce dependencies to (usually synchronous) APIs\n\n\n$broadcast\n and \n$emit\n improve on the hard dependencies, but still enforce a specific DOM structure and may lead to timing issues during instantiation.\n\n\n\n\nHow can we continue to leverage the benefits of AngularJS and offer better decoupling of (large) components?\n\n\nHow LaxarJS Addresses the Complexity Issue\n\n\nAt its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an \nevent bus\n that allows components (called \nwidgets\n) to communicate without knowing each other.\n\n\nThe Event Bus Decouples Widgets\n\n\nWidgets may \npublish\n application resources and \nsubscribe\n to changes of those resources without knowing about their mutual state.\nFor example, in a web shop one widget might represent the shopping cart while another widget resembling the catalog would add articles to the shopping cart by publishing the respective events.\nEach of the two widgets has its own view of the \nsame\n shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.\n\n\nAfter a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a \ncheck out\n button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would then \nreact\n to the event and later publish its own event to indicate that the action was performed successfully.\n\n\nThere is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation, \nrelaxing\n the tight constraints and dependencies imposed by traditional programmatic APIs.\n\n\nThe Runtime Composes Widgets\n\n\nIn the application, widgets are connected to each other in a declarative fashion using JSON \npage definitions\n.\nThe \nLaxarJS runtime\n is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets such as HTML and CSS.\n\n\nIndividual pages are interrelated through a \nflow definition\n which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.\n\n\nThe Best of Both Worlds\n\n\nBuilding upon the thriving ecosystem of Web Standards and (AngularJS) web components, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.\n\n\nIf this draws your interest, learn more about the LaxarJS \nkey concepts\n or jump in at the deep end by writing your first \nLaxarJS\n application.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#why-laxarjs", 
            "text": "It is difficult to build large applications using AngularJS.\nEven the creators  tell you  not to do that.\nUnfortunately your customer has not read that article and now you are trying to manage twenty controllers on the same page.\nWe therefore developed LaxarJS as a way to handle this complexity by splitting your application into isolated, manageable components that may be reused in different contexts.\nBecause LaxarJS allows components to collaborate without prior knowledge of each other by using publish/subscribe, you may think of it as the missing  middleware for the web client .", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#why-is-it-difficult-to-use-angularjs-in-large-applications", 
            "text": "AngularJS already tries to address some of the issues arising with larger applications such as end-to-end testability, encapsulation through directives and controller/view-separation.\nAlso there already exist  best practices  on the organization of larger applications.\nHowever it is not obvious how to isolate and possibly even reuse larger blocks of functionality as perceived by the application user.\nAngularJS offers many ways to  couple  your components, but only few ways to reliably  decouple  them:   binding to shared scope properties harms stability due to side effects  shared state via services may quickly lead to similar problems  bindings to directive controllers introduce dependencies to (usually synchronous) APIs  $broadcast  and  $emit  improve on the hard dependencies, but still enforce a specific DOM structure and may lead to timing issues during instantiation.   How can we continue to leverage the benefits of AngularJS and offer better decoupling of (large) components?", 
            "title": "Why is it Difficult to Use AngularJS in Large Applications?"
        }, 
        {
            "location": "/why_laxar/#how-laxarjs-addresses-the-complexity-issue", 
            "text": "At its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an  event bus  that allows components (called  widgets ) to communicate without knowing each other.", 
            "title": "How LaxarJS Addresses the Complexity Issue"
        }, 
        {
            "location": "/why_laxar/#the-event-bus-decouples-widgets", 
            "text": "Widgets may  publish  application resources and  subscribe  to changes of those resources without knowing about their mutual state.\nFor example, in a web shop one widget might represent the shopping cart while another widget resembling the catalog would add articles to the shopping cart by publishing the respective events.\nEach of the two widgets has its own view of the  same  shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.  After a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a  check out  button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would then  react  to the event and later publish its own event to indicate that the action was performed successfully.  There is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation,  relaxing  the tight constraints and dependencies imposed by traditional programmatic APIs.", 
            "title": "The Event Bus Decouples Widgets"
        }, 
        {
            "location": "/why_laxar/#the-runtime-composes-widgets", 
            "text": "In the application, widgets are connected to each other in a declarative fashion using JSON  page definitions .\nThe  LaxarJS runtime  is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets such as HTML and CSS.  Individual pages are interrelated through a  flow definition  which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.", 
            "title": "The Runtime Composes Widgets"
        }, 
        {
            "location": "/why_laxar/#the-best-of-both-worlds", 
            "text": "Building upon the thriving ecosystem of Web Standards and (AngularJS) web components, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.  If this draws your interest, learn more about the LaxarJS  key concepts  or jump in at the deep end by writing your first  LaxarJS  application.", 
            "title": "The Best of Both Worlds"
        }, 
        {
            "location": "/manuals/", 
            "text": "Manuals\n\n\nBefore starting with the manuals, make sure that you know \nwhat LaxarJS is about\n, and that you are familiar with the \ncore concepts\n.\n\n\nBasic Manuals\n\n\n\n\nWidgets and Activities\n\n\n\n\nLearn about the building blocks of a LaxarJS application.\n\n\n\n\n\n\nWriting Pages\n\n\nA step-by-step introduction to writing layouts and pages for a LaxarJS application.\n\n\n\n\n\n\nInstalling Third Party Widgets\n\n\n\n\n\n\nLearn how to integrate and leverage existing widgets and activities.\n\n\n\n\n\n\nFlow and Places\n\n\nCreating a flow through the pages and make the addressable as places.\n\n\n\n\n\n\nEvents\n\n\nHow to communicate between widgets using topics on the event bus.\n\n\n\n\n\n\nCreating Themes\n\n\nHow to create a custom, pluggable style for your widgets and applications.\n\n\n\n\n\n\nProviding Controls\n\n\nHow to create reusable, interactive elements that support themes.\n\n\n\n\n\n\nInfrastructure and Tools\n\n\nWhat happens when a LaxarJS application starts, and how its assets are prepared.\n\n\n\n\n\n\nAdvanced Manuals\n\n\n\n\n\n\nWriting Compositions\n\n\nWhen simple pages are not enough.\n\n\n\n\n\n\nConfiguration\n\n\nDocuments the LaxarJS configuration API which can be used to configure widgets, and the builtin configuration options.\n\n\n\n\n\n\nInternationalization (i18n)\n\n\nExplains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Before starting with the manuals, make sure that you know  what LaxarJS is about , and that you are familiar with the  core concepts .", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/#basic-manuals", 
            "text": "Widgets and Activities   Learn about the building blocks of a LaxarJS application.    Writing Pages  A step-by-step introduction to writing layouts and pages for a LaxarJS application.    Installing Third Party Widgets    Learn how to integrate and leverage existing widgets and activities.    Flow and Places  Creating a flow through the pages and make the addressable as places.    Events  How to communicate between widgets using topics on the event bus.    Creating Themes  How to create a custom, pluggable style for your widgets and applications.    Providing Controls  How to create reusable, interactive elements that support themes.    Infrastructure and Tools  What happens when a LaxarJS application starts, and how its assets are prepared.", 
            "title": "Basic Manuals"
        }, 
        {
            "location": "/manuals/#advanced-manuals", 
            "text": "Writing Compositions  When simple pages are not enough.    Configuration  Documents the LaxarJS configuration API which can be used to configure widgets, and the builtin configuration options.    Internationalization (i18n)  Explains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.", 
            "title": "Advanced Manuals"
        }, 
        {
            "location": "/manuals/providing_controls/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nControls and Libraries\n\n\nIn LaxarJS, any non-trivial HTML element, \nHTML5 Web Component\n or \nAngularJS directive\n is considered a \ncontrol\n.\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.\nTo provide their business logic, widgets and activities often depend on libraries, which might be created by third parties or simply be used to share common functionality.\nIn the latter case, be sure not to couple your controllers to tightly, e.g. the shared libraries should not allow to share state.\n\n\nHere are some examples of controls:\n\n\n* a select box\n* a date picker\n* an accordion control\n* a tab control\n\n\n\n\n\nLaxarJS helps when developing a custom control by managing its AngularJS modules, as well as its CSS and HTML assets for you.\nIf (and only if) you \nuse\n a control in one or more widgets, LaxarJS will load its CSS according to the current \ntheme\n, just like with widgets and templates.\nWhen you remove the control from your widget, or the widget from your page, its code and asset will no longer increase your application footprint. \nThis allows you to create and distribute large libraries of controls without fear of application bloat.\n\n\nCreating or Integrating a Control\n\n\nWhile HTML5 Web Components are very interesting, the current browser support is limited.\nFor this reason, LaxarJS currently only covers the creation of a control as an AngularJS directive.\n\n\nOf course you can still use Web Components, jQuery UI or any other way of creating controls in your widgets, but LaxarJS currently will not manage assets for them.\nThe recommended way is therefore to wrap such controls in an AngularJS directive.\nThis can be done either for a single widget by simply adding a directive to its module, or following the steps below. \n\n\nCreating a Control using an AngularJS directive\n\n\nLaxarJS does not care whether your control is installed through bower or if it is a part of your project, as long as it has a \nRequireJS path\n configured.\nBasic familiarity with \nRequireJS\n should be enough to create your own controls.\nWhen writing a control to integrate third party libraries that do not support RequireJS, this can sometimes be tricky.  \n\n\nLet us try to create a control that displays a digital clock to the user.\n\n\nRequireJS Path\n\n\nFirst, choose a location for your controls, such as \nincludes/lib/my_controls\n.\nIn the require configuration, you need add the path to your new controls library:\n\n\npaths\n:\n \n{\n\n   \n// ...\n\n   \nmy_controls\n:\n \n../includes/lib/my_controls\n\n\n}\n\n\n\n\n\n\nThis assumes that \nbower_components\n is your RequireJS \nbaseUrl\n.\nIf it is something else, you will need to change the path accordingly (such as \nlib/my_controls\n if using \nincludes/\n as base URL).\n\n\nNow the \nrequire-path\n for the clock-control is \nmy_controls/clock\n.\n\n\nAngularJS Directive\n\n\nNow let us create the AngularJS module for the control, in \nincludes/lib/my_controls/clock.js\n:\n\n\ndefine\n(\n \n[\n \nangular\n,\n \ntext!my_controls/clock/clock.html\n \n],\n \nfunction\n(\n \nng\n,\n \nclockTemplate\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \nvar\n \nmodule\n \n=\n \nng\n.\nmodule\n(\n \nmy_controls.clock\n,\n \n[]\n \n);\n\n\n   \nmodule\n.\nfilter\n(\n \nmyPad\n,\n \nfunction\n()\n \n{\n\n      \nreturn\n \nfunction\n(\n \nnumber\n \n)\n \n{\n\n         \nreturn\n \n(\n \nnumber\n \n \n10\n \n?\n \n0\n \n:\n \n \n)\n \n+\n \nnumber\n;\n\n      \n}\n\n   \n}\n \n);\n\n\n   \nreturn\n \nmodule\n.\ndirective\n(\n \nmyClock\n,\n \n[\n \n$timeout\n,\n \nfunction\n(\n \n$timeout\n \n)\n \n{\n\n      \nreturn\n \n{\n\n         \nrestrict\n:\n \nE\n,\n\n         \ntemplate\n:\n \nclockTemplate\n,\n\n         \nlink\n:\n \nfunction\n(\n \n$scope\n \n)\n \n{\n\n            \ntick\n();\n\n            \nfunction\n \ntick\n()\n \n{\n\n               \n$scope\n.\ndate\n \n=\n \nnew\n \nDate\n();\n\n               \n$timeout\n(\n \ntick\n,\n \n1000\n \n);\n\n            \n}\n\n         \n}\n\n      \n};\n\n\n   \n}\n \n]\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\nFor the directive, we use a prefix, to avoid collisions with future HTML elements and other controls.\nMake sure to return the AngularJS module as shown here, so that LaxarJS can use it when bootstrapping your application.\n\n\nAngularJS Template\n\n\nLet us create a simple template at \nincludes/lib/my_controls/clock/clock.html\n.\n\n\nspan\n \nclass=\nmy-clock\n\n   {{ date.getHours() | myPad }}:{{ date.getMinutes() | myPad }}:{{ date.getSeconds() | myPad }}\n\n/span\n\n\n\n\n\n\nUse a prefix for the custom CSS class, to avoid collision with other controls and libraries.\nOf course, for maximum performance you might want to move the filtering to the \ntick\n function, but this should be fine as an example.\n\n\nThe CSS Stylesheet\n\n\nTo automatically load your CSS depending on the theme, it has to be placed into a sub-directory \ndefault.theme/css\n of your require path and it has to use the same file name as the controller file.\nIn case of the clock, the correct path is \nincludes/lib/my_controls/clock/default.theme/clock.css\n.\n\n\n.my-clock\n \n{\n\n   \nfont-family\n:\n \nTimes New Roman\n,\n \nserif\n;\n\n   \nfont-weight\n:\n \nbold\n;\n\n   \nfont-size\n:\n \n36px\n;\n\n   \nborder\n:\n \n3px\n \ndouble\n \nblack\n;\n\n   \npadding\n:\n \n3px\n;\n\n\n}\n\n\n\n\n\n\nUsing a Control from a Widget\n\n\nAny widget that uses our clock should declare its dependency using \ncontrols\n entry in its \nwidget.json\n:\n\n\ncontrols\n:\n \n[\n \nmy_controls/clock\n \n]\n,\n\n\n\n\n\n\nThis allows the runtime to load the RequireJS module and to register its AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application. \n\n\nTo actually get the control onto the screen, you have to reference it from your widget template:\n\n\nh3\nMy Widget, now with 100% more 24h-clock!\n/h3\n\n\nmy-clock\n/my-clock\n\n\n\n\n\n\nAfter adding your widget to a page, you may inspect your timepiece in the browser:\n\n\n\n\nCreating or Integrating a Library\n\n\nTODO", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#controls-and-libraries", 
            "text": "In LaxarJS, any non-trivial HTML element,  HTML5 Web Component  or  AngularJS directive  is considered a  control .\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.\nTo provide their business logic, widgets and activities often depend on libraries, which might be created by third parties or simply be used to share common functionality.\nIn the latter case, be sure not to couple your controllers to tightly, e.g. the shared libraries should not allow to share state.  Here are some examples of controls:  * a select box\n* a date picker\n* an accordion control\n* a tab control  LaxarJS helps when developing a custom control by managing its AngularJS modules, as well as its CSS and HTML assets for you.\nIf (and only if) you  use  a control in one or more widgets, LaxarJS will load its CSS according to the current  theme , just like with widgets and templates.\nWhen you remove the control from your widget, or the widget from your page, its code and asset will no longer increase your application footprint. \nThis allows you to create and distribute large libraries of controls without fear of application bloat.", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-control", 
            "text": "While HTML5 Web Components are very interesting, the current browser support is limited.\nFor this reason, LaxarJS currently only covers the creation of a control as an AngularJS directive.  Of course you can still use Web Components, jQuery UI or any other way of creating controls in your widgets, but LaxarJS currently will not manage assets for them.\nThe recommended way is therefore to wrap such controls in an AngularJS directive.\nThis can be done either for a single widget by simply adding a directive to its module, or following the steps below.", 
            "title": "Creating or Integrating a Control"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-a-control-using-an-angularjs-directive", 
            "text": "LaxarJS does not care whether your control is installed through bower or if it is a part of your project, as long as it has a  RequireJS path  configured.\nBasic familiarity with  RequireJS  should be enough to create your own controls.\nWhen writing a control to integrate third party libraries that do not support RequireJS, this can sometimes be tricky.    Let us try to create a control that displays a digital clock to the user.", 
            "title": "Creating a Control using an AngularJS directive"
        }, 
        {
            "location": "/manuals/providing_controls/#requirejs-path", 
            "text": "First, choose a location for your controls, such as  includes/lib/my_controls .\nIn the require configuration, you need add the path to your new controls library:  paths :   { \n    // ... \n    my_controls :   ../includes/lib/my_controls  }   This assumes that  bower_components  is your RequireJS  baseUrl .\nIf it is something else, you will need to change the path accordingly (such as  lib/my_controls  if using  includes/  as base URL).  Now the  require-path  for the clock-control is  my_controls/clock .", 
            "title": "RequireJS Path"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-directive", 
            "text": "Now let us create the AngularJS module for the control, in  includes/lib/my_controls/clock.js :  define (   [   angular ,   text!my_controls/clock/clock.html   ],   function (   ng ,   clockTemplate   )   { \n    use strict ; \n\n    var   module   =   ng . module (   my_controls.clock ,   []   ); \n\n    module . filter (   myPad ,   function ()   { \n       return   function (   number   )   { \n          return   (   number     10   ?   0   :     )   +   number ; \n       } \n    }   ); \n\n    return   module . directive (   myClock ,   [   $timeout ,   function (   $timeout   )   { \n       return   { \n          restrict :   E , \n          template :   clockTemplate , \n          link :   function (   $scope   )   { \n             tick (); \n             function   tick ()   { \n                $scope . date   =   new   Date (); \n                $timeout (   tick ,   1000   ); \n             } \n          } \n       }; \n\n    }   ]   );  }   );   For the directive, we use a prefix, to avoid collisions with future HTML elements and other controls.\nMake sure to return the AngularJS module as shown here, so that LaxarJS can use it when bootstrapping your application.", 
            "title": "AngularJS Directive"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-template", 
            "text": "Let us create a simple template at  includes/lib/my_controls/clock/clock.html .  span   class= my-clock \n   {{ date.getHours() | myPad }}:{{ date.getMinutes() | myPad }}:{{ date.getSeconds() | myPad }} /span   Use a prefix for the custom CSS class, to avoid collision with other controls and libraries.\nOf course, for maximum performance you might want to move the filtering to the  tick  function, but this should be fine as an example.", 
            "title": "AngularJS Template"
        }, 
        {
            "location": "/manuals/providing_controls/#the-css-stylesheet", 
            "text": "To automatically load your CSS depending on the theme, it has to be placed into a sub-directory  default.theme/css  of your require path and it has to use the same file name as the controller file.\nIn case of the clock, the correct path is  includes/lib/my_controls/clock/default.theme/clock.css .  .my-clock   { \n    font-family :   Times New Roman ,   serif ; \n    font-weight :   bold ; \n    font-size :   36px ; \n    border :   3px   double   black ; \n    padding :   3px ;  }", 
            "title": "The CSS Stylesheet"
        }, 
        {
            "location": "/manuals/providing_controls/#using-a-control-from-a-widget", 
            "text": "Any widget that uses our clock should declare its dependency using  controls  entry in its  widget.json :  controls :   [   my_controls/clock   ] ,   This allows the runtime to load the RequireJS module and to register its AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application.   To actually get the control onto the screen, you have to reference it from your widget template:  h3 My Widget, now with 100% more 24h-clock! /h3  my-clock /my-clock   After adding your widget to a page, you may inspect your timepiece in the browser:", 
            "title": "Using a Control from a Widget"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-library", 
            "text": "TODO", 
            "title": "Creating or Integrating a Library"
        }, 
        {
            "location": "/manuals/creating_themes/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\n\n\nCreating Themes\n\n\nSometimes you would like to use the \none widget\n in \ntwo or more applications\n.\nFor this, usually you want the widget to \nbehave identically\n, but \nlook differently\n.\nAlternatively, you would sometimes like to offer the same application in different appearances.\nLaxarJS has the concept of \nthemes\n to help you achieve these things.\n\n\nWhy Themes?\n\n\nLaxarJS ships with a so-called \ndefault theme\n, which is actually just \nBootstrap CSS\n together with \nFont Awesome\n and a few additional classes.\nThere are several ways to add your own styles.\n\n\nFrom Ad-Hoc Styles to Theme Folders\u2026\n\n\nUsually, you will need to add some CSS classes of your own.\nFor example, the vast majority of web application needs some styling for the page background and positioning or custom header and footer areas.\nTo include such \nad-hoc styles\n, you \ncould\n simply add a CSS file of your own to the project, and load it from the debug.html and index.html files using the \nlink\n tag.\nHowever, it is \nrecommended\n to add these styles to your main application layout instead, into a sub-folder called \ndefault.theme/css\n.\n\n\nThe \nbenefit\n of using such a \ntheme folder\n is that\n\n\n* your CSS will be _bundled and compressed_ together with Bootstrap (no `\nlink\n` tag needed) and that\n* you can support different _themes_ simply by adding more `.theme` folders.\n\n\n\n\n\nDue to the first point, using the theme folders is useful and recommended \neven\n if you only use (and maybe customize) the default theme.\nThe LaxarJS \nMashupDemo\n application takes this no-fuss approach to customizing Bootstrap.\n\n\n\u2026and to Custom Themes\n\n\nAs soon as you use multiple page layouts, the previous approach does not really scale anymore: you would have to duplicate your global styles to all of them.\nIn these cases, creating your own theme is definitely recommended.\nA detailed explanation of \ncreating a theme\n is given below.\n\n\nA Note on Compass/SCSS\n\n\nWhen using theme folders or entire themes, the runtime will only ever look at \n.css\n files in \ncss\n sub-folders.\nThis means that it is entirely \nup to you\n which (if any) CSS authoring tools you would like to use.\n\n\nThat being said, we use Compass/SCSS to create themes, and the default-theme is based on the SCSS version of Bootstrap.\nUsing this approach makes it very easy to create a custom theme just by changing some Bootstrap SCSS variables.\nAlso, by using SCSS variables defined in the theme, widgets and controls can provide a consistent appearance.\nAfter explaining themes in general, below are instructions on \ncreating an SCSS theme\n.\n\n\n\n\nCreating your own Theme\n\n\nLet us create our own theme for an existing application, the \nLaxarJS ShopDemo\n.\nThe ShopDemo brings it's own theme \n\"laxar_demo\"\n, which is implemented by augmenting Bootstrap with some custom additions.\n\n\n\n\nAbove:\n The LaxarJS ShopDemo using the \nlaxar_demo\n theme\n\n\nHowever, the demo also works with just the default theme, provided by LaxarJS UiKit, although admittedly it does not look quite as pretty:\n\n\n\n\nAbove:\n The LaxarJS ShopDemo using the \ndefault\n theme\n\n\nAdding a Theme Using Plain CSS\n\n\nNow, since all applications seem to offer a \"dark\" look these days, let us try to achieve this for our shop demo app.\nFortunately, there are several collections of nice bootstrap themes available for free.\nOn the site \nBootswatch\n for example, you will find the theme \ndarkly\n, which looks like it might work for us.\n\n\nThe only thing that is actually \nrequired\n for a theme to work are a configuration entry and a CSS file in the right place.\nPut the pre-built \ndarkly css\n into the right place, which is \nincludes/themes/darkly.theme/css/theme.css\n.\nThe path prefix \nincludes/themes/\n may be changed using the RequireJS configuration path \nlaxar-path-themes\n.\nIn the LaxarJS configuration (usually \napplication/application.js\n), change the property \nlaxar.portal.theme\n from \n\"default\"\n to \n\"darkly\"\n.\nThis causes the LaxarJS runtime to use the new theme.\n\n\nBecause the ShopDemo uses \nFont Awesome\n, we need to add an import to the top of our CSS file for that as well:\n\n\n@import\n \nurl\n(\n//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css\n)\n;\n\n\n\n\n\n\nBefore opening the application in the browser, make sure to restart the development server, so that the new files are picked up.\nAnd \nvoil\u00e0\n, we have a dark web shop:\n\n\n\n\nAbove:\n The all-new ShopDemo using the \ndarkly\n theme, hopefully not for any shady business\n\n\nOf course, there are still some rough spots that need additional work:\nFor example, the widget headers look much better using the original laxar demo theme.\n\n\nLet's fix that using \nwidget-specific styles:\n\nThe widget styles use a \ncategory/name\n directory structure, similar to that of the actual widgets.\nHere are some suggestions for a nicer look, to be put under \nwidgets/shop_demo\n:\n\n\n\n\nArticleBrowserWidget\n: \narticle_browser_widget/css/article_browser_widget.css\n\n\n\n\nHere we color the icon, the headline to match the logo, and the currently selected article to match the details widget.\n\n\n/** Customize header and icon color: */\n\n\n.article-browser-widget\n \nh3\n \ni\n \n{\n\n  \ncolor\n:\n \n#F90\n;\n\n\n}\n\n\n\n.article-browser-widget\n \nth\n \n{\n\n  \nbackground-color\n:\n \n#F90\n;\n\n  \ncolor\n:\n \n#222222\n;\n\n\n}\n\n\n\n/** Highlight the selected article. */\n\n\n.article-browser-widget\n \ntr\n.selected\n \ntd\n \n{\n\n  \nfont-weight\n:\n \nbold\n;\n\n  \nbackground\n:\n \n#3498DB\n;\n\n\n}\n\n\n\n\n\n\n\n\nArticleTeaserWidget\n: \narticle_teaser_widget/css/article_teaser_widget.css\n\n\n\n\nHere we color the icon and the headline to match the button.\n\n\n/** Customize header and icon color: */\n\n\n.article-teaser-widget\n \nh3\n \ni\n \n{\n\n   \ncolor\n:\n \n#3498DB\n;\n\n\n}\n\n\n\n.article-teaser-widget\n \nh4\n \n{\n\n   \nbackground-color\n:\n \n#3498DB\n;\n\n   \npadding\n:\n \n8px\n;\n\n\n}\n\n\n\n\n\n\n\n\nShoppingCartWidget\n: \nshopping_cart_widget/css/shopping_cart_widget.css\n\n\n\n\nAgain, we color the icon and the headline to match the button.\n\n\n/** Customize header and icon color: */\n\n\n.shopping-cart-widget\n \nh3\n \ni\n \n{\n\n   \ncolor\n:\n \n#00bc8c\n;\n\n\n}\n\n\n\n.shopping-cart-widget\n \nth\n \n{\n\n   \nbackground-color\n:\n \n#00bc8c\n;\n\n\n}\n\n\n\n/** plus/minus buttons */\n\n\n.shopping-cart-widget\n \n.app-increase-quantity\n \n{\n\n   \ntext-align\n:\n \nright\n \n!important\n;\n\n\n}\n\n\n\n.shopping-cart-widget\n \n.app-increase-buttons\n \n{\n\n   \npadding\n:\n \n0\n;\n\n   \npadding-top\n:\n \n6px\n;\n\n   \nwidth\n:\n \n40px\n;\n\n\n}\n\n\n\n.shopping-cart-widget\n \n.app-increase-buttons\n \nbutton\n \n{\n\n   \npadding\n:\n \n0\n;\n\n\n}\n\n\n\n\n\n\nNow we have four different CSS files.\nOf course, we do not want users to download an additional CSS file for each widget that we use.\nInstead, we use \ngrunt dist\n to create a merged version, which we may load through the \nindex.html\n.\n\n\n\n\nAbove:\n The all-new ShopDemo using the \ndarkly\n theme with widget styles. Not too shabby, eh?\n\n\nHave a look at the \ndark theme in action\n.\n\n\nOf course, there are still some problems with this way of styling widgets.\nFor example, if we would like to change the shade of blue that is used in our theme, we would have to update multiple source code locations.\nIt would be better to have some way to define these values in our theme and reuse them from individual widgets.  \n\n\n\n\nAdding a Theme using Compass/SCSS\n\n\nTo support centralized variables, you can use a \ncompiles-to-CSS\n language such as \nSCSS/SASS\n or \nless\n.\nAt the LaxarJS team we like \nCompass\n, which is built on top of SCSS.\nFortunately, an SCSS-version of the darkly theme is available, and can be installed using \nBower\n.\n\n\nOur SCSS theme uses a single central \ncompass/config.rb\n for the theme itself, and for individual widgets.\nThe \nconfig.rb\n has a similar role for SCSS as the \nrequire_config.js\n has for the project's javascript modules: it tells Compass where to find SCSS libraries. \nWhen compiling widget CSS, the path to the config should be passed on the command line:\n\n\ncompass compile -c /path/to/shop_demo/includes/themes/darkly_scss.theme/compass/config.rb\n\n\n\n\n\nWith the \nright config\n in place, the \nSCSS for our theme\n is little more than a couple of imports.\nExecute \ncompass\n from any parent folder containing the \nscss\n, \ncss\n and possibly also \nfonts\n and \nimages\n directories.\nNote that you can probably configure your editor or IDE to always pass the \n-c\n option correctly, otherwise you can create a shell alias. \n\n\nThe advantage of using an SCSS theme is that we can now write concise widget styles using central variables.\nAs an example, here is the SCSS file for the \nArticleBrowserWidget\n:\n\n\n@import\n \nvariables_all\n;\n\n\n\n.article-browser-widget\n \n{\n\n\n  \nh3\n \ni\n \n{\n\n    \ncolor\n:\n \n$app-color-logo\n;\n\n  \n}\n\n\n  \nth\n \n{\n\n    \nbackground-color\n:\n \n$app-color-logo\n;\n\n    \ncolor\n:\n \n$body-bg\n;\n\n  \n}\n\n\n  \ntr\n.selected\n \ntd\n \n{\n\n    \nfont-weight\n:\n \nbold\n;\n\n    \nbackground\n:\n \n$brand-info\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\nWhich CSS framework and toolchain to use (if any) is ultimately up to you.\nThe \nshop demo on github\n contains the \ndarkly\n theme both as a \nplain CSS version\n, and as an \nSCSS version\n.\n\n\nThe Bootstrap framework incurs some degree of boilerplate, but makes it relatively easy to reuse widgets across applications, and to find controls that work with your theme out of the box.\n\n\nHow the Runtime Finds CSS\n\n\nAs mentioned previously, the LaxarJS runtime and grunt tasks do not care how you create your CSS.\nHowever, these tools need to find it.\n\n\nThe general lookup works always like this:\n\n\n1. if there are _application specific styles_ for an artifact then use those\n2. else if there are _default styles_ for an artifact then use those\n3. else load _nothing_\n\n\n\n\n\nOf course, \nload nothing\n means that it is completely fine for a widget not to have its own CSS styles.\nIf it was missing an HTML template on the other hand, that would simply be an error.\nFollowing this structure allows the \ngrunt-laxar\n tasks to find and combine the correct HTML and CSS assets, so that the number of HTTP requests may be minimized during production.\n\n\nLooking up the Theme CSS\n\n\nTo load the CSS for the theme itself, the portal simply uses the \nconfigured\n theme \nX\n and looks for its CSS under \nincludes/themes/X.theme/css/theme.css\n.\nThe exception is the default theme, which is currently loaded from \nlaxar_uikit\n (if no user-defined theme is specified).\n\n\nLooking up Widget CSS and HTML Templates\n\n\nFor widget CSS styles and HTML templates, the LaxarJS runtime first checks if a version is available within the theme.\nThis means that you cannot only customize the CSS for a widget \nX\n by placing a stylesheet at \ntheme\n/widgets/category/X/css/X.css\n but that you can also override the HTML at \ntheme\n/widgets/category/X/X.html\n.\nIf nothing is found in the current theme for a given widget, the \ndefault.theme\n folder within the widget itself is used.\nDo note that CSS and HTML files are treated separately:\nYou can override the CSS but not the HTML or vice versa.\n\n\nLooking up CSS and HTML for a Layout\n\n\nThemes are intended to be reusable across applications.\nBecause layouts are highly specific to an application, their CSS and HTML assets are always \nwithin the layout's folder\n, for all themes.\nOtherwise, the same process as for widgets is used: First, LaxarJS searches the current theme folder, before falling back to the default theme.\n\n\nLooking up CSS for a Control\n\n\nControls (AngularJS directives) take care of their own HTML loading, so the choice of theme has no effect here.\nThe styling however is theme specific:\nBefore looking for the default theme in \ncontrol-require-path\n/default.theme/css/\ncontrol-name\n.css\n, LaxarJS looks for a theme specific override in \ntheme-path\n/\ncontrol-require-path\n/css/\ncontrol-name\n.css\n.\nHere, the \ntheme-path\n refers to the folder containing your global theme, and the \ncontrol-require-path\n is the same path that widgets specify in their widget.json to include a control.\nHave a look at the \nmanual on controls\n for details.", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#creating-themes", 
            "text": "Sometimes you would like to use the  one widget  in  two or more applications .\nFor this, usually you want the widget to  behave identically , but  look differently .\nAlternatively, you would sometimes like to offer the same application in different appearances.\nLaxarJS has the concept of  themes  to help you achieve these things.", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#why-themes", 
            "text": "LaxarJS ships with a so-called  default theme , which is actually just  Bootstrap CSS  together with  Font Awesome  and a few additional classes.\nThere are several ways to add your own styles.", 
            "title": "Why Themes?"
        }, 
        {
            "location": "/manuals/creating_themes/#from-ad-hoc-styles-to-theme-folders", 
            "text": "Usually, you will need to add some CSS classes of your own.\nFor example, the vast majority of web application needs some styling for the page background and positioning or custom header and footer areas.\nTo include such  ad-hoc styles , you  could  simply add a CSS file of your own to the project, and load it from the debug.html and index.html files using the  link  tag.\nHowever, it is  recommended  to add these styles to your main application layout instead, into a sub-folder called  default.theme/css .  The  benefit  of using such a  theme folder  is that  * your CSS will be _bundled and compressed_ together with Bootstrap (no ` link ` tag needed) and that\n* you can support different _themes_ simply by adding more `.theme` folders.  Due to the first point, using the theme folders is useful and recommended  even  if you only use (and maybe customize) the default theme.\nThe LaxarJS  MashupDemo  application takes this no-fuss approach to customizing Bootstrap.", 
            "title": "From Ad-Hoc Styles to Theme Folders\u2026"
        }, 
        {
            "location": "/manuals/creating_themes/#and-to-custom-themes", 
            "text": "As soon as you use multiple page layouts, the previous approach does not really scale anymore: you would have to duplicate your global styles to all of them.\nIn these cases, creating your own theme is definitely recommended.\nA detailed explanation of  creating a theme  is given below.", 
            "title": "\u2026and to Custom Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#a-note-on-compassscss", 
            "text": "When using theme folders or entire themes, the runtime will only ever look at  .css  files in  css  sub-folders.\nThis means that it is entirely  up to you  which (if any) CSS authoring tools you would like to use.  That being said, we use Compass/SCSS to create themes, and the default-theme is based on the SCSS version of Bootstrap.\nUsing this approach makes it very easy to create a custom theme just by changing some Bootstrap SCSS variables.\nAlso, by using SCSS variables defined in the theme, widgets and controls can provide a consistent appearance.\nAfter explaining themes in general, below are instructions on  creating an SCSS theme .", 
            "title": "A Note on Compass/SCSS"
        }, 
        {
            "location": "/manuals/creating_themes/#creating-your-own-theme", 
            "text": "Let us create our own theme for an existing application, the  LaxarJS ShopDemo .\nThe ShopDemo brings it's own theme  \"laxar_demo\" , which is implemented by augmenting Bootstrap with some custom additions.   Above:  The LaxarJS ShopDemo using the  laxar_demo  theme  However, the demo also works with just the default theme, provided by LaxarJS UiKit, although admittedly it does not look quite as pretty:   Above:  The LaxarJS ShopDemo using the  default  theme", 
            "title": "Creating your own Theme"
        }, 
        {
            "location": "/manuals/creating_themes/#adding-a-theme-using-plain-css", 
            "text": "Now, since all applications seem to offer a \"dark\" look these days, let us try to achieve this for our shop demo app.\nFortunately, there are several collections of nice bootstrap themes available for free.\nOn the site  Bootswatch  for example, you will find the theme  darkly , which looks like it might work for us.  The only thing that is actually  required  for a theme to work are a configuration entry and a CSS file in the right place.\nPut the pre-built  darkly css  into the right place, which is  includes/themes/darkly.theme/css/theme.css .\nThe path prefix  includes/themes/  may be changed using the RequireJS configuration path  laxar-path-themes .\nIn the LaxarJS configuration (usually  application/application.js ), change the property  laxar.portal.theme  from  \"default\"  to  \"darkly\" .\nThis causes the LaxarJS runtime to use the new theme.  Because the ShopDemo uses  Font Awesome , we need to add an import to the top of our CSS file for that as well:  @import   url ( //maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css ) ;   Before opening the application in the browser, make sure to restart the development server, so that the new files are picked up.\nAnd  voil\u00e0 , we have a dark web shop:   Above:  The all-new ShopDemo using the  darkly  theme, hopefully not for any shady business  Of course, there are still some rough spots that need additional work:\nFor example, the widget headers look much better using the original laxar demo theme.  Let's fix that using  widget-specific styles: \nThe widget styles use a  category/name  directory structure, similar to that of the actual widgets.\nHere are some suggestions for a nicer look, to be put under  widgets/shop_demo :   ArticleBrowserWidget :  article_browser_widget/css/article_browser_widget.css   Here we color the icon, the headline to match the logo, and the currently selected article to match the details widget.  /** Customize header and icon color: */  .article-browser-widget   h3   i   { \n   color :   #F90 ;  }  .article-browser-widget   th   { \n   background-color :   #F90 ; \n   color :   #222222 ;  }  /** Highlight the selected article. */  .article-browser-widget   tr .selected   td   { \n   font-weight :   bold ; \n   background :   #3498DB ;  }    ArticleTeaserWidget :  article_teaser_widget/css/article_teaser_widget.css   Here we color the icon and the headline to match the button.  /** Customize header and icon color: */  .article-teaser-widget   h3   i   { \n    color :   #3498DB ;  }  .article-teaser-widget   h4   { \n    background-color :   #3498DB ; \n    padding :   8px ;  }    ShoppingCartWidget :  shopping_cart_widget/css/shopping_cart_widget.css   Again, we color the icon and the headline to match the button.  /** Customize header and icon color: */  .shopping-cart-widget   h3   i   { \n    color :   #00bc8c ;  }  .shopping-cart-widget   th   { \n    background-color :   #00bc8c ;  }  /** plus/minus buttons */  .shopping-cart-widget   .app-increase-quantity   { \n    text-align :   right   !important ;  }  .shopping-cart-widget   .app-increase-buttons   { \n    padding :   0 ; \n    padding-top :   6px ; \n    width :   40px ;  }  .shopping-cart-widget   .app-increase-buttons   button   { \n    padding :   0 ;  }   Now we have four different CSS files.\nOf course, we do not want users to download an additional CSS file for each widget that we use.\nInstead, we use  grunt dist  to create a merged version, which we may load through the  index.html .   Above:  The all-new ShopDemo using the  darkly  theme with widget styles. Not too shabby, eh?  Have a look at the  dark theme in action .  Of course, there are still some problems with this way of styling widgets.\nFor example, if we would like to change the shade of blue that is used in our theme, we would have to update multiple source code locations.\nIt would be better to have some way to define these values in our theme and reuse them from individual widgets.", 
            "title": "Adding a Theme Using Plain CSS"
        }, 
        {
            "location": "/manuals/creating_themes/#adding-a-theme-using-compassscss", 
            "text": "To support centralized variables, you can use a  compiles-to-CSS  language such as  SCSS/SASS  or  less .\nAt the LaxarJS team we like  Compass , which is built on top of SCSS.\nFortunately, an SCSS-version of the darkly theme is available, and can be installed using  Bower .  Our SCSS theme uses a single central  compass/config.rb  for the theme itself, and for individual widgets.\nThe  config.rb  has a similar role for SCSS as the  require_config.js  has for the project's javascript modules: it tells Compass where to find SCSS libraries. \nWhen compiling widget CSS, the path to the config should be passed on the command line:  compass compile -c /path/to/shop_demo/includes/themes/darkly_scss.theme/compass/config.rb  With the  right config  in place, the  SCSS for our theme  is little more than a couple of imports.\nExecute  compass  from any parent folder containing the  scss ,  css  and possibly also  fonts  and  images  directories.\nNote that you can probably configure your editor or IDE to always pass the  -c  option correctly, otherwise you can create a shell alias.   The advantage of using an SCSS theme is that we can now write concise widget styles using central variables.\nAs an example, here is the SCSS file for the  ArticleBrowserWidget :  @import   variables_all ;  .article-browser-widget   { \n\n   h3   i   { \n     color :   $app-color-logo ; \n   } \n\n   th   { \n     background-color :   $app-color-logo ; \n     color :   $body-bg ; \n   } \n\n   tr .selected   td   { \n     font-weight :   bold ; \n     background :   $brand-info ; \n   }  }   Which CSS framework and toolchain to use (if any) is ultimately up to you.\nThe  shop demo on github  contains the  darkly  theme both as a  plain CSS version , and as an  SCSS version .  The Bootstrap framework incurs some degree of boilerplate, but makes it relatively easy to reuse widgets across applications, and to find controls that work with your theme out of the box.", 
            "title": "Adding a Theme using Compass/SCSS"
        }, 
        {
            "location": "/manuals/creating_themes/#how-the-runtime-finds-css", 
            "text": "As mentioned previously, the LaxarJS runtime and grunt tasks do not care how you create your CSS.\nHowever, these tools need to find it.  The general lookup works always like this:  1. if there are _application specific styles_ for an artifact then use those\n2. else if there are _default styles_ for an artifact then use those\n3. else load _nothing_  Of course,  load nothing  means that it is completely fine for a widget not to have its own CSS styles.\nIf it was missing an HTML template on the other hand, that would simply be an error.\nFollowing this structure allows the  grunt-laxar  tasks to find and combine the correct HTML and CSS assets, so that the number of HTTP requests may be minimized during production.", 
            "title": "How the Runtime Finds CSS"
        }, 
        {
            "location": "/manuals/creating_themes/#looking-up-the-theme-css", 
            "text": "To load the CSS for the theme itself, the portal simply uses the  configured  theme  X  and looks for its CSS under  includes/themes/X.theme/css/theme.css .\nThe exception is the default theme, which is currently loaded from  laxar_uikit  (if no user-defined theme is specified).", 
            "title": "Looking up the Theme CSS"
        }, 
        {
            "location": "/manuals/creating_themes/#looking-up-widget-css-and-html-templates", 
            "text": "For widget CSS styles and HTML templates, the LaxarJS runtime first checks if a version is available within the theme.\nThis means that you cannot only customize the CSS for a widget  X  by placing a stylesheet at  theme /widgets/category/X/css/X.css  but that you can also override the HTML at  theme /widgets/category/X/X.html .\nIf nothing is found in the current theme for a given widget, the  default.theme  folder within the widget itself is used.\nDo note that CSS and HTML files are treated separately:\nYou can override the CSS but not the HTML or vice versa.", 
            "title": "Looking up Widget CSS and HTML Templates"
        }, 
        {
            "location": "/manuals/creating_themes/#looking-up-css-and-html-for-a-layout", 
            "text": "Themes are intended to be reusable across applications.\nBecause layouts are highly specific to an application, their CSS and HTML assets are always  within the layout's folder , for all themes.\nOtherwise, the same process as for widgets is used: First, LaxarJS searches the current theme folder, before falling back to the default theme.", 
            "title": "Looking up CSS and HTML for a Layout"
        }, 
        {
            "location": "/manuals/creating_themes/#looking-up-css-for-a-control", 
            "text": "Controls (AngularJS directives) take care of their own HTML loading, so the choice of theme has no effect here.\nThe styling however is theme specific:\nBefore looking for the default theme in  control-require-path /default.theme/css/ control-name .css , LaxarJS looks for a theme specific override in  theme-path / control-require-path /css/ control-name .css .\nHere, the  theme-path  refers to the folder containing your global theme, and the  control-require-path  is the same path that widgets specify in their widget.json to include a control.\nHave a look at the  manual on controls  for details.", 
            "title": "Looking up CSS for a Control"
        }, 
        {
            "location": "/manuals/events/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nEvents and Publish-Subscribe\n\n\nThe key concept that distinguishes LaxarJS applications from other AngularJS applications is the \npublish-subscribe\n (or \npub/sub\n) architecture.\nIt helps to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).\n\n\nLaxarJS consistently uses the term \nevents\n rather than \nmessages\n, to point out two key aspects of its pub/sub-architecture:\n * events convey information about \nwhat happened\n (rather than \nwho is receiver\n)\n * delivery is always \nasynchronous\n (using an \nevent loop\n)\n\n\nFor these reasons, you may also think of this pattern as a variation on the \nhollywood principle\n (\"Don't call us, we'll call you\").\n\n\nFor efficient processing, LaxarJS ties into the AngularJS \n$digest\n-cycle.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.\n\n\nThe Event Bus\n\n\nAll events are published to and delivered by the \nevent bus\n:\nThe event bus manages \nname-based\n (or \ntopic-based)\n \nevent subscriptions\n for all interested widgets and activities (the \nsubscribers)\n:\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.\n\n\nEach event has a \nname\n containing a summary of what happened, and a \npayload\n carrying additional information.\n\n\nEvent Names\n\n\nEvent names summarize \nwhat happened\n, possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.\n\n\nAn event name is a string, formed by a sequence of one or more \ntopics\n that are separated by \n.\n (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more \nsub-topics\n separated by \n-\n (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by\n\n\n* _either_ an upper case letter followed by a sequence of upper case letters and numbers\n* _or_ a lower case letter followed by a sequence of mixed case letters and numbers\n\n\n\n\n\nThese rules also exist as a formal \ngrammar\n for thorough people.\n\n\nThese are examples for \nvalid\n event names:\n\n\n* `didReplace.myShoppingCart`\n* `takeActionRequest.searchArticles`\n* `didTakeAction.searchArticles.SUCCESS`\n* `willEndLifecycle`\n* `didValidate.popup-user2`\n\n\n\n\n\nInvalid\n event names include:\n\n\n* `DidReplace.myShoppingCart`: _invalid,_ first topic starts upper case but contains lower case letters\n* `.searchArticles.SUCCESS`: _invalid,_ empty topic is not allowed\n* `didUpdate.1up`: _invalid_, topic must not start with a number\n\n\n\n\n\nNaming Best Practices and Event Patterns\n\n\nGood event names start with a very general \nverb-based first topic\n, broadly describing \nwhat\n happened.\nThat topic is often followed by a more specific \nobject-based second topic\n, describing \nwhere\n (or \nto what\n) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event \ndidValidate.popup-user2\n informs all interested subscribers, that the second user has been validated by a widget \nwithin a popup\n.\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a \nmodal third topic\n, broadly describing \nhow\n something happened (e.g. to communicate an outcome such as \nSUCCESS\n or \nERROR\n).\n\n\nOf course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.\n\n\nIt is recommended wherever possible for widgets to use one or more of the established \nevent patterns\n:\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few \ncore patterns\n are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project \nLaxarJS Patterns\n.\nEven without using the LaxarJS Patterns \nlibrary\n, widget authors are very much encouraged to use the \nevent vocabularies\n whenever meaningful.\n\n\nEvent Payload\n\n\nAn event does not only have a name, but also a \npayload\n.\nAny JavaScript object that can be directly represented as \nJSON\n can be used as a payload.\nThis allows for the object to contain instances of \nstring\n, \narray\n, \nnumber\n, \nboolean\n and \nobject\n, including \nnull\n.\nOn the other hand, it excludes\nundefined\n, \nDate\n, \nRegExp\n and custom classes.\n\n\nThe Event Bus will \ncreate a copy\n of the payload \nfor each subscriber\n that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.\n\n\nHowever, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache).\n\n\n\n\nTwo-Way Communication or the Request/Will/Did Mechanism\n\n\nSometimes a widget has to request for some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about \nwho\n actually performs the request, but it is interested in \nwhen\n the request has been fully processed by all respondents, and what is the outcome.\n\n\nAs an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a CAPTCHA.\nAnother widget offering a \nComplete Sign-Up\n button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective sign-up details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the CAPTCHA widget.\n\n\nUsing the \nRequest/Will/Did\n mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:\n\n\n\n\n\n\nThe individual widgets are \nconfigured\n on the page to work with a common \nregistrationForm\n resource.\n   On instantiation, the input widgets offering validation subscribe to \nvalidateRequest\n events for this resource.\n\n\n\n\n\n\nWhen the user activates the \nComplete Sign-Up\n button, the registration widget issues a \nvalidateRequest.registrationForm\n event, indicating that\n\n\n\n\na validation has been requested \n(what happened)\n and\n\n\nit concerns the resource \nregistrationForm\n \n(where\n it happened).\n\n\n\n\n\n\n\n\nThe registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.\n\n\n\n\n\n\nDuring delivery, the input widgets supporting validation receive the request and publish a \nwillValidate.registrationForm\n event to indicate that\n\n\n\n\na validation has been initiated \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n.\n\n\n\n\n\n\n\n\nEach widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either \ndidValidate.registrationForm.SUCCESS\n or \ndidValidate.registrationForm.ERROR\n conveying that\n\n\n\n\na validation has been performed \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n and\n\n\nthe way the validation turned out \n(how)\n.\n\n\n\n\n\n\n\n\nOnce all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the \nsign-up\n REST request may be performed.\n\n\n\n\n\n\nThis mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its \n\"didValidate\"\n events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.\n\n\nValidation and other patterns are described in the following section.\n\n\n\n\nPattern Reference\n\n\nA few event patterns are supported directly by LaxarJS, while others are described in the \nLaxarJS Patterns\n library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.\n\n\n\n\nCore Patterns\n\n\nThe core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.\n\n\nPage Lifecycle\n\n\nAfter all widget controllers have been instantiated, the runtime publishes a \nbeginLifecycleRequest\n event.\nWidgets that need to publish events on page load should do so \nafter\n receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.\n\n\nBefore \nnavigating\n away from a page, the runtime publishes the \nendLifecycleRequest\n event.\nWidgets that need to save state to a service should respond with a \nwillEndLifecycle\n event, perform their housekeeping and publish an \ndidEndLifecycle\n when done.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbeginLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that publishing of events is safe now\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nthe lifecycle ID (currently, this is always \n\"default\"\n)\n\n\n\n\n\n\nwillBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer page rendering (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page rendering may commence (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nendLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that the page is about to be destroyed\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nwillEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer tear down of the page (if necessary)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page tear down may commence (after deferring it)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\n\n\n\n\nNavigation\n\n\nWidgets and activities may initiate navigation using a \nnavigateRequest.{target}\n event, substituting an actual navigation target instead of the placeholder \n{target}\n.\nThe event is interpreted by the LaxarJS runtime as follows:\n\n\n* if _target_ is `\n_self\n`, the runtime will simply propagate its place-parameters by publishing a `didNavigate` event right away\n* if _target_ is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place\n* otherwise, if _target_ is a place within the flow definition, the runtime will initiate navigation to that place\n* otherwise, nothing will happen.\n\n\n\n\n\nWhen \ninitiating navigation\n, the LaxarJS runtime will:\n\n\n1. extract any place parameters from the event payload of the request event\n2. publish a `willNavigate.{target}` event with the corresponding target and parameters\n3. publish an `endLifecycle` event and wait for any respondents\n4. perform navigation by destroying the current page and loading the page associated with the new place\n3. publish a `beginLifecycle` event and wait for any respondents\n5. publish a `didNavigate.{target}` event, with the corresponding target and parameters as well as the resolved place\n\n\n\n\n\nHere is the summary of navigation events:\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnavigateRequest.{target}\n\n\n\n\npublished by widgets and activities to indicate that a navigation has been requested\n\n\n\n\n\n\n\n\ntarget\n\n\nthe navigation target (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\n\n\ndata\n\n\na map from place parameter names to parameter values\n\n\n\n\n\n\nwillNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has started\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\ndidNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has finished\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\n\n\nplace\n\n\nthe actual place that was navigated to, now the current place\n\n\n\n\n\n\n\n\nMore information on navigation is available in the \n\"Flow and Places\" manual\n.\n\n\nLocales and i18n\n\n\nEvents related to locales are described in the \n\"i18n\" manual\n.\n\n\nMore Patterns\n\n\nThe patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the \nLaxarJS Patterns documentation\n.\n\n\nEvent Reference\n\n\nThe single relevant API provided by LaxarJS is the event bus.\nThis section lists the exact details of using it, and on how event names may be constructed.\n\n\nThe Event Bus API\n\n\nThe event bus is available to widgets and activities through \n$scope.eventBus\n.\nIt has only a few essential methods that allow to implement all patterns mentioned above.\n\n\n\n\nsubscribe( eventPattern, callback [, options] )\n\n\n\n\nCreates a subscription on the event bus.\n\n\n  - The `eventPattern` is a prefix for events to subscribe to:\n Events that start with the given sequence of (sub-)topics will be handled by this subscription.\n For example, a subscription to the pattern `didSave` will be triggered for the event `didSave.myDocument` as well as for the event `didSave.preferences-main`.\n Most of the time, widgets are only interested in very specific events related to resources they work with or actions they handle, so they use patterns such as `didReplace.someResource` where `someResource` is given by the page configuration.\n\n  - The `callback` is the function which will be called to process any matching events.\n Event subscription callbacks receive two arguments:\n          + The `event` is this subscriber\ns copy of the payload, as published by the sender of the event.\n          + The `meta` object contains additional information about the event, in particular the `sender` (identified by a string) and the `name` (under which the event was published).\n\n  - The `options` are usually not required for widgets:\n Using `options.subscriberId`, the subscriber can identify itself to the event bus.\n However, the LaxarJS runtime decorates each widget\ns event bus such that this option is always set correctly.\n\n\n\n\n\nThe method \nsubscribe\n does not return a value.\n\n\n\n\npublish( eventName, payload [, options ] )\n\n\n\n\nPublishes an event to all interested subscribers.\n  Delivery is asynchronous: control is returned to the caller immediately, and delivery will be performed afterwards, together with an AngularJS digest cycle.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.\n\n\n- The `eventName` is used to identify matching subscribers.\nIt is matched against the `eventPattern` of any subscriptions.\n\n- The `payload` will be delivered as the `event` parameter to any matching subscriber callbacks.\nIt is copied right away, making it safe to modify afterwards.\n\n- The `options` are usually not required for widgets:\nBy setting `options.deliverToSender` to `false`, widgets can ignore their own events, which can sometimes be necessary to avoid loops.\n\n\n\n\n\nThe method \npublish\n returns a promise that is resolved after the event has been processed by all matching subscribers.\n\n\n\n\npublishAndGatherReplies( requestEventName, payload [, options ] )\n\n\n\n\nPublishes a \nrequest event\n, gathers all \nwill\n-responses during delivery and then waits for all outstanding \ndid\n-responses.\n  The parameters \npayload\n and \noptions\n are equivalent to the regular \npublish\n-method.\n  Returns a promise that is resolved when all \ndid\n-responses have been received.\n\n\nThis information should help to get started with the event bus and intentionally omits a lot of details.\nFor full information, refer to the \nEventBus module\n.\n\n\n\n\nEvent Name Grammar\n\n\nThis is the formal grammar for event names, in \nEBNF\n:\n\n\nevent-name\n \n::\n=\n \ntopic-id\n \n[\n \n.\n \ntopic-id\n \n]\n*\n\n\ntopic-id\n \n::=\n \nsub-topic-id\n \n[\n \n-\n \nsub-topic-id\n \n]\n*\n\n\nsub-topic-id\n \n::=\n \n[\na-z\n][\n+\na-zA-Z0-9\n]\n*\n \n|\n \n[\nA-Z\n][\n+\nA-Z0-9\n]\n*", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#events-and-publish-subscribe", 
            "text": "The key concept that distinguishes LaxarJS applications from other AngularJS applications is the  publish-subscribe  (or  pub/sub ) architecture.\nIt helps to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).  LaxarJS consistently uses the term  events  rather than  messages , to point out two key aspects of its pub/sub-architecture:\n * events convey information about  what happened  (rather than  who is receiver )\n * delivery is always  asynchronous  (using an  event loop )  For these reasons, you may also think of this pattern as a variation on the  hollywood principle  (\"Don't call us, we'll call you\").  For efficient processing, LaxarJS ties into the AngularJS  $digest -cycle.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#the-event-bus", 
            "text": "All events are published to and delivered by the  event bus :\nThe event bus manages  name-based  (or  topic-based)   event subscriptions  for all interested widgets and activities (the  subscribers) :\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.  Each event has a  name  containing a summary of what happened, and a  payload  carrying additional information.", 
            "title": "The Event Bus"
        }, 
        {
            "location": "/manuals/events/#event-names", 
            "text": "Event names summarize  what happened , possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.  An event name is a string, formed by a sequence of one or more  topics  that are separated by  .  (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more  sub-topics  separated by  -  (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by  * _either_ an upper case letter followed by a sequence of upper case letters and numbers\n* _or_ a lower case letter followed by a sequence of mixed case letters and numbers  These rules also exist as a formal  grammar  for thorough people.  These are examples for  valid  event names:  * `didReplace.myShoppingCart`\n* `takeActionRequest.searchArticles`\n* `didTakeAction.searchArticles.SUCCESS`\n* `willEndLifecycle`\n* `didValidate.popup-user2`  Invalid  event names include:  * `DidReplace.myShoppingCart`: _invalid,_ first topic starts upper case but contains lower case letters\n* `.searchArticles.SUCCESS`: _invalid,_ empty topic is not allowed\n* `didUpdate.1up`: _invalid_, topic must not start with a number", 
            "title": "Event Names"
        }, 
        {
            "location": "/manuals/events/#naming-best-practices-and-event-patterns", 
            "text": "Good event names start with a very general  verb-based first topic , broadly describing  what  happened.\nThat topic is often followed by a more specific  object-based second topic , describing  where  (or  to what ) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event  didValidate.popup-user2  informs all interested subscribers, that the second user has been validated by a widget  within a popup .\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a  modal third topic , broadly describing  how  something happened (e.g. to communicate an outcome such as  SUCCESS  or  ERROR ).  Of course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.  It is recommended wherever possible for widgets to use one or more of the established  event patterns :\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few  core patterns  are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project  LaxarJS Patterns .\nEven without using the LaxarJS Patterns  library , widget authors are very much encouraged to use the  event vocabularies  whenever meaningful.", 
            "title": "Naming Best Practices and Event Patterns"
        }, 
        {
            "location": "/manuals/events/#event-payload", 
            "text": "An event does not only have a name, but also a  payload .\nAny JavaScript object that can be directly represented as  JSON  can be used as a payload.\nThis allows for the object to contain instances of  string ,  array ,  number ,  boolean  and  object , including  null .\nOn the other hand, it excludes undefined ,  Date ,  RegExp  and custom classes.  The Event Bus will  create a copy  of the payload  for each subscriber  that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.  However, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache).", 
            "title": "Event Payload"
        }, 
        {
            "location": "/manuals/events/#two-way-communication-or-the-requestwilldid-mechanism", 
            "text": "Sometimes a widget has to request for some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about  who  actually performs the request, but it is interested in  when  the request has been fully processed by all respondents, and what is the outcome.  As an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a CAPTCHA.\nAnother widget offering a  Complete Sign-Up  button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective sign-up details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the CAPTCHA widget.  Using the  Request/Will/Did  mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:    The individual widgets are  configured  on the page to work with a common  registrationForm  resource.\n   On instantiation, the input widgets offering validation subscribe to  validateRequest  events for this resource.    When the user activates the  Complete Sign-Up  button, the registration widget issues a  validateRequest.registrationForm  event, indicating that   a validation has been requested  (what happened)  and  it concerns the resource  registrationForm   (where  it happened).     The registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.    During delivery, the input widgets supporting validation receive the request and publish a  willValidate.registrationForm  event to indicate that   a validation has been initiated  (what)  and  that it concerns the  registrationForm  resource  (where) .     Each widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either  didValidate.registrationForm.SUCCESS  or  didValidate.registrationForm.ERROR  conveying that   a validation has been performed  (what)  and  that it concerns the  registrationForm  resource  (where)  and  the way the validation turned out  (how) .     Once all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the  sign-up  REST request may be performed.    This mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its  \"didValidate\"  events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.  Validation and other patterns are described in the following section.", 
            "title": "Two-Way Communication or the Request/Will/Did Mechanism"
        }, 
        {
            "location": "/manuals/events/#pattern-reference", 
            "text": "A few event patterns are supported directly by LaxarJS, while others are described in the  LaxarJS Patterns  library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.", 
            "title": "Pattern Reference"
        }, 
        {
            "location": "/manuals/events/#core-patterns", 
            "text": "The core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.", 
            "title": "Core Patterns"
        }, 
        {
            "location": "/manuals/events/#page-lifecycle", 
            "text": "After all widget controllers have been instantiated, the runtime publishes a  beginLifecycleRequest  event.\nWidgets that need to publish events on page load should do so  after  receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.  Before  navigating  away from a page, the runtime publishes the  endLifecycleRequest  event.\nWidgets that need to save state to a service should respond with a  willEndLifecycle  event, perform their housekeeping and publish an  didEndLifecycle  when done.     Event name  Payload Attribute  Description      beginLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that publishing of events is safe now     lifecycleId  the lifecycle ID (currently, this is always  \"default\" )    willBeginLifecycle.{lifecycleId}   published by widgets and activities to defer page rendering (not recommended)     lifecycleId  see above    didBeginLifecycle.{lifecycleId}   published by widgets and activities when page rendering may commence (not recommended)     lifecycleId  see above    endLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that the page is about to be destroyed     lifecycleId  see above    willEndLifecycle.{lifecycleId}   published by widgets and activities to defer tear down of the page (if necessary)     lifecycleId  see above    didEndLifecycle.{lifecycleId}   published by widgets and activities when page tear down may commence (after deferring it)     lifecycleId  see above", 
            "title": "Page Lifecycle"
        }, 
        {
            "location": "/manuals/events/#navigation", 
            "text": "Widgets and activities may initiate navigation using a  navigateRequest.{target}  event, substituting an actual navigation target instead of the placeholder  {target} .\nThe event is interpreted by the LaxarJS runtime as follows:  * if _target_ is ` _self `, the runtime will simply propagate its place-parameters by publishing a `didNavigate` event right away\n* if _target_ is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place\n* otherwise, if _target_ is a place within the flow definition, the runtime will initiate navigation to that place\n* otherwise, nothing will happen.  When  initiating navigation , the LaxarJS runtime will:  1. extract any place parameters from the event payload of the request event\n2. publish a `willNavigate.{target}` event with the corresponding target and parameters\n3. publish an `endLifecycle` event and wait for any respondents\n4. perform navigation by destroying the current page and loading the page associated with the new place\n3. publish a `beginLifecycle` event and wait for any respondents\n5. publish a `didNavigate.{target}` event, with the corresponding target and parameters as well as the resolved place  Here is the summary of navigation events:     Event name  Payload Attribute  Description      navigateRequest.{target}   published by widgets and activities to indicate that a navigation has been requested     target  the navigation target (used in the payload  as well as  in the event name)     data  a map from place parameter names to parameter values    willNavigate.{target}   published by the runtime to indicate that navigation has started     target ,  data  see above    didNavigate.{target}   published by the runtime to indicate that navigation has finished     target ,  data  see above     place  the actual place that was navigated to, now the current place     More information on navigation is available in the  \"Flow and Places\" manual .", 
            "title": "Navigation"
        }, 
        {
            "location": "/manuals/events/#locales-and-i18n", 
            "text": "Events related to locales are described in the  \"i18n\" manual .", 
            "title": "Locales and i18n"
        }, 
        {
            "location": "/manuals/events/#more-patterns", 
            "text": "The patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the  LaxarJS Patterns documentation .", 
            "title": "More Patterns"
        }, 
        {
            "location": "/manuals/events/#event-reference", 
            "text": "The single relevant API provided by LaxarJS is the event bus.\nThis section lists the exact details of using it, and on how event names may be constructed.", 
            "title": "Event Reference"
        }, 
        {
            "location": "/manuals/events/#the-event-bus-api", 
            "text": "The event bus is available to widgets and activities through  $scope.eventBus .\nIt has only a few essential methods that allow to implement all patterns mentioned above.   subscribe( eventPattern, callback [, options] )   Creates a subscription on the event bus.    - The `eventPattern` is a prefix for events to subscribe to:\n Events that start with the given sequence of (sub-)topics will be handled by this subscription.\n For example, a subscription to the pattern `didSave` will be triggered for the event `didSave.myDocument` as well as for the event `didSave.preferences-main`.\n Most of the time, widgets are only interested in very specific events related to resources they work with or actions they handle, so they use patterns such as `didReplace.someResource` where `someResource` is given by the page configuration.\n\n  - The `callback` is the function which will be called to process any matching events.\n Event subscription callbacks receive two arguments:\n          + The `event` is this subscriber s copy of the payload, as published by the sender of the event.\n          + The `meta` object contains additional information about the event, in particular the `sender` (identified by a string) and the `name` (under which the event was published).\n\n  - The `options` are usually not required for widgets:\n Using `options.subscriberId`, the subscriber can identify itself to the event bus.\n However, the LaxarJS runtime decorates each widget s event bus such that this option is always set correctly.  The method  subscribe  does not return a value.   publish( eventName, payload [, options ] )   Publishes an event to all interested subscribers.\n  Delivery is asynchronous: control is returned to the caller immediately, and delivery will be performed afterwards, together with an AngularJS digest cycle.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.  - The `eventName` is used to identify matching subscribers.\nIt is matched against the `eventPattern` of any subscriptions.\n\n- The `payload` will be delivered as the `event` parameter to any matching subscriber callbacks.\nIt is copied right away, making it safe to modify afterwards.\n\n- The `options` are usually not required for widgets:\nBy setting `options.deliverToSender` to `false`, widgets can ignore their own events, which can sometimes be necessary to avoid loops.  The method  publish  returns a promise that is resolved after the event has been processed by all matching subscribers.   publishAndGatherReplies( requestEventName, payload [, options ] )   Publishes a  request event , gathers all  will -responses during delivery and then waits for all outstanding  did -responses.\n  The parameters  payload  and  options  are equivalent to the regular  publish -method.\n  Returns a promise that is resolved when all  did -responses have been received.  This information should help to get started with the event bus and intentionally omits a lot of details.\nFor full information, refer to the  EventBus module .", 
            "title": "The Event Bus API"
        }, 
        {
            "location": "/manuals/events/#event-name-grammar", 
            "text": "This is the formal grammar for event names, in  EBNF :  event-name   :: =   topic-id   [   .   topic-id   ] *  topic-id   ::=   sub-topic-id   [   -   sub-topic-id   ] *  sub-topic-id   ::=   [ a-z ][ + a-zA-Z0-9 ] *   |   [ A-Z ][ + A-Z0-9 ] *", 
            "title": "Event Name Grammar"
        }, 
        {
            "location": "/manuals/flow_and_places/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nConfiguration\n\n\nWriting Pages\n\n\n\n\nFlow and Places\n\n\nEvery application consisting of more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a \nflow\n defining a set of \nplaces\n in a declarative fashion.\nEach place corresponds to a single page that should be rendered, or some other content displayed to the user.\nCurrently the definition of one single flow file is possible, which can by default be found within the application at the path \napplication/flow/flow.json\n.\nThis can be adjusted as \nlaxar-path-flow\n in the \nrequire configuration\n of your application.\n\n\nLet us start with an example for a simple \nflow.json\n file:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nentry\n:\n \n{\n\n         \nredirectTo\n:\n \npageOne\n\n      \n},\n\n\n      \npageOne/:userId\n:\n \n{\n\n         \npage\n:\n \nfirst_page\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nA flow definition is always a JSON object having the root property \nplaces\n, which in turn is a map.\nEach entry of that map consists of the place's URL template as key and a definition of what should happen when reaching that place as value.\nFor LaxarJS an URL template always starts with a constant prefix, possibly consisting of multiple segments separated by slashes, containing optional \nparameters\n.\nThe syntax is taken from AngularJS, where variable parts of a URL are always prefixed by a colon.\nWithin the flow, the constant prefix of a place is interpreted as its \nidentifier\n.\nThus the second place in the example has the identifier \npageOne\n and one parameter, called \nuserId\n.\n\n\nThe identifier \nentry\n of the first place is always interpreted as the default place to navigate to if either no place was provided or if the requested place was not found within the flow.\nMost commonly it will just redirect to another existing place, that for example handles user login or application startup.\nJust as in plain AngularJS, routing a redirect is configured using the \nredirectTo\n keyword and naming the place identifier to navigate to.\nIn this example we simply navigate without providing a value for the \nuserId\n parameter to the place \npageOne\n.\nAny place that simply redirects to another place cannot do any meaningful in addition to that.\nControl is directly passed on to the redirection target.\n\n\nIn contrast to that, the place \npageOne\n specifies a page that should be loaded by using the key \npage\n in its definition.\nBy default all pages are searched in the \napplication/pages/\n directory with the \n.json\n suffix automatically appended when omitted.\nJust like the path to the flow file, this can also be reconfigured in the \nrequire configuration\n of your application as \nlaxar-path-pages\n.\nSo whenever this place is visited, the according page with all of its configured widgets is loaded and displayed.\n\n\nPlaces\n\n\nAs said before the syntax for places is based on the URL template syntax from AngularJS and in fact AngularJS' routing is used internally.\nWithin the flow, those URL templates have some additional meaning as they are being used as an identifier for places.\nThus a few strict rules are added to the basic AngularJS URL template rules:\n\n\n\n\nA URL always consists of one or more segments separated by slashes \n/\n.\n\n\nEach segment can either be a constant alphanumeric character string or a parameter, which is an alphanumeric character string prefixed by colon.\n\n\nA URL always starts with a unique non empty list of constant segments, which can optionally be followed by a list of parameters.\nParameters and constant segments may not appear interleaved.\n\n\nWildcards are not supported\n\n\n\n\nExamples of valid places thus are the following:\n\n\n\n\nuserListing\n\n\nuser/:userId\n\n\ncars/vans/:manufacturer/:model\n\n\n\n\nIn contrast these places would all be considered invalid:\n\n\n\n\n:userId\n: A place \nmust\n start with a non-empty constant segment\n\n\nuser/:userId/car\n: As soon as there is a parameter, no more constant segments may appear\n\n\nuser/:names*\n or \nuser/:names?\n: Wildcards are \nnot\n supported\n\n\n\n\nThese rules may seem very restrictive but they enable LaxarJS to make some assumptions and optimizations based on the URL template.\nAdditionally a URL should not encode too much sensitive information directly, as this might lead to security issues and bulky URLs.\nInstead only some domain information should be passed on between pages, that enables the widgets of the next place to fulfill their specific tasks.\n\n\nTargets\n\n\nNavigation is triggered from within a widget by issuing a \nnavigateRequest\n event expressing the desired next location within the application and providing values for place parameters.\nHow that works in practice can be read in the separate manual covering \nevents\n.\nUsing these events it is possible to always navigate directly from place to place.\nNevertheless this would instantly lead to a tight coupling between the widget triggering navigation events and the definition of places within the flow.\nInstead a widget or a page (by means of the feature configuration for a widget) should only know about semantic navigation targets reachable from their current location (roughly comparable to \nrelations\n in \nREST\n).\n\n\nIn LaxarJS this is achieved by the concept of \ntargets\n:\nEach place can define a mapping from semantic target identifier valid only for this place to the identifier of another place within the flow.\n\n\nAn example (for brevity the \nentry\n place is omitted):\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nintroduction/:userId\n:\n \n{\n\n         \npage\n:\n \nintroduction\n,\n\n         \ntargets\n:\n \n{\n\n            \nnext\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \ninterests/:userId\n:\n \n{\n\n         \npage\n:\n \ninterests\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \nintroduction\n,\n\n            \nnext\n:\n \nprofession\n,\n\n            \nhelp\n:\n \nprofessionHelp\n\n         \n}\n\n      \n},\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \ninterests\n,\n\n            \nhelp\n:\n \nprofessionHelp\n\n         \n}\n\n      \n},\n\n\n      \ninterestsHelp/:userId\n:\n \n{\n\n         \npage\n:\n \ninterests_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \nprofessionHelp/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \nprofession\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis flow is typical for a wizard-like application, as it allows a forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called \nintroduction\n, which simply displays a page and just lets the user navigate to the \nnext\n target, which would be resolved to the place \ninterests\n.\nHere a page is displayed where the user can input his interests, e.g. his hobbies or music taste.\nAs we are in the middle of a wizard, there is a \nprevious\n target reachable now in addition to the \nnext\n and \nhelp\n targets.\nUnsurprisingly the \nprevious\n target references the place \nintroduction\n again.\nThe \nnext\n target instead leads us to another new place with identifier \nprofession\n.\nThe \nprofession\n place may only lead us back to the \ninterests\n place via the \nprevious\n target.\n\n\nMay be some pages have some tricky input components or there are some advices for which things to share.\nThis is where the \nhelp\n targets come into play.\nBoth, the \ninterests\n and the \nprofession\n page, have such a target.\nNevertheless the places behind these targets are different depending on the source page.\nThis makes understanding of navigation concepts simple and provides contextual semantics.\nReturning from the help pages works in a similar way via the \nback\n targets leading to the respective places.\n\n\nEntry Points\n\n\nThe previous sections covered the concepts of navigation within the scope of one LaxarJS application.\nAdditionally it is also often necessary to integrate a use case implemented as a LaxarJS application within the context of another external application.\nFor example the process of collecting data on interests and profession could be part of a larger application creating a personal profile of a person.\nThe host application might have been be implemented in a totally different technology, like Rails or JSP (JavaServer Pages).\nThere should be some way for this application to give control to the LaxarJS application and pass in some parameters.\n\n\nThis is achieved by the concept of \nentry points\n.\nEntry points define possible ways for how to enter an application and which place to navigate to once this entry point is selected.\nLet us add entry points to our example:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n\n      \nentry\n:\n \n{\n\n         \nentryPoints\n:\n \n{\n\n            \nenterInterests\n:\n \ninterests\n,\n\n            \nenterProfession\n:\n \nprofession\n\n         \n}\n\n      \n},\n\n\n      \nintroduction/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \ninterests/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \n...\n\n   \n}\n\n\n}\n\n\n\n\n\n\nApart from the key \nentryPoints\n this is very similar to the definition of targets within the \nflow.json\n.\nThe difference mainly comes from their usage when passing control from the external application to this application:\nAn entry point is selected by configuring it in the global \nwindow.laxar\n \nconfiguration object\n as \nwindow.laxar.portal.flow.entryPoint\n property.\nThis property is an object with key \ntarget\n denoting the name of the entry point to select and an optional map under the \nparameters\n with the values for the possible place parameters.\n\n\nSo let us assume a JSP renders the bootstrapping code for the LaxarJS application, selects the \nenterInterests\n entry point and passes the user ID to the JavaScript frontend:\n\n\n!DOCTYPE html\n\n\nhtml\n\n   \nhead\n!-- contents omitted --\n/head\n\n   \nbody\n\n      \ndiv\n \ndata-ng-view\n \nstyle=\ndisplay: none\n/div\n\n      \ndiv\n \ndata-ax-page\n/div\n\n\n      \nscript \nsrc=\napplication/application.js\n/script\n\n      \nscript \nsrc=\nrequire_config.js\n/script\n\n      \nscript\n\n         \nwindow\n.\nlaxar\n.\nportal\n.\nflow\n \n=\n \n{\n\n            \nentryPoint\n:\n \n{\n\n               \ntarget\n:\n \nenterInterests\n,\n\n               \nparameters\n:\n \n{\n\n                  \nuserId\n:\n \n%= currentUserId %\n\n               \n}\n\n            \n}\n\n         \n};\n\n      \n/script\n\n      \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n   \n/body\n\n\n/html\n\n\n\n\n\n\nBy using this mechanism the external application, in this example a simple JSP, is in control of how our application is entered.\n\n\nExit Points\n\n\nExit points\n work the other way around:\nHere the external application may define a map of different exit points, which in fact are simple JavaScript functions, and the LaxarJS application selects which one to call when navigating to a specific target.\nConfiguration of possible exit points also takes place in the global \nwindow.laxar\n \nconfiguration object\n  as \nwindow.laxar.portal.flow.exitPoints\n property.\n\n\nHere we added to possible exitPoints to our example:\n\n\n!DOCTYPE html\n\n\nhtml\n\n   \nhead\n!-- contents omitted --\n/head\n\n   \nbody\n\n      \ndiv\n \ndata-ng-view\n \nstyle=\ndisplay: none\n/div\n\n      \ndiv\n \ndata-ax-page\n/div\n\n\n      \nscript \nsrc=\napplication/application.js\n/script\n\n      \nscript \nsrc=\nrequire_config.js\n/script\n\n      \nscript\n\n         \nwindow\n.\nlaxar\n.\nportal\n.\nflow\n \n=\n \n{\n\n            \nentryPoint\n:\n \n{\n\n               \ntarget\n:\n \nenterInterests\n,\n\n               \nparameters\n:\n \n{\n\n                  \nuserId\n:\n \n%= currentUserId %\n\n               \n}\n\n            \n},\n\n            \nexitPoints\n:\n \n{\n\n               \nsaveProfile\n:\n \nfunction\n(\n \nparameters\n \n)\n \n{\n\n                  \n// Do whatever is necessary here to pass control back to the JSP application ...\n\n               \n},\n\n               \ncancelProcess\n:\n \nfunction\n(\n \nparameters\n \n)\n \n{\n\n                  \n// Do whatever is necessary here to pass control back to the JSP application ...\n\n               \n}\n\n            \n}\n\n         \n};\n\n      \n/script\n\n      \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n   \n/body\n\n\n/html\n\n\n\n\n\n\nAll arguments passed to the target referencing an exit point during navigation will be forwarded as map to the according function in the \nexitPoints\n map.\n\n\nFor this example two targets using the new exit points are defined (irrelevant places omitted for brevity):\n\n\n{\n\n   \nplaces\n:\n \n{\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \ninterests\n,\n\n            \nhelp\n:\n \nprofessionHelp\n,\n\n            \ncancel\n:\n \ncancel\n,\n\n            \nsave\n:\n \nsave\n\n         \n}\n\n      \n},\n\n\n      \nsave/:userId/:profession\n:\n \n{\n\n         \nexitPoint\n:\n \nsaveProfile\n\n      \n},\n\n\n      \ncancel/:userId/:reasonForCancellation\n:\n \n{\n\n         \nexitPoint\n:\n \ncancelProcess\n\n      \n}\n\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIf the user decides to save his information by navigating to the target \nsave\n, the exit point \nsaveProfile\n with values for the parameters \nuserId\n and \nprofession\n will be called.\nOn the other hand, if the user cancels the process by navigating to the target \ncancel\n, the exit point \ncancelProcess\n with values for the parameters \nuserId\n and \nreasonForCancellation\n will get invoked.\n\n\nUsing the simple mechanisms introduced here, most integration scenarios into external applications should be possible.\nTo learn how to trigger navigation from within widgets and activities, you should go on reading the \nevents documentation\n and learn about the \nnavigateRequest\n and \ndidNavigate\n events.", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#flow-and-places", 
            "text": "Every application consisting of more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a  flow  defining a set of  places  in a declarative fashion.\nEach place corresponds to a single page that should be rendered, or some other content displayed to the user.\nCurrently the definition of one single flow file is possible, which can by default be found within the application at the path  application/flow/flow.json .\nThis can be adjusted as  laxar-path-flow  in the  require configuration  of your application.  Let us start with an example for a simple  flow.json  file:  { \n    places :   { \n       entry :   { \n          redirectTo :   pageOne \n       }, \n\n       pageOne/:userId :   { \n          page :   first_page \n       } \n    }  }   A flow definition is always a JSON object having the root property  places , which in turn is a map.\nEach entry of that map consists of the place's URL template as key and a definition of what should happen when reaching that place as value.\nFor LaxarJS an URL template always starts with a constant prefix, possibly consisting of multiple segments separated by slashes, containing optional  parameters .\nThe syntax is taken from AngularJS, where variable parts of a URL are always prefixed by a colon.\nWithin the flow, the constant prefix of a place is interpreted as its  identifier .\nThus the second place in the example has the identifier  pageOne  and one parameter, called  userId .  The identifier  entry  of the first place is always interpreted as the default place to navigate to if either no place was provided or if the requested place was not found within the flow.\nMost commonly it will just redirect to another existing place, that for example handles user login or application startup.\nJust as in plain AngularJS, routing a redirect is configured using the  redirectTo  keyword and naming the place identifier to navigate to.\nIn this example we simply navigate without providing a value for the  userId  parameter to the place  pageOne .\nAny place that simply redirects to another place cannot do any meaningful in addition to that.\nControl is directly passed on to the redirection target.  In contrast to that, the place  pageOne  specifies a page that should be loaded by using the key  page  in its definition.\nBy default all pages are searched in the  application/pages/  directory with the  .json  suffix automatically appended when omitted.\nJust like the path to the flow file, this can also be reconfigured in the  require configuration  of your application as  laxar-path-pages .\nSo whenever this place is visited, the according page with all of its configured widgets is loaded and displayed.", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#places", 
            "text": "As said before the syntax for places is based on the URL template syntax from AngularJS and in fact AngularJS' routing is used internally.\nWithin the flow, those URL templates have some additional meaning as they are being used as an identifier for places.\nThus a few strict rules are added to the basic AngularJS URL template rules:   A URL always consists of one or more segments separated by slashes  / .  Each segment can either be a constant alphanumeric character string or a parameter, which is an alphanumeric character string prefixed by colon.  A URL always starts with a unique non empty list of constant segments, which can optionally be followed by a list of parameters.\nParameters and constant segments may not appear interleaved.  Wildcards are not supported   Examples of valid places thus are the following:   userListing  user/:userId  cars/vans/:manufacturer/:model   In contrast these places would all be considered invalid:   :userId : A place  must  start with a non-empty constant segment  user/:userId/car : As soon as there is a parameter, no more constant segments may appear  user/:names*  or  user/:names? : Wildcards are  not  supported   These rules may seem very restrictive but they enable LaxarJS to make some assumptions and optimizations based on the URL template.\nAdditionally a URL should not encode too much sensitive information directly, as this might lead to security issues and bulky URLs.\nInstead only some domain information should be passed on between pages, that enables the widgets of the next place to fulfill their specific tasks.", 
            "title": "Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#targets", 
            "text": "Navigation is triggered from within a widget by issuing a  navigateRequest  event expressing the desired next location within the application and providing values for place parameters.\nHow that works in practice can be read in the separate manual covering  events .\nUsing these events it is possible to always navigate directly from place to place.\nNevertheless this would instantly lead to a tight coupling between the widget triggering navigation events and the definition of places within the flow.\nInstead a widget or a page (by means of the feature configuration for a widget) should only know about semantic navigation targets reachable from their current location (roughly comparable to  relations  in  REST ).  In LaxarJS this is achieved by the concept of  targets :\nEach place can define a mapping from semantic target identifier valid only for this place to the identifier of another place within the flow.  An example (for brevity the  entry  place is omitted):  { \n    places :   { \n       introduction/:userId :   { \n          page :   introduction , \n          targets :   { \n             next :   interests \n          } \n       }, \n\n       interests/:userId :   { \n          page :   interests , \n          targets :   { \n             previous :   introduction , \n             next :   profession , \n             help :   professionHelp \n          } \n       }, \n\n       profession/:userId :   { \n          page :   profession , \n          targets :   { \n             previous :   interests , \n             help :   professionHelp \n          } \n       }, \n\n       interestsHelp/:userId :   { \n          page :   interests_help , \n          targets :   { \n             back :   interests \n          } \n       }, \n\n       professionHelp/:userId :   { \n          page :   profession_help , \n          targets :   { \n             back :   profession \n          } \n       } \n    }  }   This flow is typical for a wizard-like application, as it allows a forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called  introduction , which simply displays a page and just lets the user navigate to the  next  target, which would be resolved to the place  interests .\nHere a page is displayed where the user can input his interests, e.g. his hobbies or music taste.\nAs we are in the middle of a wizard, there is a  previous  target reachable now in addition to the  next  and  help  targets.\nUnsurprisingly the  previous  target references the place  introduction  again.\nThe  next  target instead leads us to another new place with identifier  profession .\nThe  profession  place may only lead us back to the  interests  place via the  previous  target.  May be some pages have some tricky input components or there are some advices for which things to share.\nThis is where the  help  targets come into play.\nBoth, the  interests  and the  profession  page, have such a target.\nNevertheless the places behind these targets are different depending on the source page.\nThis makes understanding of navigation concepts simple and provides contextual semantics.\nReturning from the help pages works in a similar way via the  back  targets leading to the respective places.", 
            "title": "Targets"
        }, 
        {
            "location": "/manuals/flow_and_places/#entry-points", 
            "text": "The previous sections covered the concepts of navigation within the scope of one LaxarJS application.\nAdditionally it is also often necessary to integrate a use case implemented as a LaxarJS application within the context of another external application.\nFor example the process of collecting data on interests and profession could be part of a larger application creating a personal profile of a person.\nThe host application might have been be implemented in a totally different technology, like Rails or JSP (JavaServer Pages).\nThere should be some way for this application to give control to the LaxarJS application and pass in some parameters.  This is achieved by the concept of  entry points .\nEntry points define possible ways for how to enter an application and which place to navigate to once this entry point is selected.\nLet us add entry points to our example:  { \n    places :   { \n\n       entry :   { \n          entryPoints :   { \n             enterInterests :   interests , \n             enterProfession :   profession \n          } \n       }, \n\n       introduction/:userId :   { \n          ... \n       }, \n\n       interests/:userId :   { \n          ... \n       }, \n\n       profession/:userId :   { \n          ... \n       }, \n\n       ... \n    }  }   Apart from the key  entryPoints  this is very similar to the definition of targets within the  flow.json .\nThe difference mainly comes from their usage when passing control from the external application to this application:\nAn entry point is selected by configuring it in the global  window.laxar   configuration object  as  window.laxar.portal.flow.entryPoint  property.\nThis property is an object with key  target  denoting the name of the entry point to select and an optional map under the  parameters  with the values for the possible place parameters.  So let us assume a JSP renders the bootstrapping code for the LaxarJS application, selects the  enterInterests  entry point and passes the user ID to the JavaScript frontend:  !DOCTYPE html  html \n    head !-- contents omitted -- /head \n    body \n       div   data-ng-view   style= display: none /div \n       div   data-ax-page /div \n\n       script  src= application/application.js /script \n       script  src= require_config.js /script \n       script \n          window . laxar . portal . flow   =   { \n             entryPoint :   { \n                target :   enterInterests , \n                parameters :   { \n                   userId :   %= currentUserId % \n                } \n             } \n          }; \n       /script \n       script  data-main= ../init.js   src= bower_components/requirejs/require.js /script \n    /body  /html   By using this mechanism the external application, in this example a simple JSP, is in control of how our application is entered.", 
            "title": "Entry Points"
        }, 
        {
            "location": "/manuals/flow_and_places/#exit-points", 
            "text": "Exit points  work the other way around:\nHere the external application may define a map of different exit points, which in fact are simple JavaScript functions, and the LaxarJS application selects which one to call when navigating to a specific target.\nConfiguration of possible exit points also takes place in the global  window.laxar   configuration object   as  window.laxar.portal.flow.exitPoints  property.  Here we added to possible exitPoints to our example:  !DOCTYPE html  html \n    head !-- contents omitted -- /head \n    body \n       div   data-ng-view   style= display: none /div \n       div   data-ax-page /div \n\n       script  src= application/application.js /script \n       script  src= require_config.js /script \n       script \n          window . laxar . portal . flow   =   { \n             entryPoint :   { \n                target :   enterInterests , \n                parameters :   { \n                   userId :   %= currentUserId % \n                } \n             }, \n             exitPoints :   { \n                saveProfile :   function (   parameters   )   { \n                   // Do whatever is necessary here to pass control back to the JSP application ... \n                }, \n                cancelProcess :   function (   parameters   )   { \n                   // Do whatever is necessary here to pass control back to the JSP application ... \n                } \n             } \n          }; \n       /script \n       script  data-main= ../init.js   src= bower_components/requirejs/require.js /script \n    /body  /html   All arguments passed to the target referencing an exit point during navigation will be forwarded as map to the according function in the  exitPoints  map.  For this example two targets using the new exit points are defined (irrelevant places omitted for brevity):  { \n    places :   { \n\n       profession/:userId :   { \n          page :   profession , \n          targets :   { \n             previous :   interests , \n             help :   professionHelp , \n             cancel :   cancel , \n             save :   save \n          } \n       }, \n\n       save/:userId/:profession :   { \n          exitPoint :   saveProfile \n       }, \n\n       cancel/:userId/:reasonForCancellation :   { \n          exitPoint :   cancelProcess \n       } \n\n    }  }   If the user decides to save his information by navigating to the target  save , the exit point  saveProfile  with values for the parameters  userId  and  profession  will be called.\nOn the other hand, if the user cancels the process by navigating to the target  cancel , the exit point  cancelProcess  with values for the parameters  userId  and  reasonForCancellation  will get invoked.  Using the simple mechanisms introduced here, most integration scenarios into external applications should be possible.\nTo learn how to trigger navigation from within widgets and activities, you should go on reading the  events documentation  and learn about the  navigateRequest  and  didNavigate  events.", 
            "title": "Exit Points"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nInfrastructure and Tools\n\n\nWhat does actually happen when you navigate to a LaxarJS page using the browser?\nHow does LaxarJS load your widgets, their assets and styles?\nAnd what is the difference between the \ndebug.html\n and \nindex.html\n in the application template?\nRead on to understand the inner workings of a LaxarJS application.\n\n\nApplication Lifecycle\n\n\nThe \nLaxarJS application template\n contains a \ndebug.html\n which helps to bootstrap you application.\nAdditionally, there is an \nindex.html\n that allows you to run the application using optimized scripts and assets. \n\n\nIn your own application, you do not have to actually use these files:\nInstead you may copy the relevant parts into a \nRuby on Rails\n or \nDjango\n template, or into a \nJSP\n and bootstrap LaxarJS from there.\n\n\nScaffolding\n\n\nLet us dissect the startup process of a LaxarJS application based on the \ndebug.html\n, only that we have removed everything that is not absolutely required:\n\n\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n!-- ... optional: meta elements, title, page blocker styles go here ... --\n/head\n\n\nbody\n\n  \ndiv\n \ndata-ax-page\n/div\n\n  \ndiv\n \ndata-ng-view\n/div\n\n\n  \nscript \ndata-ax-application-mode=\nDEBUG\n \nsrc=\napplication/application.js\n/script\n\n  \nscript \nsrc=\nrequire_config.js\n/script\n\n  \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\n\nWhat do the individual elements mean?\n\n\n* The `axPage` directive determines where LaxarJS will place the layout for the current page.\n\n* The `ngView` directive integrates the [$ngRoute](https://docs.angularjs.org/api/ngRoute)-service, which the [LaxarJS flow](./flow_and_pages.md) uses for URL routing.\n\n* The `application/application.js` contains the [LaxarJS configuration](./configuration.md) for your application.\nThe `data-ax-application-mode` attribute allows to differentiate configuration between _DEBUG_ and _RELEASE_ mode.\nIt allows you to use bundled CSS, HTML and JSON assets for production, while always using their fresh source version during development. \nThe attribute is not used by LaxarJS itself, but only by the `application.js` which is under your control, so using it is a convention rather than an API.\n\n* The `require_config.js` configures paths to libraries for [AMD-loading](http://requirejs.org/docs/whyamd.html).\nThese may be your own libraries or 3rd party libraries installed through [Bower](http://bower.io/).\n\n* Finally, [RequireJS](http://requirejs.org) is loaded to bootstrap your application:\nThe `data-main` tells RequireJS where to find the initialization code (`init.js`), which is the entry point to all AMD-modules for your application.\nAngularJS modules are automatically loaded for any [widgets/activities](./widgets_and_activities.md) and [controls](./providing_controls.md) that are reachable from your [flow](./flow_and_places.md):   \nA LaxarJS grunt task prepares this list whenever you `npm install` your application or `npm start` the development server, so usually you will not to have manage AngularJS modules manually.\nFor production (`grunt optimize`, see below), all RequireJS dependencies are combined and minified by default.\n\n\n\n\n\nThe HTML files in the application template also contain an optional \naxPageFade\n and associated styles.\nThis creates an overlay that covers your application with a white layer during navigation and then fades out, to may make loading a bit nicer on the eyes.\nHowever, this may not be right for all applications, so feel free to remove the overlay, or replace it with a custom version.\n\n\nStartup\n\n\nSo, let us see what happens once all required JavaScript modules are available:\n\n\n1. The `init.js` collects all AngularJS module dependencies for your application and passes them to `laxar.bootstrap()`.\n\n2. `laxar.bootstrap()` just sets up a logging mechanism and invokes the AngularJS `ng.bootstrap` with the collected dependencies.\n This sets up your application modules and their dependencies as well as all internal LaxarJS services and `ngRoute`.\n During initialization, LaxarJS integrates with `ngRoute`, to take over navigation handling.\n\n3. `ngRoute` triggers the LaxarJS _flow controller_ which selects a page from the [flow definition](./flow_and_places.md), based on the current URL.\n\n4. The flow controller instantiates a _page controller_ for the current page.\n\n5. The page controller loads and inserts the page layout and instantiates the controllers for widgets and activities.\n Also, it loads the widget HTML templates and their CSS (during development).\n Widgets and activities controllers may already start to make HTTP requests if they need to while the view is being setup.\n\n6. After all controllers are instantiated, the page controller publishes the `beginLifecycleRequest` event to signal that widgets may start publishing events themselves.\n Now all widget templates are instantiated, inserted into the layout DOM and linked to their controllers\n scopes.\n\n7. Finally, the page controller signals to the flow controller that navigation is complete, upon which the flow controller publishes the `didNavigateEvent`.\n This allows widgets to handle their URL place parameters, and from now on they may publish navigate requests got further navigation.\n\n\n\n\n\nFrom this point on, the LaxarJS runtime interacts only through the event bus with widgets and activities.\nThe only exception to this rule is the \npage teardown\n caused by \nnavigation\n, either \nindirectly\n through a widget, or \ndirectly\n by changing the URL in the browser.\n\n\nTeardown\n\n\nBefore navigating away from a page, widgets receive \nwillNavigate\n and \nendLifecycleRequest\n events, before their scope is destroyed through the regular AngularJS mechanism.\nHowever, when the user simply closes the browser window, this is not always guaranteed.\nIf navigating to a new page, the startup process (described above) repeated, starting at step 3.\n\n\nThe File Resource Provider\n\n\nInternally, LaxarJS uses a single service to provide HTML, CSS and JSON assets used to instantiate widgets and controls:\nThe file resource provider is used to find out if a given template or stylesheet is available for the current theme.\nIt uses \nfile listings\n (JSON files) to answer these queries without actually going to the web server.\nFile listings also contain bundled resources to avoid HTTP requests in production (not during development).\nIf your application causes a lot of HTTP requests for widget templates and CSS, it is likely due to a misconfiguration of the file listings.\nThe listings are generated by one of the LaxarJS \ngrunt tasks\n, which are described subsequently.\n\n\nLaxarJS Development Tools\n\n\nMost modern single page applications are no longer developed using just a text editor, and instead relies on additional development- and build-tools. \nThe npm module \ngrunt-laxar\n provides the tooling to run LaxarJS applications and to optimize their assets.\nIt consists of several \ngrunt\n tasks that help to manage the assets and dependencies used by your application, as well as a development server to simplify the development process.\nThe application template contains a grunt configuration file (\nGruntfile.js\n) that will work for most scenarios, but feel free to modify the configuration if you would like to add your own tools to the build pipeline.\n\n\nLaxarJS Grunt Tasks\n\n\nFollowing are the most important LaxarJS grunt tasks. \nTo actually run the tasks, you will usually run one of the short, \nalias tasks\n defined to the end of the \nGruntfile.js\n (see below). \nNone of the tasks is strictly necessary to develop and run your application, but in concert they go a long way to help reduce boilerplate code and to allow for an optimized user experience.\nIn other words: you will not want to do without them.\n\n\n* `portal_angular_dependencies`\n\nThis task finds every page that can be reached from your flow definition to collect all widgets and activities used by your application, and all controls used by your widgets.\nFrom that list, it generates a listing of all the corresponding AngularJS modules and saves it to `var/static/portal_angular_dependencies.js`.\nIt is the prerequisite for step 1 of the startup process described above.\nOf course, you could assemble and maintain such a listing by hand, but using the grunt task is a lot easier and less error prone.\n\n* `directory_tree`\n\nThis task generates a JSON file tree that is used to avoid unnecessary HTTP requests for static assets.\nThe listings tell the LaxarJS file resource provider, which of the assets relevant to controls and widgets are available.\nListings may also embed entire assets to avoid having to fetch them, which is used to minimize load time in production.\nWhich assets to embed and which to list is determined by the task configuration.\nIn the application template, three listings are configured to cover the three relevant directory trees:\n\n        1. `includes/` - contains widget templates and stylesheets, as well as templates that are overridden by a theme.\n\n        2. `application/` - contains the flow definition, pages and compositions, as well as layouts.\n\n        3. `bower_components/` - contains assets for LaxarJS UiKit, for controls and for the default theme\n\nAll three trees are heavily filtered to make sure that no unnecessary files are included.\nIf something is missing, you can add a corresponding pattern to the Gruntfile.\n\n* `css_merger`\n\nSimilar to `portal_angular_dependencies`, this tasks finds and concats all CSS for the theme and for widgets, layouts and controls within your application.\nIt repeats the process once for each theme under `includes/themes`.\nThe resulting theme CSS is then used during production, to have as few CSS-related HTTP requests as possible, which reduces the number of HTTP requests as well the CPU load.\n\n* `requirejs`\n\nBased on your require configuration and the module list generated by `portal_angular_dependencies`, this produces a single, minified JavaScript file containing all your widgets and their dependencies, including LaxarJS and AngularJS.\nSimilarly to the CSS merger, this allows for fast loading of your application during production.\nInternally, `grunt-contrib-requirejs` is used.\n\n* `widgets`\n\nRuns all widgets\n spec tests in a headless web browser, using [Karma](http://karma-runner.github.io) and [PhantomJS](http://phantomjs.org/).\nThis is a very useful starting point to setup continuous integration for your project, and for a TDD-based development process.\n\n\n\n\n\nTask Aliases\n\n\nThe aliases make sure that task dependencies are observed, plus they are easier to remember and type than the full tasks.\n\n\n* `build`: creates file listings and angular dependencies, automatically runs when you start the development server\n\n* `optimize`: makes sure that CSS and JavaScript are available for release\n\n* `start`: starts the development server (see below), and watches for file changes (see below)\n\n* `test`: runs your widget tests.\n\n\n\n\n\nThe LaxarJS Development Server\n\n\nThe development server based on \nConnect middleware\n helps to run your application without having to setup a full-blown web server.\nIt polls for changes to your widgets and automatically refreshes the browser by injecting a \nlive reload\n script.\nBy default, the development server runs on port 8000, but this can be configured in the Gruntfile.\nThe directories that are watched for live reload can also be reconfigured.\nThis may be necessary if you are developing a library within in your project, and that library does not belong to a single widget.\n\n\nOther Toolchains\n\n\nAs you have seen, the LaxarJS tools provide a lot of useful functionality.\nHowever the \nruntime\n does not require that grunt-laxar is installed, it just depends on the right files in the \nvar\n directory.\nIn fact, when deploying your application to a web server, you should be able to omit the node modules entirely.\n\n\nThis means that nothing stops you from using a different toolchain, say one that is based on \ngulp.js\n, as long as it produces the right assets.\nHopefully though, the tools provided with LaxarJS serve as a useful stepping stone towards your perfect build process.", 
            "title": "Infrastructure and Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#infrastructure-and-tools", 
            "text": "What does actually happen when you navigate to a LaxarJS page using the browser?\nHow does LaxarJS load your widgets, their assets and styles?\nAnd what is the difference between the  debug.html  and  index.html  in the application template?\nRead on to understand the inner workings of a LaxarJS application.", 
            "title": "Infrastructure and Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#application-lifecycle", 
            "text": "The  LaxarJS application template  contains a  debug.html  which helps to bootstrap you application.\nAdditionally, there is an  index.html  that allows you to run the application using optimized scripts and assets.   In your own application, you do not have to actually use these files:\nInstead you may copy the relevant parts into a  Ruby on Rails  or  Django  template, or into a  JSP  and bootstrap LaxarJS from there.", 
            "title": "Application Lifecycle"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#scaffolding", 
            "text": "Let us dissect the startup process of a LaxarJS application based on the  debug.html , only that we have removed everything that is not absolutely required:  !DOCTYPE html  html  head !-- ... optional: meta elements, title, page blocker styles go here ... -- /head  body \n   div   data-ax-page /div \n   div   data-ng-view /div \n\n   script  data-ax-application-mode= DEBUG   src= application/application.js /script \n   script  src= require_config.js /script \n   script  data-main= ../init.js   src= bower_components/requirejs/require.js /script  /body  /html   What do the individual elements mean?  * The `axPage` directive determines where LaxarJS will place the layout for the current page.\n\n* The `ngView` directive integrates the [$ngRoute](https://docs.angularjs.org/api/ngRoute)-service, which the [LaxarJS flow](./flow_and_pages.md) uses for URL routing.\n\n* The `application/application.js` contains the [LaxarJS configuration](./configuration.md) for your application.\nThe `data-ax-application-mode` attribute allows to differentiate configuration between _DEBUG_ and _RELEASE_ mode.\nIt allows you to use bundled CSS, HTML and JSON assets for production, while always using their fresh source version during development. \nThe attribute is not used by LaxarJS itself, but only by the `application.js` which is under your control, so using it is a convention rather than an API.\n\n* The `require_config.js` configures paths to libraries for [AMD-loading](http://requirejs.org/docs/whyamd.html).\nThese may be your own libraries or 3rd party libraries installed through [Bower](http://bower.io/).\n\n* Finally, [RequireJS](http://requirejs.org) is loaded to bootstrap your application:\nThe `data-main` tells RequireJS where to find the initialization code (`init.js`), which is the entry point to all AMD-modules for your application.\nAngularJS modules are automatically loaded for any [widgets/activities](./widgets_and_activities.md) and [controls](./providing_controls.md) that are reachable from your [flow](./flow_and_places.md):   \nA LaxarJS grunt task prepares this list whenever you `npm install` your application or `npm start` the development server, so usually you will not to have manage AngularJS modules manually.\nFor production (`grunt optimize`, see below), all RequireJS dependencies are combined and minified by default.  The HTML files in the application template also contain an optional  axPageFade  and associated styles.\nThis creates an overlay that covers your application with a white layer during navigation and then fades out, to may make loading a bit nicer on the eyes.\nHowever, this may not be right for all applications, so feel free to remove the overlay, or replace it with a custom version.", 
            "title": "Scaffolding"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#startup", 
            "text": "So, let us see what happens once all required JavaScript modules are available:  1. The `init.js` collects all AngularJS module dependencies for your application and passes them to `laxar.bootstrap()`.\n\n2. `laxar.bootstrap()` just sets up a logging mechanism and invokes the AngularJS `ng.bootstrap` with the collected dependencies.\n This sets up your application modules and their dependencies as well as all internal LaxarJS services and `ngRoute`.\n During initialization, LaxarJS integrates with `ngRoute`, to take over navigation handling.\n\n3. `ngRoute` triggers the LaxarJS _flow controller_ which selects a page from the [flow definition](./flow_and_places.md), based on the current URL.\n\n4. The flow controller instantiates a _page controller_ for the current page.\n\n5. The page controller loads and inserts the page layout and instantiates the controllers for widgets and activities.\n Also, it loads the widget HTML templates and their CSS (during development).\n Widgets and activities controllers may already start to make HTTP requests if they need to while the view is being setup.\n\n6. After all controllers are instantiated, the page controller publishes the `beginLifecycleRequest` event to signal that widgets may start publishing events themselves.\n Now all widget templates are instantiated, inserted into the layout DOM and linked to their controllers  scopes.\n\n7. Finally, the page controller signals to the flow controller that navigation is complete, upon which the flow controller publishes the `didNavigateEvent`.\n This allows widgets to handle their URL place parameters, and from now on they may publish navigate requests got further navigation.  From this point on, the LaxarJS runtime interacts only through the event bus with widgets and activities.\nThe only exception to this rule is the  page teardown  caused by  navigation , either  indirectly  through a widget, or  directly  by changing the URL in the browser.", 
            "title": "Startup"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#teardown", 
            "text": "Before navigating away from a page, widgets receive  willNavigate  and  endLifecycleRequest  events, before their scope is destroyed through the regular AngularJS mechanism.\nHowever, when the user simply closes the browser window, this is not always guaranteed.\nIf navigating to a new page, the startup process (described above) repeated, starting at step 3.", 
            "title": "Teardown"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#the-file-resource-provider", 
            "text": "Internally, LaxarJS uses a single service to provide HTML, CSS and JSON assets used to instantiate widgets and controls:\nThe file resource provider is used to find out if a given template or stylesheet is available for the current theme.\nIt uses  file listings  (JSON files) to answer these queries without actually going to the web server.\nFile listings also contain bundled resources to avoid HTTP requests in production (not during development).\nIf your application causes a lot of HTTP requests for widget templates and CSS, it is likely due to a misconfiguration of the file listings.\nThe listings are generated by one of the LaxarJS  grunt tasks , which are described subsequently.", 
            "title": "The File Resource Provider"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#laxarjs-development-tools", 
            "text": "Most modern single page applications are no longer developed using just a text editor, and instead relies on additional development- and build-tools. \nThe npm module  grunt-laxar  provides the tooling to run LaxarJS applications and to optimize their assets.\nIt consists of several  grunt  tasks that help to manage the assets and dependencies used by your application, as well as a development server to simplify the development process.\nThe application template contains a grunt configuration file ( Gruntfile.js ) that will work for most scenarios, but feel free to modify the configuration if you would like to add your own tools to the build pipeline.", 
            "title": "LaxarJS Development Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#laxarjs-grunt-tasks", 
            "text": "Following are the most important LaxarJS grunt tasks. \nTo actually run the tasks, you will usually run one of the short,  alias tasks  defined to the end of the  Gruntfile.js  (see below). \nNone of the tasks is strictly necessary to develop and run your application, but in concert they go a long way to help reduce boilerplate code and to allow for an optimized user experience.\nIn other words: you will not want to do without them.  * `portal_angular_dependencies`\n\nThis task finds every page that can be reached from your flow definition to collect all widgets and activities used by your application, and all controls used by your widgets.\nFrom that list, it generates a listing of all the corresponding AngularJS modules and saves it to `var/static/portal_angular_dependencies.js`.\nIt is the prerequisite for step 1 of the startup process described above.\nOf course, you could assemble and maintain such a listing by hand, but using the grunt task is a lot easier and less error prone.\n\n* `directory_tree`\n\nThis task generates a JSON file tree that is used to avoid unnecessary HTTP requests for static assets.\nThe listings tell the LaxarJS file resource provider, which of the assets relevant to controls and widgets are available.\nListings may also embed entire assets to avoid having to fetch them, which is used to minimize load time in production.\nWhich assets to embed and which to list is determined by the task configuration.\nIn the application template, three listings are configured to cover the three relevant directory trees:\n\n        1. `includes/` - contains widget templates and stylesheets, as well as templates that are overridden by a theme.\n\n        2. `application/` - contains the flow definition, pages and compositions, as well as layouts.\n\n        3. `bower_components/` - contains assets for LaxarJS UiKit, for controls and for the default theme\n\nAll three trees are heavily filtered to make sure that no unnecessary files are included.\nIf something is missing, you can add a corresponding pattern to the Gruntfile.\n\n* `css_merger`\n\nSimilar to `portal_angular_dependencies`, this tasks finds and concats all CSS for the theme and for widgets, layouts and controls within your application.\nIt repeats the process once for each theme under `includes/themes`.\nThe resulting theme CSS is then used during production, to have as few CSS-related HTTP requests as possible, which reduces the number of HTTP requests as well the CPU load.\n\n* `requirejs`\n\nBased on your require configuration and the module list generated by `portal_angular_dependencies`, this produces a single, minified JavaScript file containing all your widgets and their dependencies, including LaxarJS and AngularJS.\nSimilarly to the CSS merger, this allows for fast loading of your application during production.\nInternally, `grunt-contrib-requirejs` is used.\n\n* `widgets`\n\nRuns all widgets  spec tests in a headless web browser, using [Karma](http://karma-runner.github.io) and [PhantomJS](http://phantomjs.org/).\nThis is a very useful starting point to setup continuous integration for your project, and for a TDD-based development process.", 
            "title": "LaxarJS Grunt Tasks"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#task-aliases", 
            "text": "The aliases make sure that task dependencies are observed, plus they are easier to remember and type than the full tasks.  * `build`: creates file listings and angular dependencies, automatically runs when you start the development server\n\n* `optimize`: makes sure that CSS and JavaScript are available for release\n\n* `start`: starts the development server (see below), and watches for file changes (see below)\n\n* `test`: runs your widget tests.", 
            "title": "Task Aliases"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#the-laxarjs-development-server", 
            "text": "The development server based on  Connect middleware  helps to run your application without having to setup a full-blown web server.\nIt polls for changes to your widgets and automatically refreshes the browser by injecting a  live reload  script.\nBy default, the development server runs on port 8000, but this can be configured in the Gruntfile.\nThe directories that are watched for live reload can also be reconfigured.\nThis may be necessary if you are developing a library within in your project, and that library does not belong to a single widget.", 
            "title": "The LaxarJS Development Server"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#other-toolchains", 
            "text": "As you have seen, the LaxarJS tools provide a lot of useful functionality.\nHowever the  runtime  does not require that grunt-laxar is installed, it just depends on the right files in the  var  directory.\nIn fact, when deploying your application to a web server, you should be able to omit the node modules entirely.  This means that nothing stops you from using a different toolchain, say one that is based on  gulp.js , as long as it produces the right assets.\nHopefully though, the tools provided with LaxarJS serve as a useful stepping stone towards your perfect build process.", 
            "title": "Other Toolchains"
        }, 
        {
            "location": "/manuals/installing_widgets/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\n\n\nInstalling Third Party Widgets\n\n\nAmong \nthe advantages\n of LaxarJS the concept of isolated, reusable widgets was mentioned.\nThis begs the question as to how an existing LaxarJS widget can be added to your application.\n\n\nInstalling Widgets Manually\n\n\nCurrently, widgets must be installed manually in three steps, of which usually only the first is required.\nThere are plans to automate the installation in the future using bower.\n\n\n1. Obtain the Widget\n\n\nNew widgets have to be installed into a sub-folder of \nincludes/widgets/\n just like any widgets that you create yourself.\nUsually, you will simply \nclone\n the required widgets from a git repository, or add them as \ngit submodules\n.\n\n\nIn this example, the LaxarJS headline widget in Version 1.0.0 is obtained through \ngit submodule\n:\n\n\ngit submodule add https://github.com/laxarjs/ax-headline-widget.git includes/widgets/laxarjs/ax-headline-widget\n\ncd \nincludes/widgets/laxarjs/ax-headline-widget\ngit checkout v1.0.0\n\n\n\n\n\nInstead of using git, you can also simply copy a widget from another project, unpack it from a zip archive, or obtain it in any other way.\nYou just have to make sure that the widget files are located under \nincludes/widgets/\nartifact\n, where the artifact value is given by the widget's \nbower.json\n (specifically by the \nname\n field).\nFor widgets obtained from GitHub, this is usually equivalent to the \nuser/repository\n information.\nIn the example, the package path is \nlaxarjs/ax-headline-widget\n.\n\n\n2. Obtain the Dependencies\n\n\nSome widgets have extra dependencies that should be listed in the \ndependencies\n section of the \nbower.json\n file.\nYou should compare your widget's bower dependencies to those of your application, adding missing dependencies.\nUsually, you can automate that process using \nbower\n itself:\n\n\nbower install --save ./includes/widgets/category/widget\n`\n\n\n\n\n\n\nNote:\n This will also install the widget itself as a bower component, which is not actually needed but also should not hurt.\n\n\n3. Configure Paths for RequireJS\n\n\nThis is only relevant if your widget has its own bower-dependencies (step 2):\nThe \nInstallation\n section of your widget should tell you if any changes need to be made to your RequireJS configuration.\nUsually, you will need to ensure that all bower-dependencies have a corresponding require-path configuration.\n\n\nHaving followed these steps, you can now add the new widget to a page by specifying the \nartifact\n value from step 1 in your page configuration.\n\n\nInstalling Widgets Automatically\n\n\nThis is still in the works: for LaxarJS \nv1.0\n, we are evaluating to automate all three steps, possibly using \nbower\n and \nbower-requirejs\n.", 
            "title": "Installing Third Party Widgets"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-third-party-widgets", 
            "text": "Among  the advantages  of LaxarJS the concept of isolated, reusable widgets was mentioned.\nThis begs the question as to how an existing LaxarJS widget can be added to your application.", 
            "title": "Installing Third Party Widgets"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-widgets-manually", 
            "text": "Currently, widgets must be installed manually in three steps, of which usually only the first is required.\nThere are plans to automate the installation in the future using bower.", 
            "title": "Installing Widgets Manually"
        }, 
        {
            "location": "/manuals/installing_widgets/#1-obtain-the-widget", 
            "text": "New widgets have to be installed into a sub-folder of  includes/widgets/  just like any widgets that you create yourself.\nUsually, you will simply  clone  the required widgets from a git repository, or add them as  git submodules .  In this example, the LaxarJS headline widget in Version 1.0.0 is obtained through  git submodule :  git submodule add https://github.com/laxarjs/ax-headline-widget.git includes/widgets/laxarjs/ax-headline-widget cd  includes/widgets/laxarjs/ax-headline-widget\ngit checkout v1.0.0  Instead of using git, you can also simply copy a widget from another project, unpack it from a zip archive, or obtain it in any other way.\nYou just have to make sure that the widget files are located under  includes/widgets/ artifact , where the artifact value is given by the widget's  bower.json  (specifically by the  name  field).\nFor widgets obtained from GitHub, this is usually equivalent to the  user/repository  information.\nIn the example, the package path is  laxarjs/ax-headline-widget .", 
            "title": "1. Obtain the Widget"
        }, 
        {
            "location": "/manuals/installing_widgets/#2-obtain-the-dependencies", 
            "text": "Some widgets have extra dependencies that should be listed in the  dependencies  section of the  bower.json  file.\nYou should compare your widget's bower dependencies to those of your application, adding missing dependencies.\nUsually, you can automate that process using  bower  itself:  bower install --save ./includes/widgets/category/widget `   Note:  This will also install the widget itself as a bower component, which is not actually needed but also should not hurt.", 
            "title": "2. Obtain the Dependencies"
        }, 
        {
            "location": "/manuals/installing_widgets/#3-configure-paths-for-requirejs", 
            "text": "This is only relevant if your widget has its own bower-dependencies (step 2):\nThe  Installation  section of your widget should tell you if any changes need to be made to your RequireJS configuration.\nUsually, you will need to ensure that all bower-dependencies have a corresponding require-path configuration.  Having followed these steps, you can now add the new widget to a page by specifying the  artifact  value from step 1 in your page configuration.", 
            "title": "3. Configure Paths for RequireJS"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-widgets-automatically", 
            "text": "This is still in the works: for LaxarJS  v1.0 , we are evaluating to automate all three steps, possibly using  bower  and  bower-requirejs .", 
            "title": "Installing Widgets Automatically"
        }, 
        {
            "location": "/manuals/i18n/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nInternationalizing a Widget\n\n\nIn LaxarJS, internationalization \n(i18n)\n of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.\n\n\nLocales and Language Tags: I18n in LaxarJS\n\n\nLaxarJS distinguishes \nlocales\n and \nlanguage tags\n for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a \nRFC-5646\n language tag like \"en-US\", which can change over time.\nThe locale corresponds to the audience for which a language tag should be valid.\nIf you have only one audience (regular users), using only \ndefault\n should be fine.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the \nchangeLocaleRequest.{locale}\n event.\n\n\nExample: To change the language tag of the locale \nmyLocale\n to \nde-DE\n, the following event has to be published:\n\n\n$scope\n.\neventBus\n.\npublish\n(\n \nchangeLocaleRequest.myLocale.\n,\n\n    \n{\n \n        \nlocale\n:\n \nmyLocale\n,\n \n        \nlanguageTag\n:\n \nde-DE\n \n    \n}\n\n\n);\n\n\n\n\n\n\nIf a widget is interested in changes to \nmyLocale\n, it would subscribe to the corresponding \ndidChangeLocale\n-event, which is published by the LaxarJS flow-controller:\n\n\n$scope\n.\neventBus\n.\nsubscribe\n(\n \ndidChangeLocale.myLocale.\n,\n \nfunction\n(\n \nevent\n \n)\n \n{\n\n   \nax\n.\nlog\n.\ninfo\n(\n \nI have received tag [0] for locale [1]\n,\n \nevent\n.\nlanguageTag\n,\n \nevent\n.\nlocale\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nWidgets can use the language tags that they receive over the event bus to \nlocalize\n internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with \ni18n\n:\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen-US\n:\n \nUpload file\n,\n\n    \nde-DE\n:\n \nDatei hochladen\n\n\n}\n\n\n\n\n\n\nLaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.\n\n\nWriting an I18n-Capable Widget\n\n\nTo be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry \ncontrols\n in the \nwidget.json\n.\nIf missing, this entry must be created:\n\n\ncontrols\n:\n \n[\n\n    \nlaxar_uikit/controls/i18n\n\n\n]\n\n\n\n\n\n\nNext, we have to add a feature \ni18n\n.\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example \nen-GB\n) is then used to localize internationalized values.\n\n\ni18n\n:\n \n{\n\n   \ndescription\n:\n \nWhich locale to use for displaying this widget.\n,\n\n   \ntype\n:\n \nobject\n,\n\n   \nproperties\n:\n \n{\n\n      \nlocale\n:\n \n{\n\n         \ntype\n:\n \nstring\n,\n\n         \ndescription\n:\n \nThe topic under which to expect the locale for this widget.\n,\n\n         \ndefault\n:\n \ndefault\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIf not already done, we import the Laxar-Patterns library into the widget controller (\nmy_widget.js\n).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right \ndidChangeLocale\n-events for us, by using the feature configuration that we added in the previous step:\n\n\ndefine\n(\n \n[\n   \n   \nlaxar_patterns\n\n\n],\n \nfunction\n(\n \npatterns\n \n)\n \n{\n\n   \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n \n);\n\n   \n...\n\n\n}\n\n\n\n\n\n\nAny updates to the i18n-locale received over the event bus will now be saved under \n$scope.i18n\n, along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:\n\n\n$scope.i\n18\nn\n \n=\n \n{\n      \n   \nlocale:\n \ndefault\n,\n\n   \ntags:\n \n{\n\n      \ndefault\n:\n \nen-US\n,\n\n      \ncustomer\n:\n \nde-DE\n,\n\n      \nsupport\n:\n \nen-GB\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIn the HTML template we can now use the angular filter \naxLocalize\n to convert an i18nHtmlText to a string:\n\n\np\n \ndata-ng-bind-html=\nmodel.i18nHtmlText | axLocalize:i18n\n/p\n\n\n\n\n\n\nThe filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses \n$scope.i18n.locale\n (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen-US\n:\n \nUpload file \nem\nnow\n/em\n,\n\n    \nde-DE\n:\n \nDatei \nem\njetzt\n/em\n hochladen\n\n\n}\n\n\n\n\n\n\nLocalizing Values in the Controller\n\n\nIn some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.\n\n\np\n \ndata-ng-bind-html=\nmodel.htmlVeryLongDocument\n/p\n\n\n\n\n\n\nTo achieve this, we obtain a \nlocalize\n function when we subscribe the widget to the didChangeLocale event.\nLike the \naxLocalize\n-directive, this function automatically uses the current language tag:\n\n\nvar\n \nlocalize\n \n=\n \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n,\n \n{\n\n    \nonChange\n:\n \nupdateLocalization\n\n\n}\n \n).\nlocalizer\n();\n\n\n\n\n\n\nThen we can transform any object with language tag properties to a string using the \nlocalize\n function:\n\n\nfunction\n \nupdateLocalization\n()\n \n{\n\n   \nvar\n \ndocumentUrl\n \n=\n \nlocalize\n(\n \n$scope\n.\nfeatures\n.\ni18nDocumentUrl\n \n);\n\n   \n$http\n.\nget\n(\n \ndocumentUrl\n \n).\nthen\n(\n \nfunction\n(\n \nresponse\n \n)\n \n{\n\n      \n$scope\n.\nmodel\n.\nhtmlVeryLongDocument\n \n=\n \nresponse\n.\ndata\n;\n\n   \n}\n \n);\n\n\n}", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#internationalizing-a-widget", 
            "text": "In LaxarJS, internationalization  (i18n)  of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#locales-and-language-tags-i18n-in-laxarjs", 
            "text": "LaxarJS distinguishes  locales  and  language tags  for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a  RFC-5646  language tag like \"en-US\", which can change over time.\nThe locale corresponds to the audience for which a language tag should be valid.\nIf you have only one audience (regular users), using only  default  should be fine.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the  changeLocaleRequest.{locale}  event.  Example: To change the language tag of the locale  myLocale  to  de-DE , the following event has to be published:  $scope . eventBus . publish (   changeLocaleRequest.myLocale. , \n     {  \n         locale :   myLocale ,  \n         languageTag :   de-DE  \n     }  );   If a widget is interested in changes to  myLocale , it would subscribe to the corresponding  didChangeLocale -event, which is published by the LaxarJS flow-controller:  $scope . eventBus . subscribe (   didChangeLocale.myLocale. ,   function (   event   )   { \n    ax . log . info (   I have received tag [0] for locale [1] ,   event . languageTag ,   event . locale   );  }   );   Widgets can use the language tags that they receive over the event bus to  localize  internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with  i18n :  i18nHtmlText :   { \n     en-US :   Upload file , \n     de-DE :   Datei hochladen  }   LaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.", 
            "title": "Locales and Language Tags: I18n in LaxarJS"
        }, 
        {
            "location": "/manuals/i18n/#writing-an-i18n-capable-widget", 
            "text": "To be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry  controls  in the  widget.json .\nIf missing, this entry must be created:  controls :   [ \n     laxar_uikit/controls/i18n  ]   Next, we have to add a feature  i18n .\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example  en-GB ) is then used to localize internationalized values.  i18n :   { \n    description :   Which locale to use for displaying this widget. , \n    type :   object , \n    properties :   { \n       locale :   { \n          type :   string , \n          description :   The topic under which to expect the locale for this widget. , \n          default :   default \n       } \n    }  }   If not already done, we import the Laxar-Patterns library into the widget controller ( my_widget.js ).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right  didChangeLocale -events for us, by using the feature configuration that we added in the previous step:  define (   [    \n    laxar_patterns  ],   function (   patterns   )   { \n    patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n   ); \n    ...  }   Any updates to the i18n-locale received over the event bus will now be saved under  $scope.i18n , along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:  $scope.i 18 n   =   {       \n    locale:   default , \n    tags:   { \n       default :   en-US , \n       customer :   de-DE , \n       support :   en-GB \n    }  }   In the HTML template we can now use the angular filter  axLocalize  to convert an i18nHtmlText to a string:  p   data-ng-bind-html= model.i18nHtmlText | axLocalize:i18n /p   The filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses  $scope.i18n.locale  (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.  i18nHtmlText :   { \n     en-US :   Upload file  em now /em , \n     de-DE :   Datei  em jetzt /em  hochladen  }", 
            "title": "Writing an I18n-Capable Widget"
        }, 
        {
            "location": "/manuals/i18n/#localizing-values-in-the-controller", 
            "text": "In some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.  p   data-ng-bind-html= model.htmlVeryLongDocument /p   To achieve this, we obtain a  localize  function when we subscribe the widget to the didChangeLocale event.\nLike the  axLocalize -directive, this function automatically uses the current language tag:  var   localize   =   patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n ,   { \n     onChange :   updateLocalization  }   ). localizer ();   Then we can transform any object with language tag properties to a string using the  localize  function:  function   updateLocalization ()   { \n    var   documentUrl   =   localize (   $scope . features . i18nDocumentUrl   ); \n    $http . get (   documentUrl   ). then (   function (   response   )   { \n       $scope . model . htmlVeryLongDocument   =   response . data ; \n    }   );  }", 
            "title": "Localizing Values in the Controller"
        }, 
        {
            "location": "/manuals/configuration/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nLaxarJS Configuration in an Application\n\n\nLaxarJS has a built-in configuration API which is available to libraries and widgets as \nlaxar.configuration\n.\nIn contrast to the bower- and RequireJS-configuration, this configuration is designed to be used at application run time.\n\n\nWhat is LaxarJS Configuration Used for?\n\n\nWhen writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.\n\n\nIn other cases, LaxarJS itself needs to be configured, for example to determine the theme, file listing URIs, available locales and so on.\nThe \nLaxarJS Core\n configuration options are listed below.\n\n\nConfiguration Structure\n\n\nConfiguration keys are simple JSON paths, reflecting a hierarchical configuration structure.\nThe configuration API looks for the configuration values within the \nlaxar\n property of the global object (\nwindow\n).\n\n\nLibraries, widgets and activities may define their own configuration keys, but must always use the \nlib.\n prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example, \nLaxarJS UiKit\n controls use the prefix \nlib.laxar_uikit.controls\n for their configuration options.\nKeys without the \nlib.\n-prefix are used by \nLaxarJS Core\n.\n\n\nThe Configuration API\n\n\nThe LaxarJS configuration exposes a single method \nlaxar.configuration.get( key, fallback )\n.\nThe \nkey\n-parameter is the path within the configuration object (\nwindow.laxar\n), and the (optional) \nfallback\n is returned as a default value if the key was not set in the configuration.\n\n\nFor example, a module \nmy_module\n may allow to enable some kind of compatibility behavior for a special \nfoo\n environment by exposing a boolean configuration \nfooCompatibility\n.\nBy default, the option should be disabled as compatibility with foo involves jumping through some hoops.\nThe module \nmy_module\n would then access the option like this:\n\n\ndefine\n(\n \n[\n \nlaxar\n \n],\n \nfunction\n(\n \nax\n \n)\n \n{\n\n  \nfunction\n \nsetup\n()\n \n{\n\n     \nvar\n \nrespectFoo\n \n=\n \nax\n.\nconfiguration\n.\nget\n(\n \nlib.my_module.fooCompatibility\n,\n \nfalse\n \n);\n\n     \nif\n(\n \nrespectFoo\n \n)\n \n{\n\n        \n// ... jump though some hoops ...\n\n        \nreturn\n \n{\n \nhoops\n:\n \nJUMPED\n \n};\n\n     \n}\n\n     \nreturn\n \n{};\n\n  \n}\n\n\n}\n \n);\n\n\n\n\n\n\nAnd the corresponding configuration block to enable foo-compatibility would then look like this:\n\n\nwindow\n.\nlaxar\n \n=\n \n{\n\n   \n// ...\n\n   \nlib\n:\n \n{\n\n      \nmy_module\n:\n \n{\n\n         \nfooCompatibility\n:\n \ntrue\n\n      \n},\n\n      \n// ...\n\n   \n}\n\n\n};\n\n\n\n\n\n\nTesting a Module that Uses Configuration\n\n\nTo test the behavior of a module with test-controlled configuration options, one can simply spy on the method \nconfiguration.get\n.\nHere is an exemplary jasmine test for a module \nmy_module\n, which tries to test the module behavior with foo-compatibility enabled.\n\n\ndefine\n(\n \n[\n \nlaxar/laxar_testing\n,\n \nmy_module\n \n],\n \nfunction\n(\n \nax\n,\n \nmyModule\n \n)\n \n{\n\n   \ndescribe\n(\n \na my_module with foo compatibility enabled\n,\n \nfunction\n()\n \n{\n\n      \nbeforeEach\n(\n \nfunction\n()\n \n{\n\n         \nvar\n \norigGet\n \n=\n \nax\n.\nconfiguration\n.\nget\n;\n\n         \nvar\n \nhoops\n;\n\n         \nspyOn\n(\n \nax\n.\nconfiguration\n,\n \nget\n \n).\nandCallFake\n(\n \nfunction\n(\n \nkey\n,\n \nfallback\n \n)\n \n{\n\n            \nreturn\n \nkey\n \n===\n \nlib.my_module.fooCompatibility\n \n?\n \ntrue\n \n:\n \norigGet\n(\n \nkey\n,\n \nfallback\n \n);\n\n         \n}\n \n);\n\n         \nhoops\n \n=\n \nsetup\n();\n\n      \n}\n \n);\n\n      \nit\n(\n \njumps through some hoops\n,\n \nfunction\n()\n \n{\n\n           \nexpect\n(\n \nhoops\n \n).\ntoBe\n(\n \nJUMPED\n \n);\n\n      \n}\n \n);\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nInjecting Configuration into an AngularJS module\n\n\nInstead of using RequireJS, AngularJS modules such as widgets can have the configuration module injected by requesting the service \n'Configuration'\n.\nIn cases where configuration is injected, an \nangularMocks.module\n provider may be defined during testing instead of the approach described above.\n\n\nAvailable Configuration Keys in \nLaxarJS Core\n\n\nThe following configuration options are available in \nLaxarJS Core\n.\nFor options available in \nLaxarJS UiKit\n, have a look at the \nrespective documentation\n.\n\n\n\n\n\n\n\n\nKey\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\n''\n\n\nThe name of the LaxarJS application\n\n\n\n\n\n\ndescription\n\n\n''\n\n\nA short application description\n\n\n\n\n\n\ni18n.locales\n\n\n{ 'default': 'en' }\n\n\nWhich language tag to use for the default locale, and possibly for other locales\n\n\n\n\n\n\nlogging.threshold\n\n\n'INFO'\n\n\nThe log level which is required for messages to be logged (one of \nDEBUG\n, \nTRACE\n, \nINFO\n, \nWARN\n or \nERROR\n)\n\n\n\n\n\n\nlogging.http.header\n\n\nnull\n\n\nIf set, an \n$http\n interceptor is registered to add the log tags (such as PLCE for the current place and INST for the client instance ID) to outgoing XHR requests, under the configured header field (e.g. \n-x-myapp-tags\n).\n\n\n\n\n\n\nfile_resource_provider.listings\n\n\n{}\n\n\nA mapping from application directories to file listings. The listings serve to save unnecessary HTTP requests (for example, to determine if a widget has custom styles for the current theme), and are generated by (grunt-laxar)[https://github.com/LaxarJS/grunt-laxar].\n\n\n\n\n\n\nfile_resource_provider.useEmbedded\n\n\nfalse\n\n\nWhole files may be embedded into the file listings by grunt-laxar to save even more HTTP-requests. In DEBUG-mode, these embeddings may be stale and should not be used (use \nfalse\n) while in release mode, they are beneficial (use \ntrue\n).\n\n\n\n\n\n\nevent_bus.timeout_ms\n\n\n120000\n\n\nThe maximum delay (in milliseconds) for a pending \ndid...\n event to be published, after it was announced by a \nwill...\n event.\n\n\n\n\n\n\nportal.theme\n\n\n'default'\n\n\nWhich theme to use for the application\n\n\n\n\n\n\nportal.useMergedCss\n\n\nfalse\n\n\nSimilar to \nfile_resource_provider.useEmbedded\n, this option controls an optimization: If \ntrue\n, a concatenated CSS bundled produced by \ngrunt-laxar\n is used which improves performance. If \nfalse\n, CSS-files are requested individually, which is mostly useful during development. The value is automatically \ntrue\n if a link-element with the \ndata-ax-merged-css\n attribute exists in the page.\n\n\n\n\n\n\nportal.flow.entryPoint\n\n\nnull\n\n\nIf the browser URL cannot be controlled by the LaxarJS application (for example, when integrating with a legacy system), the target and place-parameters can be set here in the form \n{ target: 'my_flow_target', parameters: { myParam: 'xyz' } }\n.\n\n\n\n\n\n\nportal.flow.exitPoints\n\n\n{}\n\n\nAllows to delegate handling of a navigation target to a different (legacy) system by specifying callbacks for individual navigation targets. Has the form \n{ exitFnName: function( parameters ) { /* ... */ } }\n where \nexitFnName\n matches the definition used as an \n'exitFunction'\n within the \nflow.json\n.", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#laxarjs-configuration-in-an-application", 
            "text": "LaxarJS has a built-in configuration API which is available to libraries and widgets as  laxar.configuration .\nIn contrast to the bower- and RequireJS-configuration, this configuration is designed to be used at application run time.", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#what-is-laxarjs-configuration-used-for", 
            "text": "When writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.  In other cases, LaxarJS itself needs to be configured, for example to determine the theme, file listing URIs, available locales and so on.\nThe  LaxarJS Core  configuration options are listed below.", 
            "title": "What is LaxarJS Configuration Used for?"
        }, 
        {
            "location": "/manuals/configuration/#configuration-structure", 
            "text": "Configuration keys are simple JSON paths, reflecting a hierarchical configuration structure.\nThe configuration API looks for the configuration values within the  laxar  property of the global object ( window ).  Libraries, widgets and activities may define their own configuration keys, but must always use the  lib.  prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example,  LaxarJS UiKit  controls use the prefix  lib.laxar_uikit.controls  for their configuration options.\nKeys without the  lib. -prefix are used by  LaxarJS Core .", 
            "title": "Configuration Structure"
        }, 
        {
            "location": "/manuals/configuration/#the-configuration-api", 
            "text": "The LaxarJS configuration exposes a single method  laxar.configuration.get( key, fallback ) .\nThe  key -parameter is the path within the configuration object ( window.laxar ), and the (optional)  fallback  is returned as a default value if the key was not set in the configuration.  For example, a module  my_module  may allow to enable some kind of compatibility behavior for a special  foo  environment by exposing a boolean configuration  fooCompatibility .\nBy default, the option should be disabled as compatibility with foo involves jumping through some hoops.\nThe module  my_module  would then access the option like this:  define (   [   laxar   ],   function (   ax   )   { \n   function   setup ()   { \n      var   respectFoo   =   ax . configuration . get (   lib.my_module.fooCompatibility ,   false   ); \n      if (   respectFoo   )   { \n         // ... jump though some hoops ... \n         return   {   hoops :   JUMPED   }; \n      } \n      return   {}; \n   }  }   );   And the corresponding configuration block to enable foo-compatibility would then look like this:  window . laxar   =   { \n    // ... \n    lib :   { \n       my_module :   { \n          fooCompatibility :   true \n       }, \n       // ... \n    }  };", 
            "title": "The Configuration API"
        }, 
        {
            "location": "/manuals/configuration/#testing-a-module-that-uses-configuration", 
            "text": "To test the behavior of a module with test-controlled configuration options, one can simply spy on the method  configuration.get .\nHere is an exemplary jasmine test for a module  my_module , which tries to test the module behavior with foo-compatibility enabled.  define (   [   laxar/laxar_testing ,   my_module   ],   function (   ax ,   myModule   )   { \n    describe (   a my_module with foo compatibility enabled ,   function ()   { \n       beforeEach (   function ()   { \n          var   origGet   =   ax . configuration . get ; \n          var   hoops ; \n          spyOn (   ax . configuration ,   get   ). andCallFake (   function (   key ,   fallback   )   { \n             return   key   ===   lib.my_module.fooCompatibility   ?   true   :   origGet (   key ,   fallback   ); \n          }   ); \n          hoops   =   setup (); \n       }   ); \n       it (   jumps through some hoops ,   function ()   { \n            expect (   hoops   ). toBe (   JUMPED   ); \n       }   ); \n    }   );  }   );", 
            "title": "Testing a Module that Uses Configuration"
        }, 
        {
            "location": "/manuals/configuration/#injecting-configuration-into-an-angularjs-module", 
            "text": "Instead of using RequireJS, AngularJS modules such as widgets can have the configuration module injected by requesting the service  'Configuration' .\nIn cases where configuration is injected, an  angularMocks.module  provider may be defined during testing instead of the approach described above.", 
            "title": "Injecting Configuration into an AngularJS module"
        }, 
        {
            "location": "/manuals/configuration/#available-configuration-keys-in-laxarjs-core", 
            "text": "The following configuration options are available in  LaxarJS Core .\nFor options available in  LaxarJS UiKit , have a look at the  respective documentation .     Key  Default  Description      name  ''  The name of the LaxarJS application    description  ''  A short application description    i18n.locales  { 'default': 'en' }  Which language tag to use for the default locale, and possibly for other locales    logging.threshold  'INFO'  The log level which is required for messages to be logged (one of  DEBUG ,  TRACE ,  INFO ,  WARN  or  ERROR )    logging.http.header  null  If set, an  $http  interceptor is registered to add the log tags (such as PLCE for the current place and INST for the client instance ID) to outgoing XHR requests, under the configured header field (e.g.  -x-myapp-tags ).    file_resource_provider.listings  {}  A mapping from application directories to file listings. The listings serve to save unnecessary HTTP requests (for example, to determine if a widget has custom styles for the current theme), and are generated by (grunt-laxar)[https://github.com/LaxarJS/grunt-laxar].    file_resource_provider.useEmbedded  false  Whole files may be embedded into the file listings by grunt-laxar to save even more HTTP-requests. In DEBUG-mode, these embeddings may be stale and should not be used (use  false ) while in release mode, they are beneficial (use  true ).    event_bus.timeout_ms  120000  The maximum delay (in milliseconds) for a pending  did...  event to be published, after it was announced by a  will...  event.    portal.theme  'default'  Which theme to use for the application    portal.useMergedCss  false  Similar to  file_resource_provider.useEmbedded , this option controls an optimization: If  true , a concatenated CSS bundled produced by  grunt-laxar  is used which improves performance. If  false , CSS-files are requested individually, which is mostly useful during development. The value is automatically  true  if a link-element with the  data-ax-merged-css  attribute exists in the page.    portal.flow.entryPoint  null  If the browser URL cannot be controlled by the LaxarJS application (for example, when integrating with a legacy system), the target and place-parameters can be set here in the form  { target: 'my_flow_target', parameters: { myParam: 'xyz' } } .    portal.flow.exitPoints  {}  Allows to delegate handling of a navigation target to a different (legacy) system by specifying callbacks for individual navigation targets. Has the form  { exitFnName: function( parameters ) { /* ... */ } }  where  exitFnName  matches the definition used as an  'exitFunction'  within the  flow.json .", 
            "title": "Available Configuration Keys in LaxarJS Core"
        }, 
        {
            "location": "/manuals/widgets_and_activities/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nWidgets and Activities\n\n\nWidgets and activities are the \n\"work horse\"\n of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.\n\n\nWidget Responsibilities\n\n\nBefore starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question: \nWhat goal does this widget help the user to accomplish?\n\nAre you thinking about a very broadly applicable, technical task such as \n\"allow the user to enter a date\"\n or \n\"allow the user to delete a data row\"\n?\nIn this case you might want to implement this functionality as a \ncontrol\n (an AngularJS directive or an HTML5 web component) and use it \nwithin\n one or more of your widgets.\n\n\nUsually, widgets correspond to significant areas of the screen and are composed from multiple controls.\nThey are built with a \nspecific user-goal\n in mind, such as \n\"allow the user to book a flight\"\n or \n\"allow the user to review shopping cart contents\"\n.\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of the thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?\n\n\nWhen to use Activities\n\n\nActivities are \n\"invisible widgets\"\n that are used to \nfetch and manage application resources\n.\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nThis makes activities perform a role similar to AngularJS services.\nThe advantage over services is that using activities puts the \npage author\n in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.\nAlthough these configurations are not impossible to achieve using AngularJS dependency injection and -services, using LaxarJS activities makes the connections declarative and visible.\n\n\nActivities may also serve as a \nmediator\n between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.\n\n\nHow to Create a Widget\n\n\nThe easiest way to create a widget is to use the appropriate \ngrunt-init\n template.\nCheck out the \nREADME\n on how to obtain the grunt-init templates and on creating an application.\n\n\nStart by creating a sub-directory for your new widget within the LaxarJS application.\nEach widget in an application lives within a sub-folder of the \nwidget root\n (\nincludes/widgets\n by default).\nTo change the widget root you can modify the RequireJS-path \n'laxar-path-widgets'\n in the require configuration.\nThe widget path \nincludes/widgets/shopping/cart_widget\n is used as an example path throughout this manual.\n\n\nThe sub-directory \nshopping\n is the \nwidget category\n in the example path.\nCategories allow to organize widgets by their general business area, for example \nshopping\n, \nsocial\n, \nfinance\n and so on.\nThe last component of the widget path is the \nwidget name\n:\nIt has to be unique throughout an application and must be written in lower case letters with components separated by underscores.\nRegular widget names always end in \n_widget\n whereas activities always end in \n_activity\n.\n\n\nTo create the actual widget, run:\n\n\ngrunt-init laxar-widget\n\n\n\n\n\nA wizard will ask for some details on the widget such as license and author, but you can always edit this information in the widget sources afterwards.\nIn the following steps, it is assumed that you used the category \nshopping\n and the widget name \ncart_widget\n as above.\n\n\nWidget Files\n\n\nA newly created widget contains the following files:\n\n\n\n\nwidget.json\n\n\n\n\nThis \nwidget specification\n contains meta-data about your widget that is used by the LaxarJS framework.\n  It allows you to describe the configuration options of your widget features as a JSON schema.\n\n\n\n\nbower.json\n\n\n\n\nThis specifies the \ndependencies\n of your widget for use with \nBower\n.\n  While not used directly by LaxarJS, it is the key to automated and isolated widget tests.\n\n\n\n\ncart_widget.js\n\n\n\n\nThe \nbusiness logic\n of your shopping cart (like calculating a total or changing item quantities) as an \nAngularJS controller\n.\n  When your controller is instantiated by the LaxarJS runtime, it will receive an AngularJS scope (the model) and a reference to the event bus, which allows for communication with the world.\n  When built for release, all controllers and their RequireJS-dependencies are bundled into a single, compressed JavaScript file.\n\n\n\n\ndefault.theme/cart_widget.html\n\n\n\n\nThe \nAngularJS HTML template\n defining the \nappearance\n of your widget.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The \nBootstrap CSS\n classes are available by convention to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all), but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be preloaded within a single JSON file when your application is packaged for release.\n\n\n\n\ndefault.theme/(s)css/cart_widget.(s)css\n\n\n\n\nWidget-specific \nstyle definitions\n.\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS (or \nSCSS\n folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, the framework will load it when the widget is used in an application, and bundle it for release.\n\n\nLaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom \ntheme\n.\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead \nmore about themes\n once you are familiar with creating and using widgets.\n\n\nWidget Files for Testing\n\n\nThe sub folder \nspec\n contains the widget spec test and associated resources.\nNone of these files are loaded during regular application runtime:\n\n\n\n\nspec/spec_runner.html\n\n\n\n\nFor convenience, LaxarJS provides a spec runner for each new widget, to run jasmine spec tests in the browser.\n  This file does not need to be touched at all.\n\n\n\n\nspec/spec_runner.js\n\n\n\n\nConfiguration for the spec test.\n  This file needs to be modified only if widget-specific external dependencies are required during testing.\n\n\n\n\nspec/cart_widget_spec.js\n\n\n\n\nThis is the actual \njasmine\n spec test.\n  The test harness (providing a simulated LaxarJS event bus) has already been prepared for you.\n\n\nImplementing a Controller\n\n\nTo write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means\n\n\n\n\n\n\nsumming the contents of the cart\n\n\n\n\n\n\nincreasing or decreasing the quantity of individual positions within the cart.\n\n\n\n\n\n\nThe grunt-init template has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart, this might be an appropriate starting implementation based on some dummy data:\n\n\n// ...\n\n\n\nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n   \n$scope\n.\nmodel\n \n=\n \n[\n\n      \n{\n \nlabel\n:\n \nDairy Dreams\n,\n \nprice\n:\n \n5.25\n,\n \namount\n:\n \n1\n \n},\n\n      \n{\n \nlabel\n:\n \nMilky Mocha\n,\n \nprice\n:\n \n12.75\n,\n \namount\n:\n \n3\n \n},\n\n      \n{\n \nlabel\n:\n \nFreezing Frapp\u00e9\n,\n \nprice\n:\n \n18.25\n,\n \namount\n:\n \n1\n \n}\n\n   \n];\n\n\n   \n$scope\n.\nincrement\n \n=\n \nfunction\n(\n \nitem\n \n)\n \n{\n\n      \n++\nitem\n.\namount\n;\n\n   \n};\n\n\n   \n$scope\n.\ndecrement\n \n=\n \nfunction\n(\n \nitem\n \n)\n \n{\n\n      \nitem\n.\namount\n \n=\n \nMath\n.\nmax\n(\n \n0\n,\n \nitem\n.\namount\n \n-\n \n1\n \n);\n\n   \n};\n\n\n   \n$scope\n.\ntotal\n \n=\n \nfunction\n(\n \nrows\n \n)\n \n{\n\n      \nreturn\n \nrows\n.\nreduce\n(\n \nfunction\n(\n \nacc\n,\n \nnext\n \n)\n \n{\n\n         \nreturn\n \nacc\n \n+\n \nnext\n.\nprice\n*\nnext\n.\namount\n;\n\n      \n},\n \n0\n \n);\n\n   \n};\n\n\n}\n\n\n\n// ...\n\n\n\n\n\n\nWe can see that a widget controller in LaxarJS works just like any other AngularJS controller.\nOf course things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.\n\n\nCreating a Template\n\n\nThe purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:\n\n\nh4\n \nng-bind-html=\nfeatures.headline.htmlText\n/h4\n\n\ntable\n \nclass=\ntable\n\n   \nthead\n\n   \ntr\n\n      \nth\nBeverage\n/th\n\n      \nth\n \nclass=\ncart-price\nPrice\n/th\n\n      \nth\n \nclass=\ncart-amount\nAmount\n/th\n\n      \nth\n/th\n\n   \n/tr\n\n   \n/thead\n\n   \ntfoot\n\n   \ntr\n\n      \nth\n \ncolspan=\n3\n \nclass=\ncart-price\n{{ total( model ) }}\n/th\n\n      \nth\n/th\n\n   \n/tr\n\n   \n/tfoot\n\n   \ntr\n \nng-repeat=\nitem in model\n\n      \ntd\n{{ item.label }}\n/td\n\n      \ntd\n \nclass=\ncart-amount\n{{ item.amount }}\n/td\n\n      \ntd\n \nclass=\ncart-price\n{{ item.price }}\n/td\n\n      \ntd\n\n         \nbutton\n \ndata-ng-click=\ndecrement( item )\n \nclass=\nbtn btn-xs\ni\n \nclass=\nfa fa-minus\n \n/\n/button\n\n         \nbutton\n \ndata-ng-click=\nincrement( item )\n \nclass=\nbtn btn-xs\ni\n \nclass=\nfa fa-plus\n \n/\n/button\n\n      \n/td\n\n   \n/tr\n\n\n/table\n\n\n\n\n\n\nNote that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that \nmodel\n, \ndecrement\n, \nincrement\n and \ntotal\n will be available upon template instantiation.\nThe \nfeatures\n property used within the headline comes from the \nwidget configuration\n, which is described below.\n\n\nAdding Some Style\n\n\nA widget may be styled using CSS.\nLaxarJS supports generating the CSS from SCSS source files, allowing to place common definitions for font size, color and much more within a shared \"theme\" folder.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under \ndefault.theme/css/cart_widget.css\n.\nOnce you are familiar with the basics, read the article on \ncreating themes\n for more information.\n\n\nThanks to Bootstrap this widget does not require a lot of fancy styling:\n\n\n.cart-widget\n \n.cart-amount\n,\n\n\n.cart-widget\n \n.cart-price\n \n{\n\n   \ntext-align\n:\n \nright\n;\n\n\n}\n\n\n\n\n\n\nFor best encapsulation, selectors should be prefixed with the widget class (\ncart-widget\n) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here (\ncart-amount\n, \ncart-price\n), just as you would prefix custom AngularJS elements or attributes when creating a directive.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.\n\n\nConfiguration Options\n\n\nWhen looking at the template, you might have wondered where the \nfeatures.headline.htmlText\n came from.\nThis is a \nfeature configuration\n option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we make it configurable by adding a feature entry to the \nwidget.json\n:\n\n\n{\n\n   \nname\n:\n \nCartWidget\n,\n\n   \ndescription\n:\n \nAllows Users to Review and Modify Purchase Items\n,\n\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nheadline\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nhtmlText\n:\n \n{\n\n                  \ntype\n:\n \nstring\n,\n\n                  \ndescription\n:\n \nThe HTML headline content.\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe \nwidget features\n are a \nJSON schema\n document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.\nSee the \nreference section\n for details on the widget specification.\n\n\nChecking out the Result\n\n\nBefore we can take a look at the widget, we will need to integrate it into the page provided by the application template (\napplication/pages/page1.json\n).\n\n\n{\n\n   \nlayout\n:\n \none_column\n,\n\n\n   \nareas\n:\n \n{\n\n      \nactivities\n:\n \n[],\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[\n\n          \n{\n\n             \nwidget\n:\n \nshopping/cart_widget\n,\n\n             \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \nhtmlText\n:\n \nMy Shopping Cart\n\n                \n}\n\n             \n}\n\n          \n}\n\n      \n],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThere is another manual to learn more about \nwriting pages\n.\n\n\nNow we can start the development web server provided by LaxarJS, from the application root:\n\n\nnpm install \n# if you have not already\n\nnpm start\n\n\n\n\n\nNavigate to \nhttp://localhost:8000/debug.html\n to admire the fruits of your labor:\n\n\n\n\nNow that you have learned the basics in creating widgets, take a closer look at widget testing.\n\n\nTesting a Widget\n\n\nOne of the major goals of LaxarJS is to simplify the development \nand testing\n of isolated components.\nFor this reason, the testing infrastructure for your widget has already been added when using \ngrunt-init\n.\n\n\nWriting Spec-Tests\n\n\nLaxarJS contains a testing infrastructure to mock out the LaxarJS runtime, effectively running your widget in a sandbox or \ntest bed\n as it is called in LaxarJS.\nA skeleton spec is already provided for you:\nIt contains code to prepare the test bed with sample configuration and to instantiate your controller.\n\n\nTo mock out AngularJS services such as \n$http\n you can work with \nngMocks\n just like you would do without LaxarJS.\nTo add a simple test for our widget, replace the existing dummy test\n\n\nit\n(\n \nstill needs some tests.\n \n);\n\n\n\n\n\n\nwith a more useful spec:\n\n\nit\n(\n \nallows to calculate a total of its contents\n,\n \nfunction\n()\n \n{\n\n    \nexpect\n(\n \ntestBed_\n.\nscope\n.\ntotal\n(\n \ntestBed_\n.\nscope\n.\nmodel\n \n)\n \n).\ntoEqual\n(\n \n61.75\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nTests get more interesting when you instrument the testbed to publish mock events to be handled by the widget controller, and in turn to inspect events published by the widget.\nFor more details on testing event bus communication, refer to the \narticle on events\n.\n\n\nRunning the Test\n\n\nNow make sure that the development web server is still running and check out the test results using the \nprovided spec runner\n:\n\n\n\n\nAlternatively, you can run the tests for all your widgets from the command line:\n\n\nnpm\n \ntest\n\n\n\n\n\n\nLaxarJS provides \ngrunt tasks\n for testing that automatically set up and run \nPhantomJS\n for you, so you should not run into problems accessing the DOM.\nHopefully this makes it simple to set up continuous integration for your application.\n\n\n\n\nLaxarJS Widget Reference\n\n\nBuilding on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and of the LaxarJS test bed.\n\n\nThe Widget Scope\n\n\nThe widget controller and the template have access to the widget scope.\nThe scope may be used by widget controllers to communicate with directives such as \nngForm\n.\nTo avoid entanglement, multiple widgets (even if nested) do \nnot\n communicate through the scope but \nalways use the event bus\n for this.\n\n\n\n\n$scope.eventBus\n\n\n\n\nMost of the time, this is the only LaxarJS scope property used by widget controllers.\n  Of course, controllers will almost always add their own properties.\n\n\n\n\n$scope.widget.id\n\n\n\n\nA unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect \nlabel\n and \ninput\n elements in an HTML form.\n\n\nThe Widget Specification Format\n\n\nEach widget has a \nwidget.json\n file which is also called \nwidget specification\n.\nLaxarJS contains a \nwidget schema definition\n that defines the exact format of this file.\nThese are the most important widget properties:\n\n\n\n\nname\n\n\n\n\nThis required field contains the \nCamelCase\n version of the widget's directory name.\n\n\n\n\ndescription\n\n\n\n\nWhat this widget is about.\n  Ideally, this contains the main \nuser-goal\n mentioned in the first section.\n\n\n\n\nfeatures\n\n\n\n\nThe widget features.\n  This is a JSON schema document that documents all configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.\n\n\n\n\ncompatibility\n\n\n\n\nAn optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to \nopt in\n to breaking LaxarJS changes (similarly to the Python \nimport from future\n construct), without harming widgets that do not yet support these changes.\n\n\n\n\ncontrols\n\n\n\n\nAn optional list of LaxarJS controls used by this widget.\n  Each control is represented by its RequireJS path.\n  This allows the LaxarJS runtime to automatically load the AngularJS modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to \nProviding Controls\n for on loading user interface components and their resources in this manner.\n\n\nThe LaxarJS Widget Test Bed\n\n\nThe LaxarJS spec test boilerplate (provided for you by grunt-init) creates a \ntestBed_\n instance which is re-initialized prior to running each test case.\nIt has the following essential properties.\n\n\n\n\ntestBed_.featuresMock\n\n\n\n\nContains the feature configuration for use during the spec test, to be specified by the author of the test.\n  It has the same format that would be provided through the page definition within an actual application.\n  Note that \nfeaturesMock\n must be set before calling \ntestBed_.setup()\n.\n\n\n\n\ntestBed_.setup()\n\n\n\n\nCreates the widget controller.\n  Afterwards, the \ntestBed_.scope\n is available.\n  This simulates navigating to a page that contains an instance of the widget under test.\n\n\n\n\ntestBed_.tearDown()\n\n\n\n\nDestroys the widget controller.\n  This is the testing equivalent to navigating away from the page that contains the widget instance.\n\n\n\n\ntestBed_.scope\n\n\n\n\nThe AngularJS scope that was created for this widget.\n  This allows to inspect widget state in white-box tests.\n\n\n\n\ntestBed_.eventBusMock\n\n\n\n\nA handle to the LaxarJS event bus that allows spec tests to simulate other widgets on the same page.\n  Through it, the spec test can publish events for manipulating the widget, and in turn subscribe to events published by the widget controller.\n  This is different from the \ntestBed_.scope.eventBus\n handle which is used by the widget controller.\n  Tests may use \nspyOn\n on the scope event bus to monitor widget behaviour directly, or interact with the \neventBusMock\n to communicate with the widget indirectly.", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widgets-and-activities", 
            "text": "Widgets and activities are the  \"work horse\"  of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-responsibilities", 
            "text": "Before starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question:  What goal does this widget help the user to accomplish? \nAre you thinking about a very broadly applicable, technical task such as  \"allow the user to enter a date\"  or  \"allow the user to delete a data row\" ?\nIn this case you might want to implement this functionality as a  control  (an AngularJS directive or an HTML5 web component) and use it  within  one or more of your widgets.  Usually, widgets correspond to significant areas of the screen and are composed from multiple controls.\nThey are built with a  specific user-goal  in mind, such as  \"allow the user to book a flight\"  or  \"allow the user to review shopping cart contents\" .\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of the thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?", 
            "title": "Widget Responsibilities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#when-to-use-activities", 
            "text": "Activities are  \"invisible widgets\"  that are used to  fetch and manage application resources .\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nThis makes activities perform a role similar to AngularJS services.\nThe advantage over services is that using activities puts the  page author  in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.\nAlthough these configurations are not impossible to achieve using AngularJS dependency injection and -services, using LaxarJS activities makes the connections declarative and visible.  Activities may also serve as a  mediator  between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.", 
            "title": "When to use Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#how-to-create-a-widget", 
            "text": "The easiest way to create a widget is to use the appropriate  grunt-init  template.\nCheck out the  README  on how to obtain the grunt-init templates and on creating an application.  Start by creating a sub-directory for your new widget within the LaxarJS application.\nEach widget in an application lives within a sub-folder of the  widget root  ( includes/widgets  by default).\nTo change the widget root you can modify the RequireJS-path  'laxar-path-widgets'  in the require configuration.\nThe widget path  includes/widgets/shopping/cart_widget  is used as an example path throughout this manual.  The sub-directory  shopping  is the  widget category  in the example path.\nCategories allow to organize widgets by their general business area, for example  shopping ,  social ,  finance  and so on.\nThe last component of the widget path is the  widget name :\nIt has to be unique throughout an application and must be written in lower case letters with components separated by underscores.\nRegular widget names always end in  _widget  whereas activities always end in  _activity .  To create the actual widget, run:  grunt-init laxar-widget  A wizard will ask for some details on the widget such as license and author, but you can always edit this information in the widget sources afterwards.\nIn the following steps, it is assumed that you used the category  shopping  and the widget name  cart_widget  as above.", 
            "title": "How to Create a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files", 
            "text": "A newly created widget contains the following files:   widget.json   This  widget specification  contains meta-data about your widget that is used by the LaxarJS framework.\n  It allows you to describe the configuration options of your widget features as a JSON schema.   bower.json   This specifies the  dependencies  of your widget for use with  Bower .\n  While not used directly by LaxarJS, it is the key to automated and isolated widget tests.   cart_widget.js   The  business logic  of your shopping cart (like calculating a total or changing item quantities) as an  AngularJS controller .\n  When your controller is instantiated by the LaxarJS runtime, it will receive an AngularJS scope (the model) and a reference to the event bus, which allows for communication with the world.\n  When built for release, all controllers and their RequireJS-dependencies are bundled into a single, compressed JavaScript file.   default.theme/cart_widget.html   The  AngularJS HTML template  defining the  appearance  of your widget.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The  Bootstrap CSS  classes are available by convention to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all), but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be preloaded within a single JSON file when your application is packaged for release.   default.theme/(s)css/cart_widget.(s)css   Widget-specific  style definitions .\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS (or  SCSS  folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, the framework will load it when the widget is used in an application, and bundle it for release.  LaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom  theme .\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead  more about themes  once you are familiar with creating and using widgets.", 
            "title": "Widget Files"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files-for-testing", 
            "text": "The sub folder  spec  contains the widget spec test and associated resources.\nNone of these files are loaded during regular application runtime:   spec/spec_runner.html   For convenience, LaxarJS provides a spec runner for each new widget, to run jasmine spec tests in the browser.\n  This file does not need to be touched at all.   spec/spec_runner.js   Configuration for the spec test.\n  This file needs to be modified only if widget-specific external dependencies are required during testing.   spec/cart_widget_spec.js   This is the actual  jasmine  spec test.\n  The test harness (providing a simulated LaxarJS event bus) has already been prepared for you.", 
            "title": "Widget Files for Testing"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#implementing-a-controller", 
            "text": "To write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means    summing the contents of the cart    increasing or decreasing the quantity of individual positions within the cart.    The grunt-init template has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart, this might be an appropriate starting implementation based on some dummy data:  // ...  function   Controller (   $scope   )   { \n    $scope . model   =   [ \n       {   label :   Dairy Dreams ,   price :   5.25 ,   amount :   1   }, \n       {   label :   Milky Mocha ,   price :   12.75 ,   amount :   3   }, \n       {   label :   Freezing Frapp\u00e9 ,   price :   18.25 ,   amount :   1   } \n    ]; \n\n    $scope . increment   =   function (   item   )   { \n       ++ item . amount ; \n    }; \n\n    $scope . decrement   =   function (   item   )   { \n       item . amount   =   Math . max (   0 ,   item . amount   -   1   ); \n    }; \n\n    $scope . total   =   function (   rows   )   { \n       return   rows . reduce (   function (   acc ,   next   )   { \n          return   acc   +   next . price * next . amount ; \n       },   0   ); \n    };  }  // ...   We can see that a widget controller in LaxarJS works just like any other AngularJS controller.\nOf course things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.", 
            "title": "Implementing a Controller"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#creating-a-template", 
            "text": "The purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:  h4   ng-bind-html= features.headline.htmlText /h4  table   class= table \n    thead \n    tr \n       th Beverage /th \n       th   class= cart-price Price /th \n       th   class= cart-amount Amount /th \n       th /th \n    /tr \n    /thead \n    tfoot \n    tr \n       th   colspan= 3   class= cart-price {{ total( model ) }} /th \n       th /th \n    /tr \n    /tfoot \n    tr   ng-repeat= item in model \n       td {{ item.label }} /td \n       td   class= cart-amount {{ item.amount }} /td \n       td   class= cart-price {{ item.price }} /td \n       td \n          button   data-ng-click= decrement( item )   class= btn btn-xs i   class= fa fa-minus   / /button \n          button   data-ng-click= increment( item )   class= btn btn-xs i   class= fa fa-plus   / /button \n       /td \n    /tr  /table   Note that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that  model ,  decrement ,  increment  and  total  will be available upon template instantiation.\nThe  features  property used within the headline comes from the  widget configuration , which is described below.", 
            "title": "Creating a Template"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#adding-some-style", 
            "text": "A widget may be styled using CSS.\nLaxarJS supports generating the CSS from SCSS source files, allowing to place common definitions for font size, color and much more within a shared \"theme\" folder.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under  default.theme/css/cart_widget.css .\nOnce you are familiar with the basics, read the article on  creating themes  for more information.  Thanks to Bootstrap this widget does not require a lot of fancy styling:  .cart-widget   .cart-amount ,  .cart-widget   .cart-price   { \n    text-align :   right ;  }   For best encapsulation, selectors should be prefixed with the widget class ( cart-widget ) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here ( cart-amount ,  cart-price ), just as you would prefix custom AngularJS elements or attributes when creating a directive.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.", 
            "title": "Adding Some Style"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#configuration-options", 
            "text": "When looking at the template, you might have wondered where the  features.headline.htmlText  came from.\nThis is a  feature configuration  option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we make it configurable by adding a feature entry to the  widget.json :  { \n    name :   CartWidget , \n    description :   Allows Users to Review and Modify Purchase Items , \n\n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          headline :   { \n             type :   object , \n             properties :   { \n                htmlText :   { \n                   type :   string , \n                   description :   The HTML headline content. \n                } \n             } \n          } \n       } \n    }  }   The  widget features  are a  JSON schema  document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.\nSee the  reference section  for details on the widget specification.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#checking-out-the-result", 
            "text": "Before we can take a look at the widget, we will need to integrate it into the page provided by the application template ( application/pages/page1.json ).  { \n    layout :   one_column , \n\n    areas :   { \n       activities :   [], \n       header :   [], \n       content :   [ \n           { \n              widget :   shopping/cart_widget , \n              features :   { \n                 headline :   { \n                    htmlText :   My Shopping Cart \n                 } \n              } \n           } \n       ], \n       footer :   [] \n    }  }   There is another manual to learn more about  writing pages .  Now we can start the development web server provided by LaxarJS, from the application root:  npm install  # if you have not already \nnpm start  Navigate to  http://localhost:8000/debug.html  to admire the fruits of your labor:   Now that you have learned the basics in creating widgets, take a closer look at widget testing.", 
            "title": "Checking out the Result"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#testing-a-widget", 
            "text": "One of the major goals of LaxarJS is to simplify the development  and testing  of isolated components.\nFor this reason, the testing infrastructure for your widget has already been added when using  grunt-init .", 
            "title": "Testing a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#writing-spec-tests", 
            "text": "LaxarJS contains a testing infrastructure to mock out the LaxarJS runtime, effectively running your widget in a sandbox or  test bed  as it is called in LaxarJS.\nA skeleton spec is already provided for you:\nIt contains code to prepare the test bed with sample configuration and to instantiate your controller.  To mock out AngularJS services such as  $http  you can work with  ngMocks  just like you would do without LaxarJS.\nTo add a simple test for our widget, replace the existing dummy test  it (   still needs some tests.   );   with a more useful spec:  it (   allows to calculate a total of its contents ,   function ()   { \n     expect (   testBed_ . scope . total (   testBed_ . scope . model   )   ). toEqual (   61.75   );  }   );   Tests get more interesting when you instrument the testbed to publish mock events to be handled by the widget controller, and in turn to inspect events published by the widget.\nFor more details on testing event bus communication, refer to the  article on events .", 
            "title": "Writing Spec-Tests"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#running-the-test", 
            "text": "Now make sure that the development web server is still running and check out the test results using the  provided spec runner :   Alternatively, you can run the tests for all your widgets from the command line:  npm   test   LaxarJS provides  grunt tasks  for testing that automatically set up and run  PhantomJS  for you, so you should not run into problems accessing the DOM.\nHopefully this makes it simple to set up continuous integration for your application.", 
            "title": "Running the Test"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#laxarjs-widget-reference", 
            "text": "Building on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and of the LaxarJS test bed.", 
            "title": "LaxarJS Widget Reference"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-widget-scope", 
            "text": "The widget controller and the template have access to the widget scope.\nThe scope may be used by widget controllers to communicate with directives such as  ngForm .\nTo avoid entanglement, multiple widgets (even if nested) do  not  communicate through the scope but  always use the event bus  for this.   $scope.eventBus   Most of the time, this is the only LaxarJS scope property used by widget controllers.\n  Of course, controllers will almost always add their own properties.   $scope.widget.id   A unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect  label  and  input  elements in an HTML form.", 
            "title": "The Widget Scope"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-widget-specification-format", 
            "text": "Each widget has a  widget.json  file which is also called  widget specification .\nLaxarJS contains a  widget schema definition  that defines the exact format of this file.\nThese are the most important widget properties:   name   This required field contains the  CamelCase  version of the widget's directory name.   description   What this widget is about.\n  Ideally, this contains the main  user-goal  mentioned in the first section.   features   The widget features.\n  This is a JSON schema document that documents all configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.   compatibility   An optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to  opt in  to breaking LaxarJS changes (similarly to the Python  import from future  construct), without harming widgets that do not yet support these changes.   controls   An optional list of LaxarJS controls used by this widget.\n  Each control is represented by its RequireJS path.\n  This allows the LaxarJS runtime to automatically load the AngularJS modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to  Providing Controls  for on loading user interface components and their resources in this manner.", 
            "title": "The Widget Specification Format"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-laxarjs-widget-test-bed", 
            "text": "The LaxarJS spec test boilerplate (provided for you by grunt-init) creates a  testBed_  instance which is re-initialized prior to running each test case.\nIt has the following essential properties.   testBed_.featuresMock   Contains the feature configuration for use during the spec test, to be specified by the author of the test.\n  It has the same format that would be provided through the page definition within an actual application.\n  Note that  featuresMock  must be set before calling  testBed_.setup() .   testBed_.setup()   Creates the widget controller.\n  Afterwards, the  testBed_.scope  is available.\n  This simulates navigating to a page that contains an instance of the widget under test.   testBed_.tearDown()   Destroys the widget controller.\n  This is the testing equivalent to navigating away from the page that contains the widget instance.   testBed_.scope   The AngularJS scope that was created for this widget.\n  This allows to inspect widget state in white-box tests.   testBed_.eventBusMock   A handle to the LaxarJS event bus that allows spec tests to simulate other widgets on the same page.\n  Through it, the spec test can publish events for manipulating the widget, and in turn subscribe to events published by the widget controller.\n  This is different from the  testBed_.scope.eventBus  handle which is used by the widget controller.\n  Tests may use  spyOn  on the scope event bus to monitor widget behaviour directly, or interact with the  eventBusMock  to communicate with the widget indirectly.", 
            "title": "The LaxarJS Widget Test Bed"
        }, 
        {
            "location": "/manuals/writing_compositions/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWriting Pages\n\n\n\n\nWriting Compositions\n\n\nAlthough inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this is not sufficient.\nVery often most of a base page fits for all pages but some small things need to be adjusted for some of the pages that could otherwise be reused throughout the application.\nAnother use case is to enable the reuse of a bundle of widgets multiple times within one page, each time only with some different configuration.\n\n\nAll of this can be achieved by using compositions.\nThe idea behind compositions is, that they provide a widget like interface regarding their addition to a page (or another composition) and the internals of a page fragment, bundling some widgets and other compositions.\nA composition thus has two basic properties: \nareas\n, like a page and \nfeatures\n like a widget.\nA third more advanced property, namely \nmergedFeatures\n, will be explained later.\n\n\nInstead we will start with the simple \npopup_composition\n we referenced above:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/popup_widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis example already shows some of the additional characteristics that go beyond the two properties \nfeatures\n and \nareas\n.\nLet us start from the beginning:\n\n\nFirst there is the \nfeatures\n object, that for simple cases looks just like a feature specification of a widget.\nHere you can define all the features that your composition needs to be configurable from the outside.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.\n\n\nSecondly there is the \nareas\n map and here there is already something noteworthy: The first area is simply named \n.\n.\nAll widgets and compositions within this special area will replace the reference of the composition within the area of the page including the composition.\nSo if we take the \nlast example\n of the chapter \nLayouts and Areas\n, this will be the area named \ncontent\n.\n\n\nFurthermore the two strings \n\"${features.openPopup.onActions}\"\n and \n\"${topic:closeAction}\"\n are worth noticing as they demonstrate another main feature of the composition concept.\nThose strings are expressions that will be evaluated by the page loader when assembling the complete page from its parts and are replaced by actual values as follows:\nThe \n\"${features.openPopup.onActions}\"\n expression is a reference to a feature defined within the \nfeatures\n object and will hold the value configured in the page including the composition.\nThus applied to the \nexample of the writing pages manual\n, this will result in the array \n[ \"next\" ]\n.\nOn the other hand the \n\"${topic:closeAction}\"\n expression generates a page wide unique event topic compatible string based on the local identifier \ncloseAction\n.\nThe result could thus be something like \n\"popupCompositionId0CloseAction\"\n which in fact is the id generated for the composition plus the local identifier.\nThese topic expressions should always be used when there is the need to have an identifier that is only used within the scope of a composition to prevent naming collisions with topics of the page, other compositions or multiple usages of this composition within the same page.\n\n\nNotice that these expressions are only written as a string to be JSON compatible and that no string interpolation takes place.\nThus something like \n\"myPrefix${topic:closeAction}\"\nwould not be interpreted when assembling the page and simply be used as is.\n\n\nThe assembled page thus looks similar to this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/popup_widget\n,\n\n            \nid\n:\n \npopupCompositionId0Popup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \npopupCompositionId0CloseAction\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopupCompositionId0Popup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \npopupCompositionId0CloseAction\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nNote how also the id of the exported area was automatically adjusted to \n\"popupCompositionId0Popup.content\"\n to prevent naming clashes.\n\n\nIn our example it is currently only possible to close the \nPopupWidget\n from within itself via an action event published by the \nCommandBarWidget\n.\nWhat if we additionally would like to close the popup on demand from outside based on another action?\nThis is where the concept of \nmerged features\n comes into play.\n\nMerged features\n allow us to merge or better concatenate two arrays, where one array is defined as a feature for the composition and the second array is defined in the \nmergedFeatures\n object.\nSyntactically this is achieved via a map under the key \nmergedFeatures\n where the key of each entry is the path to the array in the features and the value is the array to merge this value with.\n\n\nThis should become clear when looking at our adjusted example:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \nclosePopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n\n                  \n},\n\n                  \ndefault\n:\n \n[]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nmergedFeatures\n:\n \n{\n\n      \nclosePopup.onActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/popup_widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n${features.closePopup.onActions}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHere we added the possibility to configured close actions for the \nPopupWidget\n as feature \nclosePopup.onActions\n.\nFor this we then added an entry in the \nmergedFeatures\n map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the \nPopupWidget\n.\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the \nopenPopup.onActions\n feature.\nFor the configuration of the \nCommandBarWidget\n nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.\n\n\nAppendix:\n\n\nExemplary page from \nwriting pages\n manual\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#writing-compositions", 
            "text": "Although inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this is not sufficient.\nVery often most of a base page fits for all pages but some small things need to be adjusted for some of the pages that could otherwise be reused throughout the application.\nAnother use case is to enable the reuse of a bundle of widgets multiple times within one page, each time only with some different configuration.  All of this can be achieved by using compositions.\nThe idea behind compositions is, that they provide a widget like interface regarding their addition to a page (or another composition) and the internals of a page fragment, bundling some widgets and other compositions.\nA composition thus has two basic properties:  areas , like a page and  features  like a widget.\nA third more advanced property, namely  mergedFeatures , will be explained later.  Instead we will start with the simple  popup_composition  we referenced above:  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string \n                   } \n                } \n             } \n          } \n       } \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   portal/popup_widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   [   ${topic:closeAction}   ] \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   This example already shows some of the additional characteristics that go beyond the two properties  features  and  areas .\nLet us start from the beginning:  First there is the  features  object, that for simple cases looks just like a feature specification of a widget.\nHere you can define all the features that your composition needs to be configurable from the outside.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.  Secondly there is the  areas  map and here there is already something noteworthy: The first area is simply named  . .\nAll widgets and compositions within this special area will replace the reference of the composition within the area of the page including the composition.\nSo if we take the  last example  of the chapter  Layouts and Areas , this will be the area named  content .  Furthermore the two strings  \"${features.openPopup.onActions}\"  and  \"${topic:closeAction}\"  are worth noticing as they demonstrate another main feature of the composition concept.\nThose strings are expressions that will be evaluated by the page loader when assembling the complete page from its parts and are replaced by actual values as follows:\nThe  \"${features.openPopup.onActions}\"  expression is a reference to a feature defined within the  features  object and will hold the value configured in the page including the composition.\nThus applied to the  example of the writing pages manual , this will result in the array  [ \"next\" ] .\nOn the other hand the  \"${topic:closeAction}\"  expression generates a page wide unique event topic compatible string based on the local identifier  closeAction .\nThe result could thus be something like  \"popupCompositionId0CloseAction\"  which in fact is the id generated for the composition plus the local identifier.\nThese topic expressions should always be used when there is the need to have an identifier that is only used within the scope of a composition to prevent naming collisions with topics of the page, other compositions or multiple usages of this composition within the same page.  Notice that these expressions are only written as a string to be JSON compatible and that no string interpolation takes place.\nThus something like  \"myPrefix${topic:closeAction}\" would not be interpreted when assembling the page and simply be used as is.  The assembled page thus looks similar to this:  { \n    layout :   popups/layout_one , \n    areas :   { \n       header :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             widget :   portal/popup_widget , \n             id :   popupCompositionId0Popup , \n             features :   { \n                open :   { \n                   onActions :   [   next   ] \n                }, \n                close :   { \n                   onActions :   [   popupCompositionId0CloseAction   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   portal/html_display_widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ], \n       popupCompositionId0Popup.content :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   popupCompositionId0CloseAction \n                } \n             } \n          } \n       ] \n    }  }   Note how also the id of the exported area was automatically adjusted to  \"popupCompositionId0Popup.content\"  to prevent naming clashes.  In our example it is currently only possible to close the  PopupWidget  from within itself via an action event published by the  CommandBarWidget .\nWhat if we additionally would like to close the popup on demand from outside based on another action?\nThis is where the concept of  merged features  comes into play. Merged features  allow us to merge or better concatenate two arrays, where one array is defined as a feature for the composition and the second array is defined in the  mergedFeatures  object.\nSyntactically this is achieved via a map under the key  mergedFeatures  where the key of each entry is the path to the array in the features and the value is the array to merge this value with.  This should become clear when looking at our adjusted example:  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string \n                   } \n                } \n             } \n          }, \n          closePopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string \n                   }, \n                   default :   [] \n                } \n             } \n          } \n       } \n    }, \n    mergedFeatures :   { \n       closePopup.onActions :   [   ${topic:closeAction}   ] \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   portal/popup_widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   ${features.closePopup.onActions} \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   Here we added the possibility to configured close actions for the  PopupWidget  as feature  closePopup.onActions .\nFor this we then added an entry in the  mergedFeatures  map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the  PopupWidget .\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the  openPopup.onActions  feature.\nFor the configuration of the  CommandBarWidget  nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#appendix", 
            "text": "", 
            "title": "Appendix:"
        }, 
        {
            "location": "/manuals/writing_compositions/#exemplary-page-from-writing-pages-manual", 
            "text": "{ \n    layout :   popups/layout_one , \n    areas :   { \n       header :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             composition :   popup_composition , \n             features :   { \n                openPopup :   { \n                   onActions :   [   next   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   portal/html_display_widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ] \n    }  }", 
            "title": "Exemplary page from writing pages manual"
        }, 
        {
            "location": "/manuals/writing_pages/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nWriting Pages\n\n\nPages are written in a declarative fashion using the JSON format.\nStarting point is a simple object and some specific properties that will be explained in this document.\n\n\nLayouts and Areas\n\n\nFirst of all a page should specify the layout which defines the available widget areas and how they are arranged visually when rendered by the web browser.\nIf a page is intended to be used as a base page for \ninheritance\n, the layout property should be omitted.\nThis is because only one page in an extension chain may define a layout and this most probably will be one at the bottom of the hierarchy.\n\n\nConfiguring the layout is done via the \nlayout\n property of the page object.\nIts value is the name of the layout which is in turn a relative path within the layout folder to where the specific layout's assets are located.\nIf for example the desired layout is located at \npopups/layout_one\n, the according page (without any widgets yet) would look like this:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n\n\n}\n\n\n\n\n\n\nNow let us assume the html file of \npopups/layout_one\n looks like this:\n\n\n\n\ndiv\n\n   \ndiv\n \nax-widget-area=\nheader\n/div\n\n   \ndiv\n \nax-widget-area=\ncontent\n/div\n\n   \ndiv\n \nax-widget-area=\nfooter\n/div\n\n\n/div\n\n\n\n\n\n\nObviously there are three areas available, that can be occupied by widgets on the page.\nTo do so, we add another top-level key \nareas\n parallel to\nlayout\n.\nIts value is a map, where each key is the name of a widget area defined in the layout and the values are arrays, that will later list the widgets to render.\nWithout any widgets yet, We thus get the following page file:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWhen adding widgets to an area, the order is important, as this is the order in which the widgets will be rendered in the DOM.\nEach entry in the array is an object that can either reference a widget or a \ncomposition\n.\nIt thus needs to specify either \nwidget\n or \ncomposition\n as key.\nAdditionally a page wide unique (even over inheritance) \nid\n property can be provided.\nThis can be useful for debugging and is mandatory in case a widget provides one or more embedded areas (like e.g. a popover widget), which is explained in detail in \nTODO\n.\nFinally it is possible to provide the configuration for features of a widget or a composition under the key \nfeatures\n.\n\n\nHere is the example with some simple, exemplary content:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe object under \nfeatures\n needs to satisfy the schema defined for the features of the according widget in the file \nwidget.json\n.\nWhen loading a page and its widgets, LaxarJS will actually validate the configuration provided in the page against the widget's schema and throw an error in case one or more constraints are violated.\n\n\nInheritance\n\n\nThe most simple way to reuse parts of a page specification is by inheritance.\nDue to the intentional lack of complex additional inheritance features it is also the most limited way of specification reuse.\nNevertheless it has its valid use cases as in every user interface there are some elements that never change across pages.\nThese should be extracted into one or more base pages, that define no layout and can be reused by all other pages defining the layout necessary to display their contents.\n\n\nValid candidate widgets for base pages are application headlines, informational notes in a footer area or activities providing common tasks for all pages.\nLet us apply this to our example from above and extract the \nHeadlineWidget\n into a base page called \nbase_page.json\n.\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWe now can modify our original page using the keyword \nextends\n that references the base page relatively to the root path for all pages.\nThe parts already provided by the base page can then be deleted:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nextends\n:\n \nbase_page\n,\n\n   \nareas\n:\n \n{\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIt is also possible to add widgets to an area, that is already filled with one or more widgets in the base page.\nThose widgets in the extending page will be appended to the according area and thus appear after the base widgets in the DOM.\nIf a widget of the extending page should explicitly be added before another widget of a base page, this can be achieved using the keyword \ninsertBeforeId\n.\nNote that for this to work it's necessary to provide an \nid\n property for the according widget in the base page.\n\n\nLet us assume we wanted to add another additional headline in one extending page.\nWe therefore change the base page first and add an id to the existing headline:\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nid\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHence the page that has the need to add content can reference the given id using \ninsertBeforeId\n like this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nextends\n:\n \nbase_page\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \ninsertBeforeId\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \nhtmlText\n:\n \nYou just won one billion dollar!\n\n                \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n \n ... some widgets ... \n \n],\n\n      \nfooter\n:\n \n[\n \n ... some widgets ... \n \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis is all one needs to know to build basic pages for LaxarJS.\nIt might become necessary to split pages into smaller, possibly reusable chunks, which is the task compositions where designed for.\nSo if the need arises, read on in the manual for \nwriting compositions\n.", 
            "title": "Writing Pages"
        }, 
        {
            "location": "/manuals/writing_pages/#writing-pages", 
            "text": "Pages are written in a declarative fashion using the JSON format.\nStarting point is a simple object and some specific properties that will be explained in this document.", 
            "title": "Writing Pages"
        }
    ]
}