{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS\n\n\nLaxarJS helps to create maintainable AngularJS apps by assembling them from small, isolated parts.\n\n\nWhy LaxarJS?\n\n\nFind out \nwhy\n you would use LaxarJS and if it's the right tool for you.\nThen, explore the \ncore concepts\n and browse the \nmanuals\n in the \ndocumentation\n.\n\n\nHave a look at the \nLaxarJS homepage\n for demos and more information.\n\n\nGetting Started\n\n\nThis is a very minimal getting started guide.\nIt helps you to set up your first LaxarJS application and to create your first LaxarJS widget.\n\n\nGet the Prerequisites\n\n\nnpm install -g grunt-cli grunt-init\ngit clone https://github.com/LaxarJS/grunt-init-laxar-application.git ~/.grunt-init/laxar-application\ngit clone https://github.com/LaxarJS/grunt-init-laxar-widget.git ~/.grunt-init/laxar-widget\ngit clone https://github.com/LaxarJS/grunt-init-laxar-widget.git ~/.grunt-init/laxar-activity\n\n\n\n\n\nCreate a LaxarJS Application from Our Template\n\n\nmkdir tryout\n\ncd \ntryout\ngrunt-init laxar-application\nnpm install\nnpm start\n\n\n\n\n\nVisit your empty application at \nhttp://localhost:8000/debug.html\n.\n\n\nPress Ctrl-c to stop the server for now.\n\n\nCreate your first LaxarJS widget\n\n\nCreate a widget which simply displays \nHello, world!\n:\n\n\nmkdir -p includes/widgets/tryout/my_first_widget\n\ncd \nincludes/widgets/tryout/my_first_widget\ngrunt-init laxar-widget\nadd some widget-HTML:\n\necho\n \nh1\nHello, world!\n/h1\n \n default.theme/my_first_widget.html\n\n\n\n\n\nReference the widget from your page:\n\n\ncd\n -\n\necho\n \n{\n\n\n   \nlayout\n: \none_column\n,\n\n\n   \nareas\n: {\n\n\n      \nactivities\n: [ ],\n\n\n      \nheader\n: [ ],\n\n\n      \ncontent\n: [\n\n\n          {\n\n\n             \nwidget\n: \ntryout/my_first_widget\n\n\n          }\n\n\n      ],\n\n\n      \nfooter\n: [ ]\n\n\n   }\n\n\n}\n\n\n \n application/pages/page1.json\nnpm start\n\n\n\n\n\nSee your widget in action at \nhttp://localhost:8000/debug.html\n\n\nCreate a Compressed Release-Ready Version of Your Application\n\n\nFirst, stop the development server using Ctrl-c.\n\n\ngrunt dist\nnpm start\n\n\n\n\n\nNow your compressed application can be visited at \nhttp://localhost:8000/\n or may be deployed from the zip file that was just generated for you.\n\n\nNext Steps\n\n\nHave fun developing your first LaxarJS application.\n\n\nMake sure to have a look at the \nAPI doc\n and stay tuned for the upcoming getting started guide.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs", 
            "text": "LaxarJS helps to create maintainable AngularJS apps by assembling them from small, isolated parts.", 
            "title": "LaxarJS"
        }, 
        {
            "location": "/#why-laxarjs", 
            "text": "Find out  why  you would use LaxarJS and if it's the right tool for you.\nThen, explore the  core concepts  and browse the  manuals  in the  documentation .  Have a look at the  LaxarJS homepage  for demos and more information.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/#getting-started", 
            "text": "This is a very minimal getting started guide.\nIt helps you to set up your first LaxarJS application and to create your first LaxarJS widget.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#get-the-prerequisites", 
            "text": "npm install -g grunt-cli grunt-init\ngit clone https://github.com/LaxarJS/grunt-init-laxar-application.git ~/.grunt-init/laxar-application\ngit clone https://github.com/LaxarJS/grunt-init-laxar-widget.git ~/.grunt-init/laxar-widget\ngit clone https://github.com/LaxarJS/grunt-init-laxar-widget.git ~/.grunt-init/laxar-activity", 
            "title": "Get the Prerequisites"
        }, 
        {
            "location": "/#create-a-laxarjs-application-from-our-template", 
            "text": "mkdir tryout cd  tryout\ngrunt-init laxar-application\nnpm install\nnpm start  Visit your empty application at  http://localhost:8000/debug.html .  Press Ctrl-c to stop the server for now.", 
            "title": "Create a LaxarJS Application from Our Template"
        }, 
        {
            "location": "/#create-your-first-laxarjs-widget", 
            "text": "Create a widget which simply displays  Hello, world! :  mkdir -p includes/widgets/tryout/my_first_widget cd  includes/widgets/tryout/my_first_widget\ngrunt-init laxar-widget\nadd some widget-HTML: echo   h1 Hello, world! /h1    default.theme/my_first_widget.html  Reference the widget from your page:  cd  - echo   {      layout :  one_column ,      areas : {         activities : [ ],         header : [ ],         content : [            {                widget :  tryout/my_first_widget            }        ],         footer : [ ]     }  }     application/pages/page1.json\nnpm start  See your widget in action at  http://localhost:8000/debug.html", 
            "title": "Create your first LaxarJS widget"
        }, 
        {
            "location": "/#create-a-compressed-release-ready-version-of-your-application", 
            "text": "First, stop the development server using Ctrl-c.  grunt dist\nnpm start  Now your compressed application can be visited at  http://localhost:8000/  or may be deployed from the zip file that was just generated for you.", 
            "title": "Create a Compressed Release-Ready Version of Your Application"
        }, 
        {
            "location": "/#next-steps", 
            "text": "Have fun developing your first LaxarJS application.  Make sure to have a look at the  API doc  and stay tuned for the upcoming getting started guide.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv0.17.1\n\n\n\n\n#119\n: portal: fixed race condition in page loader\n\n\n#114\n: configuration: fixed mapping of deprecated fileListing entry.\n\n\n#112\n: documentation: removed colloquial style\n\n\n\n\nv0.17.0\n\n\n\n\n#108\n: documentation: unify code-snippet format, and some polish\n\n\n#109\n: documentation: added manual on providing controls\n\n\n#107\n: angular widget adapter: added widget specific event bus service.\n\n\n#106\n: documentation: fixed manuals, improved introduction in README.md\n\n\n#93\n: refactoring: extracted page related services into own files.\n\n\n#98\n: documentation: added manual on events and pub/sub\n\n\n#100\n: widget loader: added angular widget as default integration.\n\n\n#105\n: moved resumable timer handling from flow to timer.\n\n\n#104\n: configuration: deprecated configuration keys are no handled at one place.\n\n\n#101\n: documentation: use \"\u00ab\" rather than \"\n\" for backwards navigation links\n\n\n#76\n: documentation: widgets and activities\n\n\n#75\n: documentation: flow and places.\n\n\n#96\n: documentation: restructured existing documents and added stubs for missing ones.\n\n\n#95\n: documentation: wrote a motivational article for LaxarJS.\n\n\n#94\n: footprint: removed the outdated app stub in favor of grunt-init (see README.md)\n\n\n#38\n: documentation: pages and compositions.\n\n\n#91\n: portal: make sure that widget DOM is attached when linking\n\n\n\n\n#90\n: documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#89\n: documentation: primary concepts of LaxarJS\n\n\n\n\n#84\n: storage: storing \nundefined\n now causes the entry to be removed\n\n\n\n\nv0.16.0\n\n\n\n\n#87\n: portal: Ensure anonymization of logged events.\n\n\n#86\n: logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.\n\n\n\n\n#85\n: utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#83\n: portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#81\n: added check for duplicate area definitions in layouts\n\n\n\n\n\n\nv0.15.0\n\n\n\n\n\n\n#82\n: implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#80\n: storage: Improved detection of WebStorage API for Internet Explorer\n\n\n\n\n#79\n: assert: details given as object are now serialized\n\n\n#77\n: flow: the log tag \nPLCE\n with the current place name is set after navigation\n\n\n\n\nv0.14.0\n\n\n\n\n#73\n: portal: fixed lookup of merged CSS file\n\n\n#69\n: portal: moved setting widget root element IDs to widget loader\n\n\n#68\n: fixed wrongly global assert in jshintrc.\n\n\n#67\n: re-added missing widget root element IDs.\n\n\n#65\n: fixed navigation being broken when parameter values were missing.\n\n\n#66\n: prevented endless navigation ping pong in flow controller\n\n\n#63\n: axVisibilityService: use scope.$id to identify handlers, not scope.id\n\n\n#62\n: fixed endless recursion on navigation when place and target have the same name.\n\n\n\n\nv0.13.0\n\n\n\n\n\n\n#61\n: added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#60\n: tests: make sure PhantomJS is installed properly, before running spec tests.\n\n\n\n\n\n\n#52\n: portal, testing: added visibility events and the \naxVisibilityService\n\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#59\n: portal: fixed dangling comma in timer imports\n\n\n\n\n#58\n: portal, json: fixed copyright headers\n\n\n#57\n: portal: fixed double-navigation problem which can lead to skipping places\n\n\n#56\n: object: removed all direct calls of hasOwnProperty.\n\n\n#55\n: run_spec: disable loading the \nwidget.json\n if the \nspec_runner.js\n contains \nwidgetJson: false\n\n\n#54\n: testing: fixed broken testBed injection of $q and $timeout\n\n\n#50\n: performance: decoupled instantiation of widget controllers from their DOM\n\n\n\n\nv0.12.0\n\n\n\n\n\n\n#49\n: added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#48\n: Promises generated by the event bus are now scheduled by the event bus, not by AngularJS \n$apply\n.\n\n\n\n\n#51\n: Remove some obsolete NPM \ndevDependencies\n.\n\n\n#47\n: Do not schedule another full event-bus tick while one is already being processed.\n\n\n#46\n: fixed misinterpretation of falsy required attribute in json schema converter.\n\n\n#45\n: i18n: adjusted localizer.format specs to changes from \n#43\n.\n\n\n\n\n#43\n: string: added new function \nstring.format\n as simpler replacement for \ntext\n library.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#42\n: portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#40\n: portal: fixed 'flag-topic' pattern.\n\n\n\n\n\n\nv0.11.0\n\n\n\n\n\n\n#39\n: portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#37\n: improved browsing of existing api doc and fixed some syntactical errors.\n\n\n\n\n#36\n: jshintrc: disabled enforcement of dot notation for object property access.\n\n\n\n\n#34\n: Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#33\n: EventBus: added event object to the information sent to inspectors on deliver actions.\n\n\n\n\n\n\n#31\n: Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#32\n: Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#30\n: PageLoader: added missing check for duplicate composition ids.\n\n\n\n\n\n\nv0.10.0\n\n\n\n\n#27\n: Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick\n\n\n#28\n: Fixed null values in widget features within compositions being turned into empty objects.\n\n\n#29\n: PageLoader: composition features that are not configured do not result in undefined values for widget features.\n\n\n#25\n: Only the page relevant for the current place is loaded now.\n\n\n\n\n#17\n: Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#26\n: Testing: Fixed the responseTransform option for http-mock\n\n\n\n\n\n\n#22\n: FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#15\n: FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings\n\n\n\n\n\n\n#24\n: Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#23\n: FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.\n\n\n\n\n#21\n: The file resource provider now normalizes its root path.\n\n\n#20\n: Fixed event bus inspectors not being notified on unsubscription.\n\n\n#14\n: Fixed navigation being broken after successive navigation to the current location.\n\n\n#13\n: The current place is now send as part of the didNavigate event.\n\n\n#12\n: Testing: Get the LaxarJS tests running in Karma again.\n\n\n#11\n: Testing: Handle \nspec_runner.js\n that are not in a subdirectory of the RequireJS' \nbaseUrl\n.\n\n\n#10\n: Testing: Loading controls during tests now works in Karma.\n\n\n#9\n: Update Bower from ~1.2.8 to ~1.3.3.\n\n\n#8\n: Fixed the cleanup mechanism for generated widget areas.\n\n\n#6\n: The Portal now initializes an i18n object on the application's \n$rootScope\n\n\n#5\n: Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json\n\n\n#4\n: PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys\n\n\n#3\n: Added url formatting for links in Readme.md\n\n\n#2\n: Fixed grunt-init step in Getting-Started docs\n\n\n#1\n: Added initial Getting-Started documentation", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v0171", 
            "text": "#119 : portal: fixed race condition in page loader  #114 : configuration: fixed mapping of deprecated fileListing entry.  #112 : documentation: removed colloquial style", 
            "title": "v0.17.1"
        }, 
        {
            "location": "/CHANGELOG/#v0170", 
            "text": "#108 : documentation: unify code-snippet format, and some polish  #109 : documentation: added manual on providing controls  #107 : angular widget adapter: added widget specific event bus service.  #106 : documentation: fixed manuals, improved introduction in README.md  #93 : refactoring: extracted page related services into own files.  #98 : documentation: added manual on events and pub/sub  #100 : widget loader: added angular widget as default integration.  #105 : moved resumable timer handling from flow to timer.  #104 : configuration: deprecated configuration keys are no handled at one place.  #101 : documentation: use \"\u00ab\" rather than \" \" for backwards navigation links  #76 : documentation: widgets and activities  #75 : documentation: flow and places.  #96 : documentation: restructured existing documents and added stubs for missing ones.  #95 : documentation: wrote a motivational article for LaxarJS.  #94 : footprint: removed the outdated app stub in favor of grunt-init (see README.md)  #38 : documentation: pages and compositions.  #91 : portal: make sure that widget DOM is attached when linking   #90 : documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details    #89 : documentation: primary concepts of LaxarJS   #84 : storage: storing  undefined  now causes the entry to be removed", 
            "title": "v0.17.0"
        }, 
        {
            "location": "/CHANGELOG/#v0160", 
            "text": "#87 : portal: Ensure anonymization of logged events.  #86 : logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.   #85 : utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details    #83 : portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details    #81 : added check for duplicate area definitions in layouts", 
            "title": "v0.16.0"
        }, 
        {
            "location": "/CHANGELOG/#v0150", 
            "text": "#82 : implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details    #80 : storage: Improved detection of WebStorage API for Internet Explorer   #79 : assert: details given as object are now serialized  #77 : flow: the log tag  PLCE  with the current place name is set after navigation", 
            "title": "v0.15.0"
        }, 
        {
            "location": "/CHANGELOG/#v0140", 
            "text": "#73 : portal: fixed lookup of merged CSS file  #69 : portal: moved setting widget root element IDs to widget loader  #68 : fixed wrongly global assert in jshintrc.  #67 : re-added missing widget root element IDs.  #65 : fixed navigation being broken when parameter values were missing.  #66 : prevented endless navigation ping pong in flow controller  #63 : axVisibilityService: use scope.$id to identify handlers, not scope.id  #62 : fixed endless recursion on navigation when place and target have the same name.", 
            "title": "v0.14.0"
        }, 
        {
            "location": "/CHANGELOG/#v0130", 
            "text": "#61 : added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details    #60 : tests: make sure PhantomJS is installed properly, before running spec tests.    #52 : portal, testing: added visibility events and the  axVisibilityService \n        + NEW FEATURE: see ticket for details    #59 : portal: fixed dangling comma in timer imports   #58 : portal, json: fixed copyright headers  #57 : portal: fixed double-navigation problem which can lead to skipping places  #56 : object: removed all direct calls of hasOwnProperty.  #55 : run_spec: disable loading the  widget.json  if the  spec_runner.js  contains  widgetJson: false  #54 : testing: fixed broken testBed injection of $q and $timeout  #50 : performance: decoupled instantiation of widget controllers from their DOM", 
            "title": "v0.13.0"
        }, 
        {
            "location": "/CHANGELOG/#v0120", 
            "text": "#49 : added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details    #48 : Promises generated by the event bus are now scheduled by the event bus, not by AngularJS  $apply .   #51 : Remove some obsolete NPM  devDependencies .  #47 : Do not schedule another full event-bus tick while one is already being processed.  #46 : fixed misinterpretation of falsy required attribute in json schema converter.  #45 : i18n: adjusted localizer.format specs to changes from  #43 .   #43 : string: added new function  string.format  as simpler replacement for  text  library.\n        + NEW FEATURE: see ticket for details    #42 : portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details    #40 : portal: fixed 'flag-topic' pattern.", 
            "title": "v0.12.0"
        }, 
        {
            "location": "/CHANGELOG/#v0110", 
            "text": "#39 : portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details    #37 : improved browsing of existing api doc and fixed some syntactical errors.   #36 : jshintrc: disabled enforcement of dot notation for object property access.   #34 : Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details    #33 : EventBus: added event object to the information sent to inspectors on deliver actions.    #31 : Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details    #32 : Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details    #30 : PageLoader: added missing check for duplicate composition ids.", 
            "title": "v0.11.0"
        }, 
        {
            "location": "/CHANGELOG/#v0100", 
            "text": "#27 : Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick  #28 : Fixed null values in widget features within compositions being turned into empty objects.  #29 : PageLoader: composition features that are not configured do not result in undefined values for widget features.  #25 : Only the page relevant for the current place is loaded now.   #17 : Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details    #26 : Testing: Fixed the responseTransform option for http-mock    #22 : FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details    #15 : FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings    #24 : Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details    #23 : FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.   #21 : The file resource provider now normalizes its root path.  #20 : Fixed event bus inspectors not being notified on unsubscription.  #14 : Fixed navigation being broken after successive navigation to the current location.  #13 : The current place is now send as part of the didNavigate event.  #12 : Testing: Get the LaxarJS tests running in Karma again.  #11 : Testing: Handle  spec_runner.js  that are not in a subdirectory of the RequireJS'  baseUrl .  #10 : Testing: Loading controls during tests now works in Karma.  #9 : Update Bower from ~1.2.8 to ~1.3.3.  #8 : Fixed the cleanup mechanism for generated widget areas.  #6 : The Portal now initializes an i18n object on the application's  $rootScope  #5 : Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json  #4 : PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys  #3 : Added url formatting for links in Readme.md  #2 : Fixed grunt-init step in Getting-Started docs  #1 : Added initial Getting-Started documentation", 
            "title": "v0.10.0"
        }, 
        {
            "location": "/concepts/", 
            "text": "LaxarJS Concepts\n\n\nIn order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.\n\n\nA LaxarJS Application\n\n\nTo the visitor running a web browser, an \napplication\n is a set of URLs and associated resources which are run in the browser to provide some information or functionality.\nIt may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.\n\n\nFrom a developer point of view, an application primarily consists of:\n\n\n* a set of LaxarJS _widgets_ and _activities_ providing the functionality\n* the _pages_ and _layouts_ assembling these widgets and activities\n* a _flow_ that connects the individual pages\n* one or more _themes_ to define the look and feel of the application.\n\n\n\n\n\nIn order to run the application, there are additional secondary resources:\n\n\n* the _LaxarJS Core runtime_ which loads flow and pages, sets up the correct widgets and connects them through an _event bus_\n* _controls_ which are used by the widgets to provide advanced user interface functionality, some of which are provided by _LaxarJS UiKit_\n* _libraries_ used by widgets and activities, such as _moment.js_, _jQuery_, and _LaxarJS patterns_.\n\n\n\n\n\nThe following two sections first explain the primary application components, and than the underlying secondary components.\n\n\nPrimary Application Parts\n\n\nWidgets\n\n\nA LaxarJS \nwidget\n is a rectangular part of the browser viewport, which \nallows the user to perform some task\n.\nIt is usually represented by several HTML elements, but might in some cases be a single element, for example a \ncanvas\n to provide a painting surface.\n\n\nThe important distinction between a LaxarJS widget and a plain HTML control (such as a \nselect\n box or an \ninput\n field) is that a widget is written with a specific \nuser-goal\n in mind, whereas a control is general-purpose and its purpose in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a user name, or a password), a widget might combine input controls in a box to allow the same user to \nlog in\n to the application, and another widget might allow the user to \nregister\n a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.\n\n\nTo illustrate this with further examples, possible widgets \nwith their specific goals\n include:\n\n\n* a ToDo list, _to check and plan what is to do_\n* a shopping cart, _to review and edit purchase items_\n* a route planner displayed as a map, _to plan a journey_\n* a calendar displaying various events, _to schedule and check appointments_\n* the details editor for a specific event, _to reschedule or cancel an appointment_\n* a social buttons bar, _to share content_.\n\n\n\n\n\nIn contrast, these are controls:\n\n\n* an input field, _to display/edit any text_\n* a date picker, _to display/edit any date_\n* a select box, _to choose from any list of options_\n* an accordion control or a tab control, _to navigate any set of contents_.\n\n\n\n\n\nAnother way to think of it is that \nwidgets are made of controls\n, and  \ncontrols are HTML elements\n which may be user-defined (for example through AngularJS directives).\nThe program logic of an individual widget is implemented in JavaScript (as an AngularJS controller) while the presentation is defined as an (AngularJS) HTML template, optionally accompanied by CSS styling information.\nAnother important property of widgets is that they always can be \nloaded and tested in isolation\n.\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) might already be there.\n\n\nActivities\n\n\nA LaxarJS \nactivity\n is a widget without a visual representation, performing a task for the user \nbehind the scenes\n.\nFor example, a \nlogin widget\n might talk to an authentication service itself, but it might also delegate this task to an \nauthentication activity\n using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS login to OAuth) only the activity needs to be exchanged, while the widget might remain untouched.\nIn contrast to libraries and regular AngularJS services, Activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe. \n\n\nAnother possible example would be a web search widget offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just \nsubscribes\n to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching any of the other implementation.\n\n\nAnother way to think of it is that \nwidgets have to run in the browser, while activities might run in any JavaScript environment\n.\nIn contrast to visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities always perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.\n\n\nPages\n\n\nA LaxarJS \npage\n combines and configures widgets and activities that should be displayed together by embedding them in an HTML skeleton (the layout).\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions. \n\n\nAn individual widget is still somewhat generic in that it allows to perform a specific task \nin any context\n.\nFor example, a social buttons bar might allow to share \nany content\n, and the specific list of social sites to share on might be \nconfigurable\n.\nThe page establishes this context, for example \nby placing\n the social buttons below the article (rendered from markdown by another widget), and \nby configuring\n that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nBut it means that reuse is supported for those widgets where it makes sense.\n\n\nWhile widgets and activities are implemented in JavaScript and HTML, pages are written using JSON in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.\n\n\nLayouts\n\n\nLayouts are skeleton HTML documents, which contain placeholders (\nwidget areas\n) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nA layout can contain all the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.\n\n\nFor each \nwidget areas\n, the layout defines a width in grid columns, and widgets within these areas may not exceed their available number of columns.\nThe LaxarJS UiKit ships with \nBootstrap\n to implement the grid layout in CSS.\nLike widgets, layouts are accompanied by CSS styles, for example to define a background color.\n\n\nYou might think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.\n\n\nThe Flow\n\n\nThe flow defines \nURL patterns\n that may be used to navigate to the pages of an application, and \nrelations between pages\n.\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, it defines semantic relations between pages, such as what is considered the \nnext\n page for a given page in the application.\n\n\nThemes\n\n\nWidgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.\n\n\nThe LaxarJS UiKit is based on Compass/SCSS to simplify the generation of user defined themes, but any way to generate Bootstrap-like CSS styles would be a valid way to create a theme.\n\n\nSecondary Application Parts \u2013 Under the Hood\n\n\nThe LaxarJS Runtime\n\n\nThe \nruntime\n handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.\n\n\nThe LaxarJS Event Bus\n\n\nThe \nevent bus\n allows widgets to talk about common topics, without knowing \nanything\n about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or expect resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.\n\n\nControls\n\n\nControls\n are (user-defined) HTML elements and attributes, integrated as AngularJS directives.\nThey are available to widgets as reusable UI components, and are styled using \nBootstrap 3.2\n for interoperability and theme support.\nA useful set of controls to get started is provided by the \nAngular UI Bootstrap\n project.\n\n\nLibraries\n\n\nWidgets may use \nlibraries\n such as \njQuery\n or \nmoment.js\n just like in any JavaScript web application.\nLaxarJS currently provides a development workflow based on \ngrunt\n, \nbower\n, and \nRequireJS\n in order to install and load widgets with their assets as well as libraries, but other tool-chains are not out of the question.\n\n\nTo establish a useful common base vocabulary for the LaxarJS event bus, the \nLaxarJS Patterns\n library is provided.\nIt contains helpers that make it very easy for widgets to talk about user actions, common (REST) resources and boolean flags.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#laxarjs-concepts", 
            "text": "In order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#a-laxarjs-application", 
            "text": "To the visitor running a web browser, an  application  is a set of URLs and associated resources which are run in the browser to provide some information or functionality.\nIt may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.  From a developer point of view, an application primarily consists of:  * a set of LaxarJS _widgets_ and _activities_ providing the functionality\n* the _pages_ and _layouts_ assembling these widgets and activities\n* a _flow_ that connects the individual pages\n* one or more _themes_ to define the look and feel of the application.  In order to run the application, there are additional secondary resources:  * the _LaxarJS Core runtime_ which loads flow and pages, sets up the correct widgets and connects them through an _event bus_\n* _controls_ which are used by the widgets to provide advanced user interface functionality, some of which are provided by _LaxarJS UiKit_\n* _libraries_ used by widgets and activities, such as _moment.js_, _jQuery_, and _LaxarJS patterns_.  The following two sections first explain the primary application components, and than the underlying secondary components.", 
            "title": "A LaxarJS Application"
        }, 
        {
            "location": "/concepts/#primary-application-parts", 
            "text": "", 
            "title": "Primary Application Parts"
        }, 
        {
            "location": "/concepts/#widgets", 
            "text": "A LaxarJS  widget  is a rectangular part of the browser viewport, which  allows the user to perform some task .\nIt is usually represented by several HTML elements, but might in some cases be a single element, for example a  canvas  to provide a painting surface.  The important distinction between a LaxarJS widget and a plain HTML control (such as a  select  box or an  input  field) is that a widget is written with a specific  user-goal  in mind, whereas a control is general-purpose and its purpose in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a user name, or a password), a widget might combine input controls in a box to allow the same user to  log in  to the application, and another widget might allow the user to  register  a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.  To illustrate this with further examples, possible widgets  with their specific goals  include:  * a ToDo list, _to check and plan what is to do_\n* a shopping cart, _to review and edit purchase items_\n* a route planner displayed as a map, _to plan a journey_\n* a calendar displaying various events, _to schedule and check appointments_\n* the details editor for a specific event, _to reschedule or cancel an appointment_\n* a social buttons bar, _to share content_.  In contrast, these are controls:  * an input field, _to display/edit any text_\n* a date picker, _to display/edit any date_\n* a select box, _to choose from any list of options_\n* an accordion control or a tab control, _to navigate any set of contents_.  Another way to think of it is that  widgets are made of controls , and   controls are HTML elements  which may be user-defined (for example through AngularJS directives).\nThe program logic of an individual widget is implemented in JavaScript (as an AngularJS controller) while the presentation is defined as an (AngularJS) HTML template, optionally accompanied by CSS styling information.\nAnother important property of widgets is that they always can be  loaded and tested in isolation .\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) might already be there.", 
            "title": "Widgets"
        }, 
        {
            "location": "/concepts/#activities", 
            "text": "A LaxarJS  activity  is a widget without a visual representation, performing a task for the user  behind the scenes .\nFor example, a  login widget  might talk to an authentication service itself, but it might also delegate this task to an  authentication activity  using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS login to OAuth) only the activity needs to be exchanged, while the widget might remain untouched.\nIn contrast to libraries and regular AngularJS services, Activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe.   Another possible example would be a web search widget offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just  subscribes  to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching any of the other implementation.  Another way to think of it is that  widgets have to run in the browser, while activities might run in any JavaScript environment .\nIn contrast to visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities always perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.", 
            "title": "Activities"
        }, 
        {
            "location": "/concepts/#pages", 
            "text": "A LaxarJS  page  combines and configures widgets and activities that should be displayed together by embedding them in an HTML skeleton (the layout).\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions.   An individual widget is still somewhat generic in that it allows to perform a specific task  in any context .\nFor example, a social buttons bar might allow to share  any content , and the specific list of social sites to share on might be  configurable .\nThe page establishes this context, for example  by placing  the social buttons below the article (rendered from markdown by another widget), and  by configuring  that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nBut it means that reuse is supported for those widgets where it makes sense.  While widgets and activities are implemented in JavaScript and HTML, pages are written using JSON in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.", 
            "title": "Pages"
        }, 
        {
            "location": "/concepts/#layouts", 
            "text": "Layouts are skeleton HTML documents, which contain placeholders ( widget areas ) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nA layout can contain all the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.  For each  widget areas , the layout defines a width in grid columns, and widgets within these areas may not exceed their available number of columns.\nThe LaxarJS UiKit ships with  Bootstrap  to implement the grid layout in CSS.\nLike widgets, layouts are accompanied by CSS styles, for example to define a background color.  You might think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.", 
            "title": "Layouts"
        }, 
        {
            "location": "/concepts/#the-flow", 
            "text": "The flow defines  URL patterns  that may be used to navigate to the pages of an application, and  relations between pages .\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, it defines semantic relations between pages, such as what is considered the  next  page for a given page in the application.", 
            "title": "The Flow"
        }, 
        {
            "location": "/concepts/#themes", 
            "text": "Widgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.  The LaxarJS UiKit is based on Compass/SCSS to simplify the generation of user defined themes, but any way to generate Bootstrap-like CSS styles would be a valid way to create a theme.", 
            "title": "Themes"
        }, 
        {
            "location": "/concepts/#secondary-application-parts-under-the-hood", 
            "text": "", 
            "title": "Secondary Application Parts \u2013 Under the Hood"
        }, 
        {
            "location": "/concepts/#the-laxarjs-runtime", 
            "text": "The  runtime  handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.", 
            "title": "The LaxarJS Runtime"
        }, 
        {
            "location": "/concepts/#the-laxarjs-event-bus", 
            "text": "The  event bus  allows widgets to talk about common topics, without knowing  anything  about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or expect resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.", 
            "title": "The LaxarJS Event Bus"
        }, 
        {
            "location": "/concepts/#controls", 
            "text": "Controls  are (user-defined) HTML elements and attributes, integrated as AngularJS directives.\nThey are available to widgets as reusable UI components, and are styled using  Bootstrap 3.2  for interoperability and theme support.\nA useful set of controls to get started is provided by the  Angular UI Bootstrap  project.", 
            "title": "Controls"
        }, 
        {
            "location": "/concepts/#libraries", 
            "text": "Widgets may use  libraries  such as  jQuery  or  moment.js  just like in any JavaScript web application.\nLaxarJS currently provides a development workflow based on  grunt ,  bower , and  RequireJS  in order to install and load widgets with their assets as well as libraries, but other tool-chains are not out of the question.  To establish a useful common base vocabulary for the LaxarJS event bus, the  LaxarJS Patterns  library is provided.\nIt contains helpers that make it very easy for widgets to talk about user actions, common (REST) resources and boolean flags.", 
            "title": "Libraries"
        }, 
        {
            "location": "/why_laxar/", 
            "text": "Why LaxarJS?\n\n\nIt is difficult to build large applications using AngularJS.\nEven the creators \ntell you\n not to do that.\nUnfortunately your customer has not read that article and now you are trying to manage twenty controllers on the same page.\nWe therefore developed LaxarJS as a way to manage this complexity by splitting your application into isolated, manageable components, that may be reused in different contexts.\n\n\nWhy is it Difficult to Use AngularJS in Large Applications?\n\n\nAngularJS already tries to address some of the issues arising with larger applications such as end-to-end testability, encapsulation through directives and controller/view-separation.\nAlso there already exist \nbest practices\n on the organization of larger applications.\nHowever it is not obvious how to isolate and possibly even reuse larger blocks of functionality as experienced by the application user.\nAngularJS offers many ways to \ncouple\n your components, but few ways to reliably \ndecouple\n them:\n\n\n\n\nbinding to shared scope properties harms stability due to side effects\n\n\nshared state via services may quickly lead to similar problems\n\n\nbindings to directive controllers introduce dependencies to (usually synchronous) APIs\n\n\n$broadcast\n and \n$emit\n improve on the hard dependencies, but still enforce a specific DOM structure and may lead to timing issues during instantiation\n\n\n\n\nHow can we continue to leverage the benefits of AngularJS and offer better decoupling of (large) components?\n\n\nHow LaxarJS Addresses the Complexity Issue\n\n\nAt its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an \nevent bus\n that allows components (called \nwidgets\n) to communicate without knowing each other.\n\n\nThe Event Bus Decouples Widgets\n\n\nWidgets may \npublish\n application resources and \nsubscribe\n to changes to those resources without knowing about their mutual state.\nFor example in a web shop one widget might represent the shopping cart while another widget resembling the catalog would put articles into the shopping cart by publishing the respective events.\nEach of them has its own view of the \nsame\n shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.\n\n\nAfter a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a \ncheck out\n button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would \nreact\n to the event and possibly later publish its own event to indicate that the action was performed successfully.\n\n\nThere is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation, \nrelaxing\n the tight constraints and dependencies imposed by traditional programmatic APIs.\n\n\nThe Runtime Composes Widgets\n\n\nIn the application, widgets are connected to each other in a declarative fashion using JSON \npage definitions\n.\nThe LaxarJS \nruntime\n is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets, like HTML and CSS.\n\n\nIndividual pages are interrelated through a \nflow definition\n which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.\n\n\nThe Best of Both Worlds\n\n\nBuilding upon the thriving ecosystem of Web Standards and AngularJS components, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.\n\n\nIf this draws your interest, learn more about the LaxarJS \nkey concepts\n or jump in at the deep end by writing your first \nLaxarJS\n application.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#why-laxarjs", 
            "text": "It is difficult to build large applications using AngularJS.\nEven the creators  tell you  not to do that.\nUnfortunately your customer has not read that article and now you are trying to manage twenty controllers on the same page.\nWe therefore developed LaxarJS as a way to manage this complexity by splitting your application into isolated, manageable components, that may be reused in different contexts.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#why-is-it-difficult-to-use-angularjs-in-large-applications", 
            "text": "AngularJS already tries to address some of the issues arising with larger applications such as end-to-end testability, encapsulation through directives and controller/view-separation.\nAlso there already exist  best practices  on the organization of larger applications.\nHowever it is not obvious how to isolate and possibly even reuse larger blocks of functionality as experienced by the application user.\nAngularJS offers many ways to  couple  your components, but few ways to reliably  decouple  them:   binding to shared scope properties harms stability due to side effects  shared state via services may quickly lead to similar problems  bindings to directive controllers introduce dependencies to (usually synchronous) APIs  $broadcast  and  $emit  improve on the hard dependencies, but still enforce a specific DOM structure and may lead to timing issues during instantiation   How can we continue to leverage the benefits of AngularJS and offer better decoupling of (large) components?", 
            "title": "Why is it Difficult to Use AngularJS in Large Applications?"
        }, 
        {
            "location": "/why_laxar/#how-laxarjs-addresses-the-complexity-issue", 
            "text": "At its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an  event bus  that allows components (called  widgets ) to communicate without knowing each other.", 
            "title": "How LaxarJS Addresses the Complexity Issue"
        }, 
        {
            "location": "/why_laxar/#the-event-bus-decouples-widgets", 
            "text": "Widgets may  publish  application resources and  subscribe  to changes to those resources without knowing about their mutual state.\nFor example in a web shop one widget might represent the shopping cart while another widget resembling the catalog would put articles into the shopping cart by publishing the respective events.\nEach of them has its own view of the  same  shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.  After a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a  check out  button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would  react  to the event and possibly later publish its own event to indicate that the action was performed successfully.  There is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation,  relaxing  the tight constraints and dependencies imposed by traditional programmatic APIs.", 
            "title": "The Event Bus Decouples Widgets"
        }, 
        {
            "location": "/why_laxar/#the-runtime-composes-widgets", 
            "text": "In the application, widgets are connected to each other in a declarative fashion using JSON  page definitions .\nThe LaxarJS  runtime  is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets, like HTML and CSS.  Individual pages are interrelated through a  flow definition  which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.", 
            "title": "The Runtime Composes Widgets"
        }, 
        {
            "location": "/why_laxar/#the-best-of-both-worlds", 
            "text": "Building upon the thriving ecosystem of Web Standards and AngularJS components, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.  If this draws your interest, learn more about the LaxarJS  key concepts  or jump in at the deep end by writing your first  LaxarJS  application.", 
            "title": "The Best of Both Worlds"
        }, 
        {
            "location": "/api/", 
            "text": "API Documentation\n\n\n\n\nlaxar\n\n\n\n\nevent_bus\n\n\n\n\nevent_bus\n\n\n\n\ni18n\n\n\n\n\ni18n\n\n\n\n\nlogging\n\n\n\n\nlevel\n\n\nlog\n\n\nlog_context\n\n\nlogger\n\n\n\n\ntesting\n\n\n\n\nhttp_mock\n\n\njquery_mock\n\n\n\n\nutilities\n\n\n\n\narray\n\n\nassert\n\n\nobject\n\n\npath\n\n\nstorage\n\n\nstring", 
            "title": "Overview"
        }, 
        {
            "location": "/api/#api-documentation", 
            "text": "laxar", 
            "title": "API Documentation"
        }, 
        {
            "location": "/api/#event_bus", 
            "text": "event_bus", 
            "title": "event_bus"
        }, 
        {
            "location": "/api/#i18n", 
            "text": "i18n", 
            "title": "i18n"
        }, 
        {
            "location": "/api/#logging", 
            "text": "level  log  log_context  logger", 
            "title": "logging"
        }, 
        {
            "location": "/api/#testing", 
            "text": "http_mock  jquery_mock", 
            "title": "testing"
        }, 
        {
            "location": "/api/#utilities", 
            "text": "array  assert  object  path  storage  string", 
            "title": "utilities"
        }, 
        {
            "location": "/api/laxar/", 
            "text": "Documentation\n\n\nbootstrap( widgetModules )\n\n\nBootstraps AngularJS on the current \nwindow.document\n and sets up the LaxarJS portal. All AngularJS\nmodule names of widgets that are passed to this method will be passed to \nangular.bootstrap\n as initial\ndependencies, along with internal laxar modules. This is needed because AngularJS currently doesn't\nsupport lazy loading of modules. The \nportal_angular_dependencies\n grunt task of LaxarJS will collect\nall widgets reachable for the given \nflow.json\n, define them as dependencies of an amd module, that will\nreturn the names of their respective AngularJS modules. This list of module names can simply be passed\nto the \nboostrap\n method.\n\n\nParameters\n\n\n\n\nwidgetModules {String[]}\n: all AngularJS modules that should instantly be loaded (most probably the widgets)", 
            "title": "laxar.md"
        }, 
        {
            "location": "/api/laxar/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/laxar/#bootstrap-widgetmodules", 
            "text": "Bootstraps AngularJS on the current  window.document  and sets up the LaxarJS portal. All AngularJS\nmodule names of widgets that are passed to this method will be passed to  angular.bootstrap  as initial\ndependencies, along with internal laxar modules. This is needed because AngularJS currently doesn't\nsupport lazy loading of modules. The  portal_angular_dependencies  grunt task of LaxarJS will collect\nall widgets reachable for the given  flow.json , define them as dependencies of an amd module, that will\nreturn the names of their respective AngularJS modules. This list of module names can simply be passed\nto the  boostrap  method.", 
            "title": "bootstrap( widgetModules )"
        }, 
        {
            "location": "/api/laxar/#parameters", 
            "text": "widgetModules {String[]} : all AngularJS modules that should instantly be loaded (most probably the widgets)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/", 
            "text": "Documentation\n\n\nEventBus( [optionalConfiguration] )\n\n\nConstructor for an event bus.\n\n\nParameters\n\n\n\n\n\n\noptionalConfiguration\n {Object}\n: configuration for the event bus instance\n\n\n\n\npendingDidTimeout {Number}\n: the timeout in milliseconds used by {@link EventBus#publishAndGatherReplies}. Default is 120000ms\n\n\n\n\n\n\n\n\nEventBus#setErrorHandler( errorHandler )\n\n\nSets an handler for all errors that may occur during event processing. It receives an error message as\nfirst argument and a map with additional information on the problem as second argument. There may be\ninstances of \nError\n as values within the map.\nThe default error handler simply logs all issues to \nconsole.error\n or \nconsole.log\n if available.\n\n\nParameters\n\n\n\n\nerrorHandler {Function}\n: the error handler\n\n\n\n\nEventBus#setMediator( mediator )\n\n\nSets a mediator, that has the chance to alter events shortly before their delivery to the according\nsubscribers. Its sole argument is the complete list of queued events, that should be delivered during\nthe current JavaScript event loop. It then needs to return this optionally modified list again. Events\nmay be added or deleted at will, but the return type needs to be an array containing zero or more event-\nlike objects.\n\n\nParameters\n\n\n\n\nmediator {Function}\n: the mediator function\n\n\n\n\nEventBus#addInspector( inspector )\n\n\nAdds an inspector, that gets notified when certain actions within the event bus take place. Currently\nthis includes the following actions:\n\n\n\n\nsubscribe\n: a new subscriber registered for an event\n\n\npublish\n: an event is published but not yet delivered\n\n\ndeliver\n: an event is actually delivered to a subscriber\n\n\n\n\nAn inspector receives a map with the following properties:\n\n\n\n\naction\n: one of the actions from above\n\n\nsource\n: the origin of the \naction\n\n\ntarget\n: the name of the event subscriber (\ndeliver\n action)\n\n\nevent\n: the full name of the event or the subscribed event (\nsubscribe\n action)\n\n\neventObject\n: the published event item (\npublish\n action)\n\n\nsubscribedTo\n: the event, possibly with omissions, the subscriber subscribed to (\ndeliver\n action)\n\n\ncycleId\n: the id of the event cycle\n\n\n\n\nThe function returned by this method can be called to remove the inspector again and prevent it from\nbeing called for future event bus actions.\n\n\nParameters\n\n\n\n\ninspector {Function}\n: the inspector function to add\n\n\n\n\nReturns\n\n\n\n\n{Function}\n: a function to remove the inspector\n\n\n\n\nEventBus#subscribe( eventName, subscriber, [optionalOptions] )\n\n\nSubscribes to an event by name. An event name consists of so called \ntopics\n, where each topic is\nseparated from another by dots (\n.\n). If a topic is omitted, this is treated as a wildcard. Note that\ntwo dots in the middle or one dot at the beginning of an event name must remain, whereas a dot at the\nend may be omitted. As such every event name has an intrinsic wildcard at its end. For example these are\nall valid event names:\n\n\n\n\nsome.event\n: matches \nsome.event\n, \nsome.event.again\n\n\n.event\n: matches \nsome.event\n, \nany.event\n, \nany.event.again\n\n\nsome..event\n: matches \nsome.fancy.event\n, \nsome.special.event\n\n\n\n\nAdditionally subtopics are supported. A subtopic are fragments within a topic, separated from another by\nsimple dashes (\n-\n). Here only suffixes of subtopics may be omitted when subscribing. Thus subscribing\nto \nsome.event\n would match an event published with name \nsome.event-again\n or even\n\nsome.event-another.again\n.\n\n\nWhen an event is delivered, the subscriber function receives two arguments:\nThe first one is the event object as it was published. If \nclone\n yields \ntrue\n this is a simple deep\ncopy of the object (note that only properties passing a JSON-(de)serialization remain). If \nfalse\n the\nobject is frozen using \nObject.freeze\n recursively in browsers that support freezing. In Any other\nbrowser this is just an identity operation.\n\n\nThe second one is a meta object with these properties:\n\n\n\n\nunsubscribe\n: A function to directly unsubscribe the called subscriber from further events\n\n\nname\n: The name of the event as it actually was delivered (i.e. without wildcards).\n\n\ncycleId\n: The cycle the event was delivered in\n\n\nsender\n: The id of the event sender, may be \nnull\n.\n\n\ninitiator\n: The id of the initator of the cycle. Currently not implemented, thus always \nnull\n.\n\n\noptions\n: The options that were passed to \npublish\n or \npublishAndGatherReplies\n respectively.\n\n\n\n\nParameters\n\n\n\n\n\n\neventName {String}\n: the name of the event to subscribe to\n\n\n\n\n\n\nsubscriber {Function}\n: a function to call whenever an event matching the name is published\n\n\n\n\n\n\noptionalOptions\n {Object}\n: additional options for the subscribe action\n\n\n\n\n\n\nsubscriber {String}\n: the id of the subscriber. Default is \nnull\n\n\n\n\n\n\nclone {Boolean}\n: if \nfalse\n the event will be send frozen to the subscriber, otherwise it will receive a deep copy.\nDefault is \ntrue\n\n\n\n\n\n\n\n\n\n\nEventBus#unsubscribe( subscriber )\n\n\nRemoves all subscriptions of the given subscriber.\n\n\nParameters\n\n\n\n\nsubscriber {Function}\n: the function to unsubscribe\n\n\n\n\nEventBus#publish( eventName, [optionalEvent], [optionalOptions] )\n\n\nAsynchronously publishes an event on the event bus. The returned promise will be queued as soon as this\nevent is delivered and, if during delivery a new event was enqueued, resolved after that new event was\ndelivered. If no new event is queued during delivery of this event, the promise is instantly resolved.\nTo make it a bit clearer, lets assume we publish and thus enqueue an event at time \nt\n. It then will be\ndelivered at time \nt+1\n. At that precise moment the promise is enqueued to be resolved soon. We then\ndistinguish between two cases:\n\n\n\n\nAt time \nt+1\n no subscriber publishes (i.e. enqueues) an event: Thus there is no event in the same\n  cycle and the promise is also resolved at time \nt+1\n.\n\n\nAt least one subscriber publishes an event at time \nt+1\n: The promise is then scheduled to be resolved\n  as soon as this event is delivered at time \nt+2\n.\n\n\n\n\nThe implication of this is the following:\n\n\nWe have two collaborators, A and B. A listens to event b and b listens to event A.\nWhenever A publishes a and B than instantly (i.e. in the same event cycle of the JavaScript runtime its\nsubscriber function was called) \"responds\" by publishing b, b arrives at the subscriber function of A\nbefore the promise of A's publish action is resolved.\nIt is hence possible to observe possible effects of an event send by oneself,under the conditions\nmentioned above.\n\n\nParameters\n\n\n\n\n\n\neventName {String}\n: the name of the event to publish\n\n\n\n\n\n\noptionalEvent\n {Object}\n: the event to publish\n\n\n\n\n\n\noptionalOptions\n {Object}\n: additional options for the publish action\n\n\n\n\n\n\nsender {String}\n: the id of the event sender. Default is \nnull\n\n\n\n\n\n\ndeliverToSender {Boolean}\n: if \nfalse\n the event will not be send to subscribers whose subscriber name matches\n\noptionalOptions.sender\n, else all subscribers will receive the event. Default is \ntrue\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n{Promise}\n: the delivery promise\n\n\n\n\nEventBus#publishAndGatherReplies( eventName, [optionalEvent], [optionalOptions] )\n\n\nPublishes an event that follows the request-will-did pattern and awaits all replies. This pattern has\nevolved over time and is of great use when handling the asynchronous nature of event bus events.\n\n\nCertain rules need to be fulfilled: First the initiator needs to call this method with an event whose\nname has the suffix \nRequest\n, e.g. \ntakeActionRequest\n. All collaborators that want to react to this\nevent then either do so in the same event cycle by sending a \ndidTakeAction\n event or announce that they\nwill do something asynchronously by publishing a \nwillTakeAction\n event. In the latter case they need to\nbroadcast the end of their action by sending a \ndidTakeAction\n event. Note that for both events the same\nsender name needs to be given. Otherwise they cannot be mapped and the event bus doesn't know if all\nasynchronous replies were already received.\n\n\nAdditionally a timer is started using either the globally configured \npendingDidTimeout\n ms value or the\nvalue provided as option to this method. If that timer expires before all did\n events to all given will\n\nevents were received, the error handler is called to handle the incident and the promise is resolved as\nnormally.\n\n\nParameters\n\n\n\n\n\n\neventName {String}\n: the name of the event to publish\n\n\n\n\n\n\noptionalEvent\n {Object}\n: the event to publish\n\n\n\n\n\n\noptionalOptions\n {Object}\n: additional options for the publish action\n\n\n\n\n\n\nsender {String}\n: the id of the event sender. Default is \nnull\n\n\n\n\n\n\npendingDidTimeout {Number}\n: the timeout in milliseconds for pending did* events\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n{Promise}\n: the delivery promise. It receives a list of all collected \ndid*\n events and according meta information", 
            "title": "lib-event_bus-event_bus.md"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbus-optionalconfiguration", 
            "text": "Constructor for an event bus.", 
            "title": "EventBus( [optionalConfiguration] )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters", 
            "text": "optionalConfiguration  {Object} : configuration for the event bus instance   pendingDidTimeout {Number} : the timeout in milliseconds used by {@link EventBus#publishAndGatherReplies}. Default is 120000ms", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbusseterrorhandler-errorhandler", 
            "text": "Sets an handler for all errors that may occur during event processing. It receives an error message as\nfirst argument and a map with additional information on the problem as second argument. There may be\ninstances of  Error  as values within the map.\nThe default error handler simply logs all issues to  console.error  or  console.log  if available.", 
            "title": "EventBus#setErrorHandler( errorHandler )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters_1", 
            "text": "errorHandler {Function} : the error handler", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbussetmediator-mediator", 
            "text": "Sets a mediator, that has the chance to alter events shortly before their delivery to the according\nsubscribers. Its sole argument is the complete list of queued events, that should be delivered during\nthe current JavaScript event loop. It then needs to return this optionally modified list again. Events\nmay be added or deleted at will, but the return type needs to be an array containing zero or more event-\nlike objects.", 
            "title": "EventBus#setMediator( mediator )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters_2", 
            "text": "mediator {Function} : the mediator function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbusaddinspector-inspector", 
            "text": "Adds an inspector, that gets notified when certain actions within the event bus take place. Currently\nthis includes the following actions:   subscribe : a new subscriber registered for an event  publish : an event is published but not yet delivered  deliver : an event is actually delivered to a subscriber   An inspector receives a map with the following properties:   action : one of the actions from above  source : the origin of the  action  target : the name of the event subscriber ( deliver  action)  event : the full name of the event or the subscribed event ( subscribe  action)  eventObject : the published event item ( publish  action)  subscribedTo : the event, possibly with omissions, the subscriber subscribed to ( deliver  action)  cycleId : the id of the event cycle   The function returned by this method can be called to remove the inspector again and prevent it from\nbeing called for future event bus actions.", 
            "title": "EventBus#addInspector( inspector )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters_3", 
            "text": "inspector {Function} : the inspector function to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#returns", 
            "text": "{Function} : a function to remove the inspector", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbussubscribe-eventname-subscriber-optionaloptions", 
            "text": "Subscribes to an event by name. An event name consists of so called  topics , where each topic is\nseparated from another by dots ( . ). If a topic is omitted, this is treated as a wildcard. Note that\ntwo dots in the middle or one dot at the beginning of an event name must remain, whereas a dot at the\nend may be omitted. As such every event name has an intrinsic wildcard at its end. For example these are\nall valid event names:   some.event : matches  some.event ,  some.event.again  .event : matches  some.event ,  any.event ,  any.event.again  some..event : matches  some.fancy.event ,  some.special.event   Additionally subtopics are supported. A subtopic are fragments within a topic, separated from another by\nsimple dashes ( - ). Here only suffixes of subtopics may be omitted when subscribing. Thus subscribing\nto  some.event  would match an event published with name  some.event-again  or even some.event-another.again .  When an event is delivered, the subscriber function receives two arguments:\nThe first one is the event object as it was published. If  clone  yields  true  this is a simple deep\ncopy of the object (note that only properties passing a JSON-(de)serialization remain). If  false  the\nobject is frozen using  Object.freeze  recursively in browsers that support freezing. In Any other\nbrowser this is just an identity operation.  The second one is a meta object with these properties:   unsubscribe : A function to directly unsubscribe the called subscriber from further events  name : The name of the event as it actually was delivered (i.e. without wildcards).  cycleId : The cycle the event was delivered in  sender : The id of the event sender, may be  null .  initiator : The id of the initator of the cycle. Currently not implemented, thus always  null .  options : The options that were passed to  publish  or  publishAndGatherReplies  respectively.", 
            "title": "EventBus#subscribe( eventName, subscriber, [optionalOptions] )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters_4", 
            "text": "eventName {String} : the name of the event to subscribe to    subscriber {Function} : a function to call whenever an event matching the name is published    optionalOptions  {Object} : additional options for the subscribe action    subscriber {String} : the id of the subscriber. Default is  null    clone {Boolean} : if  false  the event will be send frozen to the subscriber, otherwise it will receive a deep copy.\nDefault is  true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbusunsubscribe-subscriber", 
            "text": "Removes all subscriptions of the given subscriber.", 
            "title": "EventBus#unsubscribe( subscriber )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters_5", 
            "text": "subscriber {Function} : the function to unsubscribe", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbuspublish-eventname-optionalevent-optionaloptions", 
            "text": "Asynchronously publishes an event on the event bus. The returned promise will be queued as soon as this\nevent is delivered and, if during delivery a new event was enqueued, resolved after that new event was\ndelivered. If no new event is queued during delivery of this event, the promise is instantly resolved.\nTo make it a bit clearer, lets assume we publish and thus enqueue an event at time  t . It then will be\ndelivered at time  t+1 . At that precise moment the promise is enqueued to be resolved soon. We then\ndistinguish between two cases:   At time  t+1  no subscriber publishes (i.e. enqueues) an event: Thus there is no event in the same\n  cycle and the promise is also resolved at time  t+1 .  At least one subscriber publishes an event at time  t+1 : The promise is then scheduled to be resolved\n  as soon as this event is delivered at time  t+2 .   The implication of this is the following:  We have two collaborators, A and B. A listens to event b and b listens to event A.\nWhenever A publishes a and B than instantly (i.e. in the same event cycle of the JavaScript runtime its\nsubscriber function was called) \"responds\" by publishing b, b arrives at the subscriber function of A\nbefore the promise of A's publish action is resolved.\nIt is hence possible to observe possible effects of an event send by oneself,under the conditions\nmentioned above.", 
            "title": "EventBus#publish( eventName, [optionalEvent], [optionalOptions] )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters_6", 
            "text": "eventName {String} : the name of the event to publish    optionalEvent  {Object} : the event to publish    optionalOptions  {Object} : additional options for the publish action    sender {String} : the id of the event sender. Default is  null    deliverToSender {Boolean} : if  false  the event will not be send to subscribers whose subscriber name matches optionalOptions.sender , else all subscribers will receive the event. Default is  true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#returns_1", 
            "text": "{Promise} : the delivery promise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#eventbuspublishandgatherreplies-eventname-optionalevent-optionaloptions", 
            "text": "Publishes an event that follows the request-will-did pattern and awaits all replies. This pattern has\nevolved over time and is of great use when handling the asynchronous nature of event bus events.  Certain rules need to be fulfilled: First the initiator needs to call this method with an event whose\nname has the suffix  Request , e.g.  takeActionRequest . All collaborators that want to react to this\nevent then either do so in the same event cycle by sending a  didTakeAction  event or announce that they\nwill do something asynchronously by publishing a  willTakeAction  event. In the latter case they need to\nbroadcast the end of their action by sending a  didTakeAction  event. Note that for both events the same\nsender name needs to be given. Otherwise they cannot be mapped and the event bus doesn't know if all\nasynchronous replies were already received.  Additionally a timer is started using either the globally configured  pendingDidTimeout  ms value or the\nvalue provided as option to this method. If that timer expires before all did  events to all given will \nevents were received, the error handler is called to handle the incident and the promise is resolved as\nnormally.", 
            "title": "EventBus#publishAndGatherReplies( eventName, [optionalEvent], [optionalOptions] )"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#parameters_7", 
            "text": "eventName {String} : the name of the event to publish    optionalEvent  {Object} : the event to publish    optionalOptions  {Object} : additional options for the publish action    sender {String} : the id of the event sender. Default is  null    pendingDidTimeout {Number} : the timeout in milliseconds for pending did* events", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/event_bus/event_bus/#returns_2", 
            "text": "{Promise} : the delivery promise. It receives a list of all collected  did*  events and according meta information", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/i18n/i18n/", 
            "text": "Documentation\n\n\nlocalize( languageTag, i18nValue )\n\n\nLocalize the given internationalized object using the given languageTag.\n\n\nParameters\n\n\n\n\n\n\nlanguageTag {String}\n: The languageTag to lookup a localization with\nMaybe undefined if the value is not i18n (app does not use i18n)\n\n\n\n\n\n\ni18nValue {*}\n: A possibly internationalized value:\n\n\n\n\nWhen passing a primitive value, it is returned as-is.\n\n\nWhen passing an object, the languageTag is used as a key within that object.\n\n\n\n\nReturns\n\n\n\n\n{*}\n: The localized value if found, \nundefined\n otherwise\n\n\n\n\nlocalizeRelaxed( languageTag, i18nValue )\n\n\nFor controls (such as a date-picker), we cannot anticipate all required language tags, as they may be\napp-specific. The relaxed localize behaves like localize if an exact localization is available.\nIf not, the language tag is successively generalized by stripping off the rightmost sub-tags until a\nlocalization is found.\nEventually, a fallback ('en') is used.\n\n\nParameters\n\n\n\n\n\n\nlanguageTag {String}\n: The languageTag to lookup a localization with.\nMaybe \nundefined\n if the value is not i18n (app does not use i18n)\n\n\n\n\n\n\ni18nValue {*}\n: A possibly internationalized value:\n\n\n\n\nWhen passing a primitive value, it is returned as-is.\n\n\nWhen passing an object, the \nlanguageTag\n is used as a key within that object.\n\n\n\n\nReturns\n\n\n\n\n{*}\n: The localized value if found, \nundefined\n otherwise\n\n\n\n\nlocalizer( languageTag )\n\n\nEncapsulate a given languageTag in a partially applied localize function.\n\n\nParameters\n\n\n\n\nlanguageTag {String}\n: The languageTag to lookup localizations with\n\n\n\n\nReturns\n\n\n\n\n{Function\n|\n}\n: A single-arg localize-Function, which always uses the given language-tag\nIt also has a .format-method, which can be used as a shortcut to\n\ntext.format( localize( x ), args )\n\n\n\n\nfunction Object() { [native code] }#format()\n\n\nShortcut to text.format, for simple chaining to the localizer.\n\n\nThese are equal:\n\n\n\n\ntext.format( i18n.localizer( tag )( i18nValue ), arg1, arg2 )\n\n\ni18n.localizer( tag ).format( i18nValue, arg1, arg2 )\n.\n\n\n\n\nlanguageTagFromI18n( String, )\n\n\nRetrieve the language tag of the current locale from an i18n model object, such as used on the scope.\n\n\nParameters\n\n\n\n\nString, {locale:}\n: An internationalization model, with reference to the currently active locale and a map from\nlocales to language tags.\n\n\n\n\nReturns\n\n\n\n\n{String}\n: The localized value if found, \nundefined\n otherwise", 
            "title": "lib-i18n-i18n.md"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#localize-languagetag-i18nvalue", 
            "text": "Localize the given internationalized object using the given languageTag.", 
            "title": "localize( languageTag, i18nValue )"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#parameters", 
            "text": "languageTag {String} : The languageTag to lookup a localization with\nMaybe undefined if the value is not i18n (app does not use i18n)    i18nValue {*} : A possibly internationalized value:   When passing a primitive value, it is returned as-is.  When passing an object, the languageTag is used as a key within that object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#returns", 
            "text": "{*} : The localized value if found,  undefined  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#localizerelaxed-languagetag-i18nvalue", 
            "text": "For controls (such as a date-picker), we cannot anticipate all required language tags, as they may be\napp-specific. The relaxed localize behaves like localize if an exact localization is available.\nIf not, the language tag is successively generalized by stripping off the rightmost sub-tags until a\nlocalization is found.\nEventually, a fallback ('en') is used.", 
            "title": "localizeRelaxed( languageTag, i18nValue )"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#parameters_1", 
            "text": "languageTag {String} : The languageTag to lookup a localization with.\nMaybe  undefined  if the value is not i18n (app does not use i18n)    i18nValue {*} : A possibly internationalized value:   When passing a primitive value, it is returned as-is.  When passing an object, the  languageTag  is used as a key within that object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#returns_1", 
            "text": "{*} : The localized value if found,  undefined  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#localizer-languagetag", 
            "text": "Encapsulate a given languageTag in a partially applied localize function.", 
            "title": "localizer( languageTag )"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#parameters_2", 
            "text": "languageTag {String} : The languageTag to lookup localizations with", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#returns_2", 
            "text": "{Function | } : A single-arg localize-Function, which always uses the given language-tag\nIt also has a .format-method, which can be used as a shortcut to text.format( localize( x ), args )", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#function-object-native-code-format", 
            "text": "Shortcut to text.format, for simple chaining to the localizer.  These are equal:   text.format( i18n.localizer( tag )( i18nValue ), arg1, arg2 )  i18n.localizer( tag ).format( i18nValue, arg1, arg2 ) .", 
            "title": "function Object() { [native code] }#format()"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#languagetagfromi18n-string", 
            "text": "Retrieve the language tag of the current locale from an i18n model object, such as used on the scope.", 
            "title": "languageTagFromI18n( String, )"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#parameters_3", 
            "text": "String, {locale:} : An internationalization model, with reference to the currently active locale and a map from\nlocales to language tags.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/i18n/i18n/#returns_3", 
            "text": "{String} : The localized value if found,  undefined  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/logging/level/", 
            "text": "Documentation", 
            "title": "lib-logging-level.md"
        }, 
        {
            "location": "/api/lib/logging/level/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/logging/log/", 
            "text": "Documentation", 
            "title": "lib-logging-log.md"
        }, 
        {
            "location": "/api/lib/logging/log/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/logging/log_context/", 
            "text": "Documentation\n\n\nLogContext()\n\n\nA context for a logger instance. Each context manages a stack of scopes where each scope can hold a\ndifferent set of log tags. Initially a context already has one scope on its stack, that cannot be left.\nTrying to do so will lead to an error. Thus each party entering a scope is also responsible for leaving\nthat scope again.\n\n\nLogContext#enterScope()\n\n\nEnters a new scope by pushing a scope object with an empty set of tags onto the stack.\n\n\nLogContext#leaveScope()\n\n\nLeaves the current scope and thus discards all tags set on this scope. An error is raised if an attempt\nto remove the root scope is made.\n\n\nLogContext#addTag( tag, value )\n\n\nAdds a value for a log tag to the scope entered last, i.e. the one on the top of the stack. If a tag\nis already known for the current scope, the value is appended to the existing one using a \n;\n as\nseparator. Note that no formatting of the value takes place and a non-string value will just have its\nappropriate \ntoString\n method called.\n\n\nParameters\n\n\n\n\n\n\ntag {String}\n: the id of the tag to add a value for\n\n\n\n\n\n\nvalue {String}\n: the value to add\n\n\n\n\n\n\nLogContext#gatherTags()\n\n\nReturns a map of all tags gathered from all scopes. If there are multiple values for the same tag across\ndifferent scopes, their values are concatenated using a \n;\n as separator.\n\n\nReturns\n\n\n\n\n{Object}\n: a mapping from tag to its value(s)", 
            "title": "lib-logging-log_context.md"
        }, 
        {
            "location": "/api/lib/logging/log_context/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/logging/log_context/#logcontext", 
            "text": "A context for a logger instance. Each context manages a stack of scopes where each scope can hold a\ndifferent set of log tags. Initially a context already has one scope on its stack, that cannot be left.\nTrying to do so will lead to an error. Thus each party entering a scope is also responsible for leaving\nthat scope again.", 
            "title": "LogContext()"
        }, 
        {
            "location": "/api/lib/logging/log_context/#logcontextenterscope", 
            "text": "Enters a new scope by pushing a scope object with an empty set of tags onto the stack.", 
            "title": "LogContext#enterScope()"
        }, 
        {
            "location": "/api/lib/logging/log_context/#logcontextleavescope", 
            "text": "Leaves the current scope and thus discards all tags set on this scope. An error is raised if an attempt\nto remove the root scope is made.", 
            "title": "LogContext#leaveScope()"
        }, 
        {
            "location": "/api/lib/logging/log_context/#logcontextaddtag-tag-value", 
            "text": "Adds a value for a log tag to the scope entered last, i.e. the one on the top of the stack. If a tag\nis already known for the current scope, the value is appended to the existing one using a  ;  as\nseparator. Note that no formatting of the value takes place and a non-string value will just have its\nappropriate  toString  method called.", 
            "title": "LogContext#addTag( tag, value )"
        }, 
        {
            "location": "/api/lib/logging/log_context/#parameters", 
            "text": "tag {String} : the id of the tag to add a value for    value {String} : the value to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/log_context/#logcontextgathertags", 
            "text": "Returns a map of all tags gathered from all scopes. If there are multiple values for the same tag across\ndifferent scopes, their values are concatenated using a  ;  as separator.", 
            "title": "LogContext#gatherTags()"
        }, 
        {
            "location": "/api/lib/logging/log_context/#returns", 
            "text": "{Object} : a mapping from tag to its value(s)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/logging/logger/", 
            "text": "Documentation\n\n\nLogger( options )\n\n\nConstructor for a logger.\n\n\nParameters\n\n\n\n\noptions {Object}\n: \n\n\n\n\nLogger#context {LogContext}\n\n\nThe log context of this logger.\n\n\nLogger#log( level, message, replacements )\n\n\nLogs a message. A message may contain placeholders in the form \n[#]\n where \n#\n ressembles the index\nwithin the list of \nreplacements\n. \nreplacements\n are incrementally counted starting at \n0\n. If the\nlog level is below the configured log level the message simply is discarded.\n\n\nParameters\n\n\n\n\n\n\nlevel {Number}\n: the level for this message\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#develop( message, replacements )\n\n\nLogs a message in log level \nDEVELOP\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#data( message, replacements )\n\n\nLogs a message in log level \nDATA\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#trace( message, replacements )\n\n\nLogs a message in log level \nTRACE\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#debug( message, replacements )\n\n\nLogs a message in log level \nDEBUG\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#info( message, replacements )\n\n\nLogs a message in log level \nINFO\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#warn( message, replacements )\n\n\nLogs a message in log level \nWARN\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#error( message, replacements )\n\n\nLogs a message in log level \nERROR\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#fatal( message, replacements )\n\n\nLogs a message in log level \nFATAL\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#statistics( message, replacements )\n\n\nLogs a message in log level \nSTATISTICS\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#account( message, replacements )\n\n\nLogs a message in log level \nACCOUNT\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#audit( message, replacements )\n\n\nLogs a message in log level \nAUDIT\n. See {@link #log} for further information.\n\n\nParameters\n\n\n\n\n\n\nmessage {String}\n: the message to log\n\n\n\n\n\n\nreplacements {...*}\n: objects that should replace placeholders within the message\n\n\n\n\n\n\nLogger#addLogChannel( channel )\n\n\nAdds a new channel to forward log messages to. A channel is called synchronously for every log message\nand is responsible to trigger something asynchronously itself if necessary. Each message is an object\nhaving the following properties:\n\n\n\n\nid\n: a unique, incremented id of the log message\n\n\nlevel\n: the log level of the message in string representation\n\n\ntext\n: the actual message that was logged\n\n\nreplacements\n: the raw list of replacements passed along the message\n\n\ntime\n: JavaScript Date instance when the message was logged\n\n\ntags\n: A map of all log tags currently set on the logger's scope\n\n\nsourceInfo\n: if supported, a map containing \nfile\n, \nline\n and \nchar\n where the logging took place\n\n\n\n\nParameters\n\n\n\n\nchannel {Function}\n: the log channel to add\n\n\n\n\nLogger#removeLogChannel( channel )\n\n\nRemoves a log channel and thus stops sending further messages to it.\n\n\nParameters\n\n\n\n\nchannel {Function}\n: the log channel to remove\n\n\n\n\nLogger#setLogThreshold( threshold )\n\n\nSets the threshold for log messages. Log messages with a lower level will be discarded upon logging.\n\n\nParameters\n\n\n\n\nthreshold {String|Number}\n: the numeric or the string value of the log level to use as threshold", 
            "title": "lib-logging-logger.md"
        }, 
        {
            "location": "/api/lib/logging/logger/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/logging/logger/#logger-options", 
            "text": "Constructor for a logger.", 
            "title": "Logger( options )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters", 
            "text": "options {Object} :", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggercontext-logcontext", 
            "text": "The log context of this logger.", 
            "title": "Logger#context {LogContext}"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerlog-level-message-replacements", 
            "text": "Logs a message. A message may contain placeholders in the form  [#]  where  #  ressembles the index\nwithin the list of  replacements .  replacements  are incrementally counted starting at  0 . If the\nlog level is below the configured log level the message simply is discarded.", 
            "title": "Logger#log( level, message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_1", 
            "text": "level {Number} : the level for this message    message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerdevelop-message-replacements", 
            "text": "Logs a message in log level  DEVELOP . See {@link #log} for further information.", 
            "title": "Logger#develop( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_2", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerdata-message-replacements", 
            "text": "Logs a message in log level  DATA . See {@link #log} for further information.", 
            "title": "Logger#data( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_3", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggertrace-message-replacements", 
            "text": "Logs a message in log level  TRACE . See {@link #log} for further information.", 
            "title": "Logger#trace( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_4", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerdebug-message-replacements", 
            "text": "Logs a message in log level  DEBUG . See {@link #log} for further information.", 
            "title": "Logger#debug( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_5", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerinfo-message-replacements", 
            "text": "Logs a message in log level  INFO . See {@link #log} for further information.", 
            "title": "Logger#info( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_6", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerwarn-message-replacements", 
            "text": "Logs a message in log level  WARN . See {@link #log} for further information.", 
            "title": "Logger#warn( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_7", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggererror-message-replacements", 
            "text": "Logs a message in log level  ERROR . See {@link #log} for further information.", 
            "title": "Logger#error( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_8", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerfatal-message-replacements", 
            "text": "Logs a message in log level  FATAL . See {@link #log} for further information.", 
            "title": "Logger#fatal( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_9", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerstatistics-message-replacements", 
            "text": "Logs a message in log level  STATISTICS . See {@link #log} for further information.", 
            "title": "Logger#statistics( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_10", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggeraccount-message-replacements", 
            "text": "Logs a message in log level  ACCOUNT . See {@link #log} for further information.", 
            "title": "Logger#account( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_11", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggeraudit-message-replacements", 
            "text": "Logs a message in log level  AUDIT . See {@link #log} for further information.", 
            "title": "Logger#audit( message, replacements )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_12", 
            "text": "message {String} : the message to log    replacements {...*} : objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggeraddlogchannel-channel", 
            "text": "Adds a new channel to forward log messages to. A channel is called synchronously for every log message\nand is responsible to trigger something asynchronously itself if necessary. Each message is an object\nhaving the following properties:   id : a unique, incremented id of the log message  level : the log level of the message in string representation  text : the actual message that was logged  replacements : the raw list of replacements passed along the message  time : JavaScript Date instance when the message was logged  tags : A map of all log tags currently set on the logger's scope  sourceInfo : if supported, a map containing  file ,  line  and  char  where the logging took place", 
            "title": "Logger#addLogChannel( channel )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_13", 
            "text": "channel {Function} : the log channel to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggerremovelogchannel-channel", 
            "text": "Removes a log channel and thus stops sending further messages to it.", 
            "title": "Logger#removeLogChannel( channel )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_14", 
            "text": "channel {Function} : the log channel to remove", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/logging/logger/#loggersetlogthreshold-threshold", 
            "text": "Sets the threshold for log messages. Log messages with a lower level will be discarded upon logging.", 
            "title": "Logger#setLogThreshold( threshold )"
        }, 
        {
            "location": "/api/lib/logging/logger/#parameters_15", 
            "text": "threshold {String|Number} : the numeric or the string value of the log level to use as threshold", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/testing/http_mock/", 
            "text": "Documentation\n\n\nHttpMock( q )\n\n\nA http client mock for unit tests. All mocked http methods (like e.g. \nget\n, \npost\n or \nput\n) are being\nspied on.\n\n\nParameters\n\n\n\n\nq {$q}\n: a promise library conforming to AngularJS's \n$q\n\n\n\n\nHttpMock#history {Array}\n\n\nA list of all http activities that took place so far. Each entry is a string consisting of the http\nmethod, a boolean flag indicating whether the request could be handled successfully, the requested\nurl and the time stamp of the request. Use this for debugging purposes in your test case only.\n\n\nHttpMock#responseMap {Object}\n\n\nA map of http methods to maps of urls to the mocked response objects.\n\n\nHttpMock#reset()\n\n\nResets the http mock by deleting all response mocks and the history recorded so far.\n\n\nHttpMock#setHttpResponse( method, uri, response )\n\n\nSets a new mocked http response. If a response for the given method / uri combination already exists,\nit will be overwritten. If \nresponse\n is \nnull\n, the entry is deleted. Use this method instead of\n\nrespondWith\n, if a more sophisticated response should be simulated or failed requests using a status\ncode of \n404\n for example.\n\n\nParameters\n\n\n\n\n\n\nmethod {String}\n: the http method to mock\n\n\n\n\n\n\nuri {String}\n: the uri to mock the response for\n\n\n\n\n\n\nresponse {Object}\n: the response object, probably with \nstatus\n, \ndata\n and \nheaders\n fields\n\n\n\n\n\n\nHttpMock#respondWith( [optionalMethod], uri, data )\n\n\nSets a response for a status code of \n200\n without any headers. Thus only the \ndata\n field must be\ngiven for the response. If \ndata\n is \nnull\n, the entry is deleted.\n\n\nParameters\n\n\n\n\n\n\noptionalMethod\n {String}\n: the http method to use. If omitted, \nGET\n is assumed\n\n\n\n\n\n\nuri {String}\n: the uri to mock the response for\n\n\n\n\n\n\ndata {Object}\n: the payload of the response", 
            "title": "lib-testing-http_mock.md"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#httpmock-q", 
            "text": "A http client mock for unit tests. All mocked http methods (like e.g.  get ,  post  or  put ) are being\nspied on.", 
            "title": "HttpMock( q )"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#parameters", 
            "text": "q {$q} : a promise library conforming to AngularJS's  $q", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#httpmockhistory-array", 
            "text": "A list of all http activities that took place so far. Each entry is a string consisting of the http\nmethod, a boolean flag indicating whether the request could be handled successfully, the requested\nurl and the time stamp of the request. Use this for debugging purposes in your test case only.", 
            "title": "HttpMock#history {Array}"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#httpmockresponsemap-object", 
            "text": "A map of http methods to maps of urls to the mocked response objects.", 
            "title": "HttpMock#responseMap {Object}"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#httpmockreset", 
            "text": "Resets the http mock by deleting all response mocks and the history recorded so far.", 
            "title": "HttpMock#reset()"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#httpmocksethttpresponse-method-uri-response", 
            "text": "Sets a new mocked http response. If a response for the given method / uri combination already exists,\nit will be overwritten. If  response  is  null , the entry is deleted. Use this method instead of respondWith , if a more sophisticated response should be simulated or failed requests using a status\ncode of  404  for example.", 
            "title": "HttpMock#setHttpResponse( method, uri, response )"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#parameters_1", 
            "text": "method {String} : the http method to mock    uri {String} : the uri to mock the response for    response {Object} : the response object, probably with  status ,  data  and  headers  fields", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#httpmockrespondwith-optionalmethod-uri-data", 
            "text": "Sets a response for a status code of  200  without any headers. Thus only the  data  field must be\ngiven for the response. If  data  is  null , the entry is deleted.", 
            "title": "HttpMock#respondWith( [optionalMethod], uri, data )"
        }, 
        {
            "location": "/api/lib/testing/http_mock/#parameters_2", 
            "text": "optionalMethod  {String} : the http method to use. If omitted,  GET  is assumed    uri {String} : the uri to mock the response for    data {Object} : the payload of the response", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/testing/jquery_mock/", 
            "text": "Documentation\n\n\nfunction Object() { [native code] }#mockResult( method, selectorOrElement, result )\n\n\nMocks the result to a jQuery method call. The mocked result is only returned if \nselectorOrElement\n\nmatches either the selector or the DOM element the jQuery object was created with.\n\n\nParameters\n\n\n\n\n\n\nmethod {String}\n: name of the method to mock the result for\n\n\n\n\n\n\nselectorOrElement {String|HTMLElement}\n: the selector or DOM element for which the mocked result is returned\n\n\n\n\n\n\nresult {*}\n: the mocked result\n\n\n\n\n\n\nfunction Object() { [native code] }#mockMethod( method, selectorOrElement, mockMethod )\n\n\nMocks the call to a jQuery method. The mock method is only called if \nselectorOrElement\n matches either\nthe selector or the DOM element the jQuery object was created with.\n\n\nParameters\n\n\n\n\n\n\nmethod {String}\n: name of the method to mock the result for\n\n\n\n\n\n\nselectorOrElement {String|HTMLElement}\n: the selector or DOM element for which the mocked result is returned\n\n\n\n\n\n\nmockMethod {Function}\n: the function to call instead of the original one\n\n\n\n\n\n\nfunction Object() { [native code] }#mockReset()\n\n\nRemoves all mocked methods and results from jQuery and reattaches the original implementations.", 
            "title": "lib-testing-jquery_mock.md"
        }, 
        {
            "location": "/api/lib/testing/jquery_mock/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/testing/jquery_mock/#function-object-native-code-mockresult-method-selectororelement-result", 
            "text": "Mocks the result to a jQuery method call. The mocked result is only returned if  selectorOrElement \nmatches either the selector or the DOM element the jQuery object was created with.", 
            "title": "function Object() { [native code] }#mockResult( method, selectorOrElement, result )"
        }, 
        {
            "location": "/api/lib/testing/jquery_mock/#parameters", 
            "text": "method {String} : name of the method to mock the result for    selectorOrElement {String|HTMLElement} : the selector or DOM element for which the mocked result is returned    result {*} : the mocked result", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/testing/jquery_mock/#function-object-native-code-mockmethod-method-selectororelement-mockmethod", 
            "text": "Mocks the call to a jQuery method. The mock method is only called if  selectorOrElement  matches either\nthe selector or the DOM element the jQuery object was created with.", 
            "title": "function Object() { [native code] }#mockMethod( method, selectorOrElement, mockMethod )"
        }, 
        {
            "location": "/api/lib/testing/jquery_mock/#parameters_1", 
            "text": "method {String} : name of the method to mock the result for    selectorOrElement {String|HTMLElement} : the selector or DOM element for which the mocked result is returned    mockMethod {Function} : the function to call instead of the original one", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/testing/jquery_mock/#function-object-native-code-mockreset", 
            "text": "Removes all mocked methods and results from jQuery and reattaches the original implementations.", 
            "title": "function Object() { [native code] }#mockReset()"
        }, 
        {
            "location": "/api/lib/testing/matchers/", 
            "text": "Documentation\n\n\nshint validthis:true", 
            "title": "lib-testing-matchers.md"
        }, 
        {
            "location": "/api/lib/testing/matchers/#documentation", 
            "text": "shint validthis:true", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/testing/portal_mocks/", 
            "text": "Documentation", 
            "title": "lib-testing-portal_mocks.md"
        }, 
        {
            "location": "/api/lib/testing/portal_mocks/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/testing/portal_mocks_angular/", 
            "text": "Documentation", 
            "title": "lib-testing-portal_mocks_angular.md"
        }, 
        {
            "location": "/api/lib/testing/portal_mocks_angular/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/testing/run_spec/", 
            "text": "Documentation", 
            "title": "lib-testing-run_spec.md"
        }, 
        {
            "location": "/api/lib/testing/run_spec/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/testing/testing/", 
            "text": "Documentation", 
            "title": "lib-testing-testing.md"
        }, 
        {
            "location": "/api/lib/testing/testing/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/utilities/array/", 
            "text": "Documentation\n\n\nremove( array, item )\n\n\nRemoves the first occurrence of \nitem\n in \narray\n from \narray\n and returns \ntrue\n if \nitem\n was\nremoved, or \nfalse\n if it wasn't\n\n\nParameters\n\n\n\n\n\n\narray {Array}\n: the array from which to remove the \nitem\n\n\n\n\n\n\nitem {Object}\n: the item to remove from \narray\n\n\n\n\n\n\nReturns\n\n\n\n\n{Boolean}\n: \ntrue\n if item was removed, \nfalse\n otherwise\n\n\n\n\nremoveAll( array, item )\n\n\nRemoves all occurrences of \nitem\n in \narray\n from \narray\n and returns \ntrue\n if at least one item was\nremoved, or \nfalse\n otherwise.\n\n\nParameters\n\n\n\n\n\n\narray {Array}\n: the array from which to remove the \nitem\n\n\n\n\n\n\nitem {Object}\n: the item to remove from \narray\n\n\n\n\n\n\nReturns\n\n\n\n\n{Boolean}\n: \ntrue\n if at least one item was removed, \nfalse\n otherwise", 
            "title": "lib-utilities-array.md"
        }, 
        {
            "location": "/api/lib/utilities/array/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/utilities/array/#remove-array-item", 
            "text": "Removes the first occurrence of  item  in  array  from  array  and returns  true  if  item  was\nremoved, or  false  if it wasn't", 
            "title": "remove( array, item )"
        }, 
        {
            "location": "/api/lib/utilities/array/#parameters", 
            "text": "array {Array} : the array from which to remove the  item    item {Object} : the item to remove from  array", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/array/#returns", 
            "text": "{Boolean} :  true  if item was removed,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/array/#removeall-array-item", 
            "text": "Removes all occurrences of  item  in  array  from  array  and returns  true  if at least one item was\nremoved, or  false  otherwise.", 
            "title": "removeAll( array, item )"
        }, 
        {
            "location": "/api/lib/utilities/array/#parameters_1", 
            "text": "array {Array} : the array from which to remove the  item    item {Object} : the item to remove from  array", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/array/#returns_1", 
            "text": "{Boolean} :  true  if at least one item was removed,  false  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/assert/", 
            "text": "Documentation\n\n\nAssertion( subject, [optionalDetails] )\n\n\nConstructor for Assert.\n\n\nParameters\n\n\n\n\n\n\nsubject {*}\n: the object assertions are made for\n\n\n\n\n\n\noptionalDetails\n {String}\n: details that should be printed whenever no details are given for an assertion method\n\n\n\n\n\n\nAssertion#isNotNull( [optionalDetails] )\n\n\nThrows an error if the subject is \nnull\n or \nundefined\n.\n\n\nParameters\n\n\n\n\noptionalDetails\n {String}\n: details to append to the error message\n\n\n\n\nReturns\n\n\n\n\n{Assertion}\n: this instance\n\n\n\n\nAssertion#hasType( type, [optionalDetails] )\n\n\nThrows an error if the subject is not of the given type. No error is thrown for \nnull\n or \nundefined\n.\n\n\nParameters\n\n\n\n\n\n\ntype {Function}\n: the expected type of the subject\n\n\n\n\n\n\noptionalDetails\n {String}\n: details to append to the error message\n\n\n\n\n\n\nReturns\n\n\n\n\n{Assertion}\n: this instance\n\n\n\n\nAssertion#hasProperty( property, [optionalDetails] )\n\n\nThrows an error if the subject is no object or the given property is not defined on it.\n\n\nParameters\n\n\n\n\n\n\nproperty {String}\n: the property that is expected for the subject\n\n\n\n\n\n\noptionalDetails\n {String}\n: details to append to the error message\n\n\n\n\n\n\nReturns\n\n\n\n\n{Assertion}\n: this instance\n\n\n\n\nassert( subject, [optionalDetails] )\n\n\nCreates and returns a mew \nAssertion\n instance for the given \nsubject\n.\n\n\nParameters\n\n\n\n\n\n\nsubject {*}\n: the object assertions are made for\n\n\n\n\n\n\noptionalDetails\n {String}\n: details that should be printed whenever no details are given for an assertion method\n\n\n\n\n\n\nReturns\n\n\n\n\n{Assertion}\n: the assertion instance\n\n\n\n\nfunction Object() { [native code] }#codeIsUnreachable( [optionalDetails] )\n\n\nMarks a code path as erroneous if reached by throwing an error.\n\n\nParameters\n\n\n\n\noptionalDetails\n {String}\n: details to append to the error message\n\n\n\n\nfunction Object() { [native code] }#state( expression, [optionalDetails] )\n\n\nThrows an error if the given expression is falsy.\n\n\nParameters\n\n\n\n\n\n\nexpression {*}\n: the expression to test for truthyness\n\n\n\n\n\n\noptionalDetails\n {String}\n: details to append to the error message", 
            "title": "lib-utilities-assert.md"
        }, 
        {
            "location": "/api/lib/utilities/assert/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/utilities/assert/#assertion-subject-optionaldetails", 
            "text": "Constructor for Assert.", 
            "title": "Assertion( subject, [optionalDetails] )"
        }, 
        {
            "location": "/api/lib/utilities/assert/#parameters", 
            "text": "subject {*} : the object assertions are made for    optionalDetails  {String} : details that should be printed whenever no details are given for an assertion method", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/assert/#assertionisnotnull-optionaldetails", 
            "text": "Throws an error if the subject is  null  or  undefined .", 
            "title": "Assertion#isNotNull( [optionalDetails] )"
        }, 
        {
            "location": "/api/lib/utilities/assert/#parameters_1", 
            "text": "optionalDetails  {String} : details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/assert/#returns", 
            "text": "{Assertion} : this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/assert/#assertionhastype-type-optionaldetails", 
            "text": "Throws an error if the subject is not of the given type. No error is thrown for  null  or  undefined .", 
            "title": "Assertion#hasType( type, [optionalDetails] )"
        }, 
        {
            "location": "/api/lib/utilities/assert/#parameters_2", 
            "text": "type {Function} : the expected type of the subject    optionalDetails  {String} : details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/assert/#returns_1", 
            "text": "{Assertion} : this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/assert/#assertionhasproperty-property-optionaldetails", 
            "text": "Throws an error if the subject is no object or the given property is not defined on it.", 
            "title": "Assertion#hasProperty( property, [optionalDetails] )"
        }, 
        {
            "location": "/api/lib/utilities/assert/#parameters_3", 
            "text": "property {String} : the property that is expected for the subject    optionalDetails  {String} : details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/assert/#returns_2", 
            "text": "{Assertion} : this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/assert/#assert-subject-optionaldetails", 
            "text": "Creates and returns a mew  Assertion  instance for the given  subject .", 
            "title": "assert( subject, [optionalDetails] )"
        }, 
        {
            "location": "/api/lib/utilities/assert/#parameters_4", 
            "text": "subject {*} : the object assertions are made for    optionalDetails  {String} : details that should be printed whenever no details are given for an assertion method", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/assert/#returns_3", 
            "text": "{Assertion} : the assertion instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/assert/#function-object-native-code-codeisunreachable-optionaldetails", 
            "text": "Marks a code path as erroneous if reached by throwing an error.", 
            "title": "function Object() { [native code] }#codeIsUnreachable( [optionalDetails] )"
        }, 
        {
            "location": "/api/lib/utilities/assert/#parameters_5", 
            "text": "optionalDetails  {String} : details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/assert/#function-object-native-code-state-expression-optionaldetails", 
            "text": "Throws an error if the given expression is falsy.", 
            "title": "function Object() { [native code] }#state( expression, [optionalDetails] )"
        }, 
        {
            "location": "/api/lib/utilities/assert/#parameters_6", 
            "text": "expression {*} : the expression to test for truthyness    optionalDetails  {String} : details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/", 
            "text": "Documentation\n\n\nextend( target, sources )\n\n\nCopies the properties from a set of source objects over to the target object. Properties of sources\nlater in the arguments list overwrite existing properties in the target and earlier source objects.\n\n\nParameters\n\n\n\n\n\n\ntarget {Object}\n: the target object to modify\n\n\n\n\n\n\nsources {...Object}\n: the source objects to copy over\n\n\n\n\n\n\nReturns\n\n\n\n\n{Object}\n: the modified target object\n\n\n\n\noptions( options, defaults )\n\n\nReturns all properties from \noptions\n with missing properties completed from \ndefaults\n. If \noptions\n\nis \nnull\n or \nundefined\n, an empty object is automatically created. \noptions\n and \ndefaults\n are not\nmodified.\n\n\nExample:\n\n\nobject\n.\noptions\n(\n \n{\n \nvalidate\n:\n \ntrue\n \n},\n \n{\n\n   \nvalidate\n:\n \nfalse\n,\n\n   \nhighlight\n:\n \ntrue\n\n\n}\n \n);\n\n\n// =\n\n\n// {\n\n\n//    validate: true,\n\n\n//    highlight: true\n\n\n// }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\noptions {Object}\n: the options object to use as source, may be \nnull\n or \nundefined\n\n\n\n\n\n\ndefaults {Object}\n: the defaults to take missing properties from\n\n\n\n\n\n\nReturns\n\n\n\n\n{Object}\n: the completed options object\n\n\n\n\nmap( object, mappingFunction )\n\n\nApplies a given function to each entry in the object and returns a new objects reflecting the changes\nmade by the mapping function. On each iteration the mapping function is passed the \nvalue\n, the \nkey\n\nand the complete \nobject\n as arguments. It then must return an array where the first item is the new\nkey and the second item the new value for the resulting object.\n\n\nExample:\n\n\nobject\n.\nmap\n(\n \n{\n \nx\n:\n \n1\n,\n \ny\n:\n \n2\n \n}\n \n,\n \nfunction\n(\n \nvalue\n,\n \nkey\n \n)\n \n{\n\n   \nreturn\n \n[\n \nkey\n,\n \nvalue\n \n+\n \n1\n \n];\n\n\n}\n \n);\n\n\n// =\n { x: 2, y: 3 }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\nobject {Object}\n: the object to run the mapping function on\n\n\n\n\n\n\nmappingFunction {Function}\n: the mapping function to run on each key-value pair\n\n\n\n\n\n\nReturns\n\n\n\n\n{Object}\n: a new object reflecting the results of the mapping\n\n\n\n\nforEach( object, iteratorFunction )\n\n\nIterates over the keys of an object and calls the given iterator function for each entry. On each\niteration the iterator function is passed the \nvalue\n, the \nkey\n and the complete \nobject\n as\narguments. If \nobject\n is an array, the native \nArray.prototype.forEach\n function is called and hence\nthe keys are the numeric indices of the array.\n\n\nParameters\n\n\n\n\n\n\nobject {Object}\n: the object to run the iterator function on\n\n\n\n\n\n\niteratorFunction {Function}\n: the iterator function to run on each key-value pair\n\n\n\n\n\n\npath( obj, path, [optionalDefault] )\n\n\nFinds a property in a nested object structure by a given path. A path is a string of keys, separated\nby a dot from each other, used to traverse that object and find the value of interest. An additional\ndefault is returned, if otherwise the value would yield \nundefined\n.\n\n\nParameters\n\n\n\n\n\n\nobj {Object}\n: the object to traverse\n\n\n\n\n\n\npath {String}\n: the path to search for\n\n\n\n\n\n\noptionalDefault\n {*}\n: the value to return instead of \nundefined\n if nothing is found\n\n\n\n\n\n\nReturns\n\n\n\n\n{*}\n: the value at the given path\n\n\n\n\nsetPath( obj, path, value )\n\n\nSets a property in a nested object structure at a given path to a given value. A path is a string of\nkeys, separated by a dot from each other, used to traverse that object and find the place where the\nvalue should be set. Any missing subtrees along the path are created.\n\n\nParameters\n\n\n\n\n\n\nobj {Object}\n: the object to modify\n\n\n\n\n\n\npath {String}\n: the path to set a value at\n\n\n\n\n\n\nvalue {*}\n: the value to set at the given path\n\n\n\n\n\n\nReturns\n\n\n\n\n{*}\n: the full object (for chaining)\n\n\n\n\ndeepClone( obj )\n\n\nReturns a deep clone of the given object. Note that the current implementation is intended to be\nused for simple object literals only. There is no guarantee that cloning objects instantiated via\nconstructor function works and cyclic references will lead to endless recursion.\n\n\nParameters\n\n\n\n\nobj {*}\n: the object to clone\n\n\n\n\nReturns\n\n\n\n\n{*}\n: the clone\n\n\n\n\ndeepFreeze( obj, [optionalRecursive] )\n\n\nFreezes an object, optionally recursively, in any browser capable of freezing objects. In any other\nbrowser this method simply returns its first value, i.e. is an identity operation.\n\n\nParameters\n\n\n\n\n\n\nobj {Object}\n: the object to freeze\n\n\n\n\n\n\noptionalRecursive\n {Boolean}\n: freezes recursively if \ntrue\n. Default is \nfalse\n\n\n\n\n\n\nReturns\n\n\n\n\n{Object}\n: the input (possibly) frozen", 
            "title": "lib-utilities-object.md"
        }, 
        {
            "location": "/api/lib/utilities/object/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/utilities/object/#extend-target-sources", 
            "text": "Copies the properties from a set of source objects over to the target object. Properties of sources\nlater in the arguments list overwrite existing properties in the target and earlier source objects.", 
            "title": "extend( target, sources )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters", 
            "text": "target {Object} : the target object to modify    sources {...Object} : the source objects to copy over", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#returns", 
            "text": "{Object} : the modified target object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/object/#options-options-defaults", 
            "text": "Returns all properties from  options  with missing properties completed from  defaults . If  options \nis  null  or  undefined , an empty object is automatically created.  options  and  defaults  are not\nmodified.  Example:  object . options (   {   validate :   true   },   { \n    validate :   false , \n    highlight :   true  }   );  // =  // {  //    validate: true,  //    highlight: true  // }", 
            "title": "options( options, defaults )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters_1", 
            "text": "options {Object} : the options object to use as source, may be  null  or  undefined    defaults {Object} : the defaults to take missing properties from", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#returns_1", 
            "text": "{Object} : the completed options object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/object/#map-object-mappingfunction", 
            "text": "Applies a given function to each entry in the object and returns a new objects reflecting the changes\nmade by the mapping function. On each iteration the mapping function is passed the  value , the  key \nand the complete  object  as arguments. It then must return an array where the first item is the new\nkey and the second item the new value for the resulting object.  Example:  object . map (   {   x :   1 ,   y :   2   }   ,   function (   value ,   key   )   { \n    return   [   key ,   value   +   1   ];  }   );  // =  { x: 2, y: 3 }", 
            "title": "map( object, mappingFunction )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters_2", 
            "text": "object {Object} : the object to run the mapping function on    mappingFunction {Function} : the mapping function to run on each key-value pair", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#returns_2", 
            "text": "{Object} : a new object reflecting the results of the mapping", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/object/#foreach-object-iteratorfunction", 
            "text": "Iterates over the keys of an object and calls the given iterator function for each entry. On each\niteration the iterator function is passed the  value , the  key  and the complete  object  as\narguments. If  object  is an array, the native  Array.prototype.forEach  function is called and hence\nthe keys are the numeric indices of the array.", 
            "title": "forEach( object, iteratorFunction )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters_3", 
            "text": "object {Object} : the object to run the iterator function on    iteratorFunction {Function} : the iterator function to run on each key-value pair", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#path-obj-path-optionaldefault", 
            "text": "Finds a property in a nested object structure by a given path. A path is a string of keys, separated\nby a dot from each other, used to traverse that object and find the value of interest. An additional\ndefault is returned, if otherwise the value would yield  undefined .", 
            "title": "path( obj, path, [optionalDefault] )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters_4", 
            "text": "obj {Object} : the object to traverse    path {String} : the path to search for    optionalDefault  {*} : the value to return instead of  undefined  if nothing is found", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#returns_3", 
            "text": "{*} : the value at the given path", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/object/#setpath-obj-path-value", 
            "text": "Sets a property in a nested object structure at a given path to a given value. A path is a string of\nkeys, separated by a dot from each other, used to traverse that object and find the place where the\nvalue should be set. Any missing subtrees along the path are created.", 
            "title": "setPath( obj, path, value )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters_5", 
            "text": "obj {Object} : the object to modify    path {String} : the path to set a value at    value {*} : the value to set at the given path", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#returns_4", 
            "text": "{*} : the full object (for chaining)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/object/#deepclone-obj", 
            "text": "Returns a deep clone of the given object. Note that the current implementation is intended to be\nused for simple object literals only. There is no guarantee that cloning objects instantiated via\nconstructor function works and cyclic references will lead to endless recursion.", 
            "title": "deepClone( obj )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters_6", 
            "text": "obj {*} : the object to clone", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#returns_5", 
            "text": "{*} : the clone", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/object/#deepfreeze-obj-optionalrecursive", 
            "text": "Freezes an object, optionally recursively, in any browser capable of freezing objects. In any other\nbrowser this method simply returns its first value, i.e. is an identity operation.", 
            "title": "deepFreeze( obj, [optionalRecursive] )"
        }, 
        {
            "location": "/api/lib/utilities/object/#parameters_7", 
            "text": "obj {Object} : the object to freeze    optionalRecursive  {Boolean} : freezes recursively if  true . Default is  false", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/object/#returns_6", 
            "text": "{Object} : the input (possibly) frozen", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/path/", 
            "text": "Documentation\n\n\njoin( fragments )\n\n\nJoins multiple path fragments into one normalized path. Absolute paths (paths starting with a \n/\n)\nand URLs will \"override\" any preceding paths. I.e. joining a URL or an absolute path to \nanything\n\nwill give the URL or absolute path.\n\n\nParameters\n\n\n\n\nfragments {...String}\n: the path fragments to join\n\n\n\n\nReturns\n\n\n\n\n{String}\n: the joined path\n\n\n\n\nnormalize( path )\n\n\nNormalizes a path. Removes multiple consecutive slashes, strips trailing slashes, removes \n.\n\nreferences and resolves \n..\n references (unless there are no preceding directories).\n\n\nParameters\n\n\n\n\npath {String}\n: the path to normalize\n\n\n\n\nReturns\n\n\n\n\n{String}\n: the normalized path\n\n\n\n\nrelative( from, path )\n\n\nCompute a relative path. Takes two absolute paths and returns a normalized path, relative to\nthe first path.\nNote that if both paths are URLs they are threated as if they were on the same host. I.e. this function\ndoes not complain when called with \nhttp://localhost/path\n and \nhttp://example.com/another/path\n.\n\n\nParameters\n\n\n\n\n\n\nfrom {String}\n: the starting point from which to determine the relative path\n\n\n\n\n\n\npath {String}\n: the target path\n\n\n\n\n\n\nReturns\n\n\n\n\n{String}\n: the relative path from \nfrom\n to \nto", 
            "title": "lib-utilities-path.md"
        }, 
        {
            "location": "/api/lib/utilities/path/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/utilities/path/#join-fragments", 
            "text": "Joins multiple path fragments into one normalized path. Absolute paths (paths starting with a  / )\nand URLs will \"override\" any preceding paths. I.e. joining a URL or an absolute path to  anything \nwill give the URL or absolute path.", 
            "title": "join( fragments )"
        }, 
        {
            "location": "/api/lib/utilities/path/#parameters", 
            "text": "fragments {...String} : the path fragments to join", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/path/#returns", 
            "text": "{String} : the joined path", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/path/#normalize-path", 
            "text": "Normalizes a path. Removes multiple consecutive slashes, strips trailing slashes, removes  . \nreferences and resolves  ..  references (unless there are no preceding directories).", 
            "title": "normalize( path )"
        }, 
        {
            "location": "/api/lib/utilities/path/#parameters_1", 
            "text": "path {String} : the path to normalize", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/path/#returns_1", 
            "text": "{String} : the normalized path", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/path/#relative-from-path", 
            "text": "Compute a relative path. Takes two absolute paths and returns a normalized path, relative to\nthe first path.\nNote that if both paths are URLs they are threated as if they were on the same host. I.e. this function\ndoes not complain when called with  http://localhost/path  and  http://example.com/another/path .", 
            "title": "relative( from, path )"
        }, 
        {
            "location": "/api/lib/utilities/path/#parameters_2", 
            "text": "from {String} : the starting point from which to determine the relative path    path {String} : the target path", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/path/#returns_2", 
            "text": "{String} : the relative path from  from  to  to", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/storage/", 
            "text": "Documentation\n\n\nStorage( backend, namespace )\n\n\nWrapper for \nwindow.localStorage\n or \nwindow.sessionStorage\n providing a more convenient api. In fact it\nprovides a K/V store where values can be any \"JSON-stringifyable\" object and stores them in a \nbackend\n\nonly supporting strings as values.\n\n\nParameters\n\n\n\n\n\n\nbackend {Object}\n: the K/V store, probably only accepting string values\n\n\n\n\n\n\nnamespace {String}\n: prefix for all keys for namespacing purposes\n\n\n\n\n\n\nStorage#getItem( key )\n\n\nRetrieves an item by key from the store. Note that the namespace the store was created with is prepended\nautomatically to the key.\n\n\nParameters\n\n\n\n\nkey {String}\n: the key of the item to retrieve\n\n\n\n\nReturns\n\n\n\n\n{*}\n: the value or \nnull\n if it doesn't exist in the store\n\n\n\n\nStorage#setItem( key, value )\n\n\nSets a value for a key. An existing value will be overwritten Note that the namespace the store was\ncreated with is prepended automatically to the key.\n\n\nParameters\n\n\n\n\n\n\nkey {String}\n: the key of the item to set\n\n\n\n\n\n\nvalue {*}\n: the new value to set\n\n\n\n\n\n\nStorage#removeItem( key )\n\n\nRemoves the value associated with \nkey\n from the store. Note that the namespace the store was created\nwith is prepended automatically to the key.\n\n\nParameters\n\n\n\n\nkey {String}\n: the key of the item to remove", 
            "title": "lib-utilities-storage.md"
        }, 
        {
            "location": "/api/lib/utilities/storage/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/utilities/storage/#storage-backend-namespace", 
            "text": "Wrapper for  window.localStorage  or  window.sessionStorage  providing a more convenient api. In fact it\nprovides a K/V store where values can be any \"JSON-stringifyable\" object and stores them in a  backend \nonly supporting strings as values.", 
            "title": "Storage( backend, namespace )"
        }, 
        {
            "location": "/api/lib/utilities/storage/#parameters", 
            "text": "backend {Object} : the K/V store, probably only accepting string values    namespace {String} : prefix for all keys for namespacing purposes", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/storage/#storagegetitem-key", 
            "text": "Retrieves an item by key from the store. Note that the namespace the store was created with is prepended\nautomatically to the key.", 
            "title": "Storage#getItem( key )"
        }, 
        {
            "location": "/api/lib/utilities/storage/#parameters_1", 
            "text": "key {String} : the key of the item to retrieve", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/storage/#returns", 
            "text": "{*} : the value or  null  if it doesn't exist in the store", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/storage/#storagesetitem-key-value", 
            "text": "Sets a value for a key. An existing value will be overwritten Note that the namespace the store was\ncreated with is prepended automatically to the key.", 
            "title": "Storage#setItem( key, value )"
        }, 
        {
            "location": "/api/lib/utilities/storage/#parameters_2", 
            "text": "key {String} : the key of the item to set    value {*} : the new value to set", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/storage/#storageremoveitem-key", 
            "text": "Removes the value associated with  key  from the store. Note that the namespace the store was created\nwith is prepended automatically to the key.", 
            "title": "Storage#removeItem( key )"
        }, 
        {
            "location": "/api/lib/utilities/storage/#parameters_3", 
            "text": "key {String} : the key of the item to remove", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/string/", 
            "text": "Documentation\n\n\nendsWith( inputString, suffix, [optionalIgnoreCase] )\n\n\nReturns \ntrue\n if the first argument ends with the string given as second argument.\n\n\nParameters\n\n\n\n\n\n\ninputString {String}\n: test subject\n\n\n\n\n\n\nsuffix {String}\n: string to find as tail\n\n\n\n\n\n\noptionalIgnoreCase\n {Boolean}\n: if \ntrue\n case insensitive matching takes place. Default is \nfalse\n\n\n\n\n\n\nReturns\n\n\n\n\n{Boolean}\n: \ntrue\n if suffix is the tail of inputString\n\n\n\n\nupperCaseToCamelCase( inputString, [removeAllUnderscores] )\n\n\nExpects an upper-case string with underscores and creates a new string in the corresponding camel-\ncase notation, i.e. \nSOME_NICE_FEATURE\n will be converted to \nsomeNiceFeature\n. If there are n\nsuccessive underscores for n \n 1, they will be transformed to n-1 underscores in the resulting string.\nThis can be prevented by passing the \nremoveAllUnderscores\n parameter as \ntrue\n. In that case the\nfirst character is always transformed to lower case.\n\n\nParameters\n\n\n\n\n\n\ninputString {String}\n: the uppercase-underscore string\n\n\n\n\n\n\nremoveAllUnderscores\n {Boolean}\n: if \ntrue\n all underscores will be removed\n\n\n\n\n\n\nReturns\n\n\n\n\n{String}\n: the string transformed to camelcase\n\n\n\n\nremoveUnderscoresFromCamelCase( inputString )\n\n\nRemoves all underscores from an otherwise camel-case formatted string. Those strings result e.g. from\ngenerated id's, where there is a prefix taken from a component type, combined with an generated id,\nseparated by \n__\n. Example: \naccordion_widget__id0\n will result in \naccordionWidgetId0\n\n\nParameters\n\n\n\n\ninputString {String}\n: the camel-case string to remove all underscores from\n\n\n\n\nReturns\n\n\n\n\n{String}\n: the camel case string with all underscores removed\n\n\n\n\ncapitalize( inputString )\n\n\nReturns a new string that equals the \ninputString\n where the first character is upper-case.\n\n\nParameters\n\n\n\n\ninputString {String}\n: the string to capitalize\n\n\n\n\nReturns\n\n\n\n\n{String}\n: the capitalized string\n\n\n\n\nformat( string, [optionalIndexedReplacements], [optionalNamedReplacements] )\n\n\n\nSubstitutes all unescaped placeholders in the given string for a given indexed or named value.\nA placeholder is written as a pair of brackets around the key of the placeholder. An example of an\nindexed placeholder is \n[0]\n and a named placeholder would look like this \n[replaceMe]\n. If no\nreplacement for a key exists, the placeholder will simply not be substituted.\n\n\nSome examples:\n\n\nstring\n.\nformat\n(\n \nHello [0], how do you like [1]?\n,\n \n[\n \nPeter\n,\n \nCheeseburgers\n \n]\n \n);\n\n\n// =\n \nHello Peter, how do you like Cheeseburgers?\n\n\n\n\n\n\nstring\n.\nformat\n(\n \nHello [name] and [partner], how do you like [0]?\n,\n \n[\n \nPizza\n \n],\n \n{\n\n   \nname\n:\n \nHans\n,\n\n   \npartner\n:\n \nRoswita\n\n\n}\n \n);\n\n\n// =\n \nHello Hans and Roswita, how do you like Pizza?\n\n\n\n\n\n\nIf a pair of brackets should not be treated as a placeholder, the opening bracket can simply be escaped\nby backslashes (thus to get an actual backslash, it needs to be written as double backslash):\n\n\nstring\n.\nformat\n(\n \nA [something] should eventually only have \\\\[x].\n,\n \n{\n\n   \nsomething\n:\n \nchecklist\n\n\n}\n \n);\n\n\n// =\n \nA checklist should eventually only have [x].\n\n\n\n\n\n\nA placeholder key can be any character string besides \n[\n, \n]\n and \n:\n to keep parsing simple and fast.\nUsing \n:\n as separator it is possible to provide a type specifier for string serialization. Known types\nare:\n\n\n\n\n%d\n / \n%i\n: Format the given numeric value as integer. Decimal places are removed.\n\n\n%f\n: Format the given numeric value as floating point value. This specifier supports precision as\n  sub-specifier (e.g. \n%.2f\n for 2 decimal places).\n\n\n%s\n: use simple string serialization using \ntoString\n.\n\n\n%o\n: Format complex objects using \nJSON.stringify\n.\n\n\n\n\nWhen no specifier is provided, by default \n%s\n is assumed.\n\n\nExample:\n\n\nstring\n.\nformat\n(\n \nHello [0:%s], you owe me [1:%.2f] euros.\n,\n \n[\n \nPeter\n,\n \n12.1243\n \n]\n \n);\n\n\n// =\n \nHello Peter, you owe me 12.12 euros.\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\nstring {String}\n: the string to replace placeholders in\n\n\n\n\n\n\noptionalIndexedReplacements\n {Array}\n: an optional array of indexed replacements\n\n\n\n\n\n\noptionalNamedReplacements\n {Object}\n: an optional map of named replacements\n\n\n\n\n\n\nReturns\n\n\n\n\n{String}\n: the string with placeholders substituted for their according replacements\n\n\n\n\ncreateFormatter( typeFormatters )\n\n\nCreates a new format function having the same api as \nformat()\n but without the default\nformatters for specifiers. Instead the specifiers of interest have to be passed to this function as map\nfrom specifier (omitting the \n%\n) to formatting function. A formatting function receives the value to\nformat and the sub-specifier (if any) as arguments. For example for the format specifier \n%.2f\n the\nsub-specifier would be \n.2\n where for \n%s\n it would simply be the empty string.\n\n\nExample:\n\n\nvar\n \nformat\n \n=\n \nstring\n.\ncreateFormatter\n(\n \n{\n\n   \nm\n:\n \nfunction\n(\n \nvalue\n \n)\n \n{\n\n      \nreturn\n \nvalue\n.\namount\n \n+\n \n \n \n+\n \nvalue\n.\ncurrency\n;\n\n   \n},\n\n   \np\n:\n \nfunction\n(\n \nvalue\n,\n \nsubSpecifier\n \n)\n \n{\n\n      \nreturn\n \nMath\n.\npow\n(\n \nvalue\n,\n \nparseInt\n(\n \nsubSpecifier\n,\n \n10\n \n)\n \n);\n\n   \n}\n\n\n}\n \n);\n\n\n\nformat\n(\n \nYou owe me [0:%m].\n,\n \n[\n \n{\n \namount\n:\n \n12\n,\n \ncurrency\n:\n \nEUR\n \n}\n \n]\n \n);\n\n\n// =\n \nYou owe me 12 EUR.\n\n\n\nformat\n(\n \n[0]^3 = [0:%3p]\n,\n \n[\n \n2\n \n]\n \n);\n\n\n// =\n \n2^3 = 8\n\n\n\n\n\n\nParameters\n\n\n\n\ntypeFormatters {Object}\n: map from format specifier (single letter without leading \n%\n) to formatting function\n\n\n\n\nReturns\n\n\n\n\n{Function}\n: A function having the same api as \nformat()", 
            "title": "lib-utilities-string.md"
        }, 
        {
            "location": "/api/lib/utilities/string/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/api/lib/utilities/string/#endswith-inputstring-suffix-optionalignorecase", 
            "text": "Returns  true  if the first argument ends with the string given as second argument.", 
            "title": "endsWith( inputString, suffix, [optionalIgnoreCase] )"
        }, 
        {
            "location": "/api/lib/utilities/string/#parameters", 
            "text": "inputString {String} : test subject    suffix {String} : string to find as tail    optionalIgnoreCase  {Boolean} : if  true  case insensitive matching takes place. Default is  false", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/string/#returns", 
            "text": "{Boolean} :  true  if suffix is the tail of inputString", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/string/#uppercasetocamelcase-inputstring-removeallunderscores", 
            "text": "Expects an upper-case string with underscores and creates a new string in the corresponding camel-\ncase notation, i.e.  SOME_NICE_FEATURE  will be converted to  someNiceFeature . If there are n\nsuccessive underscores for n   1, they will be transformed to n-1 underscores in the resulting string.\nThis can be prevented by passing the  removeAllUnderscores  parameter as  true . In that case the\nfirst character is always transformed to lower case.", 
            "title": "upperCaseToCamelCase( inputString, [removeAllUnderscores] )"
        }, 
        {
            "location": "/api/lib/utilities/string/#parameters_1", 
            "text": "inputString {String} : the uppercase-underscore string    removeAllUnderscores  {Boolean} : if  true  all underscores will be removed", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/string/#returns_1", 
            "text": "{String} : the string transformed to camelcase", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/string/#removeunderscoresfromcamelcase-inputstring", 
            "text": "Removes all underscores from an otherwise camel-case formatted string. Those strings result e.g. from\ngenerated id's, where there is a prefix taken from a component type, combined with an generated id,\nseparated by  __ . Example:  accordion_widget__id0  will result in  accordionWidgetId0", 
            "title": "removeUnderscoresFromCamelCase( inputString )"
        }, 
        {
            "location": "/api/lib/utilities/string/#parameters_2", 
            "text": "inputString {String} : the camel-case string to remove all underscores from", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/string/#returns_2", 
            "text": "{String} : the camel case string with all underscores removed", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/string/#capitalize-inputstring", 
            "text": "Returns a new string that equals the  inputString  where the first character is upper-case.", 
            "title": "capitalize( inputString )"
        }, 
        {
            "location": "/api/lib/utilities/string/#parameters_3", 
            "text": "inputString {String} : the string to capitalize", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/string/#returns_3", 
            "text": "{String} : the capitalized string", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/string/#format-string-optionalindexedreplacements-optionalnamedreplacements", 
            "text": "Substitutes all unescaped placeholders in the given string for a given indexed or named value.\nA placeholder is written as a pair of brackets around the key of the placeholder. An example of an\nindexed placeholder is  [0]  and a named placeholder would look like this  [replaceMe] . If no\nreplacement for a key exists, the placeholder will simply not be substituted.  Some examples:  string . format (   Hello [0], how do you like [1]? ,   [   Peter ,   Cheeseburgers   ]   );  // =   Hello Peter, how do you like Cheeseburgers?   string . format (   Hello [name] and [partner], how do you like [0]? ,   [   Pizza   ],   { \n    name :   Hans , \n    partner :   Roswita  }   );  // =   Hello Hans and Roswita, how do you like Pizza?   If a pair of brackets should not be treated as a placeholder, the opening bracket can simply be escaped\nby backslashes (thus to get an actual backslash, it needs to be written as double backslash):  string . format (   A [something] should eventually only have \\\\[x]. ,   { \n    something :   checklist  }   );  // =   A checklist should eventually only have [x].   A placeholder key can be any character string besides  [ ,  ]  and  :  to keep parsing simple and fast.\nUsing  :  as separator it is possible to provide a type specifier for string serialization. Known types\nare:   %d  /  %i : Format the given numeric value as integer. Decimal places are removed.  %f : Format the given numeric value as floating point value. This specifier supports precision as\n  sub-specifier (e.g.  %.2f  for 2 decimal places).  %s : use simple string serialization using  toString .  %o : Format complex objects using  JSON.stringify .   When no specifier is provided, by default  %s  is assumed.  Example:  string . format (   Hello [0:%s], you owe me [1:%.2f] euros. ,   [   Peter ,   12.1243   ]   );  // =   Hello Peter, you owe me 12.12 euros.", 
            "title": "format( string, [optionalIndexedReplacements], [optionalNamedReplacements] )"
        }, 
        {
            "location": "/api/lib/utilities/string/#parameters_4", 
            "text": "string {String} : the string to replace placeholders in    optionalIndexedReplacements  {Array} : an optional array of indexed replacements    optionalNamedReplacements  {Object} : an optional map of named replacements", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/string/#returns_4", 
            "text": "{String} : the string with placeholders substituted for their according replacements", 
            "title": "Returns"
        }, 
        {
            "location": "/api/lib/utilities/string/#createformatter-typeformatters", 
            "text": "Creates a new format function having the same api as  format()  but without the default\nformatters for specifiers. Instead the specifiers of interest have to be passed to this function as map\nfrom specifier (omitting the  % ) to formatting function. A formatting function receives the value to\nformat and the sub-specifier (if any) as arguments. For example for the format specifier  %.2f  the\nsub-specifier would be  .2  where for  %s  it would simply be the empty string.  Example:  var   format   =   string . createFormatter (   { \n    m :   function (   value   )   { \n       return   value . amount   +       +   value . currency ; \n    }, \n    p :   function (   value ,   subSpecifier   )   { \n       return   Math . pow (   value ,   parseInt (   subSpecifier ,   10   )   ); \n    }  }   );  format (   You owe me [0:%m]. ,   [   {   amount :   12 ,   currency :   EUR   }   ]   );  // =   You owe me 12 EUR.  format (   [0]^3 = [0:%3p] ,   [   2   ]   );  // =   2^3 = 8", 
            "title": "createFormatter( typeFormatters )"
        }, 
        {
            "location": "/api/lib/utilities/string/#parameters_5", 
            "text": "typeFormatters {Object} : map from format specifier (single letter without leading  % ) to formatting function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/lib/utilities/string/#returns_5", 
            "text": "{Function} : A function having the same api as  format()", 
            "title": "Returns"
        }, 
        {
            "location": "/manuals/", 
            "text": "\u00ab return to the manuals\n\n\nManuals\n\n\nBefore starting with the manuals, make sure that you know \nwhat LaxarJS is about\n, and that you are familiar with the \ncore concepts\n.\n\n\nBasic Manuals\n\n\n\n\nWidgets and Activities\n\n\n\n\nLearn about the building blocks of a LaxarJS application.\n\n\n\n\n\n\nWriting Pages\n\n\nA step-by-step introduction to writing layouts and pages for a LaxarJS application.\n\n\n\n\n\n\nFlow and Places\n\n\nCreating a flow through the pages and make the addressable as places.\n\n\n\n\n\n\nEvents\n\n\nHow to communicate between widgets using topics on the event bus.\n\n\n\n\n\n\nProviding Controls\n\n\nHow to create reusable, interactive elements that support themes.\n\n\n\n\n\n\nAdvanced Manuals\n\n\n\n\n\n\nWriting Compositions\n\n\nWhen simple pages are not enough.\n\n\n\n\n\n\nConfiguration\n\n\nDocuments the LaxarJS configuration API which can be used to configure widgets, and the builtin configuration options.\n\n\n\n\n\n\nInternationalization (i18n)\n\n\nExplains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Before starting with the manuals, make sure that you know  what LaxarJS is about , and that you are familiar with the  core concepts .", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/#basic-manuals", 
            "text": "Widgets and Activities   Learn about the building blocks of a LaxarJS application.    Writing Pages  A step-by-step introduction to writing layouts and pages for a LaxarJS application.    Flow and Places  Creating a flow through the pages and make the addressable as places.    Events  How to communicate between widgets using topics on the event bus.    Providing Controls  How to create reusable, interactive elements that support themes.", 
            "title": "Basic Manuals"
        }, 
        {
            "location": "/manuals/#advanced-manuals", 
            "text": "Writing Compositions  When simple pages are not enough.    Configuration  Documents the LaxarJS configuration API which can be used to configure widgets, and the builtin configuration options.    Internationalization (i18n)  Explains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.", 
            "title": "Advanced Manuals"
        }, 
        {
            "location": "/manuals/providing_controls/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nControls and Libraries\n\n\nIn LaxarJS, any non-trivial HTML element, \nHTML5 Web Component\n or \nAngularJS directive\n is considered a \ncontrol\n.\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.\nTo provide their business logic, widgets and activities often depend on libraries, which might be created by third parties or simply be used to share common functionality.\nIn the latter case, be sure not to couple your controllers to tightly, e.g. the shared libraries should not allow to share state.\n\n\nHere are some examples of controls:\n\n\n* a select box\n* a date picker\n* an accordion control\n* a tab control\n\n\n\n\n\nLaxarJS helps when developing a custom control by managing its AngularJS modules, as well as its CSS and HTML assets for you.\nIf (and only if) you \nuse\n a control in one or more widgets, LaxarJS will load its CSS according to the current \ntheme\n, just like with widgets and templates.\nWhen you remove the control from your widget, or the widget from your page, its code and asset will no longer increase your application footprint. \nThis allows you to create and distribute large libraries of controls without fear of application bloat.\n\n\nCreating or Integrating a Control\n\n\nWhile HTML5 Web Components are very interesting, the current browser support is limited.\nFor this reason, LaxarJS currently only covers the creation of a control as an AngularJS directive.\n\n\nOf course you can still use Web Components, jQuery UI or any other way of creating controls in your widgets, but LaxarJS currently will not manage assets for them.\nThe recommended way is therefore to wrap such controls in an AngularJS directive.\nThis can be done either for a single widget by simply adding a directive to its module, or following the steps below. \n\n\nCreating a Control using an AngularJS directive\n\n\nLaxarJS does not care whether your control is installed through bower or if it is a part of your project, as long as it has a \nRequireJS path\n configured.\nBasic familiarity with \nRequireJS\n should be enough to create your own controls.\nWhen writing a control to integrate third party libraries that do not support RequireJS, this can sometimes be tricky.  \n\n\nLet us try to create a control that displays a digital clock to the user.\n\n\nRequireJS Path\n\n\nFirst, choose a location for your controls, such as \nincludes/lib/my_controls\n.\nIn the require configuration, you need add the path to your new controls library:\n\n\npaths\n:\n \n{\n\n   \n// ...\n\n   \nmy_controls\n:\n \n../includes/lib/my_controls\n\n\n}\n\n\n\n\n\n\nThis assumes that \nbower_components\n is your RequireJS \nbaseUrl\n.\nIf it is something else, you will need to change the path accordingly (such as \nlib/my_controls\n if using \nincludes/\n as base URL).\n\n\nNow the \nrequire-path\n for the clock-control is \nmy_controls/clock\n.\n\n\nAngularJS Directive\n\n\nNow let us create the AngularJS module for the control, in \nincludes/lib/my_controls/clock.js\n:\n\n\ndefine\n(\n \n[\n \nangular\n,\n \ntext!my_controls/clock/clock.html\n \n],\n \nfunction\n(\n \nng\n,\n \nclockTemplate\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \nvar\n \nmodule\n \n=\n \nng\n.\nmodule\n(\n \nmy_controls.clock\n,\n \n[]\n \n);\n\n\n   \nmodule\n.\nfilter\n(\n \nmyPad\n,\n \nfunction\n()\n \n{\n\n      \nreturn\n \nfunction\n(\n \nnumber\n \n)\n \n{\n\n         \nreturn\n \n(\n \nnumber\n \n \n10\n \n?\n \n0\n \n:\n \n \n)\n \n+\n \nnumber\n;\n\n      \n}\n\n   \n}\n \n);\n\n\n   \nreturn\n \nmodule\n.\ndirective\n(\n \nmyClock\n,\n \n[\n \n$timeout\n,\n \nfunction\n(\n \n$timeout\n \n)\n \n{\n\n      \nreturn\n \n{\n\n         \nrestrict\n:\n \nE\n,\n\n         \ntemplate\n:\n \nclockTemplate\n,\n\n         \nlink\n:\n \nfunction\n(\n \n$scope\n \n)\n \n{\n\n            \ntick\n();\n\n            \nfunction\n \ntick\n()\n \n{\n\n               \n$scope\n.\ndate\n \n=\n \nnew\n \nDate\n();\n\n               \n$timeout\n(\n \ntick\n,\n \n1000\n \n);\n\n            \n}\n\n         \n}\n\n      \n};\n\n\n   \n}\n \n]\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\nFor the directive, we use a prefix, to avoid collisions with future HTML elements and other controls.\nMake sure to return the AngularJS module as shown here, so that LaxarJS can use it when bootstrapping your application.\n\n\nAngularJS Template\n\n\nLet us create a simple template at \nincludes/lib/my_controls/clock/clock.html\n.\n\n\nspan\n \nclass=\nmy-clock\n\n   {{ date.getHours() | myPad }}:{{ date.getMinutes() | myPad }}:{{ date.getSeconds() | myPad }}\n\n/span\n\n\n\n\n\n\nUse a prefix for the custom CSS class, to avoid collision with other controls and libraries.\nOf course, for maximum performance you might want to move the filtering to the \ntick\n function, but this should be fine as an example.\n\n\nThe CSS Stylesheet\n\n\nTo automatically load your CSS depending on the theme, it has to be placed into a sub-directory \ndefault.theme/css\n of your require path and it has to use the same file name as the controller file.\nIn case of the clock, the correct path is \nincludes/lib/my_controls/clock/default.theme/clock.css\n.\n\n\n.my-clock\n \n{\n\n   \nfont-family\n:\n \nTimes New Roman\n,\n \nserif\n;\n\n   \nfont-weight\n:\n \nbold\n;\n\n   \nfont-size\n:\n \n36px\n;\n\n   \nborder\n:\n \n3px\n \ndouble\n \nblack\n;\n\n   \npadding\n:\n \n3px\n;\n\n\n}\n\n\n\n\n\n\nUsing a Control from a Widget\n\n\nAny widget that uses our clock should declare its dependency using \ncontrols\n entry in its \nwidget.json\n:\n\n\ncontrols\n:\n \n[\n \nmy_controls/clock\n \n]\n,\n\n\n\n\n\n\nThis allows the runtime to load the RequireJS module and to register its AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application. \n\n\nTo actually get the control onto the screen, you have to reference it from your widget template:\n\n\nh3\nMy Widget, now with 100% more 24h-clock!\n/h3\n\n\nmy-clock\n/my-clock\n\n\n\n\n\n\nAfter adding your widget to a page, you may inspect your timepiece in the browser:\n\n\n\n\nCreating or Integrating a Library\n\n\nTODO", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#controls-and-libraries", 
            "text": "In LaxarJS, any non-trivial HTML element,  HTML5 Web Component  or  AngularJS directive  is considered a  control .\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.\nTo provide their business logic, widgets and activities often depend on libraries, which might be created by third parties or simply be used to share common functionality.\nIn the latter case, be sure not to couple your controllers to tightly, e.g. the shared libraries should not allow to share state.  Here are some examples of controls:  * a select box\n* a date picker\n* an accordion control\n* a tab control  LaxarJS helps when developing a custom control by managing its AngularJS modules, as well as its CSS and HTML assets for you.\nIf (and only if) you  use  a control in one or more widgets, LaxarJS will load its CSS according to the current  theme , just like with widgets and templates.\nWhen you remove the control from your widget, or the widget from your page, its code and asset will no longer increase your application footprint. \nThis allows you to create and distribute large libraries of controls without fear of application bloat.", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-control", 
            "text": "While HTML5 Web Components are very interesting, the current browser support is limited.\nFor this reason, LaxarJS currently only covers the creation of a control as an AngularJS directive.  Of course you can still use Web Components, jQuery UI or any other way of creating controls in your widgets, but LaxarJS currently will not manage assets for them.\nThe recommended way is therefore to wrap such controls in an AngularJS directive.\nThis can be done either for a single widget by simply adding a directive to its module, or following the steps below.", 
            "title": "Creating or Integrating a Control"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-a-control-using-an-angularjs-directive", 
            "text": "LaxarJS does not care whether your control is installed through bower or if it is a part of your project, as long as it has a  RequireJS path  configured.\nBasic familiarity with  RequireJS  should be enough to create your own controls.\nWhen writing a control to integrate third party libraries that do not support RequireJS, this can sometimes be tricky.    Let us try to create a control that displays a digital clock to the user.", 
            "title": "Creating a Control using an AngularJS directive"
        }, 
        {
            "location": "/manuals/providing_controls/#requirejs-path", 
            "text": "First, choose a location for your controls, such as  includes/lib/my_controls .\nIn the require configuration, you need add the path to your new controls library:  paths :   { \n    // ... \n    my_controls :   ../includes/lib/my_controls  }   This assumes that  bower_components  is your RequireJS  baseUrl .\nIf it is something else, you will need to change the path accordingly (such as  lib/my_controls  if using  includes/  as base URL).  Now the  require-path  for the clock-control is  my_controls/clock .", 
            "title": "RequireJS Path"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-directive", 
            "text": "Now let us create the AngularJS module for the control, in  includes/lib/my_controls/clock.js :  define (   [   angular ,   text!my_controls/clock/clock.html   ],   function (   ng ,   clockTemplate   )   { \n    use strict ; \n\n    var   module   =   ng . module (   my_controls.clock ,   []   ); \n\n    module . filter (   myPad ,   function ()   { \n       return   function (   number   )   { \n          return   (   number     10   ?   0   :     )   +   number ; \n       } \n    }   ); \n\n    return   module . directive (   myClock ,   [   $timeout ,   function (   $timeout   )   { \n       return   { \n          restrict :   E , \n          template :   clockTemplate , \n          link :   function (   $scope   )   { \n             tick (); \n             function   tick ()   { \n                $scope . date   =   new   Date (); \n                $timeout (   tick ,   1000   ); \n             } \n          } \n       }; \n\n    }   ]   );  }   );   For the directive, we use a prefix, to avoid collisions with future HTML elements and other controls.\nMake sure to return the AngularJS module as shown here, so that LaxarJS can use it when bootstrapping your application.", 
            "title": "AngularJS Directive"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-template", 
            "text": "Let us create a simple template at  includes/lib/my_controls/clock/clock.html .  span   class= my-clock \n   {{ date.getHours() | myPad }}:{{ date.getMinutes() | myPad }}:{{ date.getSeconds() | myPad }} /span   Use a prefix for the custom CSS class, to avoid collision with other controls and libraries.\nOf course, for maximum performance you might want to move the filtering to the  tick  function, but this should be fine as an example.", 
            "title": "AngularJS Template"
        }, 
        {
            "location": "/manuals/providing_controls/#the-css-stylesheet", 
            "text": "To automatically load your CSS depending on the theme, it has to be placed into a sub-directory  default.theme/css  of your require path and it has to use the same file name as the controller file.\nIn case of the clock, the correct path is  includes/lib/my_controls/clock/default.theme/clock.css .  .my-clock   { \n    font-family :   Times New Roman ,   serif ; \n    font-weight :   bold ; \n    font-size :   36px ; \n    border :   3px   double   black ; \n    padding :   3px ;  }", 
            "title": "The CSS Stylesheet"
        }, 
        {
            "location": "/manuals/providing_controls/#using-a-control-from-a-widget", 
            "text": "Any widget that uses our clock should declare its dependency using  controls  entry in its  widget.json :  controls :   [   my_controls/clock   ] ,   This allows the runtime to load the RequireJS module and to register its AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application.   To actually get the control onto the screen, you have to reference it from your widget template:  h3 My Widget, now with 100% more 24h-clock! /h3  my-clock /my-clock   After adding your widget to a page, you may inspect your timepiece in the browser:", 
            "title": "Using a Control from a Widget"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-library", 
            "text": "TODO", 
            "title": "Creating or Integrating a Library"
        }, 
        {
            "location": "/manuals/creating_themes/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\n\n\nCreating Themes\n\n\nTODO", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#creating-themes", 
            "text": "TODO", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/events/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nEvents and Publish-Subscribe\n\n\nThe key concept that distinguishes LaxarJS applications from other AngularJS applications is the \npublish-subscribe\n (or \npub/sub\n) architecture.\nIt helps to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).\n\n\nLaxarJS consistently uses the term \nevents\n rather than \nmessages\n, to point out two key aspects of its pub/sub-architecture:\n * events convey information about \nwhat happened\n (rather than \nwho is receiver\n)\n * delivery is always \nasynchronous\n (using an \nevent loop\n)\n\n\nFor these reasons, you may also think of this pattern as a variation on the \nhollywood principle\n (\"Don't call us, we'll call you\").\n\n\nFor efficient processing, LaxarJS ties into the AngularJS \n$digest\n-cycle.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.\n\n\nThe Event Bus\n\n\nAll events are published to and delivered by the \nevent bus\n:\nThe event bus manages \nname-based\n (or \ntopic-based\n) \nevent subscriptions\n for all interested widgets and activities (the \nsubscribers\n):\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.\n\n\nEach event has a \nname\n containing a summary of what happened, and a \npayload\n carrying additional information.\n\n\nEvent Names\n\n\nEvent names summarize \nwhat happened\n, possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.\n\n\nAn event name is a string, formed by a sequence of one or more \ntopics\n that are separated by \n.\n (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more \nsub-topics\n separated by \n-\n (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by\n\n\n* _either_ an upper case letter followed by a sequence of upper case letters and numbers\n* _or_ a lower case letter followed by a sequence of mixed case letters and numbers\n\n\n\n\n\nThese rules also exist as a formal \ngrammar\n for thorough people.\n\n\nThese are examples for \nvalid\n event names:\n\n\n* `didReplace.myShoppingCart`\n* `takeActionRequest.searchArticles`\n* `didTakeAction.searchArticles.SUCCESS`\n* `willEndLifecycle`\n* `didValidate.popup-user2`\n\n\n\n\n\nInvalid\n event names include:\n\n\n* `DidReplace.myShoppingCart`: _invalid,_ first topic starts upper case but contains lower case letters\n* `.searchArticles.SUCCESS`: _invalid,_ empty topic is not allowed\n* `didUpdate.1up`: _invalid_, topic must not start with a number\n\n\n\n\n\nNaming Best Practices and Event Patterns\n\n\nGood event names start with a very general \nverb-based first topic\n, broadly describing \nwhat\n happened.\nThat topic is often followed by a more specific \nobject-based second topic\n, describing \nwhere\n (or \nto what\n) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event \ndidValidate.popup-user2\n informs all interested subscribers, that the second user has been validated by a widget \nwithin a popup\n.\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a \nmodal third topic\n, broadly describing \nhow\n something happened (e.g. to communicate an outcome such as \nSUCCESS\n or \nERROR\n).\n\n\nOf course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.\n\n\nIt is recommended wherever possible for widgets to use one or more of the established \nevent patterns\n:\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few \ncore patterns\n are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project \nLaxarJS Patterns\n.\nEven without using the LaxarJS Patterns \nlibrary\n, widget authors are very much encouraged to use the \nevent vocabularies\n whenever meaningful.\n\n\nEvent Payload\n\n\nAn event does not only have a name, but also a \npayload\n.\nAny JavaScript object that can be directly represented as \nJSON\n can be used as a payload.\nThis allows for the object to contain instances of \nstring\n, \narray\n, \nnumber\n, \nboolean\n and \nobject\n, including \nnull\n.\nOn the other hand, it excludes\nundefined\n, \nDate\n, \nRegExp\n and custom classes.\n\n\nThe Event Bus will \ncreate a copy\n of the payload \nfor each subscriber\n that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.\n\n\nHowever, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache).\n\n\n\n\nTwo-Way Communication or the Request/Will/Did Mechanism\n\n\nSometimes a widget has to request for some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about \nwho\n actually performs the request, but it is interested in \nwhen\n the request has been fully processed by all respondents, and what is the outcome.\n\n\nAs an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a CAPTCHA.\nAnother widget offering a \nComplete Sign-Up\n button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective validation details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the CAPTCHA widget.\n\n\nUsing the \nRequest/Will/Did\n mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:\n\n\n\n\n\n\nThe individual widgets are \nconfigured\n on the page to work with a common \nregistrationForm\n resource.\n   On instantiation, the input widgets offering validation subscribe to \nvalidateRequest\n events for this resource.\n\n\n\n\n\n\nWhen the user activates the \nComplete Sign-Up\n button, the registration widget issues a \nvalidateRequest.registrationForm\n event, indicating that\n\n\n\n\na validation has been requested \n(what happened)\n and\n\n\nit concerns the resource \nregistrationForm\n \n(where\n it happened).\n\n\n\n\n\n\n\n\nThe registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.\n\n\n\n\n\n\nDuring delivery, the input widgets supporting validation receive the request and will publish a \nwillValidate.registrationForm\n event to indicate that\n\n\n\n\na validation is about to begin \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n.\n\n\n\n\n\n\n\n\nEach widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either \ndidValidate.registrationForm.SUCCESS\n or \ndidValidate.registrationForm.ERROR\n conveying that\n\n\n\n\na validation has been performed \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n and\n\n\nthe way the validation turned out \n(how)\n.\n\n\n\n\n\n\n\n\nOnce all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the \nsign-up\n REST request may be performed.\n\n\n\n\n\n\nThis mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its \n\"didValidate\"\n events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.\n\n\nValidation and other patterns are described in the following paragraph below.\n\n\n\n\nPattern Reference\n\n\nA few event patterns are supported directly by LaxarJS, while others are described in the \nLaxarJS Patterns\n library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.\n\n\n\n\nCore Patterns\n\n\nThe core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.\n\n\nPage Lifecycle\n\n\nAfter all widget controllers have been instantiated, the runtime publishes a \nbeginLifecycleRequest\n event.\nWidgets that need to publish events on page load should do so \nafter\n receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.\n\n\nBefore \nnavigating\n away from a page, the runtime publishes the \nendLifecycleRequest\n event.\nWidgets that need to save state to a service should respond with a \nwillEndLifecycle\n event, perform their housekeeping and publish an \ndidEndLifecycle\n when done.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbeginLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that publishing of events is safe now\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nthe lifecycle ID (currently, this is always \n\"default\"\n)\n\n\n\n\n\n\nwillBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer page rendering (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page rendering may commence (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nendLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that the page is about to be destroyed\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nwillEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer tear down of the page (if necessary)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page tear down may commence (after deferring it)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\n\n\n\n\nNavigation\n\n\nWidgets and activities may initiate navigation using a \nnavigateRequest.{target}\n event, substituting an actual navigation target instead of the placeholder \n{target}\n.\nThe event is interpreted by the LaxarJS runtime as follows:\n\n\n* if _target_ is `\n_self\n`, the runtime will simply propagate its place-parameters by publishing a `didNavigate` event right away\n* if _target_ is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place\n* otherwise, if _target_ is a place within the flow definition, the runtime will initiate navigation to that place\n* otherwise, nothing will happen.\n\n\n\n\n\nWhen \ninitiating navigation\n, the LaxarJS runtime will:\n\n\n1. extract any place parameters from the event payload of the request event\n2. publish a `willNavigate.{target}` event with the corresponding target and parameters\n3. publish an `endLifecycle` event and wait for any respondents\n4. perform navigation by destroying the current page and loading the page associated with the new place\n3. publish a `beginLifecycle` event and wait for any respondents\n5. publish a `didNavigate.{target}` event, with the corresponding target and parameters as well as the resolved place\n\n\n\n\n\nHere is the summary of navigation events:\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnavigateRequest.{target}\n\n\n\n\npublished by widgets and activities to indicate that a navigation has been requested\n\n\n\n\n\n\n\n\ntarget\n\n\nthe navigation target (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\n\n\ndata\n\n\na map from place parameter names to parameter values\n\n\n\n\n\n\nwillNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has started\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\ndidNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has finished\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\n\n\nplace\n\n\nthe actual place that was navigated to, now the current place\n\n\n\n\n\n\n\n\nMore information on navigation is available in the \n\"Flow and Places\" manual\n.\n\n\nLocales and i18n\n\n\nEvents related to locales are described in the \n\"i18n\" manual\n.\n\n\nMore Patterns\n\n\nThe patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the \nLaxarJS Patterns documentation\n.\n\n\nEvent Reference\n\n\nThe single relevant API provided by LaxarJS is the event bus.\nThis section lists the exact details of using it, and on how event names may be constructed.\n\n\nThe Event Bus API\n\n\nThe event bus is available to widgets and activities through \n$scope.eventBus\n.\nIt only has a few essential methods that allow to implement all patterns described below.\n\n\n\n\nsubscribe( eventPattern, callback, options )\n\n\n\n\nThis creates a subscription on the event bus.\n  The \neventPattern\n is a prefix for events to subscribe to:\n  Events that start with the given sequence of (sub-)topics will be handled by this subscription.\n\n\n\n\npublish( eventName, payload )\n\n\n\n\nPublishes an event to all interested subscribers.\n  Delivery is asynchronous: control is returned to the caller immediately, and delivery will be performed afterwards, together with an AngularJS digest cycle.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.\n\n\n\n\npublishAndGatherReplies( requestEventName, payload )\n\n\n\n\nPublishes a \nrequest event\n, gathers all \nwill\n-responses during delivery and then waits for all outstanding \ndid\n-responses.\n  Returns a promise that is resolved when all \ndid\n-responses have been received.\n\n\n\n\nEvent Name Grammar\n\n\nThis is the formal grammar for event names, in \nEBNF\n:\n\n\nevent-name\n \n::\n=\n \ntopic-id\n \n[\n \n.\n \ntopic-id\n \n]\n*\n\n\ntopic-id\n \n::=\n \nsub-topic-id\n \n[\n \n-\n \nsub-topic-id\n \n]\n*\n\n\nsub-topic-id\n \n::=\n \n[\na-z\n][\n+\na-zA-Z0-9\n]\n*\n \n|\n \n[\nA-Z\n][\n+\nA-Z0-9\n]\n*", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#events-and-publish-subscribe", 
            "text": "The key concept that distinguishes LaxarJS applications from other AngularJS applications is the  publish-subscribe  (or  pub/sub ) architecture.\nIt helps to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).  LaxarJS consistently uses the term  events  rather than  messages , to point out two key aspects of its pub/sub-architecture:\n * events convey information about  what happened  (rather than  who is receiver )\n * delivery is always  asynchronous  (using an  event loop )  For these reasons, you may also think of this pattern as a variation on the  hollywood principle  (\"Don't call us, we'll call you\").  For efficient processing, LaxarJS ties into the AngularJS  $digest -cycle.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#the-event-bus", 
            "text": "All events are published to and delivered by the  event bus :\nThe event bus manages  name-based  (or  topic-based )  event subscriptions  for all interested widgets and activities (the  subscribers ):\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.  Each event has a  name  containing a summary of what happened, and a  payload  carrying additional information.", 
            "title": "The Event Bus"
        }, 
        {
            "location": "/manuals/events/#event-names", 
            "text": "Event names summarize  what happened , possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.  An event name is a string, formed by a sequence of one or more  topics  that are separated by  .  (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more  sub-topics  separated by  -  (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by  * _either_ an upper case letter followed by a sequence of upper case letters and numbers\n* _or_ a lower case letter followed by a sequence of mixed case letters and numbers  These rules also exist as a formal  grammar  for thorough people.  These are examples for  valid  event names:  * `didReplace.myShoppingCart`\n* `takeActionRequest.searchArticles`\n* `didTakeAction.searchArticles.SUCCESS`\n* `willEndLifecycle`\n* `didValidate.popup-user2`  Invalid  event names include:  * `DidReplace.myShoppingCart`: _invalid,_ first topic starts upper case but contains lower case letters\n* `.searchArticles.SUCCESS`: _invalid,_ empty topic is not allowed\n* `didUpdate.1up`: _invalid_, topic must not start with a number", 
            "title": "Event Names"
        }, 
        {
            "location": "/manuals/events/#naming-best-practices-and-event-patterns", 
            "text": "Good event names start with a very general  verb-based first topic , broadly describing  what  happened.\nThat topic is often followed by a more specific  object-based second topic , describing  where  (or  to what ) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event  didValidate.popup-user2  informs all interested subscribers, that the second user has been validated by a widget  within a popup .\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a  modal third topic , broadly describing  how  something happened (e.g. to communicate an outcome such as  SUCCESS  or  ERROR ).  Of course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.  It is recommended wherever possible for widgets to use one or more of the established  event patterns :\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few  core patterns  are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project  LaxarJS Patterns .\nEven without using the LaxarJS Patterns  library , widget authors are very much encouraged to use the  event vocabularies  whenever meaningful.", 
            "title": "Naming Best Practices and Event Patterns"
        }, 
        {
            "location": "/manuals/events/#event-payload", 
            "text": "An event does not only have a name, but also a  payload .\nAny JavaScript object that can be directly represented as  JSON  can be used as a payload.\nThis allows for the object to contain instances of  string ,  array ,  number ,  boolean  and  object , including  null .\nOn the other hand, it excludes undefined ,  Date ,  RegExp  and custom classes.  The Event Bus will  create a copy  of the payload  for each subscriber  that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.  However, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache).", 
            "title": "Event Payload"
        }, 
        {
            "location": "/manuals/events/#two-way-communication-or-the-requestwilldid-mechanism", 
            "text": "Sometimes a widget has to request for some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about  who  actually performs the request, but it is interested in  when  the request has been fully processed by all respondents, and what is the outcome.  As an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a CAPTCHA.\nAnother widget offering a  Complete Sign-Up  button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective validation details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the CAPTCHA widget.  Using the  Request/Will/Did  mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:    The individual widgets are  configured  on the page to work with a common  registrationForm  resource.\n   On instantiation, the input widgets offering validation subscribe to  validateRequest  events for this resource.    When the user activates the  Complete Sign-Up  button, the registration widget issues a  validateRequest.registrationForm  event, indicating that   a validation has been requested  (what happened)  and  it concerns the resource  registrationForm   (where  it happened).     The registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.    During delivery, the input widgets supporting validation receive the request and will publish a  willValidate.registrationForm  event to indicate that   a validation is about to begin  (what)  and  that it concerns the  registrationForm  resource  (where) .     Each widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either  didValidate.registrationForm.SUCCESS  or  didValidate.registrationForm.ERROR  conveying that   a validation has been performed  (what)  and  that it concerns the  registrationForm  resource  (where)  and  the way the validation turned out  (how) .     Once all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the  sign-up  REST request may be performed.    This mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its  \"didValidate\"  events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.  Validation and other patterns are described in the following paragraph below.", 
            "title": "Two-Way Communication or the Request/Will/Did Mechanism"
        }, 
        {
            "location": "/manuals/events/#pattern-reference", 
            "text": "A few event patterns are supported directly by LaxarJS, while others are described in the  LaxarJS Patterns  library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.", 
            "title": "Pattern Reference"
        }, 
        {
            "location": "/manuals/events/#core-patterns", 
            "text": "The core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.", 
            "title": "Core Patterns"
        }, 
        {
            "location": "/manuals/events/#page-lifecycle", 
            "text": "After all widget controllers have been instantiated, the runtime publishes a  beginLifecycleRequest  event.\nWidgets that need to publish events on page load should do so  after  receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.  Before  navigating  away from a page, the runtime publishes the  endLifecycleRequest  event.\nWidgets that need to save state to a service should respond with a  willEndLifecycle  event, perform their housekeeping and publish an  didEndLifecycle  when done.     Event name  Payload Attribute  Description      beginLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that publishing of events is safe now     lifecycleId  the lifecycle ID (currently, this is always  \"default\" )    willBeginLifecycle.{lifecycleId}   published by widgets and activities to defer page rendering (not recommended)     lifecycleId  see above    didBeginLifecycle.{lifecycleId}   published by widgets and activities when page rendering may commence (not recommended)     lifecycleId  see above    endLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that the page is about to be destroyed     lifecycleId  see above    willEndLifecycle.{lifecycleId}   published by widgets and activities to defer tear down of the page (if necessary)     lifecycleId  see above    didEndLifecycle.{lifecycleId}   published by widgets and activities when page tear down may commence (after deferring it)     lifecycleId  see above", 
            "title": "Page Lifecycle"
        }, 
        {
            "location": "/manuals/events/#navigation", 
            "text": "Widgets and activities may initiate navigation using a  navigateRequest.{target}  event, substituting an actual navigation target instead of the placeholder  {target} .\nThe event is interpreted by the LaxarJS runtime as follows:  * if _target_ is ` _self `, the runtime will simply propagate its place-parameters by publishing a `didNavigate` event right away\n* if _target_ is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place\n* otherwise, if _target_ is a place within the flow definition, the runtime will initiate navigation to that place\n* otherwise, nothing will happen.  When  initiating navigation , the LaxarJS runtime will:  1. extract any place parameters from the event payload of the request event\n2. publish a `willNavigate.{target}` event with the corresponding target and parameters\n3. publish an `endLifecycle` event and wait for any respondents\n4. perform navigation by destroying the current page and loading the page associated with the new place\n3. publish a `beginLifecycle` event and wait for any respondents\n5. publish a `didNavigate.{target}` event, with the corresponding target and parameters as well as the resolved place  Here is the summary of navigation events:     Event name  Payload Attribute  Description      navigateRequest.{target}   published by widgets and activities to indicate that a navigation has been requested     target  the navigation target (used in the payload  as well as  in the event name)     data  a map from place parameter names to parameter values    willNavigate.{target}   published by the runtime to indicate that navigation has started     target ,  data  see above    didNavigate.{target}   published by the runtime to indicate that navigation has finished     target ,  data  see above     place  the actual place that was navigated to, now the current place     More information on navigation is available in the  \"Flow and Places\" manual .", 
            "title": "Navigation"
        }, 
        {
            "location": "/manuals/events/#locales-and-i18n", 
            "text": "Events related to locales are described in the  \"i18n\" manual .", 
            "title": "Locales and i18n"
        }, 
        {
            "location": "/manuals/events/#more-patterns", 
            "text": "The patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the  LaxarJS Patterns documentation .", 
            "title": "More Patterns"
        }, 
        {
            "location": "/manuals/events/#event-reference", 
            "text": "The single relevant API provided by LaxarJS is the event bus.\nThis section lists the exact details of using it, and on how event names may be constructed.", 
            "title": "Event Reference"
        }, 
        {
            "location": "/manuals/events/#the-event-bus-api", 
            "text": "The event bus is available to widgets and activities through  $scope.eventBus .\nIt only has a few essential methods that allow to implement all patterns described below.   subscribe( eventPattern, callback, options )   This creates a subscription on the event bus.\n  The  eventPattern  is a prefix for events to subscribe to:\n  Events that start with the given sequence of (sub-)topics will be handled by this subscription.   publish( eventName, payload )   Publishes an event to all interested subscribers.\n  Delivery is asynchronous: control is returned to the caller immediately, and delivery will be performed afterwards, together with an AngularJS digest cycle.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.   publishAndGatherReplies( requestEventName, payload )   Publishes a  request event , gathers all  will -responses during delivery and then waits for all outstanding  did -responses.\n  Returns a promise that is resolved when all  did -responses have been received.", 
            "title": "The Event Bus API"
        }, 
        {
            "location": "/manuals/events/#event-name-grammar", 
            "text": "This is the formal grammar for event names, in  EBNF :  event-name   :: =   topic-id   [   .   topic-id   ] *  topic-id   ::=   sub-topic-id   [   -   sub-topic-id   ] *  sub-topic-id   ::=   [ a-z ][ + a-zA-Z0-9 ] *   |   [ A-Z ][ + A-Z0-9 ] *", 
            "title": "Event Name Grammar"
        }, 
        {
            "location": "/manuals/flow_and_places/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nConfiguration\n\n\nWriting Pages\n\n\n\n\nFlow and Places\n\n\nEvery application consisting of more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a \nflow\n defining a set of \nplaces\n in a declarative fashion.\nEach place corresponds to a single page that should be rendered, or some other content displayed to the user.\nCurrently the definition of one single flow file is possible, which can by default be found within the application at the path \napplication/flow/flow.json\n.\nThis can be adjusted as \nlaxar-path-flow\n in the \nrequire configuration\n of your application.\n\n\nLet us start with an example for a simple \nflow.json\n file:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nentry\n:\n \n{\n\n         \nredirectTo\n:\n \npageOne\n\n      \n},\n\n\n      \npageOne/:userId\n:\n \n{\n\n         \npage\n:\n \nfirst_page\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nA flow definition is always a JSON object having the root property \nplaces\n, which in turn is a map.\nEach entry of that map consists of the place's URL template as key and a definition of what should happen when reaching that place as value.\nFor LaxarJS an URL template always starts with a constant prefix, possibly consisting of multiple segments separated by slashes, containing optional \nparameters\n.\nThe syntax is taken from AngularJS, where variable parts of a URL are always prefixed by a colon.\nWithin the flow, the constant prefix of a place is interpreted as its \nidentifier\n.\nThus the second place in the example has the identifier \npageOne\n and one parameter, called \nuserId\n.\n\n\nThe identifier \nentry\n of the first place is always interpreted as the default place to navigate to if either no place was provided or if the requested place was not found within the flow.\nMost commonly it will just redirect to another existing place, that for example handles user login or application startup.\nJust as in plain AngularJS, routing a redirect is configured using the \nredirectTo\n keyword and naming the place identifier to navigate to.\nIn this example we simply navigate without providing a value for the \nuserId\n parameter to the place \npageOne\n.\nAny place that simply redirects to another place cannot do any meaningful in addition to that.\nControl is directly passed on to the redirection target.\n\n\nIn contrast to that, the place \npageOne\n specifies a page that should be loaded by using the key \npage\n in its definition.\nBy default all pages are searched in the \napplication/pages/\n directory with the \n.json\n suffix automatically appended when omitted.\nJust like the path to the flow file, this can also be reconfigured in the \nrequire configuration\n of your application as \nlaxar-path-pages\n.\nSo whenever this place is visited, the according page with all of its configured widgets is loaded and displayed.\n\n\nPlaces\n\n\nAs said before the syntax for places is based on the URL template syntax from AngularJS and in fact AngularJS' routing is used internally.\nWithin the flow, those URL templates have some additional meaning as they are being used as an identifier for places.\nThus a few strict rules are added to the basic AngularJS URL template rules:\n\n\n\n\nA URL always consists of one or more segments separated by slashes \n/\n.\n\n\nEach segment can either be a constant alphanumeric character string or a parameter, which is an alphanumeric character string prefixed by colon.\n\n\nA URL always starts with a unique non empty list of constant segments, which can optionally be followed by a list of parameters.\nParameters and constant segments may not appear interleaved.\n\n\nWildcards are not supported\n\n\n\n\nExamples of valid places thus are the following:\n\n\n\n\nuserListing\n\n\nuser/:userId\n\n\ncars/vans/:manufacturer/:model\n\n\n\n\nIn contrast these places would all be considered invalid:\n\n\n\n\n:userId\n: A place \nmust\n start with a non-empty constant segment\n\n\nuser/:userId/car\n: As soon as there is a parameter, no more constant segments may appear\n\n\nuser/:names*\n or \nuser/:names?\n: Wildcards are \nnot\n supported\n\n\n\n\nThese rules may seem very restrictive but they enable LaxarJS to make some assumptions and optimizations based on the URL template.\nAdditionally a URL should not encode too much sensitive information directly, as this might lead to security issues and bulky URLs.\nInstead only some domain information should be passed on between pages, that enables the widgets of the next place to fulfill their specific tasks.\n\n\nTargets\n\n\nNavigation is triggered from within a widget by issuing a \nnavigateRequest\n event expressing the desired next location within the application and providing values for place parameters.\nHow that works in practice can be read in the separate manual covering \nevents\n.\nUsing these events it is possible to always navigate directly from place to place.\nNevertheless this would instantly lead to a tight coupling between the widget triggering navigation events and the definition of places within the flow.\nInstead a widget or a page (by means of the feature configuration for a widget) should only know about semantic navigation targets reachable from their current location (roughly comparable to \nrelations\n in \nREST\n).\n\n\nIn LaxarJS this is achieved by the concept of \ntargets\n:\nEach place can define a mapping from semantic target identifier valid only for this place to the identifier of another place within the flow.\n\n\nAn example (for brevity the \nentry\n place is omitted):\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nintroduction/:userId\n:\n \n{\n\n         \npage\n:\n \nintroduction\n,\n\n         \ntargets\n:\n \n{\n\n            \nnext\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \ninterests/:userId\n:\n \n{\n\n         \npage\n:\n \ninterests\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \nintroduction\n,\n\n            \nnext\n:\n \nprofession\n,\n\n            \nhelp\n:\n \nprofessionHelp\n\n         \n}\n\n      \n},\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \ninterests\n,\n\n            \nhelp\n:\n \nprofessionHelp\n\n         \n}\n\n      \n},\n\n\n      \ninterestsHelp/:userId\n:\n \n{\n\n         \npage\n:\n \ninterests_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \nprofessionHelp/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \nprofession\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis flow is typical for a wizard-like application, as it allows a forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called \nintroduction\n, which simply displays a page and just lets the user navigate to the \nnext\n target, which would be resolved to the place \ninterests\n.\nHere a page is displayed where the user can input his interests, e.g. his hobbies or music taste.\nAs we are in the middle of a wizard, there is a \nprevious\n target reachable now in addition to the \nnext\n and \nhelp\n targets.\nUnsurprisingly the \nprevious\n target references the place \nintroduction\n again.\nThe \nnext\n target instead leads us to another new place with identifier \nprofession\n.\nThe \nprofession\n place may only lead us back to the \ninterests\n place via the \nprevious\n target.\n\n\nMay be some pages have some tricky input components or there are some advices for which things to share.\nThis is where the \nhelp\n targets come into play.\nBoth, the \ninterests\n and the \nprofession\n page, have such a target.\nNevertheless the places behind these targets are different depending on the source page.\nThis makes understanding of navigation concepts simple and provides contextual semantics.\nReturning from the help pages works in a similar way via the \nback\n targets leading to the respective places.\n\n\nEntry Points\n\n\nThe previous sections covered the concepts of navigation within the scope of one LaxarJS application.\nAdditionally it is also often necessary to integrate a use case implemented as a LaxarJS application within the context of another external application.\nFor example the process of collecting data on interests and profession could be part of a larger application creating a personal profile of a person.\nThe host application might have been be implemented in a totally different technology, like Rails or JSP (JavaServer Pages).\nThere should be some way for this application to give control to the LaxarJS application and pass in some parameters.\n\n\nThis is achieved by the concept of \nentry points\n.\nEntry points define possible ways for how to enter an application and which place to navigate to once this entry point is selected.\nLet us add entry points to our example:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n\n      \nentry\n:\n \n{\n\n         \nentryPoints\n:\n \n{\n\n            \nenterInterests\n:\n \ninterests\n,\n\n            \nenterProfession\n:\n \nprofession\n\n         \n}\n\n      \n},\n\n\n      \nintroduction/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \ninterests/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \n...\n\n   \n}\n\n\n}\n\n\n\n\n\n\nApart from the key \nentryPoints\n this is very similar to the definition of targets within the \nflow.json\n.\nThe difference mainly comes from their usage when passing control from the external application to this application:\nAn entry point is selected by configuring it in the global \nwindow.laxar\n \nconfiguration object\n as \nwindow.laxar.portal.flow.entryPoint\n property.\nThis property is an object with key \ntarget\n denoting the name of the entry point to select and an optional map under the \nparameters\n with the values for the possible place parameters.\n\n\nSo let us assume a JSP renders the bootstrapping code for the LaxarJS application, selects the \nenterInterests\n entry point and passes the user ID to the JavaScript frontend:\n\n\n!DOCTYPE html\n\n\nhtml\n\n   \nhead\n!-- contents omitted --\n/head\n\n   \nbody\n\n      \ndiv\n \ndata-ng-view\n \nstyle=\ndisplay: none\n/div\n\n      \ndiv\n \ndata-ax-page\n/div\n\n\n      \nscript \nsrc=\napplication/application.js\n/script\n\n      \nscript \nsrc=\nrequire_config.js\n/script\n\n      \nscript\n\n         \nwindow\n.\nlaxar\n.\nportal\n.\nflow\n \n=\n \n{\n\n            \nentryPoint\n:\n \n{\n\n               \ntarget\n:\n \nenterInterests\n,\n\n               \nparameters\n:\n \n{\n\n                  \nuserId\n:\n \n%= currentUserId %\n\n               \n}\n\n            \n}\n\n         \n};\n\n      \n/script\n\n      \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n   \n/body\n\n\n/html\n\n\n\n\n\n\nBy using this mechanism the external application, in this example a simple JSP, is in control of how our application is entered.\n\n\nExit Points\n\n\nExit points\n work the other way around:\nHere the external application may define a map of different exit points, which in fact are simple JavaScript functions, and the LaxarJS application selects which one to call when navigating to a specific target.\nConfiguration of possible exit points also takes place in the global \nwindow.laxar\n \nconfiguration object\n  as \nwindow.laxar.portal.flow.exitPoints\n property.\n\n\nHere we added to possible exitPoints to our example:\n\n\n!DOCTYPE html\n\n\nhtml\n\n   \nhead\n!-- contents omitted --\n/head\n\n   \nbody\n\n      \ndiv\n \ndata-ng-view\n \nstyle=\ndisplay: none\n/div\n\n      \ndiv\n \ndata-ax-page\n/div\n\n\n      \nscript \nsrc=\napplication/application.js\n/script\n\n      \nscript \nsrc=\nrequire_config.js\n/script\n\n      \nscript\n\n         \nwindow\n.\nlaxar\n.\nportal\n.\nflow\n \n=\n \n{\n\n            \nentryPoint\n:\n \n{\n\n               \ntarget\n:\n \nenterInterests\n,\n\n               \nparameters\n:\n \n{\n\n                  \nuserId\n:\n \n%= currentUserId %\n\n               \n}\n\n            \n},\n\n            \nexitPoints\n:\n \n{\n\n               \nsaveProfile\n:\n \nfunction\n(\n \nparameters\n \n)\n \n{\n\n                  \n// Do whatever is necessary here to pass control back to the JSP application ...\n\n               \n},\n\n               \ncancelProcess\n:\n \nfunction\n(\n \nparameters\n \n)\n \n{\n\n                  \n// Do whatever is necessary here to pass control back to the JSP application ...\n\n               \n}\n\n            \n}\n\n         \n};\n\n      \n/script\n\n      \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n   \n/body\n\n\n/html\n\n\n\n\n\n\nAll arguments passed to the target referencing an exit point during navigation will be forwarded as map to the according function in the \nexitPoints\n map.\n\n\nFor this example two targets using the new exit points are defined (irrelevant places omitted for brevity):\n\n\n{\n\n   \nplaces\n:\n \n{\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \ninterests\n,\n\n            \nhelp\n:\n \nprofessionHelp\n,\n\n            \ncancel\n:\n \ncancel\n,\n\n            \nsave\n:\n \nsave\n\n         \n}\n\n      \n},\n\n\n      \nsave/:userId/:profession\n:\n \n{\n\n         \nexitPoint\n:\n \nsaveProfile\n\n      \n},\n\n\n      \ncancel/:userId/:reasonForCancellation\n:\n \n{\n\n         \nexitPoint\n:\n \ncancelProcess\n\n      \n}\n\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIf the user decides to save his information by navigating to the target \nsave\n, the exit point \nsaveProfile\n with values for the parameters \nuserId\n and \nprofession\n will be called.\nOn the other hand, if the user cancels the process by navigating to the target \ncancel\n, the exit point \ncancelProcess\n with values for the parameters \nuserId\n and \nreasonForCancellation\n will get invoked.\n\n\nUsing the simple mechanisms introduced here, most integration scenarios into external applications should be possible.\nTo learn how to trigger navigation from within widgets and activities, you should go on reading the \nevents documentation\n and learn about the \nnavigateRequest\n and \ndidNavigate\n events.", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#flow-and-places", 
            "text": "Every application consisting of more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a  flow  defining a set of  places  in a declarative fashion.\nEach place corresponds to a single page that should be rendered, or some other content displayed to the user.\nCurrently the definition of one single flow file is possible, which can by default be found within the application at the path  application/flow/flow.json .\nThis can be adjusted as  laxar-path-flow  in the  require configuration  of your application.  Let us start with an example for a simple  flow.json  file:  { \n    places :   { \n       entry :   { \n          redirectTo :   pageOne \n       }, \n\n       pageOne/:userId :   { \n          page :   first_page \n       } \n    }  }   A flow definition is always a JSON object having the root property  places , which in turn is a map.\nEach entry of that map consists of the place's URL template as key and a definition of what should happen when reaching that place as value.\nFor LaxarJS an URL template always starts with a constant prefix, possibly consisting of multiple segments separated by slashes, containing optional  parameters .\nThe syntax is taken from AngularJS, where variable parts of a URL are always prefixed by a colon.\nWithin the flow, the constant prefix of a place is interpreted as its  identifier .\nThus the second place in the example has the identifier  pageOne  and one parameter, called  userId .  The identifier  entry  of the first place is always interpreted as the default place to navigate to if either no place was provided or if the requested place was not found within the flow.\nMost commonly it will just redirect to another existing place, that for example handles user login or application startup.\nJust as in plain AngularJS, routing a redirect is configured using the  redirectTo  keyword and naming the place identifier to navigate to.\nIn this example we simply navigate without providing a value for the  userId  parameter to the place  pageOne .\nAny place that simply redirects to another place cannot do any meaningful in addition to that.\nControl is directly passed on to the redirection target.  In contrast to that, the place  pageOne  specifies a page that should be loaded by using the key  page  in its definition.\nBy default all pages are searched in the  application/pages/  directory with the  .json  suffix automatically appended when omitted.\nJust like the path to the flow file, this can also be reconfigured in the  require configuration  of your application as  laxar-path-pages .\nSo whenever this place is visited, the according page with all of its configured widgets is loaded and displayed.", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#places", 
            "text": "As said before the syntax for places is based on the URL template syntax from AngularJS and in fact AngularJS' routing is used internally.\nWithin the flow, those URL templates have some additional meaning as they are being used as an identifier for places.\nThus a few strict rules are added to the basic AngularJS URL template rules:   A URL always consists of one or more segments separated by slashes  / .  Each segment can either be a constant alphanumeric character string or a parameter, which is an alphanumeric character string prefixed by colon.  A URL always starts with a unique non empty list of constant segments, which can optionally be followed by a list of parameters.\nParameters and constant segments may not appear interleaved.  Wildcards are not supported   Examples of valid places thus are the following:   userListing  user/:userId  cars/vans/:manufacturer/:model   In contrast these places would all be considered invalid:   :userId : A place  must  start with a non-empty constant segment  user/:userId/car : As soon as there is a parameter, no more constant segments may appear  user/:names*  or  user/:names? : Wildcards are  not  supported   These rules may seem very restrictive but they enable LaxarJS to make some assumptions and optimizations based on the URL template.\nAdditionally a URL should not encode too much sensitive information directly, as this might lead to security issues and bulky URLs.\nInstead only some domain information should be passed on between pages, that enables the widgets of the next place to fulfill their specific tasks.", 
            "title": "Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#targets", 
            "text": "Navigation is triggered from within a widget by issuing a  navigateRequest  event expressing the desired next location within the application and providing values for place parameters.\nHow that works in practice can be read in the separate manual covering  events .\nUsing these events it is possible to always navigate directly from place to place.\nNevertheless this would instantly lead to a tight coupling between the widget triggering navigation events and the definition of places within the flow.\nInstead a widget or a page (by means of the feature configuration for a widget) should only know about semantic navigation targets reachable from their current location (roughly comparable to  relations  in  REST ).  In LaxarJS this is achieved by the concept of  targets :\nEach place can define a mapping from semantic target identifier valid only for this place to the identifier of another place within the flow.  An example (for brevity the  entry  place is omitted):  { \n    places :   { \n       introduction/:userId :   { \n          page :   introduction , \n          targets :   { \n             next :   interests \n          } \n       }, \n\n       interests/:userId :   { \n          page :   interests , \n          targets :   { \n             previous :   introduction , \n             next :   profession , \n             help :   professionHelp \n          } \n       }, \n\n       profession/:userId :   { \n          page :   profession , \n          targets :   { \n             previous :   interests , \n             help :   professionHelp \n          } \n       }, \n\n       interestsHelp/:userId :   { \n          page :   interests_help , \n          targets :   { \n             back :   interests \n          } \n       }, \n\n       professionHelp/:userId :   { \n          page :   profession_help , \n          targets :   { \n             back :   profession \n          } \n       } \n    }  }   This flow is typical for a wizard-like application, as it allows a forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called  introduction , which simply displays a page and just lets the user navigate to the  next  target, which would be resolved to the place  interests .\nHere a page is displayed where the user can input his interests, e.g. his hobbies or music taste.\nAs we are in the middle of a wizard, there is a  previous  target reachable now in addition to the  next  and  help  targets.\nUnsurprisingly the  previous  target references the place  introduction  again.\nThe  next  target instead leads us to another new place with identifier  profession .\nThe  profession  place may only lead us back to the  interests  place via the  previous  target.  May be some pages have some tricky input components or there are some advices for which things to share.\nThis is where the  help  targets come into play.\nBoth, the  interests  and the  profession  page, have such a target.\nNevertheless the places behind these targets are different depending on the source page.\nThis makes understanding of navigation concepts simple and provides contextual semantics.\nReturning from the help pages works in a similar way via the  back  targets leading to the respective places.", 
            "title": "Targets"
        }, 
        {
            "location": "/manuals/flow_and_places/#entry-points", 
            "text": "The previous sections covered the concepts of navigation within the scope of one LaxarJS application.\nAdditionally it is also often necessary to integrate a use case implemented as a LaxarJS application within the context of another external application.\nFor example the process of collecting data on interests and profession could be part of a larger application creating a personal profile of a person.\nThe host application might have been be implemented in a totally different technology, like Rails or JSP (JavaServer Pages).\nThere should be some way for this application to give control to the LaxarJS application and pass in some parameters.  This is achieved by the concept of  entry points .\nEntry points define possible ways for how to enter an application and which place to navigate to once this entry point is selected.\nLet us add entry points to our example:  { \n    places :   { \n\n       entry :   { \n          entryPoints :   { \n             enterInterests :   interests , \n             enterProfession :   profession \n          } \n       }, \n\n       introduction/:userId :   { \n          ... \n       }, \n\n       interests/:userId :   { \n          ... \n       }, \n\n       profession/:userId :   { \n          ... \n       }, \n\n       ... \n    }  }   Apart from the key  entryPoints  this is very similar to the definition of targets within the  flow.json .\nThe difference mainly comes from their usage when passing control from the external application to this application:\nAn entry point is selected by configuring it in the global  window.laxar   configuration object  as  window.laxar.portal.flow.entryPoint  property.\nThis property is an object with key  target  denoting the name of the entry point to select and an optional map under the  parameters  with the values for the possible place parameters.  So let us assume a JSP renders the bootstrapping code for the LaxarJS application, selects the  enterInterests  entry point and passes the user ID to the JavaScript frontend:  !DOCTYPE html  html \n    head !-- contents omitted -- /head \n    body \n       div   data-ng-view   style= display: none /div \n       div   data-ax-page /div \n\n       script  src= application/application.js /script \n       script  src= require_config.js /script \n       script \n          window . laxar . portal . flow   =   { \n             entryPoint :   { \n                target :   enterInterests , \n                parameters :   { \n                   userId :   %= currentUserId % \n                } \n             } \n          }; \n       /script \n       script  data-main= ../init.js   src= bower_components/requirejs/require.js /script \n    /body  /html   By using this mechanism the external application, in this example a simple JSP, is in control of how our application is entered.", 
            "title": "Entry Points"
        }, 
        {
            "location": "/manuals/flow_and_places/#exit-points", 
            "text": "Exit points  work the other way around:\nHere the external application may define a map of different exit points, which in fact are simple JavaScript functions, and the LaxarJS application selects which one to call when navigating to a specific target.\nConfiguration of possible exit points also takes place in the global  window.laxar   configuration object   as  window.laxar.portal.flow.exitPoints  property.  Here we added to possible exitPoints to our example:  !DOCTYPE html  html \n    head !-- contents omitted -- /head \n    body \n       div   data-ng-view   style= display: none /div \n       div   data-ax-page /div \n\n       script  src= application/application.js /script \n       script  src= require_config.js /script \n       script \n          window . laxar . portal . flow   =   { \n             entryPoint :   { \n                target :   enterInterests , \n                parameters :   { \n                   userId :   %= currentUserId % \n                } \n             }, \n             exitPoints :   { \n                saveProfile :   function (   parameters   )   { \n                   // Do whatever is necessary here to pass control back to the JSP application ... \n                }, \n                cancelProcess :   function (   parameters   )   { \n                   // Do whatever is necessary here to pass control back to the JSP application ... \n                } \n             } \n          }; \n       /script \n       script  data-main= ../init.js   src= bower_components/requirejs/require.js /script \n    /body  /html   All arguments passed to the target referencing an exit point during navigation will be forwarded as map to the according function in the  exitPoints  map.  For this example two targets using the new exit points are defined (irrelevant places omitted for brevity):  { \n    places :   { \n\n       profession/:userId :   { \n          page :   profession , \n          targets :   { \n             previous :   interests , \n             help :   professionHelp , \n             cancel :   cancel , \n             save :   save \n          } \n       }, \n\n       save/:userId/:profession :   { \n          exitPoint :   saveProfile \n       }, \n\n       cancel/:userId/:reasonForCancellation :   { \n          exitPoint :   cancelProcess \n       } \n\n    }  }   If the user decides to save his information by navigating to the target  save , the exit point  saveProfile  with values for the parameters  userId  and  profession  will be called.\nOn the other hand, if the user cancels the process by navigating to the target  cancel , the exit point  cancelProcess  with values for the parameters  userId  and  reasonForCancellation  will get invoked.  Using the simple mechanisms introduced here, most integration scenarios into external applications should be possible.\nTo learn how to trigger navigation from within widgets and activities, you should go on reading the  events documentation  and learn about the  navigateRequest  and  didNavigate  events.", 
            "title": "Exit Points"
        }, 
        {
            "location": "/manuals/i18n/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nInternationalizing a Widget\n\n\nIn LaxarJS, internationalization \n(i18n)\n of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.\n\n\nLocales and Language Tags: I18n in LaxarJS\n\n\nLaxarJS distinguishes \nlocales\n and \nlanguage tags\n for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a \nRFC-5646\n language tag like \"en-US\", which can change over time.\nThe locale corresponds to the audience for which a language tag should be valid.\nIf you have only one audience (regular users), using only \ndefault\n should be fine.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the \nchangeLocaleRequest.{locale}\n event.\n\n\nExample: To change the language tag of the locale \nmyLocale\n to \nde-DE\n, the following event has to be published:\n\n\n$scope\n.\neventBus\n.\npublish\n(\n \nchangeLocaleRequest.myLocale.\n,\n\n    \n{\n \n        \nlocale\n:\n \nmyLocale\n,\n \n        \nlanguageTag\n:\n \nde-DE\n \n    \n}\n\n\n);\n\n\n\n\n\n\nIf a widget is interested in changes to \nmyLocale\n, it would subscribe to the corresponding \ndidChangeLocale\n-event, which is published by the LaxarJS flow-controller:\n\n\n$scope\n.\neventBus\n.\nsubscribe\n(\n \ndidChangeLocale.myLocale.\n,\n \nfunction\n(\n \nevent\n \n)\n \n{\n\n   \nax\n.\nlog\n.\ninfo\n(\n \nI have received tag [0] for locale [1]\n,\n \nevent\n.\nlanguageTag\n,\n \nevent\n.\nlocale\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nWidgets can use the language tags that they receive over the event bus to \nlocalize\n internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with \ni18n\n:\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen-US\n:\n \nUpload file\n,\n\n    \nde-DE\n:\n \nDatei hochladen\n\n\n}\n\n\n\n\n\n\nLaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.\n\n\nWriting an I18n-Capable Widget\n\n\nTo be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry \ncontrols\n in the \nwidget.json\n.\nIf missing, this entry must be created:\n\n\ncontrols\n:\n \n[\n\n    \nlaxar_uikit/controls/i18n\n\n\n]\n\n\n\n\n\n\nNext, we have to add a feature \ni18n\n.\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example \nen-GB\n) is then used to localize internationalized values.\n\n\ni18n\n:\n \n{\n\n   \ndescription\n:\n \nWhich locale to use for displaying this widget.\n,\n\n   \ntype\n:\n \nobject\n,\n\n   \nproperties\n:\n \n{\n\n      \nlocale\n:\n \n{\n\n         \ntype\n:\n \nstring\n,\n\n         \ndescription\n:\n \nThe topic under which to expect the locale for this widget.\n,\n\n         \ndefault\n:\n \ndefault\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIf not already done, we import the Laxar-Patterns library into the widget controller (\nmy_widget.js\n).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right \ndidChangeLocale\n-events for us, by using the feature configuration that we added in the previous step:\n\n\ndefine\n(\n \n[\n   \n   \nlaxar_patterns\n\n\n],\n \nfunction\n(\n \npatterns\n \n)\n \n{\n\n   \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n \n);\n\n   \n...\n\n\n}\n\n\n\n\n\n\nAny updates to the i18n-locale received over the event bus will now be saved under \n$scope.i18n\n, along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:\n\n\n$scope.i\n18\nn\n \n=\n \n{\n      \n   \nlocale:\n \ndefault\n,\n\n   \ntags:\n \n{\n\n      \ndefault\n:\n \nen-US\n,\n\n      \ncustomer\n:\n \nde-DE\n,\n\n      \nsupport\n:\n \nen-GB\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIn the HTML template we can now use the angular filter \naxLocalize\n to convert an i18nHtmlText to a string:\n\n\np\n \ndata-ng-bind-html=\nmodel.i18nHtmlText | axLocalize:i18n\n/p\n\n\n\n\n\n\nThe filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses \n$scope.i18n.locale\n (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen-US\n:\n \nUpload file \nem\nnow\n/em\n,\n\n    \nde-DE\n:\n \nDatei \nem\njetzt\n/em\n hochladen\n\n\n}\n\n\n\n\n\n\nLocalizing Values in the Controller\n\n\nIn some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.\n\n\np\n \ndata-ng-bind-html=\nmodel.htmlVeryLongDocument\n/p\n\n\n\n\n\n\nTo achieve this, we obtain a \nlocalize\n function when we subscribe the widget to the didChangeLocale event.\nLike the \naxLocalize\n-directive, this function automatically uses the current language tag:\n\n\nvar\n \nlocalize\n \n=\n \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n,\n \n{\n\n    \nonChange\n:\n \nupdateLocalization\n\n\n}\n \n).\nlocalizer\n();\n\n\n\n\n\n\nThen we can transform any object with language tag properties to a string using the \nlocalize\n function:\n\n\nfunction\n \nupdateLocalization\n()\n \n{\n\n   \nvar\n \ndocumentUrl\n \n=\n \nlocalize\n(\n \n$scope\n.\nfeatures\n.\ni18nDocumentUrl\n \n);\n\n   \n$http\n.\nget\n(\n \ndocumentUrl\n \n).\nthen\n(\n \nfunction\n(\n \nresponse\n \n)\n \n{\n\n      \n$scope\n.\nmodel\n.\nhtmlVeryLongDocument\n \n=\n \nresponse\n.\ndata\n;\n\n   \n}\n \n);\n\n\n}", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#internationalizing-a-widget", 
            "text": "In LaxarJS, internationalization  (i18n)  of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#locales-and-language-tags-i18n-in-laxarjs", 
            "text": "LaxarJS distinguishes  locales  and  language tags  for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a  RFC-5646  language tag like \"en-US\", which can change over time.\nThe locale corresponds to the audience for which a language tag should be valid.\nIf you have only one audience (regular users), using only  default  should be fine.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the  changeLocaleRequest.{locale}  event.  Example: To change the language tag of the locale  myLocale  to  de-DE , the following event has to be published:  $scope . eventBus . publish (   changeLocaleRequest.myLocale. , \n     {  \n         locale :   myLocale ,  \n         languageTag :   de-DE  \n     }  );   If a widget is interested in changes to  myLocale , it would subscribe to the corresponding  didChangeLocale -event, which is published by the LaxarJS flow-controller:  $scope . eventBus . subscribe (   didChangeLocale.myLocale. ,   function (   event   )   { \n    ax . log . info (   I have received tag [0] for locale [1] ,   event . languageTag ,   event . locale   );  }   );   Widgets can use the language tags that they receive over the event bus to  localize  internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with  i18n :  i18nHtmlText :   { \n     en-US :   Upload file , \n     de-DE :   Datei hochladen  }   LaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.", 
            "title": "Locales and Language Tags: I18n in LaxarJS"
        }, 
        {
            "location": "/manuals/i18n/#writing-an-i18n-capable-widget", 
            "text": "To be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry  controls  in the  widget.json .\nIf missing, this entry must be created:  controls :   [ \n     laxar_uikit/controls/i18n  ]   Next, we have to add a feature  i18n .\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example  en-GB ) is then used to localize internationalized values.  i18n :   { \n    description :   Which locale to use for displaying this widget. , \n    type :   object , \n    properties :   { \n       locale :   { \n          type :   string , \n          description :   The topic under which to expect the locale for this widget. , \n          default :   default \n       } \n    }  }   If not already done, we import the Laxar-Patterns library into the widget controller ( my_widget.js ).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right  didChangeLocale -events for us, by using the feature configuration that we added in the previous step:  define (   [    \n    laxar_patterns  ],   function (   patterns   )   { \n    patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n   ); \n    ...  }   Any updates to the i18n-locale received over the event bus will now be saved under  $scope.i18n , along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:  $scope.i 18 n   =   {       \n    locale:   default , \n    tags:   { \n       default :   en-US , \n       customer :   de-DE , \n       support :   en-GB \n    }  }   In the HTML template we can now use the angular filter  axLocalize  to convert an i18nHtmlText to a string:  p   data-ng-bind-html= model.i18nHtmlText | axLocalize:i18n /p   The filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses  $scope.i18n.locale  (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.  i18nHtmlText :   { \n     en-US :   Upload file  em now /em , \n     de-DE :   Datei  em jetzt /em  hochladen  }", 
            "title": "Writing an I18n-Capable Widget"
        }, 
        {
            "location": "/manuals/i18n/#localizing-values-in-the-controller", 
            "text": "In some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.  p   data-ng-bind-html= model.htmlVeryLongDocument /p   To achieve this, we obtain a  localize  function when we subscribe the widget to the didChangeLocale event.\nLike the  axLocalize -directive, this function automatically uses the current language tag:  var   localize   =   patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n ,   { \n     onChange :   updateLocalization  }   ). localizer ();   Then we can transform any object with language tag properties to a string using the  localize  function:  function   updateLocalization ()   { \n    var   documentUrl   =   localize (   $scope . features . i18nDocumentUrl   ); \n    $http . get (   documentUrl   ). then (   function (   response   )   { \n       $scope . model . htmlVeryLongDocument   =   response . data ; \n    }   );  }", 
            "title": "Localizing Values in the Controller"
        }, 
        {
            "location": "/manuals/configuration/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nLaxarJS Configuration in an Application\n\n\nLaxarJS has a built-in configuration API which is available to libraries and widgets as \nlaxar.configuration\n.\nIn contrast to the bower- and RequireJS-configuration, this configuration is designed to be used at application run time.\n\n\nWhat is LaxarJS Configuration Used for?\n\n\nWhen writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.\n\n\nIn other cases, LaxarJS itself needs to be configured, for example to determine the theme, file listing URIs, available locales and so on.\nThe \nLaxarJS Core\n configuration options are listed below.\n\n\nConfiguration Structure\n\n\nConfiguration keys are simple JSON paths, reflecting a hierarchical configuration structure.\nThe configuration API looks for the configuration values within the \nlaxar\n property of the global object (\nwindow\n).\n\n\nLibraries, widgets and activities may define their own configuration keys, but must always use the \nlib.\n prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example, \nLaxarJS UiKit\n controls use the prefix \nlib.laxar_uikit.controls\n for their configuration options.\nKeys without the \nlib.\n-prefix are used by \nLaxarJS Core\n.\n\n\nThe Configuration API\n\n\nThe LaxarJS configuration exposes a single method \nlaxar.configuration.get( key, fallback )\n.\nThe \nkey\n-parameter is the path within the configuration object (\nwindow.laxar\n), and the (optional) \nfallback\n is returned as a default value if the key was not set in the configuration.\n\n\nFor example, a module \nmy_module\n may allow to enable some kind of compatibility behavior for a special \nfoo\n environment by exposing a boolean configuration \nfooCompatibility\n.\nBy default, the option should be disabled as compatibility with foo involves jumping through some hoops.\nThe module \nmy_module\n would then access the option like this:\n\n\ndefine\n(\n \n[\n \nlaxar\n \n],\n \nfunction\n(\n \nax\n \n)\n \n{\n\n  \nfunction\n \nsetup\n()\n \n{\n\n     \nvar\n \nrespectFoo\n \n=\n \nax\n.\nconfiguration\n.\nget\n(\n \nlib.my_module.fooCompatibility\n,\n \nfalse\n \n);\n\n     \nif\n(\n \nrespectFoo\n \n)\n \n{\n\n        \n// ... jump though some hoops ...\n\n        \nreturn\n \n{\n \nhoops\n:\n \nJUMPED\n \n};\n\n     \n}\n\n     \nreturn\n \n{};\n\n  \n}\n\n\n}\n \n);\n\n\n\n\n\n\nAnd the corresponding configuration block to enable foo-compatibility would then look like this:\n\n\nwindow\n.\nlaxar\n \n=\n \n{\n\n   \n// ...\n\n   \nlib\n:\n \n{\n\n      \nmy_module\n:\n \n{\n\n         \nfooCompatibility\n:\n \ntrue\n\n      \n},\n\n      \n// ...\n\n   \n}\n\n\n};\n\n\n\n\n\n\nTesting a Module that Uses Configuration\n\n\nTo test the behavior of a module with test-controlled configuration options, one can simply spy on the method \nconfiguration.get\n.\nHere is an exemplary jasmine test for a module \nmy_module\n, which tries to test the module behavior with foo-compatibility enabled.\n\n\ndefine\n(\n \n[\n \nlaxar/laxar_testing\n,\n \nmy_module\n \n],\n \nfunction\n(\n \nax\n,\n \nmyModule\n \n)\n \n{\n\n   \ndescribe\n(\n \na my_module with foo compatibility enabled\n,\n \nfunction\n()\n \n{\n\n      \nbeforeEach\n(\n \nfunction\n()\n \n{\n\n         \nvar\n \norigGet\n \n=\n \nax\n.\nconfiguration\n.\nget\n;\n\n         \nvar\n \nhoops\n;\n\n         \nspyOn\n(\n \nax\n.\nconfiguration\n,\n \nget\n \n).\nandCallThrough\n(\n \nfunction\n(\n \nkey\n,\n \nfallback\n \n)\n \n{\n\n            \nreturn\n \nkey\n \n===\n \nlib.my_module.fooCompatibility\n \n?\n \ntrue\n \n:\n \norigGet\n(\n \nkey\n,\n \nfallback\n \n);\n\n         \n}\n \n);\n\n         \nhoops\n \n=\n \nsetup\n();\n\n      \n}\n \n);\n\n      \nit\n(\n \njumps through some hoops\n,\n \nfunction\n()\n \n{\n\n           \nexpect\n(\n \nhoops\n \n).\ntoBe\n(\n \nJUMPED\n \n);\n\n      \n}\n \n);\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nInjecting Configuration into an AngularJS module\n\n\nInstead of using RequireJS, AngularJS modules such as widgets can have the configuration module injected by requesting the service \n'Configuration'\n.\nIn cases where configuration is injected, an \nangularMocks.module\n provider may be defined during testing instead of the approach described above.\n\n\nAvailable Configuration Keys in \nLaxarJS Core\n\n\nThe following configuration options are available in \nLaxarJS Core\n.\nFor options available in \nLaxarJS UiKit\n, have a look at the (respective documentation)[https://github.com/LaxarJS/laxar_uikit/blob/master/docs/manuals/configuration.md].\n\n\n\n\n\n\n\n\nKey\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\n''\n\n\nThe name of the LaxarJS application\n\n\n\n\n\n\ndescription\n\n\n''\n\n\nA short application description\n\n\n\n\n\n\ni18n.locales\n\n\n{ 'default': 'en' }\n\n\nWhich language tag to use for the default locale, and possibly for other locales\n\n\n\n\n\n\nlogging.threshold\n\n\n'INFO'\n\n\nThe log level which is required for messages to be logged (one of \nDEBUG\n, \nTRACE\n, \nINFO\n, \nWARN\n or \nERROR\n)\n\n\n\n\n\n\nfile_resource_provider.listings\n\n\n{}\n\n\nA mapping from application directories to file listings. The listings serve to save unnecessary HTTP requests (for example, to determine if a widget has custom styles for the current theme), and are generated by (grunt-laxar)[https://github.com/LaxarJS/grunt-laxar].\n\n\n\n\n\n\nfile_resource_provider.useEmbedded\n\n\nfalse\n\n\nWhole files may be embedded into the file listings by grunt-laxar to save even more HTTP-requests. In DEBUG-mode, these embeddings may be stale and should not be used (use \nfalse\n) while in release mode, they are beneficial (use \ntrue\n).\n\n\n\n\n\n\nportal.theme\n\n\n'default'\n\n\nWhich theme to use for the application\n\n\n\n\n\n\nportal.useMergedCss\n\n\nfalse\n\n\nSimilar to \nfile_resource_provider.useEmbedded\n, this option controls an optimization: If \ntrue\n, a concatenated CSS bundled produced by \ngrunt-laxar\n is used which improves performance. If \nfalse\n, CSS-files are requested individually, which is mostly useful during development. The value is automatically \ntrue\n if a link-element with the \ndata-ax-merged-css\n attribute exists in the page.\n\n\n\n\n\n\nportal.flow.entryPoint\n\n\nnull\n\n\nIf the browser URL cannot be controlled by the LaxarJS application (for example, when integrating with a legacy system), the target and place-parameters can be set here in the form \n{ target: 'my_flow_target', parameters: { myParam: 'xyz' } }\n.\n\n\n\n\n\n\nportal.flow.exitPoints\n\n\n{}\n\n\nAllows to delegate handling of a navigation target to a different (legacy) system by specifying callbacks for individual navigation targets. Has the form \n{ exitFnName: function( parameters ) { /* ... */ } }\n where \nexitFnName\n matches the definition used as an \n'exitFunction'\n within the \nflow.json\n.", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#laxarjs-configuration-in-an-application", 
            "text": "LaxarJS has a built-in configuration API which is available to libraries and widgets as  laxar.configuration .\nIn contrast to the bower- and RequireJS-configuration, this configuration is designed to be used at application run time.", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#what-is-laxarjs-configuration-used-for", 
            "text": "When writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.  In other cases, LaxarJS itself needs to be configured, for example to determine the theme, file listing URIs, available locales and so on.\nThe  LaxarJS Core  configuration options are listed below.", 
            "title": "What is LaxarJS Configuration Used for?"
        }, 
        {
            "location": "/manuals/configuration/#configuration-structure", 
            "text": "Configuration keys are simple JSON paths, reflecting a hierarchical configuration structure.\nThe configuration API looks for the configuration values within the  laxar  property of the global object ( window ).  Libraries, widgets and activities may define their own configuration keys, but must always use the  lib.  prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example,  LaxarJS UiKit  controls use the prefix  lib.laxar_uikit.controls  for their configuration options.\nKeys without the  lib. -prefix are used by  LaxarJS Core .", 
            "title": "Configuration Structure"
        }, 
        {
            "location": "/manuals/configuration/#the-configuration-api", 
            "text": "The LaxarJS configuration exposes a single method  laxar.configuration.get( key, fallback ) .\nThe  key -parameter is the path within the configuration object ( window.laxar ), and the (optional)  fallback  is returned as a default value if the key was not set in the configuration.  For example, a module  my_module  may allow to enable some kind of compatibility behavior for a special  foo  environment by exposing a boolean configuration  fooCompatibility .\nBy default, the option should be disabled as compatibility with foo involves jumping through some hoops.\nThe module  my_module  would then access the option like this:  define (   [   laxar   ],   function (   ax   )   { \n   function   setup ()   { \n      var   respectFoo   =   ax . configuration . get (   lib.my_module.fooCompatibility ,   false   ); \n      if (   respectFoo   )   { \n         // ... jump though some hoops ... \n         return   {   hoops :   JUMPED   }; \n      } \n      return   {}; \n   }  }   );   And the corresponding configuration block to enable foo-compatibility would then look like this:  window . laxar   =   { \n    // ... \n    lib :   { \n       my_module :   { \n          fooCompatibility :   true \n       }, \n       // ... \n    }  };", 
            "title": "The Configuration API"
        }, 
        {
            "location": "/manuals/configuration/#testing-a-module-that-uses-configuration", 
            "text": "To test the behavior of a module with test-controlled configuration options, one can simply spy on the method  configuration.get .\nHere is an exemplary jasmine test for a module  my_module , which tries to test the module behavior with foo-compatibility enabled.  define (   [   laxar/laxar_testing ,   my_module   ],   function (   ax ,   myModule   )   { \n    describe (   a my_module with foo compatibility enabled ,   function ()   { \n       beforeEach (   function ()   { \n          var   origGet   =   ax . configuration . get ; \n          var   hoops ; \n          spyOn (   ax . configuration ,   get   ). andCallThrough (   function (   key ,   fallback   )   { \n             return   key   ===   lib.my_module.fooCompatibility   ?   true   :   origGet (   key ,   fallback   ); \n          }   ); \n          hoops   =   setup (); \n       }   ); \n       it (   jumps through some hoops ,   function ()   { \n            expect (   hoops   ). toBe (   JUMPED   ); \n       }   ); \n    }   );  }   );", 
            "title": "Testing a Module that Uses Configuration"
        }, 
        {
            "location": "/manuals/configuration/#injecting-configuration-into-an-angularjs-module", 
            "text": "Instead of using RequireJS, AngularJS modules such as widgets can have the configuration module injected by requesting the service  'Configuration' .\nIn cases where configuration is injected, an  angularMocks.module  provider may be defined during testing instead of the approach described above.", 
            "title": "Injecting Configuration into an AngularJS module"
        }, 
        {
            "location": "/manuals/configuration/#available-configuration-keys-in-laxarjs-core", 
            "text": "The following configuration options are available in  LaxarJS Core .\nFor options available in  LaxarJS UiKit , have a look at the (respective documentation)[https://github.com/LaxarJS/laxar_uikit/blob/master/docs/manuals/configuration.md].     Key  Default  Description      name  ''  The name of the LaxarJS application    description  ''  A short application description    i18n.locales  { 'default': 'en' }  Which language tag to use for the default locale, and possibly for other locales    logging.threshold  'INFO'  The log level which is required for messages to be logged (one of  DEBUG ,  TRACE ,  INFO ,  WARN  or  ERROR )    file_resource_provider.listings  {}  A mapping from application directories to file listings. The listings serve to save unnecessary HTTP requests (for example, to determine if a widget has custom styles for the current theme), and are generated by (grunt-laxar)[https://github.com/LaxarJS/grunt-laxar].    file_resource_provider.useEmbedded  false  Whole files may be embedded into the file listings by grunt-laxar to save even more HTTP-requests. In DEBUG-mode, these embeddings may be stale and should not be used (use  false ) while in release mode, they are beneficial (use  true ).    portal.theme  'default'  Which theme to use for the application    portal.useMergedCss  false  Similar to  file_resource_provider.useEmbedded , this option controls an optimization: If  true , a concatenated CSS bundled produced by  grunt-laxar  is used which improves performance. If  false , CSS-files are requested individually, which is mostly useful during development. The value is automatically  true  if a link-element with the  data-ax-merged-css  attribute exists in the page.    portal.flow.entryPoint  null  If the browser URL cannot be controlled by the LaxarJS application (for example, when integrating with a legacy system), the target and place-parameters can be set here in the form  { target: 'my_flow_target', parameters: { myParam: 'xyz' } } .    portal.flow.exitPoints  {}  Allows to delegate handling of a navigation target to a different (legacy) system by specifying callbacks for individual navigation targets. Has the form  { exitFnName: function( parameters ) { /* ... */ } }  where  exitFnName  matches the definition used as an  'exitFunction'  within the  flow.json .", 
            "title": "Available Configuration Keys in LaxarJS Core"
        }, 
        {
            "location": "/manuals/widgets_and_activities/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nWidgets and Activities\n\n\nWidgets and activities are the \n\"work horse\"\n of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.\n\n\nWidget Responsibilities\n\n\nBefore starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question: \nWhat goal does this widget help the user to accomplish?\n\nAre you thinking about a very broadly applicable, technical task such as \n\"allow the user to enter a date\"\n or \n\"allow the user to delete a data row\"\n?\nIn this case you might want to implement this functionality as a \ncontrol\n (an AngularJS directive or an HTML5 web component) and use it \nwithin\n one or more of your widgets.\n\n\nUsually, widgets correspond to significant areas of the screen and are composed from multiple controls.\nThey are built with a \nspecific user-goal\n in mind, such as \n\"allow the user to book a flight\"\n or \n\"allow the user to review shopping cart contents\"\n.\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of the thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?\n\n\nWhen to use Activities\n\n\nActivities are \n\"invisible widgets\"\n that are used to \nfetch and manage application resources\n.\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nThis makes activities perform a role similar to AngularJS services.\nThe advantage over services is that using activities puts the \npage author\n in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.\nAlthough these configurations are not impossible to achieve using AngularJS dependency injection and -services, using LaxarJS activities makes the connections declarative and visible.\n\n\nActivities may also serve as a \nmediator\n between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.\n\n\nHow to Create a Widget\n\n\nThe easiest way to create a widget is to use the appropriate \ngrunt-init\n template.\nCheck out the \nREADME\n on how to obtain the grunt-init templates and on creating an application.\n\n\nStart by creating a sub-directory for your new widget within the LaxarJS application.\nEach widget in an application lives within a sub-folder of the \nwidget root\n (\nincludes/widgets\n by default).\nTo change the widget root you can modify the RequireJS-path \n'laxar-path-widgets'\n in the require configuration.\nThe widget path \nincludes/widgets/shopping/cart_widget\n is used as an example path throughout this manual.\n\n\nThe sub-directory \nshopping\n is the \nwidget category\n in the example path.\nCategories allow to organize widgets by their general business area, for example \nshopping\n, \nsocial\n, \nfinance\n and so on.\nThe last component of the widget path is the \nwidget name\n:\nIt has to be unique throughout an application and must be written in lower case letters with components separated by underscores.\nRegular widget names always end in \n_widget\n whereas activities always end in \n_activity\n.\n\n\nTo create the actual widget, run:\n\n\ngrunt-init laxar-widget\n\n\n\n\n\nA wizard will ask for some details on the widget such as license and author, but you can always edit this information in the widget sources afterwards.\nIn the following steps, it is assumed that you used the category \nshopping\n and the widget name \ncart_widget\n as above.\n\n\nWidget Files\n\n\nA newly created widget contains the following files:\n\n\n\n\nwidget.json\n\n\n\n\nThis \nwidget specification\n contains meta-data about your widget that is used by the LaxarJS framework.\n  It allows you to describe the configuration options of your widget features as a JSON schema.\n\n\n\n\nbower.json\n\n\n\n\nThis specifies the \ndependencies\n of your widget for use with \nBower\n.\n  While not used directly by LaxarJS, it is the key to automated and isolated widget tests.\n\n\n\n\ncart_widget.js\n\n\n\n\nThe \nbusiness logic\n of your shopping cart (like calculating a total or changing item quantities) as an \nAngularJS controller\n.\n  When your controller is instantiated by the LaxarJS runtime, it will receive an AngularJS scope (the model) and a reference to the event bus, which allows for communication with the world.\n  When built for release, all controllers and their RequireJS-dependencies are bundled into a single, compressed JavaScript file.\n\n\n\n\ndefault.theme/cart_widget.html\n\n\n\n\nThe \nAngularJS HTML template\n defining the \nappearance\n of your widget.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The \nBootstrap CSS\n classes are available by convention to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all), but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be preloaded within a single JSON file when your application is packaged for release.\n\n\n\n\ndefault.theme/(s)css/cart_widget.(s)css\n\n\n\n\nWidget-specific \nstyle definitions\n.\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS (or \nSCSS\n folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, the framework will load it when the widget is used in an application, and bundle it for release.\n\n\nLaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom \ntheme\n.\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead \nmore about themes\n once you are familiar with creating and using widgets.\n\n\nWidget Files for Testing\n\n\nThe sub folder \nspec\n contains the widget spec test and associated resources.\nNone of these files are loaded during regular application runtime:\n\n\n\n\nspec/spec_runner.html\n\n\n\n\nFor convenience, LaxarJS provides a spec runner for each new widget, to run jasmine spec tests in the browser.\n  This file does not need to be touched at all.\n\n\n\n\nspec/spec_runner.js\n\n\n\n\nConfiguration for the spec test.\n  This file needs to be modified only if widget-specific external dependencies are required during testing.\n\n\n\n\nspec/cart_widget_spec.js\n\n\n\n\nThis is the actual \njasmine\n spec test.\n  The test harness (providing a simulated LaxarJS event bus) has already been prepared for you.\n\n\nImplementing a Controller\n\n\nTo write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means\n\n\n\n\n\n\nsumming the contents of the cart\n\n\n\n\n\n\nincreasing or decreasing the quantity of individual positions within the cart.\n\n\n\n\n\n\nThe grunt-init template has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart, this might be an appropriate starting implementation based on some dummy data:\n\n\n// ...\n\n\n\nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n   \n$scope\n.\nmodel\n \n=\n \n[\n\n      \n{\n \nlabel\n:\n \nDairy Dreams\n,\n \nprice\n:\n \n5.25\n,\n \namount\n:\n \n1\n \n},\n\n      \n{\n \nlabel\n:\n \nMilky Mocha\n,\n \nprice\n:\n \n12.75\n,\n \namount\n:\n \n3\n \n},\n\n      \n{\n \nlabel\n:\n \nFreezing Frapp\u00e9\n,\n \nprice\n:\n \n18.25\n,\n \namount\n:\n \n1\n \n}\n\n   \n];\n\n\n   \n$scope\n.\nincrement\n \n=\n \nfunction\n(\n \nitem\n \n)\n \n{\n\n      \n++\nitem\n.\namount\n;\n\n   \n};\n\n\n   \n$scope\n.\ndecrement\n \n=\n \nfunction\n(\n \nitem\n \n)\n \n{\n\n      \nitem\n.\namount\n \n=\n \nMath\n.\nmax\n(\n \n0\n,\n \nitem\n.\namount\n \n-\n \n1\n \n);\n\n   \n};\n\n\n   \n$scope\n.\ntotal\n \n=\n \nfunction\n(\n \nrows\n \n)\n \n{\n\n      \nreturn\n \nrows\n.\nreduce\n(\n \nfunction\n(\n \nacc\n,\n \nnext\n \n)\n \n{\n\n         \nreturn\n \nacc\n \n+\n \nnext\n.\nprice\n*\nnext\n.\namount\n;\n\n      \n},\n \n0\n \n);\n\n   \n};\n\n\n}\n\n\n\n// ...\n\n\n\n\n\n\nWe can see that a widget controller in LaxarJS works just like any other AngularJS controller.\nOf course things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.\n\n\nCreating a Template\n\n\nThe purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:\n\n\nh4\n \nng-bind-html=\nfeatures.headline.htmlText\n/h4\n\n\ntable\n \nclass=\ntable\n\n   \nthead\n\n   \ntr\n\n      \nth\nBeverage\n/th\n\n      \nth\n \nclass=\ncart-price\nPrice\n/th\n\n      \nth\n \nclass=\ncart-amount\nAmount\n/th\n\n      \nth\n/th\n\n   \n/tr\n\n   \n/thead\n\n   \ntfoot\n\n   \ntr\n\n      \nth\n \ncolspan=\n3\n \nclass=\ncart-price\n{{ total( model ) }}\n/th\n\n      \nth\n/th\n\n   \n/tr\n\n   \n/tfoot\n\n   \ntr\n \nng-repeat=\nitem in model\n\n      \ntd\n{{ item.label }}\n/td\n\n      \ntd\n \nclass=\ncart-amount\n{{ item.amount }}\n/td\n\n      \ntd\n \nclass=\ncart-price\n{{ item.price }}\n/td\n\n      \ntd\n\n         \nbutton\n \ndata-ng-click=\ndecrement( item )\n \nclass=\nbtn btn-xs\ni\n \nclass=\nfa fa-minus\n \n/\n/button\n\n         \nbutton\n \ndata-ng-click=\nincrement( item )\n \nclass=\nbtn btn-xs\ni\n \nclass=\nfa fa-plus\n \n/\n/button\n\n      \n/td\n\n   \n/tr\n\n\n/table\n\n\n\n\n\n\nNote that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that \nmodel\n, \ndecrement\n, \nincrement\n and \ntotal\n will be available upon template instantiation.\nThe \nfeatures\n property used within the headline comes from the \nwidget configuration\n, which is described below.\n\n\nAdding Some Style\n\n\nA widget may be styled using CSS.\nLaxarJS supports generating the CSS from SCSS source files, allowing to place common definitions for font size, color and much more within a shared \"theme\" folder.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under \ndefault.theme/css/cart_widget.css\n.\nOnce you are familiar with the basics, read the article on \ncreating themes\n for more information.\n\n\nThanks to Bootstrap this widget does not require a lot of fancy styling:\n\n\n.cart-widget\n \n.cart-amount\n,\n\n\n.cart-widget\n \n.cart-price\n \n{\n\n   \ntext-align\n:\n \nright\n;\n\n\n}\n\n\n\n\n\n\nFor best encapsulation, selectors should be prefixed with the widget class (\ncart-widget\n) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here (\ncart-amount\n, \ncart-price\n), just as you would prefix custom AngularJS elements or attributes when creating a directive.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.\n\n\nConfiguration Options\n\n\nWhen looking at the template, you might have wondered where the \nfeatures.headline.htmlText\n came from.\nThis is a \nfeature configuration\n option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we make it configurable by adding a feature entry to the \nwidget.json\n:\n\n\n{\n\n   \nname\n:\n \nCartWidget\n,\n\n   \ndescription\n:\n \nAllows Users to Review and Modify Purchase Items\n,\n\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nheadline\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nhtmlText\n:\n \n{\n\n                  \ntype\n:\n \nstring\n,\n\n                  \ndescription\n:\n \nThe HTML headline content.\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe \nwidget features\n are a \nJSON schema\n document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.\nSee the \nreference section\n for details on the widget specification.\n\n\nChecking out the Result\n\n\nBefore we can take a look at the widget, we will need to integrate it into the page provided by the application template (\napplication/pages/page1.json\n).\n\n\n{\n\n   \nlayout\n:\n \none_column\n,\n\n\n   \nareas\n:\n \n{\n\n      \nactivities\n:\n \n[],\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[\n\n          \n{\n\n             \nwidget\n:\n \nshopping/cart_widget\n,\n\n             \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \nhtmlText\n:\n \nMy Shopping Cart\n\n                \n}\n\n             \n}\n\n          \n}\n\n      \n],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThere is another manual to learn more about \nwriting pages\n.\n\n\nNow we can start the development web server provided by LaxarJS, from the application root:\n\n\nnpm install \n# if you have not already\n\nnpm start\n\n\n\n\n\nNavigate to \nhttp://localhost:8000/debug.html\n to admire the fruits of your labor:\n\n\n\n\nNow that you have learned the basics in creating widgets, take a closer look at widget testing.\n\n\nTesting a Widget\n\n\nOne of the major goals of LaxarJS is to simplify the development \nand testing\n of isolated components.\nFor this reason, the testing infrastructure for your widget has already been added when using \ngrunt-init\n.\n\n\nWriting Spec-Tests\n\n\nLaxarJS contains a testing infrastructure to mock out the LaxarJS runtime, effectively running your widget in a sandbox or \ntest bed\n as it is called in LaxarJS.\nA skeleton spec is already provided for you:\nIt contains code to prepare the test bed with sample configuration and to instantiate your controller.\n\n\nTo mock out AngularJS services such as \n$http\n you can work with \nngMocks\n just like you would do without LaxarJS.\nTo add a simple test for our widget, replace the existing dummy test\n\n\nit\n(\n \nstill needs some tests.\n \n);\n\n\n\n\n\n\nwith a more useful spec:\n\n\nit\n(\n \nallows to calculate a total of its contents\n,\n \nfunction\n()\n \n{\n\n    \nexpect\n(\n \ntestBed_\n.\nscope\n.\ntotal\n(\n \ntestBed_\n.\nscope\n.\nmodel\n \n)\n \n).\ntoEqual\n(\n \n61.75\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nTests get more interesting when you instrument the testbed to publish mock events to be handled by the widget controller, and in turn to inspect events published by the widget.\nFor more details on testing event bus communication, refer to the \narticle on events\n.\n\n\nRunning the Test\n\n\nNow make sure that the development web server is still running and check out the test results using the \nprovided spec runner\n:\n\n\n\n\nAlternatively, you can run the tests for all your widgets from the command line:\n\n\nnpm\n \ntest\n\n\n\n\n\n\nLaxarJS provides \ngrunt tasks\n for testing that automatically set up and run \nPhantomJS\n for you, so you should not run into problems accessing the DOM.\nHopefully this makes it simple to set up continuous integration for your application.\n\n\n\n\nLaxarJS Widget Reference\n\n\nBuilding on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and of the LaxarJS test bed.\n\n\nThe Widget Scope\n\n\nThe widget controller and the template have access to the widget scope.\nThe scope may be used by widget controllers to communicate with directives such as \nngForm\n.\nTo avoid entanglement, multiple widgets (even if nested) do \nnot\n communicate through the scope but \nalways use the event bus\n for this.\n\n\n\n\n$scope.eventBus\n\n\n\n\nMost of the time, this is the only LaxarJS scope property used by widget controllers.\n  Of course, controllers will almost always add their own properties.\n\n\n\n\n$scope.widget.id\n\n\n\n\nA unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect \nlabel\n and \ninput\n elements in an HTML form.\n\n\nThe Widget Specification Format\n\n\nEach widget has a \nwidget.json\n file which is also called \nwidget specification\n.\nLaxarJS contains a \nwidget schema definition\n that defines the exact format of this file.\nThese are the most important widget properties:\n\n\n\n\nname\n\n\n\n\nThis required field contains the \nCamelCase\n version of the widget's directory name.\n\n\n\n\ndescription\n\n\n\n\nWhat this widget is about.\n  Ideally, this contains the main \nuser-goal\n mentioned in the first section.\n\n\n\n\nfeatures\n\n\n\n\nThe widget features.\n  This is a JSON schema document that documents all configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.\n\n\n\n\ncompatibility\n\n\n\n\nAn optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to \nopt in\n to breaking LaxarJS changes (similarly to the Python \nimport from future\n construct), without harming widgets that do not yet support these changes.\n\n\n\n\ncontrols\n\n\n\n\nAn optional list of LaxarJS controls used by this widget.\n  Each control is represented by its RequireJS path.\n  This allows the LaxarJS runtime to automatically load the AngularJS modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to \nProviding Controls\n for on loading user interface components and their resources in this manner.\n\n\nThe LaxarJS Widget Test Bed\n\n\nThe LaxarJS spec test boilerplate (provided for you by grunt-init) creates a \ntestBed_\n instance which is re-initialized prior to running each test case.\nIt has the following essential properties.\n\n\n\n\ntestBed_.featuresMock\n\n\n\n\nContains the feature configuration for use during the spec test, to be specified by the author of the test.\n  It has the same format that would be provided through the page definition within an actual application.\n  Note that \nfeaturesMock\n must be set before calling \ntestBed_.setup()\n.\n\n\n\n\ntestBed_.setup()\n\n\n\n\nCreates the widget controller.\n  Afterwards, the \ntestBed_.scope\n is available.\n  This simulates navigating to a page that contains an instance of the widget under test.\n\n\n\n\ntestBed_.tearDown()\n\n\n\n\nDestroys the widget controller.\n  This is the testing equivalent to navigating away from the page that contains the widget instance.\n\n\n\n\ntestBed_.scope\n\n\n\n\nThe AngularJS scope that was created for this widget.\n  This allows to inspect widget state in white-box tests.\n\n\n\n\ntestBed_.eventBusMock\n\n\n\n\nA handle to the LaxarJS event bus that allows spec tests to simulate other widgets on the same page.\n  Through it, the spec test can publish events for manipulating the widget, and in turn subscribe to events published by the widget controller.\n  This is different from the \ntestBed_.scope.eventBus\n handle which is used by the widget controller.\n  Tests may use \nspyOn\n on the scope event bus to monitor widget behaviour directly, or interact with the \neventBusMock\n to communicate with the widget indirectly.", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widgets-and-activities", 
            "text": "Widgets and activities are the  \"work horse\"  of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-responsibilities", 
            "text": "Before starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question:  What goal does this widget help the user to accomplish? \nAre you thinking about a very broadly applicable, technical task such as  \"allow the user to enter a date\"  or  \"allow the user to delete a data row\" ?\nIn this case you might want to implement this functionality as a  control  (an AngularJS directive or an HTML5 web component) and use it  within  one or more of your widgets.  Usually, widgets correspond to significant areas of the screen and are composed from multiple controls.\nThey are built with a  specific user-goal  in mind, such as  \"allow the user to book a flight\"  or  \"allow the user to review shopping cart contents\" .\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of the thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?", 
            "title": "Widget Responsibilities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#when-to-use-activities", 
            "text": "Activities are  \"invisible widgets\"  that are used to  fetch and manage application resources .\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nThis makes activities perform a role similar to AngularJS services.\nThe advantage over services is that using activities puts the  page author  in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.\nAlthough these configurations are not impossible to achieve using AngularJS dependency injection and -services, using LaxarJS activities makes the connections declarative and visible.  Activities may also serve as a  mediator  between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.", 
            "title": "When to use Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#how-to-create-a-widget", 
            "text": "The easiest way to create a widget is to use the appropriate  grunt-init  template.\nCheck out the  README  on how to obtain the grunt-init templates and on creating an application.  Start by creating a sub-directory for your new widget within the LaxarJS application.\nEach widget in an application lives within a sub-folder of the  widget root  ( includes/widgets  by default).\nTo change the widget root you can modify the RequireJS-path  'laxar-path-widgets'  in the require configuration.\nThe widget path  includes/widgets/shopping/cart_widget  is used as an example path throughout this manual.  The sub-directory  shopping  is the  widget category  in the example path.\nCategories allow to organize widgets by their general business area, for example  shopping ,  social ,  finance  and so on.\nThe last component of the widget path is the  widget name :\nIt has to be unique throughout an application and must be written in lower case letters with components separated by underscores.\nRegular widget names always end in  _widget  whereas activities always end in  _activity .  To create the actual widget, run:  grunt-init laxar-widget  A wizard will ask for some details on the widget such as license and author, but you can always edit this information in the widget sources afterwards.\nIn the following steps, it is assumed that you used the category  shopping  and the widget name  cart_widget  as above.", 
            "title": "How to Create a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files", 
            "text": "A newly created widget contains the following files:   widget.json   This  widget specification  contains meta-data about your widget that is used by the LaxarJS framework.\n  It allows you to describe the configuration options of your widget features as a JSON schema.   bower.json   This specifies the  dependencies  of your widget for use with  Bower .\n  While not used directly by LaxarJS, it is the key to automated and isolated widget tests.   cart_widget.js   The  business logic  of your shopping cart (like calculating a total or changing item quantities) as an  AngularJS controller .\n  When your controller is instantiated by the LaxarJS runtime, it will receive an AngularJS scope (the model) and a reference to the event bus, which allows for communication with the world.\n  When built for release, all controllers and their RequireJS-dependencies are bundled into a single, compressed JavaScript file.   default.theme/cart_widget.html   The  AngularJS HTML template  defining the  appearance  of your widget.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The  Bootstrap CSS  classes are available by convention to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all), but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be preloaded within a single JSON file when your application is packaged for release.   default.theme/(s)css/cart_widget.(s)css   Widget-specific  style definitions .\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS (or  SCSS  folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, the framework will load it when the widget is used in an application, and bundle it for release.  LaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom  theme .\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead  more about themes  once you are familiar with creating and using widgets.", 
            "title": "Widget Files"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files-for-testing", 
            "text": "The sub folder  spec  contains the widget spec test and associated resources.\nNone of these files are loaded during regular application runtime:   spec/spec_runner.html   For convenience, LaxarJS provides a spec runner for each new widget, to run jasmine spec tests in the browser.\n  This file does not need to be touched at all.   spec/spec_runner.js   Configuration for the spec test.\n  This file needs to be modified only if widget-specific external dependencies are required during testing.   spec/cart_widget_spec.js   This is the actual  jasmine  spec test.\n  The test harness (providing a simulated LaxarJS event bus) has already been prepared for you.", 
            "title": "Widget Files for Testing"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#implementing-a-controller", 
            "text": "To write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means    summing the contents of the cart    increasing or decreasing the quantity of individual positions within the cart.    The grunt-init template has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart, this might be an appropriate starting implementation based on some dummy data:  // ...  function   Controller (   $scope   )   { \n    $scope . model   =   [ \n       {   label :   Dairy Dreams ,   price :   5.25 ,   amount :   1   }, \n       {   label :   Milky Mocha ,   price :   12.75 ,   amount :   3   }, \n       {   label :   Freezing Frapp\u00e9 ,   price :   18.25 ,   amount :   1   } \n    ]; \n\n    $scope . increment   =   function (   item   )   { \n       ++ item . amount ; \n    }; \n\n    $scope . decrement   =   function (   item   )   { \n       item . amount   =   Math . max (   0 ,   item . amount   -   1   ); \n    }; \n\n    $scope . total   =   function (   rows   )   { \n       return   rows . reduce (   function (   acc ,   next   )   { \n          return   acc   +   next . price * next . amount ; \n       },   0   ); \n    };  }  // ...   We can see that a widget controller in LaxarJS works just like any other AngularJS controller.\nOf course things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.", 
            "title": "Implementing a Controller"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#creating-a-template", 
            "text": "The purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:  h4   ng-bind-html= features.headline.htmlText /h4  table   class= table \n    thead \n    tr \n       th Beverage /th \n       th   class= cart-price Price /th \n       th   class= cart-amount Amount /th \n       th /th \n    /tr \n    /thead \n    tfoot \n    tr \n       th   colspan= 3   class= cart-price {{ total( model ) }} /th \n       th /th \n    /tr \n    /tfoot \n    tr   ng-repeat= item in model \n       td {{ item.label }} /td \n       td   class= cart-amount {{ item.amount }} /td \n       td   class= cart-price {{ item.price }} /td \n       td \n          button   data-ng-click= decrement( item )   class= btn btn-xs i   class= fa fa-minus   / /button \n          button   data-ng-click= increment( item )   class= btn btn-xs i   class= fa fa-plus   / /button \n       /td \n    /tr  /table   Note that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that  model ,  decrement ,  increment  and  total  will be available upon template instantiation.\nThe  features  property used within the headline comes from the  widget configuration , which is described below.", 
            "title": "Creating a Template"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#adding-some-style", 
            "text": "A widget may be styled using CSS.\nLaxarJS supports generating the CSS from SCSS source files, allowing to place common definitions for font size, color and much more within a shared \"theme\" folder.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under  default.theme/css/cart_widget.css .\nOnce you are familiar with the basics, read the article on  creating themes  for more information.  Thanks to Bootstrap this widget does not require a lot of fancy styling:  .cart-widget   .cart-amount ,  .cart-widget   .cart-price   { \n    text-align :   right ;  }   For best encapsulation, selectors should be prefixed with the widget class ( cart-widget ) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here ( cart-amount ,  cart-price ), just as you would prefix custom AngularJS elements or attributes when creating a directive.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.", 
            "title": "Adding Some Style"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#configuration-options", 
            "text": "When looking at the template, you might have wondered where the  features.headline.htmlText  came from.\nThis is a  feature configuration  option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we make it configurable by adding a feature entry to the  widget.json :  { \n    name :   CartWidget , \n    description :   Allows Users to Review and Modify Purchase Items , \n\n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          headline :   { \n             type :   object , \n             properties :   { \n                htmlText :   { \n                   type :   string , \n                   description :   The HTML headline content. \n                } \n             } \n          } \n       } \n    }  }   The  widget features  are a  JSON schema  document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.\nSee the  reference section  for details on the widget specification.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#checking-out-the-result", 
            "text": "Before we can take a look at the widget, we will need to integrate it into the page provided by the application template ( application/pages/page1.json ).  { \n    layout :   one_column , \n\n    areas :   { \n       activities :   [], \n       header :   [], \n       content :   [ \n           { \n              widget :   shopping/cart_widget , \n              features :   { \n                 headline :   { \n                    htmlText :   My Shopping Cart \n                 } \n              } \n           } \n       ], \n       footer :   [] \n    }  }   There is another manual to learn more about  writing pages .  Now we can start the development web server provided by LaxarJS, from the application root:  npm install  # if you have not already \nnpm start  Navigate to  http://localhost:8000/debug.html  to admire the fruits of your labor:   Now that you have learned the basics in creating widgets, take a closer look at widget testing.", 
            "title": "Checking out the Result"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#testing-a-widget", 
            "text": "One of the major goals of LaxarJS is to simplify the development  and testing  of isolated components.\nFor this reason, the testing infrastructure for your widget has already been added when using  grunt-init .", 
            "title": "Testing a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#writing-spec-tests", 
            "text": "LaxarJS contains a testing infrastructure to mock out the LaxarJS runtime, effectively running your widget in a sandbox or  test bed  as it is called in LaxarJS.\nA skeleton spec is already provided for you:\nIt contains code to prepare the test bed with sample configuration and to instantiate your controller.  To mock out AngularJS services such as  $http  you can work with  ngMocks  just like you would do without LaxarJS.\nTo add a simple test for our widget, replace the existing dummy test  it (   still needs some tests.   );   with a more useful spec:  it (   allows to calculate a total of its contents ,   function ()   { \n     expect (   testBed_ . scope . total (   testBed_ . scope . model   )   ). toEqual (   61.75   );  }   );   Tests get more interesting when you instrument the testbed to publish mock events to be handled by the widget controller, and in turn to inspect events published by the widget.\nFor more details on testing event bus communication, refer to the  article on events .", 
            "title": "Writing Spec-Tests"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#running-the-test", 
            "text": "Now make sure that the development web server is still running and check out the test results using the  provided spec runner :   Alternatively, you can run the tests for all your widgets from the command line:  npm   test   LaxarJS provides  grunt tasks  for testing that automatically set up and run  PhantomJS  for you, so you should not run into problems accessing the DOM.\nHopefully this makes it simple to set up continuous integration for your application.", 
            "title": "Running the Test"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#laxarjs-widget-reference", 
            "text": "Building on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and of the LaxarJS test bed.", 
            "title": "LaxarJS Widget Reference"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-widget-scope", 
            "text": "The widget controller and the template have access to the widget scope.\nThe scope may be used by widget controllers to communicate with directives such as  ngForm .\nTo avoid entanglement, multiple widgets (even if nested) do  not  communicate through the scope but  always use the event bus  for this.   $scope.eventBus   Most of the time, this is the only LaxarJS scope property used by widget controllers.\n  Of course, controllers will almost always add their own properties.   $scope.widget.id   A unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect  label  and  input  elements in an HTML form.", 
            "title": "The Widget Scope"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-widget-specification-format", 
            "text": "Each widget has a  widget.json  file which is also called  widget specification .\nLaxarJS contains a  widget schema definition  that defines the exact format of this file.\nThese are the most important widget properties:   name   This required field contains the  CamelCase  version of the widget's directory name.   description   What this widget is about.\n  Ideally, this contains the main  user-goal  mentioned in the first section.   features   The widget features.\n  This is a JSON schema document that documents all configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.   compatibility   An optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to  opt in  to breaking LaxarJS changes (similarly to the Python  import from future  construct), without harming widgets that do not yet support these changes.   controls   An optional list of LaxarJS controls used by this widget.\n  Each control is represented by its RequireJS path.\n  This allows the LaxarJS runtime to automatically load the AngularJS modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to  Providing Controls  for on loading user interface components and their resources in this manner.", 
            "title": "The Widget Specification Format"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-laxarjs-widget-test-bed", 
            "text": "The LaxarJS spec test boilerplate (provided for you by grunt-init) creates a  testBed_  instance which is re-initialized prior to running each test case.\nIt has the following essential properties.   testBed_.featuresMock   Contains the feature configuration for use during the spec test, to be specified by the author of the test.\n  It has the same format that would be provided through the page definition within an actual application.\n  Note that  featuresMock  must be set before calling  testBed_.setup() .   testBed_.setup()   Creates the widget controller.\n  Afterwards, the  testBed_.scope  is available.\n  This simulates navigating to a page that contains an instance of the widget under test.   testBed_.tearDown()   Destroys the widget controller.\n  This is the testing equivalent to navigating away from the page that contains the widget instance.   testBed_.scope   The AngularJS scope that was created for this widget.\n  This allows to inspect widget state in white-box tests.   testBed_.eventBusMock   A handle to the LaxarJS event bus that allows spec tests to simulate other widgets on the same page.\n  Through it, the spec test can publish events for manipulating the widget, and in turn subscribe to events published by the widget controller.\n  This is different from the  testBed_.scope.eventBus  handle which is used by the widget controller.\n  Tests may use  spyOn  on the scope event bus to monitor widget behaviour directly, or interact with the  eventBusMock  to communicate with the widget indirectly.", 
            "title": "The LaxarJS Widget Test Bed"
        }, 
        {
            "location": "/manuals/writing_compositions/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWriting Pages\n\n\n\n\nWriting Compositions\n\n\nAlthough inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this is not sufficient.\nVery often most of a base page fits for all pages but some small things need to be adjusted for some of the pages that could otherwise be reused throughout the application.\nAnother use case is to enable the reuse of a bundle of widgets multiple times within one page, each time only with some different configuration.\n\n\nAll of this can be achieved by using compositions.\nThe idea behind compositions is, that they provide a widget like interface regarding their addition to a page (or another composition) and the internals of a page fragment, bundling some widgets and other compositions.\nA composition thus has two basic properties: \nareas\n, like a page and \nfeatures\n like a widget.\nA third more advanced property, namely \nmergedFeatures\n, will be explained later.\n\n\nInstead we will start with the simple \npopup_composition\n we referenced above:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/popup_widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis example already shows some of the additional characteristics that go beyond the two properties \nfeatures\n and \nareas\n.\nLet us start from the beginning:\n\n\nFirst there is the \nfeatures\n object, that for simple cases looks just like a feature specification of a widget.\nHere you can define all the features that your composition needs to be configurable from the outside.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.\n\n\nSecondly there is the \nareas\n map and here there is already something noteworthy: The first area is simply named \n.\n.\nAll widgets and compositions within this special area will replace the reference of the composition within the area of the page including the composition.\nSo if we take the \nlast example\n of the chapter \nLayouts and Areas\n, this will be the area named \ncontent\n.\n\n\nFurthermore the two strings \n\"${features.openPopup.onActions}\"\n and \n\"${topic:closeAction}\"\n are worth noticing as they demonstrate another main feature of the composition concept.\nThose strings are expressions that will be evaluated by the page loader when assembling the complete page from its parts and are replaced by actual values as follows:\nThe \n\"${features.openPopup.onActions}\"\n expression is a reference to a feature defined within the \nfeatures\n object and will hold the value configured in the page including the composition.\nThus applied to the \nexample of the writing pages manual\n, this will result in the array \n[ \"next\" ]\n.\nOn the other hand the \n\"${topic:closeAction}\"\n expression generates a page wide unique event topic compatible string based on the local identifier \ncloseAction\n.\nThe result could thus be something like \n\"popupCompositionId0CloseAction\"\n which in fact is the id generated for the composition plus the local identifier.\nThese topic expressions should always be used when there is the need to have an identifier that is only used within the scope of a composition to prevent naming collisions with topics of the page, other compositions or multiple usages of this composition within the same page.\n\n\nNotice that these expressions are only written as a string to be JSON compatible and that no string interpolation takes place.\nThus something like \n\"myPrefix${topic:closeAction}\"\nwould not be interpreted when assembling the page and simply be used as is.\n\n\nThe assembled page thus looks similar to this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/popup_widget\n,\n\n            \nid\n:\n \npopupCompositionId0Popup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \npopupCompositionId0CloseAction\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopupCompositionId0Popup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \npopupCompositionId0CloseAction\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nNote how also the id of the exported area was automatically adjusted to \n\"popupCompositionId0Popup.content\"\n to prevent naming clashes.\n\n\nIn our example it is currently only possible to close the \nPopupWidget\n from within itself via an action event published by the \nCommandBarWidget\n.\nWhat if we additionally would like to close the popup on demand from outside based on another action?\nThis is where the concept of \nmerged features\n comes into play.\n\nMerged features\n allow us to merge or better concatenate two arrays, where one array is defined as a feature for the composition and the second array is defined in the \nmergedFeatures\n object.\nSyntactically this is achieved via a map under the key \nmergedFeatures\n where the key of each entry is the path to the array in the features and the value is the array to merge this value with.\n\n\nThis should become clear when looking at our adjusted example:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \nclosePopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n\n                  \n},\n\n                  \ndefault\n:\n \n[]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nmergedFeatures\n:\n \n{\n\n      \nclosePopup.onActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/popup_widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n${features.closePopup.onActions}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHere we added the possibility to configured close actions for the \nPopupWidget\n as feature \nclosePopup.onActions\n.\nFor this we then added an entry in the \nmergedFeatures\n map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the \nPopupWidget\n.\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the \nopenPopup.onActions\n feature.\nFor the configuration of the \nCommandBarWidget\n nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.\n\n\nAppendix:\n\n\nExemplary page from \nwriting pages\n manual\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#writing-compositions", 
            "text": "Although inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this is not sufficient.\nVery often most of a base page fits for all pages but some small things need to be adjusted for some of the pages that could otherwise be reused throughout the application.\nAnother use case is to enable the reuse of a bundle of widgets multiple times within one page, each time only with some different configuration.  All of this can be achieved by using compositions.\nThe idea behind compositions is, that they provide a widget like interface regarding their addition to a page (or another composition) and the internals of a page fragment, bundling some widgets and other compositions.\nA composition thus has two basic properties:  areas , like a page and  features  like a widget.\nA third more advanced property, namely  mergedFeatures , will be explained later.  Instead we will start with the simple  popup_composition  we referenced above:  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string \n                   } \n                } \n             } \n          } \n       } \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   portal/popup_widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   [   ${topic:closeAction}   ] \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   This example already shows some of the additional characteristics that go beyond the two properties  features  and  areas .\nLet us start from the beginning:  First there is the  features  object, that for simple cases looks just like a feature specification of a widget.\nHere you can define all the features that your composition needs to be configurable from the outside.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.  Secondly there is the  areas  map and here there is already something noteworthy: The first area is simply named  . .\nAll widgets and compositions within this special area will replace the reference of the composition within the area of the page including the composition.\nSo if we take the  last example  of the chapter  Layouts and Areas , this will be the area named  content .  Furthermore the two strings  \"${features.openPopup.onActions}\"  and  \"${topic:closeAction}\"  are worth noticing as they demonstrate another main feature of the composition concept.\nThose strings are expressions that will be evaluated by the page loader when assembling the complete page from its parts and are replaced by actual values as follows:\nThe  \"${features.openPopup.onActions}\"  expression is a reference to a feature defined within the  features  object and will hold the value configured in the page including the composition.\nThus applied to the  example of the writing pages manual , this will result in the array  [ \"next\" ] .\nOn the other hand the  \"${topic:closeAction}\"  expression generates a page wide unique event topic compatible string based on the local identifier  closeAction .\nThe result could thus be something like  \"popupCompositionId0CloseAction\"  which in fact is the id generated for the composition plus the local identifier.\nThese topic expressions should always be used when there is the need to have an identifier that is only used within the scope of a composition to prevent naming collisions with topics of the page, other compositions or multiple usages of this composition within the same page.  Notice that these expressions are only written as a string to be JSON compatible and that no string interpolation takes place.\nThus something like  \"myPrefix${topic:closeAction}\" would not be interpreted when assembling the page and simply be used as is.  The assembled page thus looks similar to this:  { \n    layout :   popups/layout_one , \n    areas :   { \n       header :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             widget :   portal/popup_widget , \n             id :   popupCompositionId0Popup , \n             features :   { \n                open :   { \n                   onActions :   [   next   ] \n                }, \n                close :   { \n                   onActions :   [   popupCompositionId0CloseAction   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   portal/html_display_widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ], \n       popupCompositionId0Popup.content :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   popupCompositionId0CloseAction \n                } \n             } \n          } \n       ] \n    }  }   Note how also the id of the exported area was automatically adjusted to  \"popupCompositionId0Popup.content\"  to prevent naming clashes.  In our example it is currently only possible to close the  PopupWidget  from within itself via an action event published by the  CommandBarWidget .\nWhat if we additionally would like to close the popup on demand from outside based on another action?\nThis is where the concept of  merged features  comes into play. Merged features  allow us to merge or better concatenate two arrays, where one array is defined as a feature for the composition and the second array is defined in the  mergedFeatures  object.\nSyntactically this is achieved via a map under the key  mergedFeatures  where the key of each entry is the path to the array in the features and the value is the array to merge this value with.  This should become clear when looking at our adjusted example:  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string \n                   } \n                } \n             } \n          }, \n          closePopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string \n                   }, \n                   default :   [] \n                } \n             } \n          } \n       } \n    }, \n    mergedFeatures :   { \n       closePopup.onActions :   [   ${topic:closeAction}   ] \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   portal/popup_widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   ${features.closePopup.onActions} \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   Here we added the possibility to configured close actions for the  PopupWidget  as feature  closePopup.onActions .\nFor this we then added an entry in the  mergedFeatures  map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the  PopupWidget .\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the  openPopup.onActions  feature.\nFor the configuration of the  CommandBarWidget  nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#appendix", 
            "text": "", 
            "title": "Appendix:"
        }, 
        {
            "location": "/manuals/writing_compositions/#exemplary-page-from-writing-pages-manual", 
            "text": "{ \n    layout :   popups/layout_one , \n    areas :   { \n       header :   [ \n          { \n             widget :   portal/headline_widget , \n             features :   { \n                headline :   { \n                   htmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   portal/command_bar_widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             composition :   popup_composition , \n             features :   { \n                openPopup :   { \n                   onActions :   [   next   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   portal/html_display_widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ] \n    }  }", 
            "title": "Exemplary page from writing pages manual"
        }, 
        {
            "location": "/manuals/writing_pages/", 
            "text": "\u00ab return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nWriting Pages\n\n\nPages are written in a declarative fashion using the JSON format.\nStarting point is a simple object and some specific properties that will be explained in this document.\n\n\nLayouts and Areas\n\n\nFirst of all a page should specify the layout which defines the available widget areas and how they are arranged visually when rendered by the web browser.\nIf a page is intended to be used as a base page for \ninheritance\n, the layout property should be omitted.\nThis is because only one page in an extension chain may define a layout and this most probably will be one at the bottom of the hierarchy.\n\n\nConfiguring the layout is done via the \nlayout\n property of the page object.\nIts value is the name of the layout which is in turn a relative path within the layout folder to where the specific layout's assets are located.\nIf for example the desired layout is located at \npopups/layout_one\n, the according page (without any widgets yet) would look like this:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n\n\n}\n\n\n\n\n\n\nNow let us assume the html file of \npopups/layout_one\n looks like this:\n\n\n\n\ndiv\n\n   \ndiv\n \nax-widget-area=\nheader\n/div\n\n   \ndiv\n \nax-widget-area=\ncontent\n/div\n\n   \ndiv\n \nax-widget-area=\nfooter\n/div\n\n\n/div\n\n\n\n\n\n\nObviously there are three areas available, that can be occupied by widgets on the page.\nTo do so, we add another top-level key \nareas\n parallel to\nlayout\n.\nIts value is a map, where each key is the name of a widget area defined in the layout and the values are arrays, that will later list the widgets to render.\nWithout any widgets yet, We thus get the following page file:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWhen adding widgets to an area, the order is important, as this is the order in which the widgets will be rendered in the DOM.\nEach entry in the array is an object that can either reference a widget or a \ncomposition\n.\nIt thus needs to specify either \nwidget\n or \ncomposition\n as key.\nAdditionally a page wide unique (even over inheritance) \nid\n property can be provided.\nThis can be useful for debugging and is mandatory in case a widget provides one or more embedded areas (like e.g. a popover widget), which is explained in detail in \nTODO\n.\nFinally it is possible to provide the configuration for features of a widget or a composition under the key \nfeatures\n.\n\n\nHere is the example with some simple, exemplary content:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe object under \nfeatures\n needs to satisfy the schema defined for the features of the according widget in the file \nwidget.json\n.\nWhen loading a page and its widgets, LaxarJS will actually validate the configuration provided in the page against the widget's schema and throw an error in case one or more constraints are violated.\n\n\nInheritance\n\n\nThe most simple way to reuse parts of a page specification is by inheritance.\nDue to the intentional lack of complex additional inheritance features it is also the most limited way of specification reuse.\nNevertheless it has its valid use cases as in every user interface there are some elements that never change across pages.\nThese should be extracted into one or more base pages, that define no layout and can be reused by all other pages defining the layout necessary to display their contents.\n\n\nValid candidate widgets for base pages are application headlines, informational notes in a footer area or activities providing common tasks for all pages.\nLet us apply this to our example from above and extract the \nHeadlineWidget\n into a base page called \nbase_page.json\n.\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWe now can modify our original page using the keyword \nextends\n that references the base page relatively to the root path for all pages.\nThe parts already provided by the base page can then be deleted:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nextends\n:\n \nbase_page\n,\n\n   \nareas\n:\n \n{\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/command_bar_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/html_display_widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIt is also possible to add widgets to an area, that is already filled with one or more widgets in the base page.\nThose widgets in the extending page will be appended to the according area and thus appear after the base widgets in the DOM.\nIf a widget of the extending page should explicitly be added before another widget of a base page, this can be achieved using the keyword \ninsertBeforeId\n.\nNote that for this to work it's necessary to provide an \nid\n property for the according widget in the base page.\n\n\nLet us assume we wanted to add another additional headline in one extending page.\nWe therefore change the base page first and add an id to the existing headline:\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \nid\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \nhtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHence the page that has the need to add content can reference the given id using \ninsertBeforeId\n like this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nextends\n:\n \nbase_page\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nportal/headline_widget\n,\n\n            \ninsertBeforeId\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \nhtmlText\n:\n \nYou just won one billion dollar!\n\n                \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n \n ... some widgets ... \n \n],\n\n      \nfooter\n:\n \n[\n \n ... some widgets ... \n \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis is all one needs to know to build basic pages for LaxarJS.\nIt might become necessary to split pages into smaller, possibly reusable chunks, which is the task compositions where designed for.\nSo if the need arises, read on in the manual for \nwriting compositions\n.", 
            "title": "Writing Pages"
        }, 
        {
            "location": "/manuals/writing_pages/#writing-pages", 
            "text": "Pages are written in a declarative fashion using the JSON format.\nStarting point is a simple object and some specific properties that will be explained in this document.", 
            "title": "Writing Pages"
        }
    ]
}