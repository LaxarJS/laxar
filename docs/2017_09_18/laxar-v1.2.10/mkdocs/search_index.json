{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS \n\n\n\n\nMiddleware for your web client:\n Create maintainable applications from small, isolated parts.\n\n\n\n\nWhy LaxarJS?\n\n\nFind out \nwhy\n you would use LaxarJS and if it's the right tool for you.\nThen, explore the \ncore concepts\n and browse the \nmanuals\n in the \ndocumentation\n.\n\n\nHave a look at the \nLaxarJS homepage\n for demos and more information.\n\n\nGetting Started\n\n\nThe following is a very minimal getting started guide.\nIt helps you to set up your first LaxarJS application and to create your first LaxarJS widget.\n\n\nGet the Prerequisites\n\n\nThe node package manager \nnpm\n is required to get started with LaxarJS.\nFirst we use it to obtain some basic development tools, namely \nYeoman\n and \ngrunt-cli\n, as well as the Yeoman generator for LaxarJS.\n\n\nnpm install -g grunt-cli yo\nnpm install -g generator-laxarjs\n\n\n\n\n\nNote that\n, depending on your workstation setup, you might have to use \nsudo\n when running \nnpm install\n with the \n-g\n option.\nMake sure that your \nPATH\n includes the global \nnode_modules/bin\n directory.\nFor additional information and troubleshooting, consult the documentation of \nnpm\n and \nYeoman\n respectively. \n\n\nCreate a LaxarJS Application from Our Template\n\n\nThe scaffolding tool \nyo\n can now be used to create artifacts from the LaxarJS templates.\nWhen asked if you would like to create example widgets, answer with \nYes\n.\n\n\nmkdir tryout\n\ncd \ntryout\nyo laxarjs\nnpm install\nnpm start\n\n\n\n\n\nVisit your fresh application at \nhttp://localhost:8000/debug.html\n.\n\n\nPress \nCtrl-C\n to stop the server for now.\n\n\nCreate your own LaxarJS widget\n\n\nCreate a widget which simply displays \nHello, world\n:\n\n\nyo laxarjs:widget\n\n\n\n\n\nAsked for the widget name, let's try \nmy-first-widget\n.\n\n\nAdd some widget-HTML:\n\n\necho\n \nh1\nHello, world!\n/h1\n \n includes/widgets/my-first-widget/default.theme/my-first-widget.html\n\n\n\n\n\nAdd the widget to the page \napplication/pages/example1.json\n, so that it looks like this:\n\n\n{\n\n   \nlayout\n:\n \ntwo-columns\n,\n\n   \nareas\n:\n \n{\n\n      \nleft\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nmy-first-widget\n\n         \n}\n\n      \n],\n\n      \n// ...\n\n   \n}\n\n\n}\n\n\n\n\n\n\nNow you may start the development server again:\n\n\nnpm start\n\n\n\n\n\nSee your \nHello, World!\n widget in action at \nhttp://localhost:8000/debug.html\n\n\nCreate a Compressed Release-Ready Version of Your Application\n\n\nFirst, stop the development server using \nCtrl-C\n.\n\n\ngrunt optimize\nnpm start\n\n\n\n\n\nNow, your production-ready application can be visited at \nhttp://localhost:8000/index.html\n.\nYou can also use \ngrunt dist\n to get a zip archive containing the application without development server and build tools.\n\n\nNext Steps\n\n\nHave fun developing your first LaxarJS application.\n\n\nMake sure to have a look at the \nmanuals\n and and check out the demo applications on the \nLaxarJS website\n.\nIf you're already developing your first widgets and want to know which programmatic APIs are provided by LaxarJS, have a look at the \nAPI docs\n.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs", 
            "text": "Middleware for your web client:  Create maintainable applications from small, isolated parts.", 
            "title": "LaxarJS"
        }, 
        {
            "location": "/#why-laxarjs", 
            "text": "Find out  why  you would use LaxarJS and if it's the right tool for you.\nThen, explore the  core concepts  and browse the  manuals  in the  documentation .  Have a look at the  LaxarJS homepage  for demos and more information.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/#getting-started", 
            "text": "The following is a very minimal getting started guide.\nIt helps you to set up your first LaxarJS application and to create your first LaxarJS widget.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#get-the-prerequisites", 
            "text": "The node package manager  npm  is required to get started with LaxarJS.\nFirst we use it to obtain some basic development tools, namely  Yeoman  and  grunt-cli , as well as the Yeoman generator for LaxarJS.  npm install -g grunt-cli yo\nnpm install -g generator-laxarjs  Note that , depending on your workstation setup, you might have to use  sudo  when running  npm install  with the  -g  option.\nMake sure that your  PATH  includes the global  node_modules/bin  directory.\nFor additional information and troubleshooting, consult the documentation of  npm  and  Yeoman  respectively.", 
            "title": "Get the Prerequisites"
        }, 
        {
            "location": "/#create-a-laxarjs-application-from-our-template", 
            "text": "The scaffolding tool  yo  can now be used to create artifacts from the LaxarJS templates.\nWhen asked if you would like to create example widgets, answer with  Yes .  mkdir tryout cd  tryout\nyo laxarjs\nnpm install\nnpm start  Visit your fresh application at  http://localhost:8000/debug.html .  Press  Ctrl-C  to stop the server for now.", 
            "title": "Create a LaxarJS Application from Our Template"
        }, 
        {
            "location": "/#create-your-own-laxarjs-widget", 
            "text": "Create a widget which simply displays  Hello, world :  yo laxarjs:widget  Asked for the widget name, let's try  my-first-widget .  Add some widget-HTML:  echo   h1 Hello, world! /h1    includes/widgets/my-first-widget/default.theme/my-first-widget.html  Add the widget to the page  application/pages/example1.json , so that it looks like this:  { \n    layout :   two-columns , \n    areas :   { \n       left :   [ \n          { \n             widget :   my-first-widget \n          } \n       ], \n       // ... \n    }  }   Now you may start the development server again:  npm start  See your  Hello, World!  widget in action at  http://localhost:8000/debug.html", 
            "title": "Create your own LaxarJS widget"
        }, 
        {
            "location": "/#create-a-compressed-release-ready-version-of-your-application", 
            "text": "First, stop the development server using  Ctrl-C .  grunt optimize\nnpm start  Now, your production-ready application can be visited at  http://localhost:8000/index.html .\nYou can also use  grunt dist  to get a zip archive containing the application without development server and build tools.", 
            "title": "Create a Compressed Release-Ready Version of Your Application"
        }, 
        {
            "location": "/#next-steps", 
            "text": "Have fun developing your first LaxarJS application.  Make sure to have a look at the  manuals  and and check out the demo applications on the  LaxarJS website .\nIf you're already developing your first widgets and want to know which programmatic APIs are provided by LaxarJS, have a look at the  API docs .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv1.2.10\n\n\n\n\n#371\n: flow: fixed URL encoding of place parameter values\n\n\n\n\nv1.2.9\n\n\n\n\n#369\n: documentation: improved docs and specs for object.path/setPath\n\n\n\n\nv1.2.8\n\n\n\n\n#322\n: logging: fixed source location reporting\n\n\n\n\nv1.2.7\n\n\n\n\n#301\n changelog: removed erroneous entry for (#293) from \nv1.2.6\n.\n\n\n\n\nv1.2.6\n\n\n\n\n#296\n: documentation: fixed string API doc module name\n\n\n#297\n: project: updated .gitignore for better v2.0 compatibility\n\n\n#284\n: documentation: fixed broken link\n\n\n\n\nv1.2.5\n\n\n\n\n#295\n: documentation: fixed order of preliminary readings\n\n\n\n\nv1.2.4\n\n\n\n\n#289\n: page loader: merged namespaces for widget- and composition-ids\n\n\n\n\nv1.2.3\n\n\n\n\n#285\n: page loader: improved error message for missing composition\n\n\n\n\nv1.2.2\n\n\n\n\n#277\n: loaders: Fix problem with insertBeforeId in compositions\n\n\n#274\n: loaders: Fix handling of compositions without '.' area\n\n\n\n\nv1.2.1\n\n\n\n\n#268\n: EventBus: fixed handling of single \ndid\n response after multiple requests with individual \nwill\n\n\n#255\n: tooling: fixed test and enabled it for grunt-karma\n\n\n#254\n: documentation: improved and updated manuals\n\n\n#251\n: utilities: reactivated spec tests\n\n\n\n\nv1.2.0\n\n\n\n\n#249\n: project: updated copyright year in file header\n\n\n\n\nv1.2.0-beta.0\n\n\n\n\n#248\n: tooling: added compositions to page inspection API\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.2.0-alpha.2\n\n\n\n\n\n\n#247\n: tooling: added page inspection API\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#244\n: documentation: added extensive documentation on visibility events\n\n\n\n\n\n\nv1.2.0-alpha.1\n\n\n\n\n#243\n: fn: fixed invalid setTimeout application\n\n\n\n\nv1.2.0-alpha.0\n\n\n\n\n\n\n#242\n: tooling: added \nprovideQ\n factory\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#241\n: fn: allow to cancel debounced functions\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#240\n: documentation: fixed prerequisites (yeoman, not grunt-init)\n\n\n\n\n\n\nv1.1.0\n\n\nv1.1.0-beta.1\n\n\n\n\n#238\n: testing: fixed initialization of \naxControls\n mock\n\n\n\n\nv1.1.0-beta.0\n\n\n\n\n#210\n: runtime: added \naxControls\n service so that controls can be instantiated in any integration technology\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.1.0-alpha.9\n\n\n\n\n#237\n: runtime: defer page-controller injections until controller instantiation\n\n\n\n\nv1.1.0-alpha.8\n\n\n\n\n#236\n: loaders: fixed typo which prevented default theme from loading (debug mode)\n\n\n\n\nv1.1.0-alpha.7\n\n\n\n\n#235\n: loaders: to find CSS in theme, first try the descriptor name\n\n\n\n\nv1.1.0-alpha.6\n\n\n\n\n#234\n: testing: do not query widget CSS/HTML assets\n\n\n\n\nv1.1.0-alpha.5\n\n\n\n\n#233\n: loaders: fixed widget theme lookup\n\n\n#232\n: documentation: explain Bower-based widget installation\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.1.0-alpha.4\n\n\n\n\n\n\n#195\n: documentation: added manual on the FileResourceProvider\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#230\n: documentation: fixed example in \nWidgets and Activities\n manual\n\n\n\n\n#223\n: documentation: explain tooling with the new grunt tasks\n\n\n#228\n: documentation: documented writing widget controller for specific technologies\n\n\n#229\n: adapters: added axFeatures as injection for angular widgets\n\n\n#221\n: adapters: made all relevant services available to plain widgets\n\n\n\n\nv1.1.0-alpha.3\n\n\n\n\n#227\n: testing: fixed widget descriptor lookup so that it is independent of the widget location\n\n\n#225\n: loaders: prefer widget specification name over directory name if possible\n\n\n#226\n: angular: normalized widget module lookup so that widget.json can use dash-separated-names\n\n\n\n\n#129\n: integration: implemented using widgets installed via bower as amd module\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#222\n: require_config: added documentation for widget / control specific configuration\n\n\n\n\n#215\n: testing: updated documentation regarding widget tests\n\n\n#220\n: fixed off-by-one bug in HTML spec-runners\n\n\n#78\n: tests: allow to execute spec-tests using a project RequireJS configuration\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.1.0-alpha.2\n\n\n\n\n\n\n#219\n: added Travis-CI build integration\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#213\n: documentation: fixed widget installation manual\n\n\n\n\n#214\n: axHeartBeat: using applyViewChanges via page controller\n\n\n\n\nv1.1.0-alpha.1\n\n\n\n\n#193\n: loaders: implemented nesting of layouts within areas directly in a page\n\n\n\n\nv1.1.0-alpha.0\n\n\n\n\n#127\n: testing: made necessary changes for new, distinct testing framework\n\n\n\n\n#211\n: project: state compatibility with AngularJS 1.4.x\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#212\n: documentation: added basic manual on installing controls\n\n\n\n\n#150\n: documentation: added contributor guide\n\n\n#209\n: api-doc: update generated api doc\n\n\n#208\n: configuration: applied default for \ni18n.locales\n when setting \n$rootScope.i18n.tags\n\n\n\n\nv1.0.0\n\n\n\n\n#205\n: documentation: updated README.md according to latest template version\n\n\n\n\nv1.0.0-beta.1\n\n\n\n\n#207\n: documentation: adapted to changed naming\n\n\n#206\n: runtime: fixed problem with possible duplicate flow-controller\n\n\n#203\n: documentation: updated manual on controls to cover the new descriptor\n\n\n\n\nv1.0.0-beta.0\n\n\n\n\n#132\n: documentation: provided updated API doc for relevant modules\n\n\n\n\nv1.0.0-alpha.15\n\n\n\n\n#202\n: themes: made path to the default theme configurable\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv1.0.0-alpha.14\n\n\n\n\n#201\n: testing: fix loading of old-style controls\n\n\n\n\nv1.0.0-alpha.13\n\n\n\n\n#200\n: loaders, testing: fix loading of controls that are configured as commonjs packages in RequireJS\n\n\n\n\nv1.0.0-alpha.12\n\n\n\n\n#199\n: project: removed unnecessary dependencies, simplified Bower references\n\n\n#197\n: loaders: read control name from control.json descriptor if present\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.0.0-alpha.11\n\n\n\n\n#198\n: project: prepared \nlaxar\n npm package\n\n\n\n\nv1.0.0-alpha.10\n\n\n\n\n#196\n: runtime: fixed default theme loading\n\n\n\n\nv1.0.0-alpha.9\n\n\n\n\n\n\n#183\n: runtime, file_resource_provider: allow to load file listings directly from configuration\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#186\n: loaders: allow to load layouts from theme\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#192\n: loaders: removed duplicate code for defaults application\n\n\n\n\n\n\nv1.0.0-alpha.8\n\n\n\n\n#189\n: loaders: fixed inferring top-level widget configuration defaults for JSON schema v4\n\n\n#188\n: configuration: moved configuration module to utilities\n\n\n\n\n#187\n: storage: use per-app unique storage prefixes\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#184\n: documentation: fixed logging configuration documentation\n\n\n\n\n#185\n: logging: configuration value not applied correctly\n\n\n\n\n#128\n: logging, utilities: simplified and removed some APIs\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#159\n: flow: removed support for triggerBrowserReload.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#182\n: runtime: removed live theme switching\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#180\n: directives: removed \naxPageFade\n directive\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\nv1.0.0-alpha.7\n\n\n\n\n#179\n: loaders: fixed loading of CSS for controls\n\n\n#154\n: widget_adapters: added deprecation warning for old-style widget modules\n\n\n\n\n#177\n: runtime: renamed configuration options\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#171\n: documentation: added manual on widget adapters\n\n\n\n\n#178\n: runtime: renamed AngularJS modules to match AMD modules\n\n\n#176\n: documentation: replaced the widget category \nportal\n with \nlaxarjs\n\n\n\n\n#175\n: loaders: changed generated DOM- and topic-IDs to be more compact\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#174\n: widget_adapters: simplified widget adapter API\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\nv1.0.0-alpha.6\n\n\n\n\n#173\n: testing: fixed a bug when configuring the widget under test.\n\n\n\n\n#167\n: widget_adapters: added injectable axContext as alternative to AngularJS scopes.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#170\n: loaders: refactored widget loader and widget adapters.\n\n\n\n\n#168\n: documentation: added basic documentation on coding style\n\n\n#136\n: storage: removed \nwindow.name\n-shim for session-storage\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv1.0.0-alpha.5\n\n\n\n\n#130\n: portal: refactored portal artifacts to runtime and loaders.\n\n\n\n\nv1.0.0-alpha.4\n\n\n\n\n#164\n: updated bower dependencies jjv and jjve to latest versions.\n\n\n#71\n: angular_adapter: widget and activity scopes are now created on demand.\n\n\n\n\nv1.0.0-alpha.3\n\n\n\n\n\n\n#165\n: i18n: changed localizer.format signature to match string.format\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#161\n: portal: removed memory leak fix for msie8\n\n\n\n\n\n\nv1.0.0-alpha.2\n\n\n\n\n\n\n#158\n: changed AngularJS support to version 1.3.15.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#147\n: footprint: made jquery from a dependency into a dev-dependency\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#162\n: documentation: fixed theme manual after shop-demo update\n\n\n\n\n\n\nv1.0.0-alpha.1\n\n\n\n\n\n\n#160\n: refactoring: normalized AngularJS artifact names\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#149\n: testing: always use \nwidget.json\n for widget spec tests\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#139\n: loader: removed widget compatibility warning for now\n\n\n\n\n#124\n: implemented an adapter for plain JavaScript widgets.\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.0.0-alpha.0\n\n\n\n\n\n\n#103\n: portal: removed json patch compatibility layer.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#117\n: portal: implemented a flow service that provides place urls usable as hyperlinks.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#35\n: Upgraded internal JSON schemas to draft v4.\n\n\n\n\n\n\n#116\n: performance: the flow is now loaded through the file resource provider\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#99\n: exit points are now configured as \nexitPoint\n in flow.json.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#72\n: configuration: removed deprecated configuration paths.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#88\n: footprint: removed \nunderscore\n dependency\n\n\n\n\n\n\n#70\n: footprint: removed \nlaxar.text\n API (use \nlaxar.string.format\n instead)\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#92\n: removed obsolete mixins in favor of compositions.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#181\n: runtime: added missing default for the configuration key \ni18n.locales\n\n\n\n\n\n\nv0.26.0\n\n\n\n\n#169\n: widget_adapters: fixed plain-adapter to use new-style widget module names\n\n\n#172\n: documentation: fixed dead link\n\n\n#166\n: cleanup: removed distribution-related configuration and files\n\n\n#163\n: EventBus: fixed request topic matching\n\n\n\n\nv0.25.0\n\n\n\n\n#156\n: i18n: by default, use relaxed matching for language tags\n\n\n\n\nv0.24.0\n\n\n\n\n#157\n: portal: angular-adapter: fixed error reporting\n\n\n#145\n: testing: added missing cancel-method to mock-$timeout\n\n\n#155\n: visibility: page controller now unsubscribes on tear-down\n\n\n#152\n: documentation: added widget installation manual\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv0.23.0\n\n\n\n\n\n\n#153\n: portal: angular-adapter: simplified widget and controller naming\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#151\n: EventBus: fixed cycle count for zero subscribers\n\n\n\n\n#148\n: documentation: more detailed information on the event bus, link to api doc\n\n\n\n\nv0.22.0\n\n\n\n\n#146\n: documentation: improved the prerequisites in the \nREADME.md\n and writing style\n\n\n#143\n: documentation: fixed testing configuration example (\nandCallFake\n, not \nandCallThrough\n)\n\n\n#142\n: documentation: fixed task alias for development server (\nstart\n, not \ndevelop\n)\n\n\n#144\n: EventBus: reject publishAndGatherReplies-promise after timeout\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv0.21.0\n\n\n\n\n#137\n: flow: warn on empty place\n\n\n#140\n: EventBus: make timeout configurable\n\n\n#126\n: testing: \naxEventBus\n injection available to widget controllers during testing\n\n\n\n\nv0.20.0\n\n\n\n\n\n\n#138\n: logging: the instance id is now generated by the log context and transmitted using an $http interceptor\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#134\n: storage: fixed storage in iOS Safari private browsing\n\n\n\n\n\n\nv0.19.0\n\n\n\n\n\n\n#125\n: axLayout: emit AngularJS event when loaded\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#113\n: documentation: manual on tools\n\n\n\n\n\n\n#122\n: testing: allow to inject dependencies\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#123\n: portal: preload widget assets on page load\n\n\n\n\n#117\n: portal: implemented a flow service that provides place urls usable as hyperlinks.\n\n\n#121\n: documentation: have README.md next steps point to manuals\n\n\n#118\n: performance: removed $timeout from axPageFade\n\n\n#120\n: portal: fixed flaky timestamp test\n\n\n#119\n: portal: fixed race condition in page loader\n\n\n\n\nv0.18.0\n\n\n\n\n#97\n: documentation: manual on themes\n\n\n#112\n: documentation: removed colloquial style\n\n\n\n\nv0.17.0\n\n\n\n\n#108\n: documentation: unify code-snippet format, and some polish\n\n\n#109\n: documentation: added manual on providing controls\n\n\n#107\n: angular widget adapter: added widget specific event bus service.\n\n\n#106\n: documentation: fixed manuals, improved introduction in README.md\n\n\n#93\n: refactoring: extracted page related services into own files.\n\n\n#98\n: documentation: added manual on events and pub/sub\n\n\n#100\n: widget loader: added angular widget as default integration.\n\n\n#105\n: moved resumable timer handling from flow to timer.\n\n\n#104\n: configuration: deprecated configuration keys are no handled at one place.\n\n\n#101\n: documentation: use \"\u00ab\" rather than \"\n\" for backwards navigation links\n\n\n#76\n: documentation: widgets and activities\n\n\n#75\n: documentation: flow and places.\n\n\n#96\n: documentation: restructured existing documents and added stubs for missing ones.\n\n\n#95\n: documentation: wrote a motivational article for LaxarJS.\n\n\n#94\n: footprint: removed the outdated app stub in favor of grunt-init (see README.md)\n\n\n#38\n: documentation: pages and compositions.\n\n\n#91\n: portal: make sure that widget DOM is attached when linking\n\n\n\n\n#90\n: documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#89\n: documentation: primary concepts of LaxarJS\n\n\n\n\n#84\n: storage: storing \nundefined\n now causes the entry to be removed\n\n\n\n\nv0.16.0\n\n\n\n\n#87\n: portal: Ensure anonymization of logged events.\n\n\n#86\n: logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.\n\n\n\n\n#85\n: utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#83\n: portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#81\n: added check for duplicate area definitions in layouts\n\n\n\n\n\n\nv0.15.0\n\n\n\n\n\n\n#82\n: implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#80\n: storage: Improved detection of WebStorage API for Internet Explorer\n\n\n\n\n#79\n: assert: details given as object are now serialized\n\n\n#77\n: flow: the log tag \nPLCE\n with the current place name is set after navigation\n\n\n\n\nv0.14.0\n\n\n\n\n#73\n: portal: fixed lookup of merged CSS file\n\n\n#69\n: portal: moved setting widget root element IDs to widget loader\n\n\n#68\n: fixed wrongly global assert in jshintrc.\n\n\n#67\n: re-added missing widget root element IDs.\n\n\n#65\n: fixed navigation being broken when parameter values were missing.\n\n\n#66\n: prevented endless navigation ping pong in flow controller\n\n\n#63\n: axVisibilityService: use scope.$id to identify handlers, not scope.id\n\n\n#62\n: fixed endless recursion on navigation when place and target have the same name.\n\n\n\n\nv0.13.0\n\n\n\n\n\n\n#61\n: added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#60\n: tests: make sure PhantomJS is installed properly, before running spec tests.\n\n\n\n\n\n\n#52\n: portal, testing: added visibility events and the \naxVisibilityService\n\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#59\n: portal: fixed dangling comma in timer imports\n\n\n\n\n#58\n: portal, json: fixed copyright headers\n\n\n#57\n: portal: fixed double-navigation problem which can lead to skipping places\n\n\n#56\n: object: removed all direct calls of hasOwnProperty.\n\n\n#55\n: run_spec: disable loading the \nwidget.json\n if the \nspec_runner.js\n contains \nwidgetJson: false\n\n\n#54\n: testing: fixed broken testBed injection of $q and $timeout\n\n\n#50\n: performance: decoupled instantiation of widget controllers from their DOM\n\n\n\n\nv0.12.0\n\n\n\n\n\n\n#49\n: added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#48\n: Promises generated by the event bus are now scheduled by the event bus, not by AngularJS \n$apply\n.\n\n\n\n\n#51\n: Remove some obsolete NPM \ndevDependencies\n.\n\n\n#47\n: Do not schedule another full event-bus tick while one is already being processed.\n\n\n#46\n: fixed misinterpretation of falsy required attribute in json schema converter.\n\n\n#45\n: i18n: adjusted localizer.format specs to changes from \n#43\n.\n\n\n\n\n#43\n: string: added new function \nstring.format\n as simpler replacement for \ntext\n library.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#42\n: portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#40\n: portal: fixed 'flag-topic' pattern.\n\n\n\n\n\n\nv0.11.0\n\n\n\n\n\n\n#39\n: portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#37\n: improved browsing of existing api doc and fixed some syntactical errors.\n\n\n\n\n#36\n: jshintrc: disabled enforcement of dot notation for object property access.\n\n\n\n\n#34\n: Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#33\n: EventBus: added event object to the information sent to inspectors on deliver actions.\n\n\n\n\n\n\n#31\n: Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#32\n: Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#30\n: PageLoader: added missing check for duplicate composition ids.\n\n\n\n\n\n\nv0.10.0\n\n\n\n\n#27\n: Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick\n\n\n#28\n: Fixed null values in widget features within compositions being turned into empty objects.\n\n\n#29\n: PageLoader: composition features that are not configured do not result in undefined values for widget features.\n\n\n#25\n: Only the page relevant for the current place is loaded now.\n\n\n\n\n#17\n: Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#26\n: Testing: Fixed the responseTransform option for http-mock\n\n\n\n\n\n\n#22\n: FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#15\n: FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings\n\n\n\n\n\n\n#24\n: Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#23\n: FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.\n\n\n\n\n#21\n: The file resource provider now normalizes its root path.\n\n\n#20\n: Fixed event bus inspectors not being notified on unsubscription.\n\n\n#14\n: Fixed navigation being broken after successive navigation to the current location.\n\n\n#13\n: The current place is now send as part of the didNavigate event.\n\n\n#12\n: Testing: Get the LaxarJS tests running in Karma again.\n\n\n#11\n: Testing: Handle \nspec_runner.js\n that are not in a subdirectory of the RequireJS' \nbaseUrl\n.\n\n\n#10\n: Testing: Loading controls during tests now works in Karma.\n\n\n#9\n: Update Bower from ~1.2.8 to ~1.3.3.\n\n\n#8\n: Fixed the cleanup mechanism for generated widget areas.\n\n\n#6\n: The Portal now initializes an i18n object on the application's \n$rootScope\n\n\n#5\n: Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json\n\n\n#4\n: PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys\n\n\n#3\n: Added url formatting for links in Readme.md\n\n\n#2\n: Fixed grunt-init step in Getting-Started docs\n\n\n#1\n: Added initial Getting-Started documentation", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v1210", 
            "text": "#371 : flow: fixed URL encoding of place parameter values", 
            "title": "v1.2.10"
        }, 
        {
            "location": "/CHANGELOG/#v129", 
            "text": "#369 : documentation: improved docs and specs for object.path/setPath", 
            "title": "v1.2.9"
        }, 
        {
            "location": "/CHANGELOG/#v128", 
            "text": "#322 : logging: fixed source location reporting", 
            "title": "v1.2.8"
        }, 
        {
            "location": "/CHANGELOG/#v127", 
            "text": "#301  changelog: removed erroneous entry for (#293) from  v1.2.6 .", 
            "title": "v1.2.7"
        }, 
        {
            "location": "/CHANGELOG/#v126", 
            "text": "#296 : documentation: fixed string API doc module name  #297 : project: updated .gitignore for better v2.0 compatibility  #284 : documentation: fixed broken link", 
            "title": "v1.2.6"
        }, 
        {
            "location": "/CHANGELOG/#v125", 
            "text": "#295 : documentation: fixed order of preliminary readings", 
            "title": "v1.2.5"
        }, 
        {
            "location": "/CHANGELOG/#v124", 
            "text": "#289 : page loader: merged namespaces for widget- and composition-ids", 
            "title": "v1.2.4"
        }, 
        {
            "location": "/CHANGELOG/#v123", 
            "text": "#285 : page loader: improved error message for missing composition", 
            "title": "v1.2.3"
        }, 
        {
            "location": "/CHANGELOG/#v122", 
            "text": "#277 : loaders: Fix problem with insertBeforeId in compositions  #274 : loaders: Fix handling of compositions without '.' area", 
            "title": "v1.2.2"
        }, 
        {
            "location": "/CHANGELOG/#v121", 
            "text": "#268 : EventBus: fixed handling of single  did  response after multiple requests with individual  will  #255 : tooling: fixed test and enabled it for grunt-karma  #254 : documentation: improved and updated manuals  #251 : utilities: reactivated spec tests", 
            "title": "v1.2.1"
        }, 
        {
            "location": "/CHANGELOG/#v120", 
            "text": "#249 : project: updated copyright year in file header", 
            "title": "v1.2.0"
        }, 
        {
            "location": "/CHANGELOG/#v120-beta0", 
            "text": "#248 : tooling: added compositions to page inspection API\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.2.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v120-alpha2", 
            "text": "#247 : tooling: added page inspection API\n        + NEW FEATURE: see ticket for details    #244 : documentation: added extensive documentation on visibility events", 
            "title": "v1.2.0-alpha.2"
        }, 
        {
            "location": "/CHANGELOG/#v120-alpha1", 
            "text": "#243 : fn: fixed invalid setTimeout application", 
            "title": "v1.2.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v120-alpha0", 
            "text": "#242 : tooling: added  provideQ  factory\n        + NEW FEATURE: see ticket for details    #241 : fn: allow to cancel debounced functions\n        + NEW FEATURE: see ticket for details    #240 : documentation: fixed prerequisites (yeoman, not grunt-init)", 
            "title": "v1.2.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v110", 
            "text": "", 
            "title": "v1.1.0"
        }, 
        {
            "location": "/CHANGELOG/#v110-beta1", 
            "text": "#238 : testing: fixed initialization of  axControls  mock", 
            "title": "v1.1.0-beta.1"
        }, 
        {
            "location": "/CHANGELOG/#v110-beta0", 
            "text": "#210 : runtime: added  axControls  service so that controls can be instantiated in any integration technology\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.1.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha9", 
            "text": "#237 : runtime: defer page-controller injections until controller instantiation", 
            "title": "v1.1.0-alpha.9"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha8", 
            "text": "#236 : loaders: fixed typo which prevented default theme from loading (debug mode)", 
            "title": "v1.1.0-alpha.8"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha7", 
            "text": "#235 : loaders: to find CSS in theme, first try the descriptor name", 
            "title": "v1.1.0-alpha.7"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha6", 
            "text": "#234 : testing: do not query widget CSS/HTML assets", 
            "title": "v1.1.0-alpha.6"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha5", 
            "text": "#233 : loaders: fixed widget theme lookup  #232 : documentation: explain Bower-based widget installation\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.1.0-alpha.5"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha4", 
            "text": "#195 : documentation: added manual on the FileResourceProvider\n        + NEW FEATURE: see ticket for details    #230 : documentation: fixed example in  Widgets and Activities  manual   #223 : documentation: explain tooling with the new grunt tasks  #228 : documentation: documented writing widget controller for specific technologies  #229 : adapters: added axFeatures as injection for angular widgets  #221 : adapters: made all relevant services available to plain widgets", 
            "title": "v1.1.0-alpha.4"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha3", 
            "text": "#227 : testing: fixed widget descriptor lookup so that it is independent of the widget location  #225 : loaders: prefer widget specification name over directory name if possible  #226 : angular: normalized widget module lookup so that widget.json can use dash-separated-names   #129 : integration: implemented using widgets installed via bower as amd module\n        + NEW FEATURE: see ticket for details    #222 : require_config: added documentation for widget / control specific configuration   #215 : testing: updated documentation regarding widget tests  #220 : fixed off-by-one bug in HTML spec-runners  #78 : tests: allow to execute spec-tests using a project RequireJS configuration\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.1.0-alpha.3"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha2", 
            "text": "#219 : added Travis-CI build integration\n        + NEW FEATURE: see ticket for details    #213 : documentation: fixed widget installation manual   #214 : axHeartBeat: using applyViewChanges via page controller", 
            "title": "v1.1.0-alpha.2"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha1", 
            "text": "#193 : loaders: implemented nesting of layouts within areas directly in a page", 
            "title": "v1.1.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha0", 
            "text": "#127 : testing: made necessary changes for new, distinct testing framework   #211 : project: state compatibility with AngularJS 1.4.x\n        + NEW FEATURE: see ticket for details    #212 : documentation: added basic manual on installing controls   #150 : documentation: added contributor guide  #209 : api-doc: update generated api doc  #208 : configuration: applied default for  i18n.locales  when setting  $rootScope.i18n.tags", 
            "title": "v1.1.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v100", 
            "text": "#205 : documentation: updated README.md according to latest template version", 
            "title": "v1.0.0"
        }, 
        {
            "location": "/CHANGELOG/#v100-beta1", 
            "text": "#207 : documentation: adapted to changed naming  #206 : runtime: fixed problem with possible duplicate flow-controller  #203 : documentation: updated manual on controls to cover the new descriptor", 
            "title": "v1.0.0-beta.1"
        }, 
        {
            "location": "/CHANGELOG/#v100-beta0", 
            "text": "#132 : documentation: provided updated API doc for relevant modules", 
            "title": "v1.0.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha15", 
            "text": "#202 : themes: made path to the default theme configurable\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v1.0.0-alpha.15"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha14", 
            "text": "#201 : testing: fix loading of old-style controls", 
            "title": "v1.0.0-alpha.14"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha13", 
            "text": "#200 : loaders, testing: fix loading of controls that are configured as commonjs packages in RequireJS", 
            "title": "v1.0.0-alpha.13"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha12", 
            "text": "#199 : project: removed unnecessary dependencies, simplified Bower references  #197 : loaders: read control name from control.json descriptor if present\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.0.0-alpha.12"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha11", 
            "text": "#198 : project: prepared  laxar  npm package", 
            "title": "v1.0.0-alpha.11"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha10", 
            "text": "#196 : runtime: fixed default theme loading", 
            "title": "v1.0.0-alpha.10"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha9", 
            "text": "#183 : runtime, file_resource_provider: allow to load file listings directly from configuration\n        + NEW FEATURE: see ticket for details    #186 : loaders: allow to load layouts from theme\n        + NEW FEATURE: see ticket for details    #192 : loaders: removed duplicate code for defaults application", 
            "title": "v1.0.0-alpha.9"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha8", 
            "text": "#189 : loaders: fixed inferring top-level widget configuration defaults for JSON schema v4  #188 : configuration: moved configuration module to utilities   #187 : storage: use per-app unique storage prefixes\n        + NEW FEATURE: see ticket for details    #184 : documentation: fixed logging configuration documentation   #185 : logging: configuration value not applied correctly   #128 : logging, utilities: simplified and removed some APIs\n        +  BREAKING CHANGE:  see ticket for details    #159 : flow: removed support for triggerBrowserReload.\n        +  BREAKING CHANGE:  see ticket for details    #182 : runtime: removed live theme switching\n        +  BREAKING CHANGE:  see ticket for details    #180 : directives: removed  axPageFade  directive\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v1.0.0-alpha.8"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha7", 
            "text": "#179 : loaders: fixed loading of CSS for controls  #154 : widget_adapters: added deprecation warning for old-style widget modules   #177 : runtime: renamed configuration options\n        + NEW FEATURE: see ticket for details    #171 : documentation: added manual on widget adapters   #178 : runtime: renamed AngularJS modules to match AMD modules  #176 : documentation: replaced the widget category  portal  with  laxarjs   #175 : loaders: changed generated DOM- and topic-IDs to be more compact\n        +  BREAKING CHANGE:  see ticket for details    #174 : widget_adapters: simplified widget adapter API\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.0.0-alpha.7"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha6", 
            "text": "#173 : testing: fixed a bug when configuring the widget under test.   #167 : widget_adapters: added injectable axContext as alternative to AngularJS scopes.\n        + NEW FEATURE: see ticket for details    #170 : loaders: refactored widget loader and widget adapters.   #168 : documentation: added basic documentation on coding style  #136 : storage: removed  window.name -shim for session-storage\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v1.0.0-alpha.6"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha5", 
            "text": "#130 : portal: refactored portal artifacts to runtime and loaders.", 
            "title": "v1.0.0-alpha.5"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha4", 
            "text": "#164 : updated bower dependencies jjv and jjve to latest versions.  #71 : angular_adapter: widget and activity scopes are now created on demand.", 
            "title": "v1.0.0-alpha.4"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha3", 
            "text": "#165 : i18n: changed localizer.format signature to match string.format\n        +  BREAKING CHANGE:  see ticket for details    #161 : portal: removed memory leak fix for msie8", 
            "title": "v1.0.0-alpha.3"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha2", 
            "text": "#158 : changed AngularJS support to version 1.3.15.\n        +  BREAKING CHANGE:  see ticket for details    #147 : footprint: made jquery from a dependency into a dev-dependency\n        + NEW FEATURE: see ticket for details    #162 : documentation: fixed theme manual after shop-demo update", 
            "title": "v1.0.0-alpha.2"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha1", 
            "text": "#160 : refactoring: normalized AngularJS artifact names\n        +  BREAKING CHANGE:  see ticket for details    #149 : testing: always use  widget.json  for widget spec tests\n        +  BREAKING CHANGE:  see ticket for details    #139 : loader: removed widget compatibility warning for now   #124 : implemented an adapter for plain JavaScript widgets.\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.0.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha0", 
            "text": "#103 : portal: removed json patch compatibility layer.\n        +  BREAKING CHANGE:  see ticket for details    #117 : portal: implemented a flow service that provides place urls usable as hyperlinks.\n        +  BREAKING CHANGE:  see ticket for details    #35 : Upgraded internal JSON schemas to draft v4.    #116 : performance: the flow is now loaded through the file resource provider\n        +  BREAKING CHANGE:  see ticket for details    #99 : exit points are now configured as  exitPoint  in flow.json.\n        +  BREAKING CHANGE:  see ticket for details    #72 : configuration: removed deprecated configuration paths.\n        +  BREAKING CHANGE:  see ticket for details    #88 : footprint: removed  underscore  dependency    #70 : footprint: removed  laxar.text  API (use  laxar.string.format  instead)\n        +  BREAKING CHANGE:  see ticket for details    #92 : removed obsolete mixins in favor of compositions.\n        +  BREAKING CHANGE:  see ticket for details    #181 : runtime: added missing default for the configuration key  i18n.locales", 
            "title": "v1.0.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v0260", 
            "text": "#169 : widget_adapters: fixed plain-adapter to use new-style widget module names  #172 : documentation: fixed dead link  #166 : cleanup: removed distribution-related configuration and files  #163 : EventBus: fixed request topic matching", 
            "title": "v0.26.0"
        }, 
        {
            "location": "/CHANGELOG/#v0250", 
            "text": "#156 : i18n: by default, use relaxed matching for language tags", 
            "title": "v0.25.0"
        }, 
        {
            "location": "/CHANGELOG/#v0240", 
            "text": "#157 : portal: angular-adapter: fixed error reporting  #145 : testing: added missing cancel-method to mock-$timeout  #155 : visibility: page controller now unsubscribes on tear-down  #152 : documentation: added widget installation manual\n        + NEW FEATURE: see ticket for details", 
            "title": "v0.24.0"
        }, 
        {
            "location": "/CHANGELOG/#v0230", 
            "text": "#153 : portal: angular-adapter: simplified widget and controller naming\n        + NEW FEATURE: see ticket for details    #151 : EventBus: fixed cycle count for zero subscribers   #148 : documentation: more detailed information on the event bus, link to api doc", 
            "title": "v0.23.0"
        }, 
        {
            "location": "/CHANGELOG/#v0220", 
            "text": "#146 : documentation: improved the prerequisites in the  README.md  and writing style  #143 : documentation: fixed testing configuration example ( andCallFake , not  andCallThrough )  #142 : documentation: fixed task alias for development server ( start , not  develop )  #144 : EventBus: reject publishAndGatherReplies-promise after timeout\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v0.22.0"
        }, 
        {
            "location": "/CHANGELOG/#v0210", 
            "text": "#137 : flow: warn on empty place  #140 : EventBus: make timeout configurable  #126 : testing:  axEventBus  injection available to widget controllers during testing", 
            "title": "v0.21.0"
        }, 
        {
            "location": "/CHANGELOG/#v0200", 
            "text": "#138 : logging: the instance id is now generated by the log context and transmitted using an $http interceptor\n        + NEW FEATURE: see ticket for details    #134 : storage: fixed storage in iOS Safari private browsing", 
            "title": "v0.20.0"
        }, 
        {
            "location": "/CHANGELOG/#v0190", 
            "text": "#125 : axLayout: emit AngularJS event when loaded\n        + NEW FEATURE: see ticket for details    #113 : documentation: manual on tools    #122 : testing: allow to inject dependencies\n        + NEW FEATURE: see ticket for details    #123 : portal: preload widget assets on page load   #117 : portal: implemented a flow service that provides place urls usable as hyperlinks.  #121 : documentation: have README.md next steps point to manuals  #118 : performance: removed $timeout from axPageFade  #120 : portal: fixed flaky timestamp test  #119 : portal: fixed race condition in page loader", 
            "title": "v0.19.0"
        }, 
        {
            "location": "/CHANGELOG/#v0180", 
            "text": "#97 : documentation: manual on themes  #112 : documentation: removed colloquial style", 
            "title": "v0.18.0"
        }, 
        {
            "location": "/CHANGELOG/#v0170", 
            "text": "#108 : documentation: unify code-snippet format, and some polish  #109 : documentation: added manual on providing controls  #107 : angular widget adapter: added widget specific event bus service.  #106 : documentation: fixed manuals, improved introduction in README.md  #93 : refactoring: extracted page related services into own files.  #98 : documentation: added manual on events and pub/sub  #100 : widget loader: added angular widget as default integration.  #105 : moved resumable timer handling from flow to timer.  #104 : configuration: deprecated configuration keys are no handled at one place.  #101 : documentation: use \"\u00ab\" rather than \" \" for backwards navigation links  #76 : documentation: widgets and activities  #75 : documentation: flow and places.  #96 : documentation: restructured existing documents and added stubs for missing ones.  #95 : documentation: wrote a motivational article for LaxarJS.  #94 : footprint: removed the outdated app stub in favor of grunt-init (see README.md)  #38 : documentation: pages and compositions.  #91 : portal: make sure that widget DOM is attached when linking   #90 : documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details    #89 : documentation: primary concepts of LaxarJS   #84 : storage: storing  undefined  now causes the entry to be removed", 
            "title": "v0.17.0"
        }, 
        {
            "location": "/CHANGELOG/#v0160", 
            "text": "#87 : portal: Ensure anonymization of logged events.  #86 : logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.   #85 : utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details    #83 : portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details    #81 : added check for duplicate area definitions in layouts", 
            "title": "v0.16.0"
        }, 
        {
            "location": "/CHANGELOG/#v0150", 
            "text": "#82 : implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details    #80 : storage: Improved detection of WebStorage API for Internet Explorer   #79 : assert: details given as object are now serialized  #77 : flow: the log tag  PLCE  with the current place name is set after navigation", 
            "title": "v0.15.0"
        }, 
        {
            "location": "/CHANGELOG/#v0140", 
            "text": "#73 : portal: fixed lookup of merged CSS file  #69 : portal: moved setting widget root element IDs to widget loader  #68 : fixed wrongly global assert in jshintrc.  #67 : re-added missing widget root element IDs.  #65 : fixed navigation being broken when parameter values were missing.  #66 : prevented endless navigation ping pong in flow controller  #63 : axVisibilityService: use scope.$id to identify handlers, not scope.id  #62 : fixed endless recursion on navigation when place and target have the same name.", 
            "title": "v0.14.0"
        }, 
        {
            "location": "/CHANGELOG/#v0130", 
            "text": "#61 : added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details    #60 : tests: make sure PhantomJS is installed properly, before running spec tests.    #52 : portal, testing: added visibility events and the  axVisibilityService \n        + NEW FEATURE: see ticket for details    #59 : portal: fixed dangling comma in timer imports   #58 : portal, json: fixed copyright headers  #57 : portal: fixed double-navigation problem which can lead to skipping places  #56 : object: removed all direct calls of hasOwnProperty.  #55 : run_spec: disable loading the  widget.json  if the  spec_runner.js  contains  widgetJson: false  #54 : testing: fixed broken testBed injection of $q and $timeout  #50 : performance: decoupled instantiation of widget controllers from their DOM", 
            "title": "v0.13.0"
        }, 
        {
            "location": "/CHANGELOG/#v0120", 
            "text": "#49 : added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details    #48 : Promises generated by the event bus are now scheduled by the event bus, not by AngularJS  $apply .   #51 : Remove some obsolete NPM  devDependencies .  #47 : Do not schedule another full event-bus tick while one is already being processed.  #46 : fixed misinterpretation of falsy required attribute in json schema converter.  #45 : i18n: adjusted localizer.format specs to changes from  #43 .   #43 : string: added new function  string.format  as simpler replacement for  text  library.\n        + NEW FEATURE: see ticket for details    #42 : portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details    #40 : portal: fixed 'flag-topic' pattern.", 
            "title": "v0.12.0"
        }, 
        {
            "location": "/CHANGELOG/#v0110", 
            "text": "#39 : portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details    #37 : improved browsing of existing api doc and fixed some syntactical errors.   #36 : jshintrc: disabled enforcement of dot notation for object property access.   #34 : Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details    #33 : EventBus: added event object to the information sent to inspectors on deliver actions.    #31 : Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details    #32 : Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details    #30 : PageLoader: added missing check for duplicate composition ids.", 
            "title": "v0.11.0"
        }, 
        {
            "location": "/CHANGELOG/#v0100", 
            "text": "#27 : Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick  #28 : Fixed null values in widget features within compositions being turned into empty objects.  #29 : PageLoader: composition features that are not configured do not result in undefined values for widget features.  #25 : Only the page relevant for the current place is loaded now.   #17 : Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details    #26 : Testing: Fixed the responseTransform option for http-mock    #22 : FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details    #15 : FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings    #24 : Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details    #23 : FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.   #21 : The file resource provider now normalizes its root path.  #20 : Fixed event bus inspectors not being notified on unsubscription.  #14 : Fixed navigation being broken after successive navigation to the current location.  #13 : The current place is now send as part of the didNavigate event.  #12 : Testing: Get the LaxarJS tests running in Karma again.  #11 : Testing: Handle  spec_runner.js  that are not in a subdirectory of the RequireJS'  baseUrl .  #10 : Testing: Loading controls during tests now works in Karma.  #9 : Update Bower from ~1.2.8 to ~1.3.3.  #8 : Fixed the cleanup mechanism for generated widget areas.  #6 : The Portal now initializes an i18n object on the application's  $rootScope  #5 : Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json  #4 : PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys  #3 : Added url formatting for links in Readme.md  #2 : Fixed grunt-init step in Getting-Started docs  #1 : Added initial Getting-Started documentation", 
            "title": "v0.10.0"
        }, 
        {
            "location": "/concepts/", 
            "text": "LaxarJS Concepts\n\n\nIn order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.\n\n\nA LaxarJS Application\n\n\nTo the visitor running a web browser, an \napplication\n is a set of URLs and associated pages which are loaded by the browser to provide some information or functionality.\nAn application may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.\n\n\nFrom a developer point of view, an application primarily consists of:\n\n\n* a set of LaxarJS _widgets_ and _activities_ providing the functionality\n* the _pages_ and _layouts_ assembling these widgets and activities\n* a _flow_ that connects the individual pages\n* one or more _themes_ to define the look and feel of the application.\n\n\n\n\n\nIn order to run the application, there are additional secondary resources:\n\n\n* the _LaxarJS runtime_ loads flow and pages, sets up the widgets and connects them to the _event bus_\n* _controls_ which are used by the widgets to provide advanced user interface functionality, such as those provided by _LaxarJS UiKit_\n* _libraries_ used by widgets and activities, such as _moment.js_, _jQuery_, and _LaxarJS Patterns_.\n\n\n\n\n\nThe following two sections first explain the primary application components, and then the underlying secondary components.\n\n\nPrimary Application Parts\n\n\nWidgets\n\n\nA \nLaxarJS widget\n is a rectangular part of the browser viewport which \nallows the user to perform some task\n.\nIt usually consists of several HTML elements, but might in some cases use only a single element, for example a \ncanvas\n to provide a painting surface.\n\n\nThe important distinction between a LaxarJS widget and a plain HTML control (such as a \nselect\n box or an \ninput\n field) is that a widget is written with a specific \nuser-goal\n in mind, whereas a control is general-purpose and its role in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a name, or a password), a widget might combine these input controls in a box to allow the same user to \nlog in\n to the application, and another widget might allow the user to \nregister\n a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.\n\n\nTo illustrate this with further examples, possible widgets \nwith their specific goals\n include:\n\n\n* a to-do list, _to check and plan what is to do_\n* a shopping cart, _to review and edit purchase items_\n* a route planner displayed as a map, _to plan a journey_\n* a calendar displaying various events, _to schedule and check appointments_\n* the details editor for a specific event, _to reschedule or cancel an appointment_\n* a social buttons bar, _to share content_.\n\n\n\n\n\nIn contrast, these are controls:\n\n\n* an input field, _to display/edit any text_\n* a date picker, _to display/edit any date_\n* a select box, _to choose from any list of options_\n* an accordion control or a tab control, _to navigate any set of contents_.\n\n\n\n\n\nAnother way to think of it is that \nwidgets are made of controls\n, and  \ncontrols are HTML elements\n which may be user-defined (for example through AngularJS directives).\nThe program logic of an individual widget is implemented in JavaScript (as an AngularJS controller) while the presentation is defined as an (AngularJS) HTML template, optionally accompanied by CSS styling information.\nAnother important property of widgets is that they always can be \nloaded and tested in isolation\n.\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) might already be there.\n\n\nActivities\n\n\nA \nLaxarJS activity\n is a widget without a visual representation, performing a task for the user \nbehind the scenes\n.\nTo build upon the previous example, a \nlogin widget\n might talk to an authentication service itself, but it might also delegate this task to an \nauthentication activity\n using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS login to OAuth) only the activity needs to be exchanged, while the widget might remain untouched.\nIn contrast to libraries and regular AngularJS services, activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe.\n\n\nAnother possible example would be a \nweb search widget\n offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just \nsubscribes\n to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching any of the other implementations.\n\n\nAnother way to think of it is that \nwidgets have to run in the browser, while activities might run in any JavaScript environment\n.\nIn contrast to visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.\n\n\nPages\n\n\nA \nLaxarJS page\n combines and configures widgets and activities that should be displayed together by embedding them in an HTML skeleton (the layout).\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions.\n\n\nAn individual widget is still somewhat generic in that it allows to perform a specific task \nin any context\n.\nFor example, a social buttons bar might allow to share \nany content\n, and the specific list of social sites to share on might be \nconfigurable\n.\nThe page establishes this context, for example \nby placing\n the social buttons below a news article (rendered from markdown by another widget), and \nby configuring\n that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nBut it means that reuse is supported for those widgets where it makes sense.\n\n\nWhile widgets and activities are implemented in JavaScript and HTML, pages are written using JSON in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.\nUsually, each page occupies its own \"screen\" in your application, but there are mechanisms to divide pages into fragments and to \ncompose\n them back together.\n\n\nLayouts\n\n\nLaxarJS layouts\n are skeleton HTML documents, which contain placeholders (called \nwidget areas\n) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nA layout can contain all the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.\n\n\nFor each \nwidget areas\n, the layout defines a width in grid columns, and widgets within these areas may not exceed their available number of columns.\nThe LaxarJS UiKit ships with \nBootstrap\n to implement the grid layout in CSS.\nLike widgets, layouts are accompanied by CSS styles, for example to define a background color.\n\n\nYou might think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.\n\n\nThe Flow\n\n\nThe flow defines \nURL patterns\n that may be used to navigate to the pages of an application, and \nrelations between pages\n.\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, the flow defines semantic relations between pages, such as what is considered the \nnext\n page from a given page in the application.\n\n\nThemes\n\n\nWidgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.\n\n\nThe LaxarJS UiKit is based on Compass/SCSS to simplify the generation of user defined themes. However, any way to generate Bootstrap-like CSS styles is a valid way to create a theme.\n\n\nSecondary Application Parts \u2013 Under the Hood\n\n\nThe LaxarJS Runtime\n\n\nThe \nruntime\n handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.\nOnce everything is set up, the runtime gets out of the way: it lets the widgets perform their tasks and communicate through the event bus as needed.\n\n\nThe LaxarJS Event Bus\n\n\nThe \nevent bus\n allows widgets to talk about common topics, without knowing \nanything\n about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or expect resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.\n\n\nControls\n\n\nControls\n are (user-defined) HTML elements and attributes, usually implemented as AngularJS directives.\nThey are available to widgets as reusable UI components, and are styled using \nBootstrap 3.2\n for interoperability and theme support.\nA useful set of controls to get started is provided by the \nAngular UI Bootstrap\n project.\n\n\nLibraries\n\n\nWidgets may use \nlibraries\n such as \njQuery\n or \nmoment.js\n just like in any JavaScript web application.\nLaxarJS currently provides a development workflow based on \ngrunt\n, \nbower\n, and \nRequireJS\n in order to install and load widgets with their assets as well as libraries, but other tool-chains are not out of the question.\n\n\nTo establish a useful common base vocabulary for use with the event bus, the \nLaxarJS Patterns\n library is provided.\nIt contains helpers that make it easy for widgets to talk about user actions, common (REST) resources and boolean flags.\n\n\nNext Steps\n\n\nAfter this quick tour through the building blocks of a LaxarJS application, have a look at the \nmanuals\n for in-depth information on individual topics.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#laxarjs-concepts", 
            "text": "In order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#a-laxarjs-application", 
            "text": "To the visitor running a web browser, an  application  is a set of URLs and associated pages which are loaded by the browser to provide some information or functionality.\nAn application may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.  From a developer point of view, an application primarily consists of:  * a set of LaxarJS _widgets_ and _activities_ providing the functionality\n* the _pages_ and _layouts_ assembling these widgets and activities\n* a _flow_ that connects the individual pages\n* one or more _themes_ to define the look and feel of the application.  In order to run the application, there are additional secondary resources:  * the _LaxarJS runtime_ loads flow and pages, sets up the widgets and connects them to the _event bus_\n* _controls_ which are used by the widgets to provide advanced user interface functionality, such as those provided by _LaxarJS UiKit_\n* _libraries_ used by widgets and activities, such as _moment.js_, _jQuery_, and _LaxarJS Patterns_.  The following two sections first explain the primary application components, and then the underlying secondary components.", 
            "title": "A LaxarJS Application"
        }, 
        {
            "location": "/concepts/#primary-application-parts", 
            "text": "", 
            "title": "Primary Application Parts"
        }, 
        {
            "location": "/concepts/#widgets", 
            "text": "A  LaxarJS widget  is a rectangular part of the browser viewport which  allows the user to perform some task .\nIt usually consists of several HTML elements, but might in some cases use only a single element, for example a  canvas  to provide a painting surface.  The important distinction between a LaxarJS widget and a plain HTML control (such as a  select  box or an  input  field) is that a widget is written with a specific  user-goal  in mind, whereas a control is general-purpose and its role in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a name, or a password), a widget might combine these input controls in a box to allow the same user to  log in  to the application, and another widget might allow the user to  register  a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.  To illustrate this with further examples, possible widgets  with their specific goals  include:  * a to-do list, _to check and plan what is to do_\n* a shopping cart, _to review and edit purchase items_\n* a route planner displayed as a map, _to plan a journey_\n* a calendar displaying various events, _to schedule and check appointments_\n* the details editor for a specific event, _to reschedule or cancel an appointment_\n* a social buttons bar, _to share content_.  In contrast, these are controls:  * an input field, _to display/edit any text_\n* a date picker, _to display/edit any date_\n* a select box, _to choose from any list of options_\n* an accordion control or a tab control, _to navigate any set of contents_.  Another way to think of it is that  widgets are made of controls , and   controls are HTML elements  which may be user-defined (for example through AngularJS directives).\nThe program logic of an individual widget is implemented in JavaScript (as an AngularJS controller) while the presentation is defined as an (AngularJS) HTML template, optionally accompanied by CSS styling information.\nAnother important property of widgets is that they always can be  loaded and tested in isolation .\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) might already be there.", 
            "title": "Widgets"
        }, 
        {
            "location": "/concepts/#activities", 
            "text": "A  LaxarJS activity  is a widget without a visual representation, performing a task for the user  behind the scenes .\nTo build upon the previous example, a  login widget  might talk to an authentication service itself, but it might also delegate this task to an  authentication activity  using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS login to OAuth) only the activity needs to be exchanged, while the widget might remain untouched.\nIn contrast to libraries and regular AngularJS services, activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe.  Another possible example would be a  web search widget  offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just  subscribes  to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching any of the other implementations.  Another way to think of it is that  widgets have to run in the browser, while activities might run in any JavaScript environment .\nIn contrast to visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.", 
            "title": "Activities"
        }, 
        {
            "location": "/concepts/#pages", 
            "text": "A  LaxarJS page  combines and configures widgets and activities that should be displayed together by embedding them in an HTML skeleton (the layout).\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions.  An individual widget is still somewhat generic in that it allows to perform a specific task  in any context .\nFor example, a social buttons bar might allow to share  any content , and the specific list of social sites to share on might be  configurable .\nThe page establishes this context, for example  by placing  the social buttons below a news article (rendered from markdown by another widget), and  by configuring  that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nBut it means that reuse is supported for those widgets where it makes sense.  While widgets and activities are implemented in JavaScript and HTML, pages are written using JSON in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.\nUsually, each page occupies its own \"screen\" in your application, but there are mechanisms to divide pages into fragments and to  compose  them back together.", 
            "title": "Pages"
        }, 
        {
            "location": "/concepts/#layouts", 
            "text": "LaxarJS layouts  are skeleton HTML documents, which contain placeholders (called  widget areas ) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nA layout can contain all the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.  For each  widget areas , the layout defines a width in grid columns, and widgets within these areas may not exceed their available number of columns.\nThe LaxarJS UiKit ships with  Bootstrap  to implement the grid layout in CSS.\nLike widgets, layouts are accompanied by CSS styles, for example to define a background color.  You might think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.", 
            "title": "Layouts"
        }, 
        {
            "location": "/concepts/#the-flow", 
            "text": "The flow defines  URL patterns  that may be used to navigate to the pages of an application, and  relations between pages .\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, the flow defines semantic relations between pages, such as what is considered the  next  page from a given page in the application.", 
            "title": "The Flow"
        }, 
        {
            "location": "/concepts/#themes", 
            "text": "Widgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.  The LaxarJS UiKit is based on Compass/SCSS to simplify the generation of user defined themes. However, any way to generate Bootstrap-like CSS styles is a valid way to create a theme.", 
            "title": "Themes"
        }, 
        {
            "location": "/concepts/#secondary-application-parts-under-the-hood", 
            "text": "", 
            "title": "Secondary Application Parts \u2013 Under the Hood"
        }, 
        {
            "location": "/concepts/#the-laxarjs-runtime", 
            "text": "The  runtime  handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.\nOnce everything is set up, the runtime gets out of the way: it lets the widgets perform their tasks and communicate through the event bus as needed.", 
            "title": "The LaxarJS Runtime"
        }, 
        {
            "location": "/concepts/#the-laxarjs-event-bus", 
            "text": "The  event bus  allows widgets to talk about common topics, without knowing  anything  about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or expect resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.", 
            "title": "The LaxarJS Event Bus"
        }, 
        {
            "location": "/concepts/#controls", 
            "text": "Controls  are (user-defined) HTML elements and attributes, usually implemented as AngularJS directives.\nThey are available to widgets as reusable UI components, and are styled using  Bootstrap 3.2  for interoperability and theme support.\nA useful set of controls to get started is provided by the  Angular UI Bootstrap  project.", 
            "title": "Controls"
        }, 
        {
            "location": "/concepts/#libraries", 
            "text": "Widgets may use  libraries  such as  jQuery  or  moment.js  just like in any JavaScript web application.\nLaxarJS currently provides a development workflow based on  grunt ,  bower , and  RequireJS  in order to install and load widgets with their assets as well as libraries, but other tool-chains are not out of the question.  To establish a useful common base vocabulary for use with the event bus, the  LaxarJS Patterns  library is provided.\nIt contains helpers that make it easy for widgets to talk about user actions, common (REST) resources and boolean flags.", 
            "title": "Libraries"
        }, 
        {
            "location": "/concepts/#next-steps", 
            "text": "After this quick tour through the building blocks of a LaxarJS application, have a look at the  manuals  for in-depth information on individual topics.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/why_laxar/", 
            "text": "Why LaxarJS?\n\n\nIt is difficult to build large applications using AngularJS.\nEven the creators \ntell you\n not to do that.\nUnfortunately your customer has not read that article and now you are trying to manage twenty controllers on the same page.\nWe therefore developed LaxarJS as a way to handle this complexity by splitting your application into isolated, manageable components that may be reused in different contexts.\nBecause LaxarJS allows components to collaborate without prior knowledge of each other by using publish/subscribe, you may think of it as the missing \nmiddleware for the web client\n.\n\n\nWhy is it Difficult to Use AngularJS in Large Applications?\n\n\nAngularJS already tries to address some of the issues arising with larger applications such as end-to-end testability, encapsulation through directives and controller/view-separation.\nAlso there already exist \nbest practices\n on the organization of larger applications.\nHowever it is not obvious how to isolate and possibly even reuse larger blocks of functionality as perceived by the application user.\nAngularJS offers many ways to \ncouple\n your components, but only few ways to reliably \ndecouple\n them:\n\n\n\n\nbinding to shared scope properties harms stability due to side effects\n\n\nshared state via services may quickly lead to similar problems\n\n\nbindings to directive controllers introduce dependencies to (usually synchronous) APIs\n\n\n$broadcast\n and \n$emit\n improve on the hard dependencies, but still enforce a specific DOM structure and may lead to timing issues during instantiation.\n\n\n\n\nHow can we continue to leverage the benefits of AngularJS and offer better decoupling of (large) components?\n\n\nHow LaxarJS Addresses the Complexity Issue\n\n\nAt its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an \nevent bus\n that allows components (called \nwidgets\n) to communicate without knowing each other.\n\n\nThe Event Bus Decouples Widgets\n\n\nWidgets may \npublish\n application resources and \nsubscribe\n to changes of those resources without knowing about their mutual state.\nFor example, in a web shop one widget might represent the shopping cart while another widget resembling the catalog would add articles to the shopping cart by publishing the respective events.\nEach of the two widgets has its own view of the \nsame\n shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.\n\n\nAfter a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a \ncheck out\n button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would then \nreact\n to the event and later publish its own event to indicate that the action was performed successfully.\n\n\nThere is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation, \nrelaxing\n the tight constraints and dependencies imposed by traditional programmatic APIs.\n\n\nThe Runtime Composes Widgets\n\n\nIn the application, widgets are connected to each other in a declarative fashion using JSON \npage definitions\n.\nThe \nLaxarJS runtime\n is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets such as HTML and CSS.\nNote that LaxarJS is also not limited to AngularJS: Widgets can be written in pretty much any technology (including React, or plain DOM), but AngularJS is currently supported best.\n\n\nIndividual pages are interrelated through a \nflow definition\n which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.\n\n\nThe Best of Both Worlds\n\n\nBuilding upon the thriving ecosystem of Web Standards and (AngularJS) web components, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.\n\n\nIf this draws your interest, learn more about the LaxarJS \nkey concepts\n or jump in at the deep end by writing your first \nLaxarJS\n application.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#why-laxarjs", 
            "text": "It is difficult to build large applications using AngularJS.\nEven the creators  tell you  not to do that.\nUnfortunately your customer has not read that article and now you are trying to manage twenty controllers on the same page.\nWe therefore developed LaxarJS as a way to handle this complexity by splitting your application into isolated, manageable components that may be reused in different contexts.\nBecause LaxarJS allows components to collaborate without prior knowledge of each other by using publish/subscribe, you may think of it as the missing  middleware for the web client .", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#why-is-it-difficult-to-use-angularjs-in-large-applications", 
            "text": "AngularJS already tries to address some of the issues arising with larger applications such as end-to-end testability, encapsulation through directives and controller/view-separation.\nAlso there already exist  best practices  on the organization of larger applications.\nHowever it is not obvious how to isolate and possibly even reuse larger blocks of functionality as perceived by the application user.\nAngularJS offers many ways to  couple  your components, but only few ways to reliably  decouple  them:   binding to shared scope properties harms stability due to side effects  shared state via services may quickly lead to similar problems  bindings to directive controllers introduce dependencies to (usually synchronous) APIs  $broadcast  and  $emit  improve on the hard dependencies, but still enforce a specific DOM structure and may lead to timing issues during instantiation.   How can we continue to leverage the benefits of AngularJS and offer better decoupling of (large) components?", 
            "title": "Why is it Difficult to Use AngularJS in Large Applications?"
        }, 
        {
            "location": "/why_laxar/#how-laxarjs-addresses-the-complexity-issue", 
            "text": "At its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an  event bus  that allows components (called  widgets ) to communicate without knowing each other.", 
            "title": "How LaxarJS Addresses the Complexity Issue"
        }, 
        {
            "location": "/why_laxar/#the-event-bus-decouples-widgets", 
            "text": "Widgets may  publish  application resources and  subscribe  to changes of those resources without knowing about their mutual state.\nFor example, in a web shop one widget might represent the shopping cart while another widget resembling the catalog would add articles to the shopping cart by publishing the respective events.\nEach of the two widgets has its own view of the  same  shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.  After a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a  check out  button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would then  react  to the event and later publish its own event to indicate that the action was performed successfully.  There is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation,  relaxing  the tight constraints and dependencies imposed by traditional programmatic APIs.", 
            "title": "The Event Bus Decouples Widgets"
        }, 
        {
            "location": "/why_laxar/#the-runtime-composes-widgets", 
            "text": "In the application, widgets are connected to each other in a declarative fashion using JSON  page definitions .\nThe  LaxarJS runtime  is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets such as HTML and CSS.\nNote that LaxarJS is also not limited to AngularJS: Widgets can be written in pretty much any technology (including React, or plain DOM), but AngularJS is currently supported best.  Individual pages are interrelated through a  flow definition  which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.", 
            "title": "The Runtime Composes Widgets"
        }, 
        {
            "location": "/why_laxar/#the-best-of-both-worlds", 
            "text": "Building upon the thriving ecosystem of Web Standards and (AngularJS) web components, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.  If this draws your interest, learn more about the LaxarJS  key concepts  or jump in at the deep end by writing your first  LaxarJS  application.", 
            "title": "The Best of Both Worlds"
        }, 
        {
            "location": "/api/assert.js/", 
            "text": "assert\n\n\nThe \nassert\n module provides some simple assertion methods for type checks, truthyness tests and guards\ninvalid code paths.\n\n\nWhen requiring \nlaxar\n, it is available as \nlaxar.assert\n.\n\n\nContents\n\n\nModule Members\n\n\n\n\nassert\n\n\ncodeIsUnreachable\n\n\nstate\n\n\n\n\nTypes\n\n\n\n\nAssertion\n\n\nAssertion#isNotNull\n\n\nAssertion#hasType\n\n\nAssertion#hasProperty\n\n\n\n\n\n\n\n\nModule Members\n\n\nassert( subject, optionalDetails )\n\n\nCreates and returns a new \nAssertion\n instance for the given \nsubject\n.\n\n\nNote\n: this function is no member of the module, but the module itself. Thus when using \nassert\n via\nlaxar, \nassert\n is will be no simple object, but this function having the other functions as\nproperties.\n\n\nExample:\n\n\ndefine\n(\n \n[\n \nlaxar\n \n],\n \nfunction\n(\n \nax\n \n)\n \n{\n\n   \nax\n.\nassert\n(\n \nax\n.\nassert\n \n).\nhasType\n(\n \nFunction\n \n);\n\n   \nax\n.\nassert\n.\nstate\n(\n \ntypeof\n \nax\n.\nassert\n.\ncodeIsUnreachable\n \n===\n \nfunction\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsubject\n\n\n*\n\n\nthe object assertions are made for\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails that should be printed in case no specific details are given when calling an assertion method\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthe assertion instance\n\n\n\n\n\n\n\n\ncodeIsUnreachable( optionalDetails )\n\n\nMarks a code path as erroneous by throwing an error when reached.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nstate( expression, optionalDetails )\n\n\nThrows an error if the given expression is falsy.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexpression\n\n\n*\n\n\nthe expression to test for truthyness\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nTypes\n\n\nAssertion\n\n\nAssertion#isNotNull( optionalDetails )\n\n\nThrows an error if the subject is \nnull\n or \nundefined\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthis instance\n\n\n\n\n\n\n\n\nAssertion#hasType( type, optionalDetails )\n\n\nThrows an error if the subject is not of the given type. No error is thrown for \nnull\n or \nundefined\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nFunction\n\n\nthe expected type of the subject\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthis instance\n\n\n\n\n\n\n\n\nAssertion#hasProperty( property, optionalDetails )\n\n\nThrows an error if the subject is no object or the given property is not defined on it.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nproperty\n\n\nString\n\n\nthe property that is expected for the subject\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthis instance", 
            "title": "assert"
        }, 
        {
            "location": "/api/assert.js/#assert", 
            "text": "The  assert  module provides some simple assertion methods for type checks, truthyness tests and guards\ninvalid code paths.  When requiring  laxar , it is available as  laxar.assert .", 
            "title": "assert"
        }, 
        {
            "location": "/api/assert.js/#contents", 
            "text": "Module Members   assert  codeIsUnreachable  state   Types   Assertion  Assertion#isNotNull  Assertion#hasType  Assertion#hasProperty", 
            "title": "Contents"
        }, 
        {
            "location": "/api/assert.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/assert.js/#parameters", 
            "text": "Property  Type  Description      subject  *  the object assertions are made for    optionalDetails  String  details that should be printed in case no specific details are given when calling an assertion method", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/assert.js/#returns", 
            "text": "Type  Description      Assertion  the assertion instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/assert.js/#parameters_1", 
            "text": "Property  Type  Description      optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/assert.js/#parameters_2", 
            "text": "Property  Type  Description      expression  *  the expression to test for truthyness    optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/assert.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/assert.js/#parameters_3", 
            "text": "Property  Type  Description      optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/assert.js/#returns_1", 
            "text": "Type  Description      Assertion  this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/assert.js/#parameters_4", 
            "text": "Property  Type  Description      type  Function  the expected type of the subject    optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/assert.js/#returns_2", 
            "text": "Type  Description      Assertion  this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/assert.js/#parameters_5", 
            "text": "Property  Type  Description      property  String  the property that is expected for the subject    optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/assert.js/#returns_3", 
            "text": "Type  Description      Assertion  this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/id.js/", 
            "text": "axId\n\n\nA module for the \naxId\n and \naxFor\n directives.\n\n\nContents\n\n\nAngularJS Directives\n\n\n\n\naxId\n\n\naxFor\n\n\n\n\nAngularJS Directives\n\n\naxId\n\n\nThis directive should be used within a widget whenever a unique id for a DOM element should be created.\nIt's value is evaluated as AngularJS expression and used as a local identifier to generate a distinct,\nunique document wide id.\n\n\nA common use case is in combination with \naxFor\n for input fields having a label.\n\n\nExample:\n\n\nlabel\n \nax-for=\nuserName\nPlease enter your name:\n/label\n\n\ninput\n \nax-id=\nuserName\n \ntype=\ntext\n \nng-model=\nusername\n\n\n\n\n\n\naxFor\n\n\nThis directive should be used within a widget whenever an id, generated using the \naxId\n directive,\nshould be referenced at a \nlabel\n element.\n\n\nExample:\n\n\nlabel\n \nax-for=\nuserName\nPlease enter your name:\n/label\n\n\ninput\n \nax-id=\nuserName\n \ntype=\ntext\n \nng-model=\nusername", 
            "title": "axId"
        }, 
        {
            "location": "/api/id.js/#axid", 
            "text": "A module for the  axId  and  axFor  directives.", 
            "title": "axId"
        }, 
        {
            "location": "/api/id.js/#contents", 
            "text": "AngularJS Directives   axId  axFor", 
            "title": "Contents"
        }, 
        {
            "location": "/api/id.js/#angularjs-directives", 
            "text": "", 
            "title": "AngularJS Directives"
        }, 
        {
            "location": "/api/layout.js/", 
            "text": "axLayout\n\n\nA module for the \naxLayout\n directive.\n\n\nContents\n\n\nAngularJS Directives\n\n\n\n\naxLayout\n\n\n\n\nAngularJS Directives\n\n\naxLayout\n\n\nThis directive uses the \naxLayoutLoader\n service to load a given layout and compile it as child to the\nelement the directive is set on. In contrast to \nngInclude\n it doesn't watch the provided expression for\nperformance reasons and takes LaxarJS theming into account when loading the assets.", 
            "title": "axLayout"
        }, 
        {
            "location": "/api/layout.js/#axlayout", 
            "text": "A module for the  axLayout  directive.", 
            "title": "axLayout"
        }, 
        {
            "location": "/api/layout.js/#contents", 
            "text": "AngularJS Directives   axLayout", 
            "title": "Contents"
        }, 
        {
            "location": "/api/layout.js/#angularjs-directives", 
            "text": "", 
            "title": "AngularJS Directives"
        }, 
        {
            "location": "/api/runtime_services.js/", 
            "text": "axRuntimeServices\n\n\nThis module provides some services for AngularJS DI. Although it is fine to use these services in widgets,\nmost of them are primarily intended to be used internally by LaxarJS. Documentation is nevertheless of use\nwhen e.g. they need to be mocked during tests.\n\n\nContents\n\n\nInjectable Services\n\n\n\n\n\n\naxHeartbeat\n\n\n\n\naxHeartbeat#onNext\n\n\naxHeartbeat#onBeforeNext\n\n\naxHeartbeat#onAfterNext\n\n\n\n\n\n\n\n\naxTimestamp\n\n\n\n\naxControls\n\n\naxGlobalEventBus\n\n\naxConfiguration\n\n\naxI18n\n\n\naxFileResourceProvider\n\n\naxThemeManager\n\n\naxLayoutLoader\n\n\n\n\naxCssLoader\n\n\n\n\naxCssLoader#load\n\n\n\n\n\n\n\n\naxVisibilityService\n\n\n\n\naxVisibilityService#handlerFor\n\n\naxVisibilityService#isVisible\n\n\n\n\n\n\n\n\nTypes\n\n\n\n\naxVisibilityServiceHandler\n\n\naxVisibilityServiceHandler#isVisible\n\n\naxVisibilityServiceHandler#onChange\n\n\naxVisibilityServiceHandler#onShow\n\n\naxVisibilityServiceHandler#onHide\n\n\naxVisibilityServiceHandler#clear\n\n\n\n\n\n\n\n\nInjectable Services\n\n\naxHeartbeat\n\n\nThis is a scheduler for asynchronous tasks (like nodejs' \nprocess.nextTick\n)  trimmed for performance.\nIt is intended for use cases where many tasks are scheduled in succession within one JavaScript event\nloop. It integrates into the AngularJS \n$digest\n cycle, while trying to minimize the amount of full\n\n\n$digest\n cycles.\n\n\nFor example in LaxarJS the global event bus instance (\naxGlobalEventBus\n) uses this service.\n\n\naxHeartbeat#onNext( func )\n\n\nSchedules a function for the next heartbeat. If no heartbeat was triggered yet, it will be\nrequested now.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nFunction\n\n\na function to schedule for the next tick\n\n\n\n\n\n\n\n\naxHeartbeat#onBeforeNext( func )\n\n\nSchedules a function to be called before the next heartbeat occurs. Note that \nfunc\n may never be\ncalled, if there is no next heartbeat.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nFunction\n\n\na function to call before the next heartbeat\n\n\n\n\n\n\n\n\naxHeartbeat#onAfterNext( func )\n\n\nSchedules a function to be called after the next heartbeat occured. Note that \nfunc\n may never be\ncalled, if there is no next heartbeat.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nFunction\n\n\na function to call after the next heartbeat\n\n\n\n\n\n\n\n\naxTimestamp\n\n\nA timestamp function, provided as a service to support the jasmine mock clock during testing. The\nmock-free implementation simply uses \nnew Date().getTime()\n. Whenever a simple timestamp is needed in a\nwidget, this service can be used to allow for hassle-free testing.\n\n\nExample:\n\n\nController\n.\n$inject\n \n=\n \n[\n \naxTimestamp\n \n];\n\n\nfunction\n \nController\n(\n \naxTimestamp\n \n)\n \n{\n\n   \nvar\n \ncurrentTimestamp\n \n=\n \naxTimestamp\n();\n\n\n};\n\n\n\n\n\n\naxControls\n\n\nProvides access to the control-implementation-modules used by a widget.\nFurther documentation on the api can be found at the \ncontrols_service\n module api doc.\n\n\naxGlobalEventBus\n\n\nThe global event bus instance provided by the LaxarJS runtime. Widgets \nshould never\n use this, as\nsubscriptions won't be removed when a widget is destroyed. Instead widgets should always either use the\n\neventBus\n property on their local \n$scope\n object or the service \naxEventBus\n. These take care of all\nsubscriptions on widget destructions and thus prevent from leaking memory and other side effects.\n\n\nThis service instead can be used by other services, that live throughout the whole lifetime of an\napplication or take care of unsubscribing from events themselves. Further documentation on the api can\nbe found at the \nevent_bus\n module api doc.\n\n\naxConfiguration\n\n\nProvides access to the global configuration, otherwise accessible via the \nconfiguration\n module.\nFurther documentation can be found there.\n\n\naxI18n\n\n\nProvides access to the i18n api, otherwise accessible via the \ni18n\n module. Further documentation can\nbe found there.\n\n\naxFileResourceProvider\n\n\nA global, pre-configured file resource provider instance. Further documentation on the api can\nbe found at the \nfile_resource_provider\n module api doc.\n\n\nThis service has already all the file listings configured under \nwindow.laxar.fileListings\n. These can\neither be uris to listing JSON files or already embedded JSON objects of the directory tree.\n\n\naxThemeManager\n\n\nProvides access to the configured theme and theme relevant assets via a theme manager instance. Further\ndocumentation on the api can be found at the \ntheme_manager\n module api doc.\n\n\naxLayoutLoader\n\n\nLoads a layout relative to the path \nlaxar-path-root\n configured via RequireJS (by default\n\n/application/layouts\n), taking the configured theme into account. If a CSS file is found, it will\ndirectly be loaded into the page. A HTML template will instead get returned for manual insertion at the\ncorrect DOM location. For this service there is also the companion directive \naxLayout\n available.\n\n\nExample:\n\n\nmyNgModule\n.\ndirective\n(\n \n[\n \naxLayoutLoader\n,\n \nfunction\n(\n \naxLayoutLoader\n \n)\n \n{\n\n   \nreturn\n \n{\n\n      \nlink\n:\n \nfunction\n(\n \nscope\n,\n \nelement\n,\n \nattrs\n \n)\n \n{\n\n         \naxLayoutLoader\n.\nload\n(\n \nmyLayout\n \n)\n\n            \n.\nthen\n(\n \nfunction\n(\n \nlayoutInfo\n \n)\n \n{\n\n               \nelement\n.\nhtml\n(\n \nlayoutInfo\n.\nhtml\n \n);\n\n            \n}\n \n);\n\n      \n}\n\n   \n};\n\n\n}\n \n]\n \n);\n\n\n\n\n\n\naxCssLoader\n\n\nA service to load css files on demand during development. If a merged release css file has already been\nloaded (marked with a \ndata-ax-merged-css\n html attribute at the according \nlink\n tag) or \nuseMergedCss\n\nis configured as \ntrue\n, the \nload\n method will simply be a noop. In the latter case the merged css file\nwill be loaded once by this service.\n\n\naxCssLoader#load( url )\n\n\nIf not already loaded, loads the given file into the current page by appending a \nlink\n element to\nthe document's \nhead\n element.\n\n\nAdditionally it works around a\n\nstyle sheet limit\n in older Internet Explorers\n(version \n 10). The workaround is based on\n\nthis test\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nString\n\n\nthe url of the css file to load\n\n\n\n\n\n\n\n\naxVisibilityService\n\n\nDirectives should use this service to stay informed about visibility changes to their widget.\nThey should not attempt to determine their visibility from the event bus (no DOM information),\nnor poll it from the browser (too expensive).\n\n\nIn contrast to the visibility events received over the event bus, these handlers will fire \nafter\n the\nvisibility change has been implemented in the DOM, at which point in time the actual browser rendering\nstate should correspond to the information conveyed in the event.\n\n\nThe visibility service allows to register for onShow/onHide/onChange. When cleared, all handlers for\nthe given scope will be cleared. Handlers are automatically cleared as soon as the given scope is\ndestroyed. Handlers will be called whenever the given scope's visibility changes due to the widget\nbecoming visible/invisible. Handlers will \nnot\n be called on state changes originating \nfrom within\n the\nwidget such as those caused by \nngShow\n.\n\n\nIf a widget becomes visible at all, the corresponding handlers for onChange and onShow are guaranteed\nto be called at least once.\n\n\naxVisibilityService#handlerFor( scope )\n\n\nCreate a DOM visibility handler for the given scope.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nscope\n\n\nObject\n\n\nthe scope from which to infer visibility. Must be a widget scope or nested in a widget scope\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler\n\n\na visibility handler for the given scope\n\n\n\n\n\n\n\n\naxVisibilityService#isVisible( area )\n\n\nDetermine if the given area's content DOM is visible right now.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narea\n\n\nString\n\n\nthe full name of the widget area to query\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBoolean\n\n\ntrue\n if the area is visible right now, else \nfalse\n.\n\n\n\n\n\n\n\n\nTypes\n\n\naxVisibilityServiceHandler\n\n\nA scope bound visibility handler.\n\n\naxVisibilityServiceHandler#isVisible()\n\n\nDetermine if the governing widget scope's DOM is visible right now.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBoolean\n\n\ntrue\n if the widget associated with this handler is visible right now, else \nfalse\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler#onChange( handler )\n\n\nSchedule a handler to be called with the new DOM visibility on any DOM visibility change.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhandler\n\n\nFunction.\nBoolean\n\n\nthe callback to process visibility changes\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler\n\n\nthis visibility handler (for chaining)\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler#onShow( handler )\n\n\nSchedule a handler to be called with the new DOM visibility when it has changed to \ntrue\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhandler\n\n\nFunction.\nBoolean\n\n\nthe callback to process visibility changes\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler\n\n\nthis visibility handler (for chaining)\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler#onHide( handler )\n\n\nSchedule a handler to be called with the new DOM visibility when it has changed to \nfalse\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhandler\n\n\nFunction.\nBoolean\n\n\nthe callback to process visibility changes\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler\n\n\nthis visibility handler (for chaining)\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler#clear()\n\n\nRemoves all visibility handlers.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naxVisibilityServiceHandler\n\n\nthis visibility handler (for chaining)", 
            "title": "axRuntimeServices"
        }, 
        {
            "location": "/api/runtime_services.js/#axruntimeservices", 
            "text": "This module provides some services for AngularJS DI. Although it is fine to use these services in widgets,\nmost of them are primarily intended to be used internally by LaxarJS. Documentation is nevertheless of use\nwhen e.g. they need to be mocked during tests.", 
            "title": "axRuntimeServices"
        }, 
        {
            "location": "/api/runtime_services.js/#contents", 
            "text": "Injectable Services    axHeartbeat   axHeartbeat#onNext  axHeartbeat#onBeforeNext  axHeartbeat#onAfterNext     axTimestamp   axControls  axGlobalEventBus  axConfiguration  axI18n  axFileResourceProvider  axThemeManager  axLayoutLoader   axCssLoader   axCssLoader#load     axVisibilityService   axVisibilityService#handlerFor  axVisibilityService#isVisible     Types   axVisibilityServiceHandler  axVisibilityServiceHandler#isVisible  axVisibilityServiceHandler#onChange  axVisibilityServiceHandler#onShow  axVisibilityServiceHandler#onHide  axVisibilityServiceHandler#clear", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime_services.js/#injectable-services", 
            "text": "", 
            "title": "Injectable Services"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters", 
            "text": "Property  Type  Description      func  Function  a function to schedule for the next tick", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_1", 
            "text": "Property  Type  Description      func  Function  a function to call before the next heartbeat", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_2", 
            "text": "Property  Type  Description      func  Function  a function to call after the next heartbeat", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_3", 
            "text": "Property  Type  Description      url  String  the url of the css file to load", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_4", 
            "text": "Property  Type  Description      scope  Object  the scope from which to infer visibility. Must be a widget scope or nested in a widget scope", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#returns", 
            "text": "Type  Description      axVisibilityServiceHandler  a visibility handler for the given scope", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_5", 
            "text": "Property  Type  Description      area  String  the full name of the widget area to query", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#returns_1", 
            "text": "Type  Description      Boolean  true  if the area is visible right now, else  false .", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime_services.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime_services.js/#returns_2", 
            "text": "Type  Description      Boolean  true  if the widget associated with this handler is visible right now, else  false", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_6", 
            "text": "Property  Type  Description      handler  Function. Boolean  the callback to process visibility changes", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#returns_3", 
            "text": "Type  Description      axVisibilityServiceHandler  this visibility handler (for chaining)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_7", 
            "text": "Property  Type  Description      handler  Function. Boolean  the callback to process visibility changes", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#returns_4", 
            "text": "Type  Description      axVisibilityServiceHandler  this visibility handler (for chaining)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime_services.js/#parameters_8", 
            "text": "Property  Type  Description      handler  Function. Boolean  the callback to process visibility changes", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime_services.js/#returns_5", 
            "text": "Type  Description      axVisibilityServiceHandler  this visibility handler (for chaining)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime_services.js/#returns_6", 
            "text": "Type  Description      axVisibilityServiceHandler  this visibility handler (for chaining)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/widget_area.js/", 
            "text": "axWidgetArea\n\n\nA module for the \naxWidgetArea\n directive.\n\n\nContents\n\n\nAngularJS Directives\n\n\n\n\naxWidgetArea\n\n\n\n\nAngularJS Directives\n\n\naxWidgetArea\n\n\nThe \naxWidgetArea\n directive is used to mark DOM elements as possible containers for widgets. They're\nmost commonly used in layouts using static names. These areas can then be referenced from within page\ndefinitions in order to add widgets to them. Additionally it is possible that widgets expose widget\nareas themselves. In that case the name given within the widget template is prefixed with the id of the\nwidget instance, separated by a dot. If, within a widget, a name is dynamic (i.e. can be configured via\nfeature configuration), the corresponding \nax-widget-area-binding\n attribute can be set to bind a name.\n\n\nExample:\n\n\ndiv\n \nax-widget-area=\nmyArea\n!-- Here will be widgets --\n/div\n\n\n\n\n\n\nExample with binding:\n\n\ndiv\n \nax-widget-area\n\n     \nax-widget-area-binding=\nfeatures.content.areaName\n\n   \n!-- Here will be widgets --\n\n\n/div", 
            "title": "axWidgetArea"
        }, 
        {
            "location": "/api/widget_area.js/#axwidgetarea", 
            "text": "A module for the  axWidgetArea  directive.", 
            "title": "axWidgetArea"
        }, 
        {
            "location": "/api/widget_area.js/#contents", 
            "text": "AngularJS Directives   axWidgetArea", 
            "title": "Contents"
        }, 
        {
            "location": "/api/widget_area.js/#angularjs-directives", 
            "text": "", 
            "title": "AngularJS Directives"
        }, 
        {
            "location": "/api/configuration.js/", 
            "text": "configuration\n\n\nThe \nconfiguration\n module provides convenient readonly access to all values configured for this application\nunder \nwindow.laxar\n. Most probably this configuration takes place in the JavaScript file\n\napplication/application.js\n under your project's root directory.\n\n\nWhen requiring \nlaxar\n, it is available as \nlaxar.configuration\n.\n\n\nContents\n\n\nModule Members\n\n\n\n\nget\n\n\n\n\nModule Members\n\n\nget( key, optionalDefault )\n\n\nReturns the configured value for the specified attribute path or \nundefined\n in case it wasn't\nconfigured. If a default value was passed as second argument this is returned instead of \nundefined\n.\n\n\nExamples:\n\n\ndefine\n(\n \n[\n \nlaxar\n \n],\n \nfunction\n(\n \nax\n \n)\n \n{\n\n   \nax\n.\nconfiguration\n.\nget\n(\n \nlogging.threshold\n \n);\n \n// -\n \nINFO\n\n   \nax\n.\nconfiguration\n.\nget\n(\n \niDontExist\n \n);\n \n// -\n undefined\n\n   \nax\n.\nconfiguration\n.\nget\n(\n \niDontExist\n,\n \n42\n \n);\n \n// -\n 42\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\na  path (using \n.\n as separator) to the property in the configuration object\n\n\n\n\n\n\noptionalDefault\n\n\n*\n\n\nthe value to return if no value was set for \nkey\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\neither the configured value, \nundefined\n or \noptionalDefault", 
            "title": "configuration"
        }, 
        {
            "location": "/api/configuration.js/#configuration", 
            "text": "The  configuration  module provides convenient readonly access to all values configured for this application\nunder  window.laxar . Most probably this configuration takes place in the JavaScript file application/application.js  under your project's root directory.  When requiring  laxar , it is available as  laxar.configuration .", 
            "title": "configuration"
        }, 
        {
            "location": "/api/configuration.js/#contents", 
            "text": "Module Members   get", 
            "title": "Contents"
        }, 
        {
            "location": "/api/configuration.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/configuration.js/#parameters", 
            "text": "Property  Type  Description      key  String  a  path (using  .  as separator) to the property in the configuration object    optionalDefault  *  the value to return if no value was set for  key", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/configuration.js/#returns", 
            "text": "Type  Description      *  either the configured value,  undefined  or  optionalDefault", 
            "title": "Returns"
        }, 
        {
            "location": "/api/controls_service.js/", 
            "text": "controls_service\n\n\nThe controls service helps to lookup control assets and implementations.\nIt should be used via dependency injection as the \naxControls\n service.\n\n\nContents\n\n\nModule Members\n\n\n\n\nprovide\n\n\n\n\nModule Members\n\n\nprovide( controlRef )\n\n\nProvides the implementation module of the given control, for manual instantiation by a widget.\n\n\nBecause the method must return synchronously, it may only be called for controls that have been\nloaded before (using \nload\n)!\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontrolRef\n\n\nString\n\n\na valid control reference as used in the \nwidget.json\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe AMD module for the requested control reference", 
            "title": "controls_service"
        }, 
        {
            "location": "/api/controls_service.js/#controls_service", 
            "text": "The controls service helps to lookup control assets and implementations.\nIt should be used via dependency injection as the  axControls  service.", 
            "title": "controls_service"
        }, 
        {
            "location": "/api/controls_service.js/#contents", 
            "text": "Module Members   provide", 
            "title": "Contents"
        }, 
        {
            "location": "/api/controls_service.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/controls_service.js/#parameters", 
            "text": "Property  Type  Description      controlRef  String  a valid control reference as used in the  widget.json", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/controls_service.js/#returns", 
            "text": "Type  Description      *  the AMD module for the requested control reference", 
            "title": "Returns"
        }, 
        {
            "location": "/api/event_bus.js/", 
            "text": "event_bus\n\n\nThe \nevent_bus\n module contains the implementation of the \nLaxarJS EventBus\n. In an application you'll\nnever use this module or instantiate an event bus instance directly. Instead within a widget the event bus\ncan be injected via service or accessed as property on the AngularJS \n$scope\n or \naxContext\n injections.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate\n\n\ninit\n\n\n\n\nTypes\n\n\n\n\nEventBus\n\n\nEventBus#setErrorHandler\n\n\nEventBus#setMediator\n\n\nEventBus#addInspector\n\n\nEventBus#subscribe\n\n\nEventBus#unsubscribe\n\n\nEventBus#publish\n\n\nEventBus#publishAndGatherReplies\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( optionalConfiguration )\n\n\nCreates and returns a new event bus instance using the given configuration.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalConfiguration\n\n\nObject\n\n\nconfiguration for the event bus instance\n\n\n\n\n\n\noptionalConfiguration.pendingDidTimeout\n\n\nNumber\n\n\nthe timeout in milliseconds used by \nEventBus#publishAndGatherReplies\n. Default is 120000ms\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nEventBus\n\n\n\n\n\n\n\n\n\n\ninit( q, nextTick, timeoutFunction )\n\n\nInitializes the module.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nq\n\n\nObject\n\n\na promise library like AngularJS' \n$q\n\n\n\n\n\n\nnextTick\n\n\nFunction\n\n\na next tick function like \nprocess.nextTick\n or AngularJS' \n$timeout\n\n\n\n\n\n\ntimeoutFunction\n\n\nFunction\n\n\na timeout function like \nwindow.setTimeout\n  or AngularJS' \n$timeout\n\n\n\n\n\n\n\n\nTypes\n\n\nEventBus\n\n\nEventBus#setErrorHandler( errorHandler )\n\n\nSets a handler for all errors that may occur during event processing. It receives an error message as\nfirst argument and a map with additional information on the problem as second argument. There may be\ninstances of \nError\n as values within the map.\nThe default error handler simply logs all issues to \nconsole.error\n or \nconsole.log\n if available.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nerrorHandler\n\n\nFunction\n\n\nthe error handler\n\n\n\n\n\n\n\n\nEventBus#setMediator( mediator )\n\n\nSets a mediator, that has the chance to alter events shortly before their delivery to the according\nsubscribers. Its sole argument is the complete list of queued event items that should be delivered\nduring the current JavaScript event loop. It then needs to return this list, including optional\nmodifications, again. Event items may be added or deleted at will, but the return type needs to be an\narray containing zero or more event item-like objects.\n\n\nAn event item has these properties:\n\n\n\n\n\n\nmeta\n: map with meta information for this event\n\n\n\n\nname\n: full name of the published event\n\n\ncycleId\n: the id of the cycle the event was published in\n\n\nsender\n: name of sender (if available)\n\n\ninitiator\n: name of the sender initiating the current event cycle (if available)\n\n\noptions\n: map of options given when publishing the event\n\n\n\n\n\n\n\n\nevent\n: the event payload it self as published by the sender\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmediator\n\n\nFunction\n\n\nthe mediator function\n\n\n\n\n\n\n\n\nEventBus#addInspector( inspector )\n\n\nAdds an inspector, that gets notified when certain actions within the event bus take place. Currently\nthese actions may occur:\n\n\n\n\nsubscribe\n: a new subscriber registered for an event\n\n\npublish\n: an event is published but not yet delivered\n\n\ndeliver\n: an event is actually delivered to a subscriber\n\n\n\n\nAn inspector receives a map with the following properties:\n\n\n\n\naction\n: one of the actions from above\n\n\nsource\n: the origin of the \naction\n\n\ntarget\n: the name of the event subscriber (\ndeliver\n action only)\n\n\nevent\n: the full name of the event or the subscribed event (\nsubscribe\n action only)\n\n\neventObject\n: the published event item (\npublish\n action only)\n\n\nsubscribedTo\n: the event, possibly with omissions, the subscriber subscribed to (\ndeliver\n action only)\n\n\ncycleId\n: the id of the event cycle\n\n\n\n\nThe function returned by this method can be called to remove the inspector again and prevent it from\nbeing called for future event bus actions.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninspector\n\n\nFunction\n\n\nthe inspector function to add\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function to remove the inspector\n\n\n\n\n\n\n\n\nEventBus#subscribe( eventName, subscriber, optionalOptions )\n\n\nSubscribes to an event by name. An event name consists of so called \ntopics\n, where each topic is\nseparated from another by dots (\n.\n). If a topic is omitted, this is treated as a wildcard. Note that\ntwo dots in the middle or one dot at the beginning of an event name must remain, whereas a dot at the\nend may be omitted. As such every event name has an intrinsic wildcard at its end. For example these are\nall valid event names:\n\n\n\n\nsome.event\n: matches \nsome.event\n, \nsome.event.again\n\n\n.event\n: matches \nsome.event\n, \nany.event\n, \nany.event.again\n\n\nsome..event\n: matches \nsome.fancy.event\n, \nsome.special.event\n\n\n\n\nAdditionally \nsubtopics\n are supported. A subtopic are fragments of a topic, separated from another by\nsimple dashes (\n-\n). Here only suffixes of subtopics may be omitted when subscribing. Thus subscribing\nto \nsome.event\n would match an event published with name \nsome.event-again\n or even\n\nsome.event-another.again\n.\n\n\nWhen an event is delivered, the subscriber function receives two arguments:\nThe first one is the event object as it was published. If \nclone\n yields \ntrue\n this is a simple deep\ncopy of the object (note that only properties passing a JSON-(de)serialization remain). If \nfalse\n the\nobject is frozen using \nObject.freeze\n recursively in browsers that support freezing. In any other\nbrowser this is just an identity operation.\n\n\nThe second one is a meta object with these properties:\n\n\n\n\nunsubscribe\n: A function to directly unsubscribe the called subscriber from further events\n\n\nname\n: The name of the event as it actually was published (i.e. without wildcards).\n\n\ncycleId\n: The id of the cycle the event was published (and delivered) in\n\n\nsender\n: The id of the event sender, may be \nnull\n.\n\n\ninitiator\n: The id of the initiator of the cycle. Currently not implemented, thus always \nnull\n.\n\n\noptions\n: The options that were passed to \npublish\n or \npublishAndGatherReplies\n respectively.\n\n\n\n\nNote that the subscriber function will receive a property \nax__events\n to keep track of all events this\nfunction was attached to. This is necessary to make \nEventBus#unsubscribe\n work.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neventName\n\n\nString\n\n\nthe name of the event to subscribe to\n\n\n\n\n\n\nsubscriber\n\n\nFunction\n\n\na function to call whenever an event matching \neventName\n is published\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nadditional options for the subscribe action\n\n\n\n\n\n\noptionalOptions.subscriber\n\n\nString\n\n\nthe id of the subscriber. Default is \nnull\n\n\n\n\n\n\noptionalOptions.clone\n\n\nBoolean\n\n\nif \nfalse\n the event will be send frozen to the subscriber, otherwise it will receive a deep copy. Default is \ntrue\n\n\n\n\n\n\n\n\nEventBus#unsubscribe( subscriber )\n\n\nRemoves all subscriptions of the given subscriber.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsubscriber\n\n\nFunction\n\n\nthe function to unsubscribe\n\n\n\n\n\n\n\n\nEventBus#publish( eventName, optionalEvent, optionalOptions )\n\n\nAsynchronously publishes an event on the event bus. The returned promise will be queued as soon as this\nevent is delivered and, if during delivery a new event was enqueued, resolved after that new event was\ndelivered. If no new event is queued during delivery of this event, the promise is instantly resolved.\nTo make this a bit clearer, lets assume we publish and thus enqueue an event at time \nt\n. It then will\nbe delivered at time \nt+1\n. At that precise moment the promise is enqueued to be resolved soon. We then\ndistinguish between two cases:\n\n\n\n\nAt time \nt+1\n no subscriber publishes (i.e. enqueues) an event: Thus there is no event in the same\n  cycle and the promise is also resolved at time \nt+1\n.\n\n\nAt least one subscriber publishes an event at time \nt+1\n: The promise is then scheduled to be resolved\n  as soon as this event is delivered at time \nt+2\n.\n\n\n\n\nThe implication of this is the following:\n\n\nWe have two collaborators, A and B. A listens to event b and B listens to event a.\nWhenever A publishes a and B than instantly (i.e. in the same event cycle of the JavaScript runtime\nwhere its subscriber function was called) \nresponds\n by publishing b, b arrives at the subscriber\nfunction of A, before the promise of A's publish action is resolved.\nIt is hence possible to observe possible effects of an event sent by oneself, under the conditions\nmentioned above. Practically this is used internally for the implementation of\n\nEventBus#publishAndGatherReplies\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neventName\n\n\nString\n\n\nthe name of the event to publish\n\n\n\n\n\n\noptionalEvent\n\n\nObject\n\n\nthe event to publish\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nadditional options for the publish action\n\n\n\n\n\n\noptionalOptions.sender\n\n\nString\n\n\nthe id of the event sender. Default is \nnull\n\n\n\n\n\n\noptionalOptions.deliverToSender\n\n\nBoolean\n\n\nif \nfalse\n the event will not be send to subscribers whose subscriber name matches \noptionalOptions.sender\n, else all subscribers will receive the event. Default is \ntrue\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\nthe delivery promise\n\n\n\n\n\n\n\n\nEventBus#publishAndGatherReplies( eventName, optionalEvent, optionalOptions )\n\n\nPublishes an event that follows the \nrequest-will-did pattern\n and awaits all replies. This pattern has\nevolved over time and is of great use when handling the asynchronous nature of event bus events.\n\n\nCertain rules need to be fulfilled: First the initiator needs to call this method with an event whose\nname has the suffix \nRequest\n, e.g. \ntakeActionRequest\n. All collaborators that want to react to this\nevent then either do so in the same event cycle by sending a \ndidTakeAction\n event or announce that they\nwill do something asynchronously by publishing a \nwillTakeAction\n event. In the latter case they need to\nbroadcast the fulfillment of their action by sending a \ndidTakeAction\n event. Note that for both events\nthe same sender name needs to be given. Otherwise they cannot be mapped and the event bus doesn't know\nif all asynchronous replies were already received.\n\n\nAdditionally a timer is started using either the globally configured \npendingDidTimeout\n ms value or the\nvalue provided as option to this method. If that timer expires before all \ndid*\n events to all given\n\nwill*\n events were received, the error handler is called to handle the incident and the promise is\nrejected with all response received up to now.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neventName\n\n\nString\n\n\nthe name of the event to publish\n\n\n\n\n\n\noptionalEvent\n\n\nObject\n\n\nthe event to publish\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nadditional options for the publish action\n\n\n\n\n\n\noptionalOptions.sender\n\n\nString\n\n\nthe id of the event sender. Default is \nnull\n\n\n\n\n\n\noptionalOptions.pendingDidTimeout\n\n\nNumber\n\n\nthe timeout in milliseconds for pending did* events\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\nthe delivery promise. It receives a list of all collected \ndid*\n events and according meta information", 
            "title": "event_bus"
        }, 
        {
            "location": "/api/event_bus.js/#event_bus", 
            "text": "The  event_bus  module contains the implementation of the  LaxarJS EventBus . In an application you'll\nnever use this module or instantiate an event bus instance directly. Instead within a widget the event bus\ncan be injected via service or accessed as property on the AngularJS  $scope  or  axContext  injections.", 
            "title": "event_bus"
        }, 
        {
            "location": "/api/event_bus.js/#contents", 
            "text": "Module Members   create  init   Types   EventBus  EventBus#setErrorHandler  EventBus#setMediator  EventBus#addInspector  EventBus#subscribe  EventBus#unsubscribe  EventBus#publish  EventBus#publishAndGatherReplies", 
            "title": "Contents"
        }, 
        {
            "location": "/api/event_bus.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/event_bus.js/#parameters", 
            "text": "Property  Type  Description      optionalConfiguration  Object  configuration for the event bus instance    optionalConfiguration.pendingDidTimeout  Number  the timeout in milliseconds used by  EventBus#publishAndGatherReplies . Default is 120000ms", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#returns", 
            "text": "Type  Description      EventBus", 
            "title": "Returns"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_1", 
            "text": "Property  Type  Description      q  Object  a promise library like AngularJS'  $q    nextTick  Function  a next tick function like  process.nextTick  or AngularJS'  $timeout    timeoutFunction  Function  a timeout function like  window.setTimeout   or AngularJS'  $timeout", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_2", 
            "text": "Property  Type  Description      errorHandler  Function  the error handler", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_3", 
            "text": "Property  Type  Description      mediator  Function  the mediator function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_4", 
            "text": "Property  Type  Description      inspector  Function  the inspector function to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#returns_1", 
            "text": "Type  Description      Function  a function to remove the inspector", 
            "title": "Returns"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_5", 
            "text": "Property  Type  Description      eventName  String  the name of the event to subscribe to    subscriber  Function  a function to call whenever an event matching  eventName  is published    optionalOptions  Object  additional options for the subscribe action    optionalOptions.subscriber  String  the id of the subscriber. Default is  null    optionalOptions.clone  Boolean  if  false  the event will be send frozen to the subscriber, otherwise it will receive a deep copy. Default is  true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_6", 
            "text": "Property  Type  Description      subscriber  Function  the function to unsubscribe", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_7", 
            "text": "Property  Type  Description      eventName  String  the name of the event to publish    optionalEvent  Object  the event to publish    optionalOptions  Object  additional options for the publish action    optionalOptions.sender  String  the id of the event sender. Default is  null    optionalOptions.deliverToSender  Boolean  if  false  the event will not be send to subscribers whose subscriber name matches  optionalOptions.sender , else all subscribers will receive the event. Default is  true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#returns_2", 
            "text": "Type  Description      Promise  the delivery promise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/event_bus.js/#parameters_8", 
            "text": "Property  Type  Description      eventName  String  the name of the event to publish    optionalEvent  Object  the event to publish    optionalOptions  Object  additional options for the publish action    optionalOptions.sender  String  the id of the event sender. Default is  null    optionalOptions.pendingDidTimeout  Number  the timeout in milliseconds for pending did* events", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/event_bus.js/#returns_3", 
            "text": "Type  Description      Promise  the delivery promise. It receives a list of all collected  did*  events and according meta information", 
            "title": "Returns"
        }, 
        {
            "location": "/api/file_resource_provider.js/", 
            "text": "file_resource_provider\n\n\nThe \nfile_resource_provider\n module defines a mechanism to load static assets from the web server of the\nLaxarJS application efficiently. Whenever a file should be requested from the server, the file resource\nprovider should be used in favor of manual http requests, due to two reasons: During development it reduces\nthe amount of \n404\n status replies for files that may or may not exist, and when making a release build,\nfile contents may optionally be embedded in the build bundle. This makes further http requests redundant,\nwhich is especially relevant in high-latency networks, such as cellular networks.\n\n\nThis module should not be used directly, but via the \naxFileResourceProvider\n service provided by LaxarJS.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate\n\n\ninit\n\n\n\n\nTypes\n\n\n\n\nFileResourceProvider\n\n\nFileResourceProvider#provide\n\n\nFileResourceProvider#isAvailable\n\n\nFileResourceProvider#setFileListingUri\n\n\nFileResourceProvider#setFileListingContents\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( rootPath )\n\n\nCreates and returns a new instance.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrootPath\n\n\nString\n\n\nthe path to the root of the application. It is needed to prefix relative paths found in a listing with an absolute prefix\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFileResourceProvider\n\n\na new instance\n\n\n\n\n\n\n\n\ninit( q, httpClient )\n\n\nInitializes the module.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nq\n\n\nObject\n\n\na promise library like AngularJS' \n$q\n\n\n\n\n\n\nhttpClient\n\n\nObject\n\n\na http client whose api conforms to AngularJS' \n$http\n service\n\n\n\n\n\n\n\n\nTypes\n\n\nFileResourceProvider\n\n\nFileResourceProvider#provide( url )\n\n\nIf available, resolves the returned promise with the requested file's contents. Otherwise the promise is\nrejected. It uses the file mapping prior to fetching the contents to prevent from 404 errors. In the\noptimal case the contents are already embedded in the listing and simply need to be returned. If no\nlisting for the path is available, a request simply takes place and either succeeds or fails.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nString\n\n\nthe uri to the resource to provide\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\nresolved with the file's content or rejected when the file could not be fetched\n\n\n\n\n\n\n\n\nFileResourceProvider#isAvailable( url )\n\n\nResolves the returned promise with \ntrue\n as argument, if the requested resource is available and\n\nfalse\n otherwise.  If no listing for the path is available, a HEAD request takes place and either\nsucceeds or fails.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nString\n\n\nthe uri to check for availability\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\na promise that is always resolved with a boolean value\n\n\n\n\n\n\n\n\nFileResourceProvider#setFileListingUri( directory, listingUri )\n\n\nSets the uri to a file listing file for a given path.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndirectory\n\n\nString\n\n\nthe directory the file listing is valid for\n\n\n\n\n\n\nlistingUri\n\n\nString\n\n\nthe uri to the listing file\n\n\n\n\n\n\n\n\nFileResourceProvider#setFileListingContents( directory, listing )\n\n\nSets the contents of a file listing file to the given object. This a useful alternative to\n\nFileResourceProvider#setFileListingUri\n, to avoid an additional round-trip during production.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndirectory\n\n\nString\n\n\nthe directory the file listing is valid for\n\n\n\n\n\n\nlisting\n\n\nString\n\n\nthe actual file listing", 
            "title": "file_resource_provider"
        }, 
        {
            "location": "/api/file_resource_provider.js/#file_resource_provider", 
            "text": "The  file_resource_provider  module defines a mechanism to load static assets from the web server of the\nLaxarJS application efficiently. Whenever a file should be requested from the server, the file resource\nprovider should be used in favor of manual http requests, due to two reasons: During development it reduces\nthe amount of  404  status replies for files that may or may not exist, and when making a release build,\nfile contents may optionally be embedded in the build bundle. This makes further http requests redundant,\nwhich is especially relevant in high-latency networks, such as cellular networks.  This module should not be used directly, but via the  axFileResourceProvider  service provided by LaxarJS.", 
            "title": "file_resource_provider"
        }, 
        {
            "location": "/api/file_resource_provider.js/#contents", 
            "text": "Module Members   create  init   Types   FileResourceProvider  FileResourceProvider#provide  FileResourceProvider#isAvailable  FileResourceProvider#setFileListingUri  FileResourceProvider#setFileListingContents", 
            "title": "Contents"
        }, 
        {
            "location": "/api/file_resource_provider.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/file_resource_provider.js/#parameters", 
            "text": "Property  Type  Description      rootPath  String  the path to the root of the application. It is needed to prefix relative paths found in a listing with an absolute prefix", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/file_resource_provider.js/#returns", 
            "text": "Type  Description      FileResourceProvider  a new instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/file_resource_provider.js/#parameters_1", 
            "text": "Property  Type  Description      q  Object  a promise library like AngularJS'  $q    httpClient  Object  a http client whose api conforms to AngularJS'  $http  service", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/file_resource_provider.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/file_resource_provider.js/#parameters_2", 
            "text": "Property  Type  Description      url  String  the uri to the resource to provide", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/file_resource_provider.js/#returns_1", 
            "text": "Type  Description      Promise  resolved with the file's content or rejected when the file could not be fetched", 
            "title": "Returns"
        }, 
        {
            "location": "/api/file_resource_provider.js/#parameters_3", 
            "text": "Property  Type  Description      url  String  the uri to check for availability", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/file_resource_provider.js/#returns_2", 
            "text": "Type  Description      Promise  a promise that is always resolved with a boolean value", 
            "title": "Returns"
        }, 
        {
            "location": "/api/file_resource_provider.js/#parameters_4", 
            "text": "Property  Type  Description      directory  String  the directory the file listing is valid for    listingUri  String  the uri to the listing file", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/file_resource_provider.js/#parameters_5", 
            "text": "Property  Type  Description      directory  String  the directory the file listing is valid for    listing  String  the actual file listing", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/flow.js/", 
            "text": "flow\n\n\nThe \nflow\n module is responsible for the handling of all tasks regarding navigation and routing and as such\nis part of the LaxarJS core. It is your communication partner on the other end of the event bus for\n\nnavigateRequest\n, \nwillNavigate\n and \ndidNavigate\n events. For application developers it additionally\nprovides the \naxFlowService\n, which can be used for some flow specific tasks.\n\n\nContents\n\n\nInjectable Services\n\n\n\n\naxFlowService\n\n\naxFlowService#constructPath\n\n\naxFlowService#constructAnchor\n\n\naxFlowService#constructAbsoluteUrl\n\n\naxFlowService#place\n\n\n\n\n\n\n\n\nInjectable Services\n\n\naxFlowService\n\n\nA service providing some flow specific tasks that may be useful from within widgets.\n\n\naxFlowService#constructPath( targetOrPlace, optionalParameters )\n\n\nConstructs a path, that is compatible to the expected arguments of \n$location.path()\n from\nAngularJS. If a target is given as first argument, this is resolved using the currently active\nplace.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetOrPlace\n\n\nString\n\n\nthe target or place id to construct the url for\n\n\n\n\n\n\noptionalParameters\n\n\nObject\n\n\noptional map of place parameters. Missing parameters are taken from the parameters that were passed to the currently active place\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring\n\n\nthe generated path\n\n\n\n\n\n\n\n\naxFlowService#constructAnchor( targetOrPlace, optionalParameters )\n\n\nConstructs a path and prepends a \n#\n to make it directly usable as relative link within an\napplication. If a target is given as first argument, this is resolved using the currently active\nplace.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetOrPlace\n\n\nString\n\n\nthe target or place id to construct the url for\n\n\n\n\n\n\noptionalParameters\n\n\nObject\n\n\noptional map of place parameters. Missing parameters are taken from the parameters that were passed to the currently active place\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring\n\n\nthe generated anchor\n\n\n\n\n\n\n\n\naxFlowService#constructAbsoluteUrl( targetOrPlace, optionalParameters )\n\n\nConstructs an absolute url to the given target or place using the given parameters application. If\na target is given as first argument, this is resolved using the currently active place.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetOrPlace\n\n\nString\n\n\nthe target or place id to construct the url for\n\n\n\n\n\n\noptionalParameters\n\n\nObject\n\n\noptional map of place parameters. Missing parameters are taken from the parameters that were passed to the currently active place\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring\n\n\nthe generated url\n\n\n\n\n\n\n\n\naxFlowService#place()\n\n\nReturns a copy of the currently active place.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe currently active place", 
            "title": "flow"
        }, 
        {
            "location": "/api/flow.js/#flow", 
            "text": "The  flow  module is responsible for the handling of all tasks regarding navigation and routing and as such\nis part of the LaxarJS core. It is your communication partner on the other end of the event bus for navigateRequest ,  willNavigate  and  didNavigate  events. For application developers it additionally\nprovides the  axFlowService , which can be used for some flow specific tasks.", 
            "title": "flow"
        }, 
        {
            "location": "/api/flow.js/#contents", 
            "text": "Injectable Services   axFlowService  axFlowService#constructPath  axFlowService#constructAnchor  axFlowService#constructAbsoluteUrl  axFlowService#place", 
            "title": "Contents"
        }, 
        {
            "location": "/api/flow.js/#injectable-services", 
            "text": "", 
            "title": "Injectable Services"
        }, 
        {
            "location": "/api/flow.js/#parameters", 
            "text": "Property  Type  Description      targetOrPlace  String  the target or place id to construct the url for    optionalParameters  Object  optional map of place parameters. Missing parameters are taken from the parameters that were passed to the currently active place", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/flow.js/#returns", 
            "text": "Type  Description      string  the generated path", 
            "title": "Returns"
        }, 
        {
            "location": "/api/flow.js/#parameters_1", 
            "text": "Property  Type  Description      targetOrPlace  String  the target or place id to construct the url for    optionalParameters  Object  optional map of place parameters. Missing parameters are taken from the parameters that were passed to the currently active place", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/flow.js/#returns_1", 
            "text": "Type  Description      string  the generated anchor", 
            "title": "Returns"
        }, 
        {
            "location": "/api/flow.js/#parameters_2", 
            "text": "Property  Type  Description      targetOrPlace  String  the target or place id to construct the url for    optionalParameters  Object  optional map of place parameters. Missing parameters are taken from the parameters that were passed to the currently active place", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/flow.js/#returns_2", 
            "text": "Type  Description      string  the generated url", 
            "title": "Returns"
        }, 
        {
            "location": "/api/flow.js/#returns_3", 
            "text": "Type  Description      Object  the currently active place", 
            "title": "Returns"
        }, 
        {
            "location": "/api/fn.js/", 
            "text": "fn\n\n\nUtilities for dealing with functions.\n\n\nWhen requiring \nlaxar\n, it is available as \nlaxar.fn\n.\n\n\nContents\n\n\nModule Members\n\n\n\n\ndebounce\n\n\n\n\nModule Members\n\n\ndebounce( f, waitMs, immediate )\n\n\nUnderscore \ndebounce\n, but with LaxarJS offering mocking in\ntests. See \nhttp://underscorejs.org/#debounce\n for detailed\ndocumentation.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nf\n\n\nFunction\n\n\nthe function to return a debounced version of\n\n\n\n\n\n\nwaitMs\n\n\nNumber\n\n\nmilliseconds to debounce before invoking \nf\n\n\n\n\n\n\nimmediate\n\n\nBoolean\n\n\nif \ntrue\n \nf\n is invoked prior to start waiting \nwaitMs\n milliseconds. Otherwise \nf\n is invoked after the given debounce duration has passed. Default is \nfalse\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nthe debounced function", 
            "title": "fn"
        }, 
        {
            "location": "/api/fn.js/#fn", 
            "text": "Utilities for dealing with functions.  When requiring  laxar , it is available as  laxar.fn .", 
            "title": "fn"
        }, 
        {
            "location": "/api/fn.js/#contents", 
            "text": "Module Members   debounce", 
            "title": "Contents"
        }, 
        {
            "location": "/api/fn.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/fn.js/#parameters", 
            "text": "Property  Type  Description      f  Function  the function to return a debounced version of    waitMs  Number  milliseconds to debounce before invoking  f    immediate  Boolean  if  true   f  is invoked prior to start waiting  waitMs  milliseconds. Otherwise  f  is invoked after the given debounce duration has passed. Default is  false", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/fn.js/#returns", 
            "text": "Type  Description      Function  the debounced function", 
            "title": "Returns"
        }, 
        {
            "location": "/api/i18n.js/", 
            "text": "i18n\n\n\nUtilities for dealing with internationalization (i18n).\n\n\nWhen requiring \nlaxar\n, it is available as \nlaxar.i18n\n.\n\n\nContents\n\n\nModule Members\n\n\n\n\nlocalize\n\n\nlocalizeStrict\n\n\nlocalizeRelaxed\n\n\nlocalizer\n\n\nlanguageTagFromI18n\n\n\n\n\nTypes\n\n\n\n\nLocalizer\n\n\nLocalizer#format\n\n\n\n\n\n\n\n\nModule Members\n\n\nlocalize()\n\n\nShortcut to \nlocalizeRelaxed\n.\n\n\nlocalizeStrict( languageTag, i18nValue, optionalFallback )\n\n\nLocalize the given internationalized object using the given languageTag.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguageTag\n\n\nString\n\n\nthe languageTag to lookup a localization with. Maybe \nundefined\n, if the value is not i18n (app does not use i18n)\n\n\n\n\n\n\ni18nValue\n\n\n*\n\n\na possibly internationalized value:\n- when passing a primitive value, it is returned as-is\n- when passing an object, the languageTag is used as a key within that object\n\n\n\n\n\n\noptionalFallback\n\n\n*\n\n\na value to use if no localization is available for the given language tag\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe localized value if found, \nundefined\n otherwise\n\n\n\n\n\n\n\n\nlocalizeRelaxed( languageTag, i18nValue, optionalFallback )\n\n\nFor controls (such as a date-picker), we cannot anticipate all required language tags, as they may be\napp-specific. The relaxed localize behaves like localize if an exact localization is available. If not,\nthe language tag is successively generalized by stripping off the rightmost sub-tags until a\nlocalization is found. Eventually, a fallback ('en') is used.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguageTag\n\n\nString\n\n\nthe languageTag to lookup a localization with. Maybe \nundefined\n, if the value is not i18n (app does not use i18n)\n\n\n\n\n\n\ni18nValue\n\n\n*\n\n\na possibly internationalized value:\n- when passing a primitive value, it is returned as-is\n- when passing an object, the \nlanguageTag\n is used to look up a localization within that object\n\n\n\n\n\n\noptionalFallback\n\n\n*\n\n\na value to use if no localization is available for the given language tag\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe localized value if found, the fallback \nundefined\n otherwise\n\n\n\n\n\n\n\n\nlocalizer( languageTag, optionalFallback )\n\n\nEncapsulate a given languageTag in a partially applied localize function.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguageTag\n\n\nString\n\n\nthe languageTag to lookup localizations with\n\n\n\n\n\n\noptionalFallback\n\n\n*\n\n\na value to use by the localizer function whenever no localization is available for the language tag\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLocalizer\n\n\nA single-arg localize-Function, which always uses the given language-tag. It also has a \n.format\n-method, which can be used as a shortcut to \nstring.format( localize( x ), args )\n\n\n\n\n\n\n\n\nlanguageTagFromI18n( i18n, optionalFallbackLanguageTag )\n\n\nRetrieve the language tag of the current locale from an i18n model object, such as used on the scope.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ni18n\n\n\n[object Object]\n\n\nan internationalization model, with reference to the currently active locale and a map from locales to language tags\n\n\n\n\n\n\noptionalFallbackLanguageTag\n\n\n*\n\n\na language tag to use if no tags are found on the given object\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe localized value if found, \nundefined\n otherwise\n\n\n\n\n\n\n\n\nTypes\n\n\nLocalizer\n\n\nLocalizer#format( i18nValue, optionalIndexedReplacements, optionalNamedReplacements )\n\n\nShortcut to string.format, for simple chaining to the localizer.\n\n\nThese are equal:\n\n\n\n\nstring.format( i18n.localizer( tag )( i18nValue ), numericArgs, namedArgs )\n\n\ni18n.localizer( tag ).format( i18nValue, numericArgs, namedArgs )\n.\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ni18nValue\n\n\nString\n\n\nthe value to localize and then format\n\n\n\n\n\n\noptionalIndexedReplacements\n\n\nArray\n\n\nreplacements for any numeric placeholders in the localized value\n\n\n\n\n\n\noptionalNamedReplacements\n\n\nObject\n\n\nreplacements for any named placeholders in the localized value\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe formatted string, taking i18n into account", 
            "title": "i18n"
        }, 
        {
            "location": "/api/i18n.js/#i18n", 
            "text": "Utilities for dealing with internationalization (i18n).  When requiring  laxar , it is available as  laxar.i18n .", 
            "title": "i18n"
        }, 
        {
            "location": "/api/i18n.js/#contents", 
            "text": "Module Members   localize  localizeStrict  localizeRelaxed  localizer  languageTagFromI18n   Types   Localizer  Localizer#format", 
            "title": "Contents"
        }, 
        {
            "location": "/api/i18n.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/i18n.js/#parameters", 
            "text": "Property  Type  Description      languageTag  String  the languageTag to lookup a localization with. Maybe  undefined , if the value is not i18n (app does not use i18n)    i18nValue  *  a possibly internationalized value: - when passing a primitive value, it is returned as-is - when passing an object, the languageTag is used as a key within that object    optionalFallback  *  a value to use if no localization is available for the given language tag", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/i18n.js/#returns", 
            "text": "Type  Description      *  the localized value if found,  undefined  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/i18n.js/#parameters_1", 
            "text": "Property  Type  Description      languageTag  String  the languageTag to lookup a localization with. Maybe  undefined , if the value is not i18n (app does not use i18n)    i18nValue  *  a possibly internationalized value: - when passing a primitive value, it is returned as-is - when passing an object, the  languageTag  is used to look up a localization within that object    optionalFallback  *  a value to use if no localization is available for the given language tag", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/i18n.js/#returns_1", 
            "text": "Type  Description      *  the localized value if found, the fallback  undefined  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/i18n.js/#parameters_2", 
            "text": "Property  Type  Description      languageTag  String  the languageTag to lookup localizations with    optionalFallback  *  a value to use by the localizer function whenever no localization is available for the language tag", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/i18n.js/#returns_2", 
            "text": "Type  Description      Localizer  A single-arg localize-Function, which always uses the given language-tag. It also has a  .format -method, which can be used as a shortcut to  string.format( localize( x ), args )", 
            "title": "Returns"
        }, 
        {
            "location": "/api/i18n.js/#parameters_3", 
            "text": "Property  Type  Description      i18n  [object Object]  an internationalization model, with reference to the currently active locale and a map from locales to language tags    optionalFallbackLanguageTag  *  a language tag to use if no tags are found on the given object", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/i18n.js/#returns_3", 
            "text": "Type  Description      String  the localized value if found,  undefined  otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/i18n.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/i18n.js/#parameters_4", 
            "text": "Property  Type  Description      i18nValue  String  the value to localize and then format    optionalIndexedReplacements  Array  replacements for any numeric placeholders in the localized value    optionalNamedReplacements  Object  replacements for any named placeholders in the localized value", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/i18n.js/#returns_4", 
            "text": "Type  Description      String  the formatted string, taking i18n into account", 
            "title": "Returns"
        }, 
        {
            "location": "/api/log.js/", 
            "text": "log\n\n\nAn interface for logging purposes. At least for permanent logging this should always be used in favor of\n\nconsole.log\n and friends, as it is cross browser secure and allows attaching multiple channels where\nmessages can be routed to (i.e. to send them to a server process for persistence). If available, messages\nwill be logged to the browser's console using a builtin console channel.\n\n\nWhen requiring \nlaxar\n, an instance of the \nLogger\n type is available as \nlaxar.log\n.\n\n\nContents\n\n\nTypes\n\n\n\n\nlevel\n\n\nBLACKBOX\n\n\nLogger\n\n\nLogger#create\n\n\nLogger#log\n\n\nLogger#trace\n\n\nLogger#debug\n\n\nLogger#info\n\n\nLogger#warn\n\n\nLogger#error\n\n\nLogger#fatal\n\n\nLogger#addLogChannel\n\n\nLogger#removeLogChannel\n\n\nLogger#addTag\n\n\nLogger#setTag\n\n\nLogger#removeTag\n\n\nLogger#gatherTags\n\n\nLogger#setLogThreshold\n\n\n\n\n\n\n\n\nTypes\n\n\nlevel\n\n\nBy default available log levels, sorted by increasing log level:\n\n\n\n\nTRACE (level 100)\n\n\nDEBUG (level 200)\n\n\nINFO (level 300)\n\n\nWARN (level 400)\n\n\nERROR (level 500)\n\n\nFATAL (level 600)\n\n\n\n\nBLACKBOX\n\n\nPass this as an additional replacement parameter to a log-method to blackbox your logging call.\nBlackboxed callers are ignored when logging the source information (file, line). (#322)\n\n\nLogger\n\n\nLogger#create()\n\n\nCreates and returns a new logger instance. Intended for testing purposes only.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLogger\n\n\na new logger instance\n\n\n\n\n\n\n\n\nLogger#log( level, message, replacementArguments )\n\n\nLogs a message. A message may contain placeholders in the form \n[#]\n where \n#\n resembles the index\nwithin the list of \nreplacements\n. \nreplacements\n are incrementally counted starting at \n0\n. If the\nlog level is below the configured log threshold, the message is simply discarded.\n\n\nIt is recommended not to use this method directly, but instead one of the short cut methods for the\naccording log level.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlevel\n\n\nNumber\n\n\nthe level for this message\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacementArguments...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger#trace( message, replacements )\n\n\nLogs a message in log level \nTRACE\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger#debug( message, replacements )\n\n\nLogs a message in log level \nDEBUG\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger#info( message, replacements )\n\n\nLogs a message in log level \nINFO\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger#warn( message, replacements )\n\n\nLogs a message in log level \nWARN\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger#error( message, replacements )\n\n\nLogs a message in log level \nERROR\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger#fatal( message, replacements )\n\n\nLogs a message in log level \nFATAL\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger#addLogChannel( channel )\n\n\nAdds a new channel to forward log messages to. A channel is called synchronously for every log message\nand can do whatever necessary to handle the message according to its task. Note that blocking or\nperformance critical actions within a channel should always take place asynchronously to prevent from\nblocking the application. Ideally a web worker is used for heavier background tasks.\n\n\nEach message is an object having the following properties:\n\n\n\n\nid\n: the unique, ascending id of the log message\n\n\nlevel\n: the log level of the message in string representation\n\n\ntext\n: the actual message that was logged\n\n\nreplacements\n: the raw list of replacements passed along the message\n\n\ntime\n: JavaScript Date instance when the message was logged\n\n\ntags\n: A map of all log tags currently set for the logger\n\n\nsourceInfo\n: if supported, a map containing \nfile\n, \nline\n and \nchar\n where the logging took place\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nchannel\n\n\nFunction\n\n\nthe log channel to add\n\n\n\n\n\n\n\n\nLogger#removeLogChannel( channel )\n\n\nRemoves a log channel and thus stops sending further messages to it.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nchannel\n\n\nFunction\n\n\nthe log channel to remove\n\n\n\n\n\n\n\n\nLogger#addTag( tag, value )\n\n\nAdds a value for a log tag. If a tag is already known, the value is appended to the existing one using a\n\n;\n as separator. Note that no formatting of the value takes place and a non-string value will just have\nits appropriate \ntoString\n method called.\n\n\nLog tags can be used to mark a set of log messages with a value giving further information on the\ncurrent logging context. For example laxar sets a tag \n'INST'\n with a unique-like identifier for the\ncurrent browser client. If then for example log messages are persisted on a server, messages belonging\nto the same client can be accumulated.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntag\n\n\nString\n\n\nthe id of the tag to add a value for\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nthe value to add\n\n\n\n\n\n\n\n\nLogger#setTag( tag, value )\n\n\nSets a value for a log tag. If a tag is already known, the value is overwritten by the given one. Note\nthat no formatting of the value takes place and a non-string value will just have its appropriate\n\ntoString\n method called. For further information on log tags, see \nLogger#addTag\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntag\n\n\nString\n\n\nthe id of the tag to set a value for\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nthe value to set\n\n\n\n\n\n\n\n\nLogger#removeTag( tag )\n\n\nRemoves a log tag. For further information on log tags, see \nLogger#addTag\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntag\n\n\nString\n\n\nthe id of the tag to set a value for\n\n\n\n\n\n\n\n\nLogger#gatherTags()\n\n\nReturns a map of all tags. If there are multiple values for the same tag, their values are concatenated\nusing a \n;\n as separator. For further information on log tags, see \nLogger#addTag\n.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\na mapping from tag to its value(s)\n\n\n\n\n\n\n\n\nLogger#setLogThreshold( threshold )\n\n\nSets the threshold for log messages. Log messages with a lower level will be discarded upon logging.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nthreshold\n\n\nString\n, \nNumber\n\n\nthe numeric or the string value of the log level to use as threshold", 
            "title": "log"
        }, 
        {
            "location": "/api/log.js/#log", 
            "text": "An interface for logging purposes. At least for permanent logging this should always be used in favor of console.log  and friends, as it is cross browser secure and allows attaching multiple channels where\nmessages can be routed to (i.e. to send them to a server process for persistence). If available, messages\nwill be logged to the browser's console using a builtin console channel.  When requiring  laxar , an instance of the  Logger  type is available as  laxar.log .", 
            "title": "log"
        }, 
        {
            "location": "/api/log.js/#contents", 
            "text": "Types   level  BLACKBOX  Logger  Logger#create  Logger#log  Logger#trace  Logger#debug  Logger#info  Logger#warn  Logger#error  Logger#fatal  Logger#addLogChannel  Logger#removeLogChannel  Logger#addTag  Logger#setTag  Logger#removeTag  Logger#gatherTags  Logger#setLogThreshold", 
            "title": "Contents"
        }, 
        {
            "location": "/api/log.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/log.js/#returns", 
            "text": "Type  Description      Logger  a new logger instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/log.js/#parameters", 
            "text": "Property  Type  Description      level  Number  the level for this message    message  String  the message to log    replacementArguments...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_1", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_2", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_3", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_4", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_5", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_6", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_7", 
            "text": "Property  Type  Description      channel  Function  the log channel to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_8", 
            "text": "Property  Type  Description      channel  Function  the log channel to remove", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_9", 
            "text": "Property  Type  Description      tag  String  the id of the tag to add a value for    value  String  the value to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_10", 
            "text": "Property  Type  Description      tag  String  the id of the tag to set a value for    value  String  the value to set", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#parameters_11", 
            "text": "Property  Type  Description      tag  String  the id of the tag to set a value for", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/log.js/#returns_1", 
            "text": "Type  Description      Object  a mapping from tag to its value(s)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/log.js/#parameters_12", 
            "text": "Property  Type  Description      threshold  String ,  Number  the numeric or the string value of the log level to use as threshold", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/", 
            "text": "object\n\n\nUtilities for dealing with objects.\n\n\nWhen requiring \nlaxar\n, it is available as \nlaxar.object\n.\n\n\nContents\n\n\nModule Members\n\n\n\n\nextend\n\n\noptions\n\n\nforEach\n\n\npath\n\n\nsetPath\n\n\ndeepClone\n\n\ndeepFreeze\n\n\n\n\nModule Members\n\n\nextend( target, sources )\n\n\nCopies the properties from a set of source objects over to the target object. Properties of sources\nlater in the arguments list overwrite existing properties in the target and earlier source objects.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntarget\n\n\nObject\n\n\nthe target object to modify\n\n\n\n\n\n\nsources...\n\n\nObject\n\n\nthe source objects to copy over\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe modified target object\n\n\n\n\n\n\n\n\noptions( obj, defaults )\n\n\nReturns all properties from \nobj\n with missing properties completed from \ndefaults\n. If \nobj\n is \nnull\n\nor \nundefined\n, an empty object is automatically created. \nobj\n and \ndefaults\n are not modified by this\nfunction. This is very useful for optional map arguments, resembling some kind of configuration.\n\n\nExample:\n\n\nobject\n.\noptions\n(\n \n{\n \nvalidate\n:\n \ntrue\n \n},\n \n{\n\n   \nvalidate\n:\n \nfalse\n,\n\n   \nhighlight\n:\n \ntrue\n\n\n}\n \n);\n\n\n// =\n\n\n// {\n\n\n//    validate: true,\n\n\n//    highlight: true\n\n\n// }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj\n\n\nObject\n\n\nthe options object to use as source, may be \nnull\n or \nundefined\n\n\n\n\n\n\ndefaults\n\n\nObject\n\n\nthe defaults to take missing properties from\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe completed options object\n\n\n\n\n\n\n\n\nforEach( object, iteratorFunction )\n\n\nIterates over the keys of an object and calls the given iterator function for each entry. On each\niteration the iterator function is passed the \nvalue\n, the \nkey\n and the complete \nobject\n as\narguments. If \nobject\n is an array, the native \nArray.prototype.forEach\n function is called and hence\nthe keys are the numeric indices of the array.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobject\n\n\nObject\n\n\nthe object to run the iterator function on\n\n\n\n\n\n\niteratorFunction\n\n\nFunction\n\n\nthe iterator function to run on each key-value pair\n\n\n\n\n\n\n\n\npath( obj, thePath, optionalDefault )\n\n\nFinds a property in a nested object structure by a given path. A path is a string of keys, separated\nby a dot from each other, used to traverse that object and find the value of interest. An additional\ndefault is returned, if otherwise the value would yield \nundefined\n.\n\n\nNote that \nobject.path\n must only be used in situations where all path segments are also valid\nJavaScript identifiers, and should never be used with user-specified paths:\n\n\n\n\nthere is no mechanism to escape '.' in path segments; a dot always separates keys,\n\n\nan empty string as a path segment will abort processing and return the entire sub-object under the\n   respective position. For historical reasons, the path interpretation differs from that performed by\n   #setPath (see there).\n\n\n\n\nExample:\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.two\n \n);\n \n// =\n 3\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.three\n \n);\n \n// =\n undefined\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.three\n,\n \n42\n \n);\n \n// =\n 42\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.\n \n);\n \n// =\n { two: 3 }\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \n \n);\n \n// =\n { one: { two: 3 } }\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \n.\n \n);\n \n// =\n { one: { two: 3 } }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj\n\n\nObject\n\n\nthe object to traverse\n\n\n\n\n\n\nthePath\n\n\nString\n\n\nthe path to search for\n\n\n\n\n\n\noptionalDefault\n\n\n*\n\n\nthe value to return instead of \nundefined\n if nothing is found\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe value at the given path\n\n\n\n\n\n\n\n\nsetPath( obj, path, value )\n\n\nSets a property in a nested object structure at a given path to a given value. A path is a string of\nkeys, separated by a dot from each other, used to traverse that object and find the place where the\nvalue should be set. Any missing subtrees along the path are created.\n\n\nNote that \nobject.setPath\n must only be used in situations where all path segments are also valid\nJavaScript identifiers, and should never be used with user-specified paths:\n\n\n\n\nthere is no mechanism to escape '.' in path segments; a dot will always create separate keys,\n\n\nan empty string as a path segment will create an empty string key in the object graph where missing.\n   For historical reasons, this path interpretation differs from that performed by #path (see there).\n\n\n\n\nExample:\n\n\nobject\n.\nsetPath\n(\n \n{},\n \nname.first\n,\n \nPeter\n \n);\n \n// =\n { name: { first: \nPeter\n } }\n\n\nobject\n.\nsetPath\n(\n \n{},\n \npets.1\n,\n \nHamster\n \n);\n \n// =\n { pets: [ null, \nHamster\n ] }\n\n\nobject\n.\nsetPath\n(\n \n{},\n \n,\n \nHamster\n \n);\n \n// =\n { \n: \nHamster\n } }\n\n\nobject\n.\nsetPath\n(\n \n{},\n \n.\n,\n \nHamster\n \n);\n \n// =\n { \n: { \n: \nHamster\n } } }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj\n\n\nObject\n\n\nthe object to modify\n\n\n\n\n\n\npath\n\n\nString\n\n\nthe path to set a value at\n\n\n\n\n\n\nvalue\n\n\n*\n\n\nthe value to set at the given path\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe full object (for chaining)\n\n\n\n\n\n\n\n\ndeepClone( object )\n\n\nReturns a deep clone of the given object. Note that the current implementation is intended to be used\nfor simple object literals only. There is no guarantee that cloning objects instantiated via\nconstructor function works and cyclic references will lead to endless recursion.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobject\n\n\n*\n\n\nthe object to clone\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe clone\n\n\n\n\n\n\n\n\ndeepFreeze( obj, optionalRecursive )\n\n\nFreezes an object, optionally recursively, in any browser capable of freezing objects. In any other\nbrowser this method simply returns its first value, i.e. is an identity operation.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj\n\n\nObject\n\n\nthe object to freeze\n\n\n\n\n\n\noptionalRecursive\n\n\nBoolean\n\n\nfreezes recursively if \ntrue\n. Default is \nfalse\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe input (possibly) frozen", 
            "title": "object"
        }, 
        {
            "location": "/api/object.js/#object", 
            "text": "Utilities for dealing with objects.  When requiring  laxar , it is available as  laxar.object .", 
            "title": "object"
        }, 
        {
            "location": "/api/object.js/#contents", 
            "text": "Module Members   extend  options  forEach  path  setPath  deepClone  deepFreeze", 
            "title": "Contents"
        }, 
        {
            "location": "/api/object.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/object.js/#parameters", 
            "text": "Property  Type  Description      target  Object  the target object to modify    sources...  Object  the source objects to copy over", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/#returns", 
            "text": "Type  Description      Object  the modified target object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/object.js/#parameters_1", 
            "text": "Property  Type  Description      obj  Object  the options object to use as source, may be  null  or  undefined    defaults  Object  the defaults to take missing properties from", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/#returns_1", 
            "text": "Type  Description      Object  the completed options object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/object.js/#parameters_2", 
            "text": "Property  Type  Description      object  Object  the object to run the iterator function on    iteratorFunction  Function  the iterator function to run on each key-value pair", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/#parameters_3", 
            "text": "Property  Type  Description      obj  Object  the object to traverse    thePath  String  the path to search for    optionalDefault  *  the value to return instead of  undefined  if nothing is found", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/#returns_2", 
            "text": "Type  Description      *  the value at the given path", 
            "title": "Returns"
        }, 
        {
            "location": "/api/object.js/#parameters_4", 
            "text": "Property  Type  Description      obj  Object  the object to modify    path  String  the path to set a value at    value  *  the value to set at the given path", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/#returns_3", 
            "text": "Type  Description      *  the full object (for chaining)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/object.js/#parameters_5", 
            "text": "Property  Type  Description      object  *  the object to clone", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/#returns_4", 
            "text": "Type  Description      *  the clone", 
            "title": "Returns"
        }, 
        {
            "location": "/api/object.js/#parameters_6", 
            "text": "Property  Type  Description      obj  Object  the object to freeze    optionalRecursive  Boolean  freezes recursively if  true . Default is  false", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/object.js/#returns_5", 
            "text": "Type  Description      Object  the input (possibly) frozen", 
            "title": "Returns"
        }, 
        {
            "location": "/api/storage.js/", 
            "text": "storage\n\n\nProvides a convenient api over the browser's \nwindow.localStorage\n and \nwindow.sessionStorage\n objects. If\na browser doesn't support \nweb storage\n, a warning is logged to the\n\nconsole\n (if available) and a non-persistent in-memory store will be used instead. Note that this can for\nexample also happen when using Mozilla Firefox with cookies disabled and as such isn't limited to older\nbrowsers.\n\n\nAdditionally, in contrast to plain \nweb storage\n access, non-string values will be automatically passed\nthrough JSON (de-) serialization on storage or retrieval. All keys will be prepended with a combination of\nan arbitrary and a configured namespace to prevent naming clashes with other web applications running on\nthe same host and port. All \nStorageApi\n accessor methods should then be called without any namespace\nsince adding and removing it, is done automatically.\n\n\nWhen requiring \nlaxar\n, it is available as \nlaxar.storage\n.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate\n\n\ngetLocalStorage\n\n\ngetSessionStorage\n\n\ngetApplicationLocalStorage\n\n\ngetApplicationSessionStorage\n\n\n\n\nTypes\n\n\n\n\nStorageApi\n\n\nStorageApi#getItem\n\n\nStorageApi#setItem\n\n\nStorageApi#for\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( localStorageBackend, sessionStorageBackend )\n\n\nCreates a new storage module. In most cases this module will be called without arguments,\nbut having the ability to provide them is useful e.g. for mocking purposes within tests.\nIf the arguments are omitted, an attempt is made to access the native browser WebStorage api.\nIf that fails, storage is only mocked by an in memory map (thus actually unavailable).\n\n\nDevelopers are free to use polyfills to support cases where local- or session-storage may not be\navailable. Just make sure to initialize the polyfills before this module.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlocalStorageBackend\n\n\nObject\n\n\nthe backend for local storage, Default is \nwindow.localStorage\n\n\n\n\n\n\nsessionStorageBackend\n\n\nObject\n\n\nthe backend for session storage, Default is \nwindow.sessionStorage\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\na new storage module\n\n\n\n\n\n\n\n\ngetLocalStorage( namespace )\n\n\nReturns a local storage object for a specific local namespace.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace\n\n\nString\n\n\nthe namespace to prepend to keys\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe local storage object\n\n\n\n\n\n\n\n\ngetSessionStorage( namespace )\n\n\nReturns a session storage object for a specific local namespace.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace\n\n\nString\n\n\nthe namespace to prepend to keys\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe session storage object\n\n\n\n\n\n\n\n\ngetApplicationLocalStorage()\n\n\nReturns the local storage object for application scoped keys. This is equivalent to\n\nstorage.getLocalStorage( 'app' )\n.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe application local storage object\n\n\n\n\n\n\n\n\ngetApplicationSessionStorage()\n\n\nReturns the session storage object for application scoped keys. This is equivalent to\n\nstorage.getSessionStorage( 'app' )\n.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe application session storage object\n\n\n\n\n\n\n\n\nTypes\n\n\nStorageApi\n\n\nThe api returned by one of the \nget*Storage\n functions of the \nstorage\n module.\n\n\nStorageApi#getItem( key )\n\n\nRetrieves a \nvalue\n by \nkey\n from the store. JSON deserialization will automatically be applied.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\nthe key of the item to retrieve (without namespace prefix)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe value or \nnull\n if it doesn't exist in the store\n\n\n\n\n\n\n\n\nStorageApi#setItem( key, value )\n\n\nSets a \nvalue\n for a \nkey\n. The value should be JSON serializable. An existing value will be\noverwritten.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\nthe key of the item to set (without namespace prefix)\n\n\n\n\n\n\nvalue\n\n\n*\n\n\nthe new value to set\n\n\n\n\n\n\n\n\nStorageApi#for( key )\n\n\nRemoves the value associated with \nkey\n from the store.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\nthe key of the item to remove (without namespace prefix)", 
            "title": "storage"
        }, 
        {
            "location": "/api/storage.js/#storage", 
            "text": "Provides a convenient api over the browser's  window.localStorage  and  window.sessionStorage  objects. If\na browser doesn't support  web storage , a warning is logged to the console  (if available) and a non-persistent in-memory store will be used instead. Note that this can for\nexample also happen when using Mozilla Firefox with cookies disabled and as such isn't limited to older\nbrowsers.  Additionally, in contrast to plain  web storage  access, non-string values will be automatically passed\nthrough JSON (de-) serialization on storage or retrieval. All keys will be prepended with a combination of\nan arbitrary and a configured namespace to prevent naming clashes with other web applications running on\nthe same host and port. All  StorageApi  accessor methods should then be called without any namespace\nsince adding and removing it, is done automatically.  When requiring  laxar , it is available as  laxar.storage .", 
            "title": "storage"
        }, 
        {
            "location": "/api/storage.js/#contents", 
            "text": "Module Members   create  getLocalStorage  getSessionStorage  getApplicationLocalStorage  getApplicationSessionStorage   Types   StorageApi  StorageApi#getItem  StorageApi#setItem  StorageApi#for", 
            "title": "Contents"
        }, 
        {
            "location": "/api/storage.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/storage.js/#parameters", 
            "text": "Property  Type  Description      localStorageBackend  Object  the backend for local storage, Default is  window.localStorage    sessionStorageBackend  Object  the backend for session storage, Default is  window.sessionStorage", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/storage.js/#returns", 
            "text": "Type  Description      Object  a new storage module", 
            "title": "Returns"
        }, 
        {
            "location": "/api/storage.js/#parameters_1", 
            "text": "Property  Type  Description      namespace  String  the namespace to prepend to keys", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/storage.js/#returns_1", 
            "text": "Type  Description      StorageApi  the local storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/storage.js/#parameters_2", 
            "text": "Property  Type  Description      namespace  String  the namespace to prepend to keys", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/storage.js/#returns_2", 
            "text": "Type  Description      StorageApi  the session storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/storage.js/#returns_3", 
            "text": "Type  Description      StorageApi  the application local storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/storage.js/#returns_4", 
            "text": "Type  Description      StorageApi  the application session storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/storage.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/storage.js/#parameters_3", 
            "text": "Property  Type  Description      key  String  the key of the item to retrieve (without namespace prefix)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/storage.js/#returns_5", 
            "text": "Type  Description      *  the value or  null  if it doesn't exist in the store", 
            "title": "Returns"
        }, 
        {
            "location": "/api/storage.js/#parameters_4", 
            "text": "Property  Type  Description      key  String  the key of the item to set (without namespace prefix)    value  *  the new value to set", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/storage.js/#parameters_5", 
            "text": "Property  Type  Description      key  String  the key of the item to remove (without namespace prefix)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/string.js/", 
            "text": "string\n\n\nUtilities for dealing with strings.\n\n\nWhen requiring \nlaxar\n, it is available as \nlaxar.string\n.\n\n\nContents\n\n\nModule Members\n\n\n\n\nformat\n\n\ncreateFormatter\n\n\n\n\nModule Members\n\n\nformat( string, optionalIndexedReplacements, optionalNamedReplacements )\n\n\nSubstitutes all unescaped placeholders in the given string for a given indexed or named value.\nA placeholder is written as a pair of brackets around the key of the placeholder. An example of an\nindexed placeholder is \n[0]\n and a named placeholder would look like this \n[replaceMe]\n. If no\nreplacement for a key exists, the placeholder will simply not be substituted.\n\n\nSome examples:\n\n\nstring\n.\nformat\n(\n \nHello [0], how do you like [1]?\n,\n \n[\n \nPeter\n,\n \nCheeseburgers\n \n]\n \n);\n\n\n// =\n \nHello Peter, how do you like Cheeseburgers?\n\n\n\n\n\n\nstring\n.\nformat\n(\n \nHello [name] and [partner], how do you like [0]?\n,\n \n[\n \nPizza\n \n],\n \n{\n\n   \nname\n:\n \nHans\n,\n\n   \npartner\n:\n \nRoswita\n\n\n}\n \n);\n\n\n// =\n \nHello Hans and Roswita, how do you like Pizza?\n\n\n\n\n\n\nIf a pair of brackets should not be treated as a placeholder, the opening bracket can simply be escaped\nby backslashes (thus to get an actual backslash in a JavaScript string literal, which is then treated as\nan escape symbol, it needs to be written as double backslash):\n\n\nstring\n.\nformat\n(\n \nA [something] should eventually only have \\\\[x].\n,\n \n{\n\n   \nsomething\n:\n \nchecklist\n\n\n}\n \n);\n\n\n// =\n \nA checklist should eventually only have [x].\n\n\n\n\n\n\nA placeholder key can be any character string besides \n[\n, \n]\n and \n:\n to keep parsing simple and fast.\nBy using \n:\n as separator it is possible to provide a type specifier for string serialization or other\nadditional mapping functions for the value to insert. Type specifiers always begin with an \n%\n and end\nwith the specifier type. Builtin specifier types are the following:\n\n\n\n\n%d\n / \n%i\n: Format the given numeric value as integer. Decimal places are removed.\n\n\n%f\n: Format the given numeric value as floating point value. This specifier supports precision as\n  sub-specifier (e.g. \n%.2f\n for 2 decimal places).\n\n\n%s\n: use simple string serialization using \ntoString\n.\n\n\n%o\n: Format complex objects using \nJSON.stringify\n.\n\n\n\n\nWhen no specifier is provided, by default \n%s\n is assumed.\n\n\nExample:\n\n\nstring\n.\nformat\n(\n \nHello [0:%s], you owe me [1:%.2f] euros.\n,\n \n[\n \nPeter\n,\n \n12.1243\n \n]\n \n);\n\n\n// =\n \nHello Peter, you owe me 12.12 euros.\n\n\n\n\n\n\nMapping functions should instead consist of simple strings and may not begin with a \n%\n character. It is\nadvised to use the same naming rules as for simple JavaScript functions. Type specifiers and mapping\nfunctions are applied in the order they appear within the placeholder.\n\n\nAn example, where we assume that the mapping functions \nflip\n and \ndouble\n where defined by the user\nwhen creating the \nformatString\n function using \ncreateFormatter\n:\n\n\nformatString\n(\n \nHello [0:%s:flip], you owe me [1:double:%.2f] euros.\n,\n \n[\n \nPeter\n,\n \n12\n \n]\n \n);\n\n\n// =\n \nHello reteP, you owe me 24.00 euros.\n\n\n\n\n\n\nNote that there currently exist no builtin mapping functions.\n\n\nIf a type specifier is used that doesn't exist, an exception is thrown. In contrast to that the use of\nan unknown mapping function results in a no-op. This is on purpose to be able to use filter-like\nfunctions that, in case they are defined for a formatter, transform a value as needed and in all other\ncases simply are ignored and don't alter the value.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring\n\n\nString\n\n\nthe string to replace placeholders in\n\n\n\n\n\n\noptionalIndexedReplacements\n\n\nArray\n\n\nan optional array of indexed replacements\n\n\n\n\n\n\noptionalNamedReplacements\n\n\nObject\n\n\nan optional map of named replacements\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe string with placeholders substituted for their according replacements\n\n\n\n\n\n\n\n\ncreateFormatter( typeFormatters, optionalValueMappers )\n\n\nCreates a new format function having the same api as \nformat\n. If the first argument is\nomitted or \nnull\n, the default formatters for type specifiers are used. Otherwise only the provided map\nof specifiers is available to the returned format function. Each key of the map is a specifier character\nwhere the \n%\n is omitted and the value is the formatting function. A formatting function receives the\nvalue to format (i.e. serialize) and the sub-specifier (if any) as arguments. For example for the format\nspecifier \n%.2f\n the sub-specifier would be \n.2\n where for \n%s\n it would simply be the empty string.\n\n\nExample:\n\n\nvar\n \nformat\n \n=\n \nstring\n.\ncreateFormatter\n(\n \n{\n\n   \nm\n:\n \nfunction\n(\n \nvalue\n \n)\n \n{\n\n      \nreturn\n \nvalue\n.\namount\n \n+\n \n \n \n+\n \nvalue\n.\ncurrency\n;\n\n   \n},\n\n   \np\n:\n \nfunction\n(\n \nvalue\n,\n \nsubSpecifier\n \n)\n \n{\n\n      \nreturn\n \nMath\n.\npow\n(\n \nvalue\n,\n \nparseInt\n(\n \nsubSpecifier\n,\n \n10\n \n)\n \n);\n\n   \n}\n\n\n}\n \n);\n\n\n\nformat\n(\n \nYou owe me [0:%m].\n,\n \n[\n \n{\n \namount\n:\n \n12\n,\n \ncurrency\n:\n \nEUR\n \n}\n \n]\n \n);\n\n\n// =\n \nYou owe me 12 EUR.\n\n\n\nformat\n(\n \n[0]^3 = [0:%3p]\n,\n \n[\n \n2\n \n]\n \n);\n\n\n// =\n \n2^3 = 8\n\n\n\n\n\n\nThe second argument is completely additional to the behavior of the default \nformat\n\nfunction. Here a map from mapping function id to actual mapping function can be passed in. Whenever the\nid of a mapping function is found within the placeholder, that mapping function is called with the\ncurrent value and its return value is either passed to the next mapping function or rendered\ninstead of the placeholder if there are no more mapping function ids or type specifiers within the\nplaceholder string.\n\n\nvar\n \nformat\n \n=\n \nstring\n.\ncreateFormatter\n(\n \nnull\n,\n \n{\n\n   \nflip\n:\n \nfunction\n(\n \nvalue\n \n)\n \n{\n\n      \nreturn\n \n(\n \n \n+\n \ns\n \n).\nsplit\n(\n \n \n).\nreverse\n().\njoin\n(\n \n \n);\n\n   \n},\n\n   \ndouble\n:\n \nfunction\n(\n \nvalue\n \n)\n \n{\n\n      \nreturn\n \nvalue\n \n*\n \n2\n;\n\n   \n}\n\n\n}\n \n);\n\n\n\nformat\n(\n \nHello [0:%s:flip], you owe me [1:double:%.2f] euros.\n,\n \n[\n \nPeter\n,\n \n12\n \n]\n \n);\n\n\n// =\n \nHello reteP, you owe me 24.00 euros.\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntypeFormatters\n\n\nObject\n\n\nmap from format specifier (single letter without leading \n%\n) to formatting function\n\n\n\n\n\n\noptionalValueMappers\n\n\nObject\n\n\nmap from mapping identifier to mapping function\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\nA function having the same api as \nformat", 
            "title": "string"
        }, 
        {
            "location": "/api/string.js/#string", 
            "text": "Utilities for dealing with strings.  When requiring  laxar , it is available as  laxar.string .", 
            "title": "string"
        }, 
        {
            "location": "/api/string.js/#contents", 
            "text": "Module Members   format  createFormatter", 
            "title": "Contents"
        }, 
        {
            "location": "/api/string.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/string.js/#parameters", 
            "text": "Property  Type  Description      string  String  the string to replace placeholders in    optionalIndexedReplacements  Array  an optional array of indexed replacements    optionalNamedReplacements  Object  an optional map of named replacements", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/string.js/#returns", 
            "text": "Type  Description      String  the string with placeholders substituted for their according replacements", 
            "title": "Returns"
        }, 
        {
            "location": "/api/string.js/#parameters_1", 
            "text": "Property  Type  Description      typeFormatters  Object  map from format specifier (single letter without leading  % ) to formatting function    optionalValueMappers  Object  map from mapping identifier to mapping function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/string.js/#returns_1", 
            "text": "Type  Description      Function  A function having the same api as  format", 
            "title": "Returns"
        }, 
        {
            "location": "/api/theme_manager.js/", 
            "text": "theme_manager\n\n\nThe theme manager simplifies lookup of theme specific assets. It should be used via AngularJS DI as\n\n\naxThemeManager\n service.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate\n\n\n\n\nTypes\n\n\n\n\nThemeManager\n\n\nThemeManager#getTheme\n\n\nThemeManager#urlProvider\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( fileResourceProvider, q, theme )\n\n\nCreates and returns a new theme manager instance.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfileResourceProvider\n\n\nFileResourceProvider\n\n\nthe file resource provider used for theme file lookup\n\n\n\n\n\n\nq\n\n\n$q\n\n\na \n$q\n like promise library\n\n\n\n\n\n\ntheme\n\n\nString\n\n\nthe theme to use\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nThemeManager\n\n\n\n\n\n\n\n\n\n\nTypes\n\n\nThemeManager\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfileResourceProvider\n\n\nFileResourceProvider\n\n\nthe file resource provider used for theme file lookups\n\n\n\n\n\n\nq\n\n\n$q\n\n\na \n$q\n like promise library\n\n\n\n\n\n\ntheme\n\n\nString\n\n\nthe theme to use\n\n\n\n\n\n\n\n\nThemeManager#getTheme()\n\n\nReturns the currently used theme.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe currently active theme\n\n\n\n\n\n\n\n\nThemeManager#urlProvider( artifactPathPattern, themePathPattern, fallbackPathPatterns )\n\n\nReturns a URL provider for specific path patterns that are used to lookup themed artifacts. The token\n\n[theme]\n will be replaced by the name of the currently active theme (plus \n.theme\n suffix) or by\n\ndefault.theme\n as a fallback. The \nprovide\n method of the returned object can be called with a list of\nfiles for which a themed version should be found. The most specific location is searched first and the\ndefault theme last.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nartifactPathPattern\n\n\nString\n\n\na path pattern for search within the artifact directory itself, based on the current theme\n\n\n\n\n\n\nthemePathPattern\n\n\nString\n\n\na path pattern for search within the current theme\n\n\n\n\n\n\nfallbackPathPatterns\n\n\nArray.\nString\n\n\nfallback paths, used if all else fails. Possibly without placeholders, e.g. for loading the default theme itself.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n[object Object]\n\n\nan object with a provide method", 
            "title": "theme_manager"
        }, 
        {
            "location": "/api/theme_manager.js/#theme_manager", 
            "text": "The theme manager simplifies lookup of theme specific assets. It should be used via AngularJS DI as  axThemeManager  service.", 
            "title": "theme_manager"
        }, 
        {
            "location": "/api/theme_manager.js/#contents", 
            "text": "Module Members   create   Types   ThemeManager  ThemeManager#getTheme  ThemeManager#urlProvider", 
            "title": "Contents"
        }, 
        {
            "location": "/api/theme_manager.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/theme_manager.js/#parameters", 
            "text": "Property  Type  Description      fileResourceProvider  FileResourceProvider  the file resource provider used for theme file lookup    q  $q  a  $q  like promise library    theme  String  the theme to use", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/theme_manager.js/#returns", 
            "text": "Type  Description      ThemeManager", 
            "title": "Returns"
        }, 
        {
            "location": "/api/theme_manager.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/theme_manager.js/#parameters_1", 
            "text": "Property  Type  Description      fileResourceProvider  FileResourceProvider  the file resource provider used for theme file lookups    q  $q  a  $q  like promise library    theme  String  the theme to use", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/theme_manager.js/#returns_1", 
            "text": "Type  Description      String  the currently active theme", 
            "title": "Returns"
        }, 
        {
            "location": "/api/theme_manager.js/#parameters_2", 
            "text": "Property  Type  Description      artifactPathPattern  String  a path pattern for search within the artifact directory itself, based on the current theme    themePathPattern  String  a path pattern for search within the current theme    fallbackPathPatterns  Array. String  fallback paths, used if all else fails. Possibly without placeholders, e.g. for loading the default theme itself.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/theme_manager.js/#returns_2", 
            "text": "Type  Description      [object Object]  an object with a provide method", 
            "title": "Returns"
        }, 
        {
            "location": "/contributing/styleguide/", 
            "text": "LaxarJS Coding Styles\n\n\nThese are basic coding style guidelines for use with LaxarJS.\nTheir purpose is to warrant consistency across the code base, so that developers do not need to mentally \"switch gears\" when working on different parts of the code.\n\n\nJavaScript\n\n\nMost of the LaxarJS code base is written in JavaScript, so this language takes up the bulk of the coding styles.\n\n\n1. Use JSHint\n\n\nLaxarJS comes with a \n.jshintrc\n that encodes the LaxarJS code formatting rules and allows you to check them automatically.\nYou should configure your editor to use this file when working with the LaxarJS code base.\nPull Requests that violate JSHint rules cannot be accepted.\n\n\n2. Use Functions to Create Objects (not \nnew\n).\n\n\nWhen using classes with prototypes, it is often difficult to tell if instance methods need to be called directly on an instance (so that \nthis\n is available), or if they can be passed around as callbacks for use with \nthen\n, \nmap\n, \nfilter\n and so on.\nAlso, the properties defined on \nthis\n are not safe against undesired modification.\nBecause of this, and because inheritance is very hard to get right in JavaScript, the recommended way to create objects is by defining a closure that returns the new object or, in most cases, an API to that object.\nFor example, rather than defining a constructor function \nMyService\n, have your AMD-module provide a factory function \ncreateMyService\n like shown here:\n\n\n/** ...jsdoc... */\n\n\nfunction\n \ncreateMyService\n()\n \n{\n\n\n   \nvar\n \nexports\n \n=\n \n{\n\n      \nqueryValue\n:\n \nqueryValue\n,\n\n      \n// ...\n\n   \n};\n\n\n   \nvar\n \nmyPrivateValue\n \n=\n \n17\n;\n\n\n   \n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n   \n/** ...jsdoc... */\n\n   \nfunction\n \nqueryValue\n()\n \n{\n \n/* ... */\n \n}\n\n\n   \n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n   \nreturn\n \nexports\n;\n\n\n\n}\n\n\n\n\n\n\nThis format ensures that anyone looking at the code can see the structure of the return value without having to go through the implementation.\n\n\nIn some simple cases, you do not need any imperative initialization logic for your object and just want to provide access to a bunch of methods.\nTo do this, you can omit the intermediate variable \nexports\n and return the API exports right away.\n\n\n/** ...jsdoc... */\n\n\nfunction\n \ncreateMyService\n()\n \n{\n\n\n   \nreturn\n \n{\n\n      \ncalculateValue\n:\n \ncalculateValue\n,\n\n      \n// ...\n\n   \n};\n\n\n   \n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n   \n/** ...jsdoc... */\n\n   \nfunction\n \ncalculateValue\n()\n \n{\n \n/* ... */\n \n}\n\n\n\n}\n\n\n\n\n\n\nJSON\n\n\nBecause JSON is a subset of JavaScript, the same formatting rules apply.\nBut since string literals cannot span multiple lines and cannot be broken up in JSON, the maximum line length may be violated to encode a JSON string that has to be long.", 
            "title": "LaxarJS Coding Styles"
        }, 
        {
            "location": "/contributing/styleguide/#laxarjs-coding-styles", 
            "text": "These are basic coding style guidelines for use with LaxarJS.\nTheir purpose is to warrant consistency across the code base, so that developers do not need to mentally \"switch gears\" when working on different parts of the code.", 
            "title": "LaxarJS Coding Styles"
        }, 
        {
            "location": "/contributing/styleguide/#javascript", 
            "text": "Most of the LaxarJS code base is written in JavaScript, so this language takes up the bulk of the coding styles.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/contributing/styleguide/#1-use-jshint", 
            "text": "LaxarJS comes with a  .jshintrc  that encodes the LaxarJS code formatting rules and allows you to check them automatically.\nYou should configure your editor to use this file when working with the LaxarJS code base.\nPull Requests that violate JSHint rules cannot be accepted.", 
            "title": "1. Use JSHint"
        }, 
        {
            "location": "/contributing/styleguide/#2-use-functions-to-create-objects-not-new", 
            "text": "When using classes with prototypes, it is often difficult to tell if instance methods need to be called directly on an instance (so that  this  is available), or if they can be passed around as callbacks for use with  then ,  map ,  filter  and so on.\nAlso, the properties defined on  this  are not safe against undesired modification.\nBecause of this, and because inheritance is very hard to get right in JavaScript, the recommended way to create objects is by defining a closure that returns the new object or, in most cases, an API to that object.\nFor example, rather than defining a constructor function  MyService , have your AMD-module provide a factory function  createMyService  like shown here:  /** ...jsdoc... */  function   createMyService ()   { \n\n    var   exports   =   { \n       queryValue :   queryValue , \n       // ... \n    }; \n\n    var   myPrivateValue   =   17 ; \n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////// \n\n    /** ...jsdoc... */ \n    function   queryValue ()   {   /* ... */   } \n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////// \n\n    return   exports ;  }   This format ensures that anyone looking at the code can see the structure of the return value without having to go through the implementation.  In some simple cases, you do not need any imperative initialization logic for your object and just want to provide access to a bunch of methods.\nTo do this, you can omit the intermediate variable  exports  and return the API exports right away.  /** ...jsdoc... */  function   createMyService ()   { \n\n    return   { \n       calculateValue :   calculateValue , \n       // ... \n    }; \n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////// \n\n    /** ...jsdoc... */ \n    function   calculateValue ()   {   /* ... */   }  }", 
            "title": "2. Use Functions to Create Objects (not new)."
        }, 
        {
            "location": "/contributing/styleguide/#json", 
            "text": "Because JSON is a subset of JavaScript, the same formatting rules apply.\nBut since string literals cannot span multiple lines and cannot be broken up in JSON, the maximum line length may be violated to encode a JSON string that has to be long.", 
            "title": "JSON"
        }, 
        {
            "location": "/manuals/", 
            "text": "Manuals\n\n\nBefore starting with the manuals, make sure that you know \nwhat LaxarJS is about\n, and that you are familiar with the \ncore concepts\n.\nIf you're already developing your first widgets and want to know which programmatic APIs are provided by LaxarJS, have a look at the \nAPI docs\n.\n\n\nBasic Manuals\n\n\n\n\nWidgets and Activities\n\n\n\n\nLearn about the building blocks of a LaxarJS application.\n\n\n\n\nWriting Pages\n\n\n\n\nA step-by-step introduction to writing layouts and pages for a LaxarJS application.\n\n\n\n\nInstalling Third Party Widgets\n\n\n\n\nLearn how to integrate and leverage existing widgets and activities.\n\n\n\n\nFlow and Places\n\n\n\n\nCreating a flow through the pages and make the addressable as places.\n\n\n\n\nWriting Widget Controllers\n\n\n\n\nHow to create a basic widget controller for a specific integration technology.\n\n\n\n\nEvents\n\n\n\n\nHow to communicate between widgets using topics on the event bus.\n\n\n\n\nCreating Themes\n\n\n\n\nHow to create a custom, pluggable style for your widgets and applications.\n\n\n\n\nProviding Controls\n\n\n\n\nHow to create reusable, interactive elements that support themes.\n\n\n\n\nInfrastructure and Tools\n\n\n\n\nWhat happens when a LaxarJS application starts, and how its assets are prepared.\n\n\nAdvanced Manuals\n\n\n\n\nAsset Lookup and the FileResourceProvider\n\n\n\n\nHow CSS, HTML and other static assets are resolved and loaded.\n\n\n\n\nWriting Compositions\n\n\n\n\nWhen simple pages are not enough.\n\n\n\n\nConfiguring RequireJS for widgets and controls\n\n\n\n\nHow to configure RequireJS for widgets and controls with extraordinary needs.\n\n\n\n\nConfiguration\n\n\n\n\nDocuments the LaxarJS configuration API which can be used to configure widgets, and the built-in configuration options.\n\n\n\n\nInternationalization (i18n)\n\n\n\n\nExplains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.\n\n\n\n\nVisibility Events\n\n\n\n\nIntroduces visibility events for improving performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.\n\n\n\n\nCreating an Adapter for a new Widget Technology\n\n\n\n\nTired of writing widgets in AngularJS? Learn how to adapt any MVC technology for creating LaxarJS widgets.", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Before starting with the manuals, make sure that you know  what LaxarJS is about , and that you are familiar with the  core concepts .\nIf you're already developing your first widgets and want to know which programmatic APIs are provided by LaxarJS, have a look at the  API docs .", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/#basic-manuals", 
            "text": "Widgets and Activities   Learn about the building blocks of a LaxarJS application.   Writing Pages   A step-by-step introduction to writing layouts and pages for a LaxarJS application.   Installing Third Party Widgets   Learn how to integrate and leverage existing widgets and activities.   Flow and Places   Creating a flow through the pages and make the addressable as places.   Writing Widget Controllers   How to create a basic widget controller for a specific integration technology.   Events   How to communicate between widgets using topics on the event bus.   Creating Themes   How to create a custom, pluggable style for your widgets and applications.   Providing Controls   How to create reusable, interactive elements that support themes.   Infrastructure and Tools   What happens when a LaxarJS application starts, and how its assets are prepared.", 
            "title": "Basic Manuals"
        }, 
        {
            "location": "/manuals/#advanced-manuals", 
            "text": "Asset Lookup and the FileResourceProvider   How CSS, HTML and other static assets are resolved and loaded.   Writing Compositions   When simple pages are not enough.   Configuring RequireJS for widgets and controls   How to configure RequireJS for widgets and controls with extraordinary needs.   Configuration   Documents the LaxarJS configuration API which can be used to configure widgets, and the built-in configuration options.   Internationalization (i18n)   Explains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.   Visibility Events   Introduces visibility events for improving performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.   Creating an Adapter for a new Widget Technology   Tired of writing widgets in AngularJS? Learn how to adapt any MVC technology for creating LaxarJS widgets.", 
            "title": "Advanced Manuals"
        }, 
        {
            "location": "/manuals/asset_lookup/", 
            "text": "Assets and the FileResourceProvider\n\n\n\u00ab return to the manuals\n\n\nWidgets and controls depend on various non-JavaScript resources which have to be loaded into the browser somehow.\nThese resources are also called \nassets\n.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\nCreating Themes\n\n\nInfrastructure and Tools\n\n\n\n\nBecause of the LaxarJS themes feature, the specific set of HTML/CSS assets used by any widget always depend on the application where it is used.\n\n\nIn order to avoid excessive configuration, assets are selected based on their path in the directory tree of an application.\n\n\nTypes of Assets handled by LaxarJS\n\n\nFor \nwidgets\n, LaxarJS manages the following assets:\n\n\n* the `widget.json` *descriptor*, which describes the widget features\n\n* the *HTML template* which defines the widget markup, and may be overwritten by the theme\n\n* the *CSS style sheet* refining the presentation of the widget, which is often overwritten by the theme, but which may also be missing completely\n\n\n\n\n\nFor \nactivities\n, LaxarJS only manages the \nwidget.json\n descriptor, since activities lack an associated presentation.\n\n\nFor \ncontrols\n, LaxarJS manages the \ncontrol.json\n descriptor, and the theme-dependent CSS style sheet (if any).\nControls may sometimes choose to load HTML assets (preferably using RequireJS), but these are not covered by the themeing mechanism.\n\n\nFor \nlayouts\n, LaxarJS loads the AngularJS HTML template, and the CSS style sheet (if any).\nBoth may be overridden by the application theme.\n\n\nWhy Centralized Asset Handling?\n\n\nSince LaxarJS widgets and controls may use AMD-style imports, they could try to include their assets themselves, for example through RequireJS plugins (\njson\n, \ncss\n and \nhtml\n).\nThis would also allow for simple automatic minification through \nr.js\n.\nHowever, we chose a different approach for the following reasons:\n\n\n\n\n\n\nThe runtime needs access to the \nwidget.json\n to resolve the controller module and to validate the feature configuration, while only the actual configuration values for a specific widget instance are relevant to the corresponding controller instance.\n  For this reason, the runtime should take care of obtaining the widget descriptor.\n\n\n\n\n\n\nThe LaxarJS runtime knows when a widget is actually being displayed, and will only then instantiate the corresponding HTML template.\n\n\n\n\n\n\nThe CSS should be loaded \nen bloc\n using a single, optimized style sheet right on application entry.\n  Deferring load of styles to the time where individual widgets are instantiated produces jitter and visual noise.\n  Often, the page will look broken until the various CSS fragments have been loaded.\n\n\n\n\n\n\nThe LaxarJS runtime will need to select assets based on the application \ntheme\n, and based on which assets of a given artifact are available in which theme.\n\n\n\n\n\n\nFor these reasons, the LaxarJS runtime takes care of selecting and loading assets.\nBy using the FileResourceProvider service, fast development iterations as well as comprehensive optimization during production are still available.\n\n\nThe FileResourceProvider\n\n\nDuring application development, the LaxarJS runtime needs to know if HTML and CSS are available for a given artifact, and \u2013 if they are \u2013 from where to load them.\nThe straightforward approach for this is to query each possible location using an HTTP-request (starting with the application theme, and falling back to the default theme), and to use the first resource that is available.\nHowever, this may considerably slow down loading the application, and will lead to a lot of ugly and confusing HTTP-404 errors in the browser console.\n\n\nIdeally, the runtime would \njust know\n what assets are available so it could simply load the best matching variant, or skip loading completely for assets that are missing.\nFortunately, in LaxarJS there is a component that does precisely this: the \nFileResourceProvider\n service can be \nconfigured\n with a long list of all available assets.\nUsing this list, it can tell other components about the availability of individual asset and of their theme-specific variants.\nIt can also go ahead and fetch individual assets.\nOf course, you do not have to create and maintain this list of assets by hand.\nInstead, the \ngrunt-laxar\n task \nlaxar-resources\n, which is part of the \nlaxar-build\n target will automatically prepare the listing for you in JSON format, and the application configuration can be used to get it to the file resource provider.\n\n\nWhile we have now eliminated the unnecessary 404 requests, in production we would like to avoid \nany\n requests that are not absolutely necessary.\nFor this reason, the FileResourceProvider can serve asset contents that were \nembedded\n into the JSON file listing, rather than fetching the contents using HTTP.\nAgain, the application configuration (\nuseEmbeddedFileListings\n) determines if embedded assets are used.\nNote that CSS is not embedded into the listings, but rather compiled into a single production CSS file by the grunt-laxar task \nlaxar-dist-css\n, which is part of the \nlaxar-dist\n target.\n\n\nAssets by Artifact Type\n\n\nHaving explained the general asset loading mechanism, the following sections go into detail on the individual artifact types and their asset locations.\n\n\nLooking up the Theme CSS\n\n\nTo load the CSS for the theme itself, the runtime simply uses the \nconfigured\n theme \nX\n and looks for its CSS under \nincludes/themes/X.theme/css/theme.css\n.\nThe exception is the \ndefault theme\n, which is currently loaded from within \nlaxar-uikit\n (if no user-defined theme is specified).\nBoth the path for application specific themes and for the default theme can optionally be configured within the \nrequire_config.js\n of your project to match your setup.\nThe relevant paths are \nlaxar-path-themes\n and \nlaxar-path-default-theme\n respectively.\nIn most cases however, the predefined values should work just fine.\n\n\nLooking up Widget CSS and HTML Templates\n\n\nFor widget CSS styles and HTML templates, the LaxarJS runtime first checks if a version is available within the theme.\nThis means that you cannot only customize the CSS for a widget \nx\n installed under \nincludes/widgets/cat/x\n by placing a style sheet at \ntheme-folder\n/widgets/category/x/css/x.css\n but that you can also override the HTML at \ntheme-folder\n/widgets/category/x/x.html\n.\n\n\nWhen nothing was found among the assets bundled with the theme, the assets bundled with the widget are checked:\nFor a widget installed under \nbower_components/x/\n, the paths \nbower_components/x/a.theme/css/x.css\n and \nbower_components/x/a.theme/x.html\n respectively will be checked when using a theme \na.theme\n.\nNote that both locations (theme-bundled and artifact-bundled) are respected, no matter if a widget was installed as Bower component or locally into the \nincludes/widgets\n folder.\n\n\nIf nothing was found for the application theme for a given widget, the \ndefault.theme\n folder within the widget itself is used.\nDo note that CSS and HTML files are treated separately:\nYou can override the CSS but not the HTML or vice versa.\n\n\nLooking up CSS and HTML for a Layout\n\n\nThemes are intended to be reusable across applications.\nBecause layouts are highly specific to an application, usually their CSS and HTML assets live \nwithin the layout's folder\n of the application, with styling for all relevant themes.\nHowever, like with widgets it is possible to style application layouts externally using the sub-folder \nlayouts\n of the theme in use.\nFor lookup, the same process as for widgets is used:\nFirst, LaxarJS searches the theme itself, then the theme folder within the layout, before finally falling back to the default theme.\n\n\nLooking up CSS for a Control\n\n\nControls (mostly AngularJS directives) take care of their own HTML loading (if required at all), so the choice of theme has no effect here.\nThe CSS styling however is theme specific:\nBefore looking for the default theme in \ncontrol-amd-path\n/default.theme/css/\ncontrol-name\n.css\n, LaxarJS looks for a theme specific override in \ntheme-path\n/controls/\ncontrol-amd-path\n/css/\ncontrol-name\n.css\n.\nHere, the \ntheme-path\n refers to the folder containing your global theme, and the \ncontrol-amd-path\n is the same path that widgets specify in their \nwidget.json\n descriptor to include a control.\nHave a look at the \nmanual on controls\n for details.", 
            "title": "Assets and the FileResourceProvider"
        }, 
        {
            "location": "/manuals/asset_lookup/#assets-and-the-fileresourceprovider", 
            "text": "\u00ab return to the manuals  Widgets and controls depend on various non-JavaScript resources which have to be loaded into the browser somehow.\nThese resources are also called  assets .  Preliminary readings:   Widgets and Activities  Creating Themes  Infrastructure and Tools   Because of the LaxarJS themes feature, the specific set of HTML/CSS assets used by any widget always depend on the application where it is used.  In order to avoid excessive configuration, assets are selected based on their path in the directory tree of an application.", 
            "title": "Assets and the FileResourceProvider"
        }, 
        {
            "location": "/manuals/asset_lookup/#types-of-assets-handled-by-laxarjs", 
            "text": "For  widgets , LaxarJS manages the following assets:  * the `widget.json` *descriptor*, which describes the widget features\n\n* the *HTML template* which defines the widget markup, and may be overwritten by the theme\n\n* the *CSS style sheet* refining the presentation of the widget, which is often overwritten by the theme, but which may also be missing completely  For  activities , LaxarJS only manages the  widget.json  descriptor, since activities lack an associated presentation.  For  controls , LaxarJS manages the  control.json  descriptor, and the theme-dependent CSS style sheet (if any).\nControls may sometimes choose to load HTML assets (preferably using RequireJS), but these are not covered by the themeing mechanism.  For  layouts , LaxarJS loads the AngularJS HTML template, and the CSS style sheet (if any).\nBoth may be overridden by the application theme.", 
            "title": "Types of Assets handled by LaxarJS"
        }, 
        {
            "location": "/manuals/asset_lookup/#why-centralized-asset-handling", 
            "text": "Since LaxarJS widgets and controls may use AMD-style imports, they could try to include their assets themselves, for example through RequireJS plugins ( json ,  css  and  html ).\nThis would also allow for simple automatic minification through  r.js .\nHowever, we chose a different approach for the following reasons:    The runtime needs access to the  widget.json  to resolve the controller module and to validate the feature configuration, while only the actual configuration values for a specific widget instance are relevant to the corresponding controller instance.\n  For this reason, the runtime should take care of obtaining the widget descriptor.    The LaxarJS runtime knows when a widget is actually being displayed, and will only then instantiate the corresponding HTML template.    The CSS should be loaded  en bloc  using a single, optimized style sheet right on application entry.\n  Deferring load of styles to the time where individual widgets are instantiated produces jitter and visual noise.\n  Often, the page will look broken until the various CSS fragments have been loaded.    The LaxarJS runtime will need to select assets based on the application  theme , and based on which assets of a given artifact are available in which theme.    For these reasons, the LaxarJS runtime takes care of selecting and loading assets.\nBy using the FileResourceProvider service, fast development iterations as well as comprehensive optimization during production are still available.", 
            "title": "Why Centralized Asset Handling?"
        }, 
        {
            "location": "/manuals/asset_lookup/#the-fileresourceprovider", 
            "text": "During application development, the LaxarJS runtime needs to know if HTML and CSS are available for a given artifact, and \u2013 if they are \u2013 from where to load them.\nThe straightforward approach for this is to query each possible location using an HTTP-request (starting with the application theme, and falling back to the default theme), and to use the first resource that is available.\nHowever, this may considerably slow down loading the application, and will lead to a lot of ugly and confusing HTTP-404 errors in the browser console.  Ideally, the runtime would  just know  what assets are available so it could simply load the best matching variant, or skip loading completely for assets that are missing.\nFortunately, in LaxarJS there is a component that does precisely this: the  FileResourceProvider  service can be  configured  with a long list of all available assets.\nUsing this list, it can tell other components about the availability of individual asset and of their theme-specific variants.\nIt can also go ahead and fetch individual assets.\nOf course, you do not have to create and maintain this list of assets by hand.\nInstead, the  grunt-laxar  task  laxar-resources , which is part of the  laxar-build  target will automatically prepare the listing for you in JSON format, and the application configuration can be used to get it to the file resource provider.  While we have now eliminated the unnecessary 404 requests, in production we would like to avoid  any  requests that are not absolutely necessary.\nFor this reason, the FileResourceProvider can serve asset contents that were  embedded  into the JSON file listing, rather than fetching the contents using HTTP.\nAgain, the application configuration ( useEmbeddedFileListings ) determines if embedded assets are used.\nNote that CSS is not embedded into the listings, but rather compiled into a single production CSS file by the grunt-laxar task  laxar-dist-css , which is part of the  laxar-dist  target.", 
            "title": "The FileResourceProvider"
        }, 
        {
            "location": "/manuals/asset_lookup/#assets-by-artifact-type", 
            "text": "Having explained the general asset loading mechanism, the following sections go into detail on the individual artifact types and their asset locations.", 
            "title": "Assets by Artifact Type"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-the-theme-css", 
            "text": "To load the CSS for the theme itself, the runtime simply uses the  configured  theme  X  and looks for its CSS under  includes/themes/X.theme/css/theme.css .\nThe exception is the  default theme , which is currently loaded from within  laxar-uikit  (if no user-defined theme is specified).\nBoth the path for application specific themes and for the default theme can optionally be configured within the  require_config.js  of your project to match your setup.\nThe relevant paths are  laxar-path-themes  and  laxar-path-default-theme  respectively.\nIn most cases however, the predefined values should work just fine.", 
            "title": "Looking up the Theme CSS"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-widget-css-and-html-templates", 
            "text": "For widget CSS styles and HTML templates, the LaxarJS runtime first checks if a version is available within the theme.\nThis means that you cannot only customize the CSS for a widget  x  installed under  includes/widgets/cat/x  by placing a style sheet at  theme-folder /widgets/category/x/css/x.css  but that you can also override the HTML at  theme-folder /widgets/category/x/x.html .  When nothing was found among the assets bundled with the theme, the assets bundled with the widget are checked:\nFor a widget installed under  bower_components/x/ , the paths  bower_components/x/a.theme/css/x.css  and  bower_components/x/a.theme/x.html  respectively will be checked when using a theme  a.theme .\nNote that both locations (theme-bundled and artifact-bundled) are respected, no matter if a widget was installed as Bower component or locally into the  includes/widgets  folder.  If nothing was found for the application theme for a given widget, the  default.theme  folder within the widget itself is used.\nDo note that CSS and HTML files are treated separately:\nYou can override the CSS but not the HTML or vice versa.", 
            "title": "Looking up Widget CSS and HTML Templates"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-css-and-html-for-a-layout", 
            "text": "Themes are intended to be reusable across applications.\nBecause layouts are highly specific to an application, usually their CSS and HTML assets live  within the layout's folder  of the application, with styling for all relevant themes.\nHowever, like with widgets it is possible to style application layouts externally using the sub-folder  layouts  of the theme in use.\nFor lookup, the same process as for widgets is used:\nFirst, LaxarJS searches the theme itself, then the theme folder within the layout, before finally falling back to the default theme.", 
            "title": "Looking up CSS and HTML for a Layout"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-css-for-a-control", 
            "text": "Controls (mostly AngularJS directives) take care of their own HTML loading (if required at all), so the choice of theme has no effect here.\nThe CSS styling however is theme specific:\nBefore looking for the default theme in  control-amd-path /default.theme/css/ control-name .css , LaxarJS looks for a theme specific override in  theme-path /controls/ control-amd-path /css/ control-name .css .\nHere, the  theme-path  refers to the folder containing your global theme, and the  control-amd-path  is the same path that widgets specify in their  widget.json  descriptor to include a control.\nHave a look at the  manual on controls  for details.", 
            "title": "Looking up CSS for a Control"
        }, 
        {
            "location": "/manuals/configuring_requirejs/", 
            "text": "Configuring RequireJS for Widgets and Controls\n\n\n\u00ab return to the manuals\n\n\nThe Need for Configuration\n\n\nWidgets and Controls perform very different tasks and are of varying complexity.\nIn many cases only the event bus is needed as communication interface and all logic is contained within the implementation of an artifact.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\nInfrastructure and Tools\n\n\n\n\nHowever, sooner or later one will come to a point, where third party libraries are useful or even necessary for a widget or control, or where own code should be extracted into a separate library.\nWhen using such external dependencies, it is never a good idea to assume a specific location for it.\nInstead, a widget should add a dependency to an according \nnamed module\n, where the actual location of a module can then be configured independently by using the \nconfiguration API of RequireJS\n.\n\n\nThe One-File-Fits-All Way\n\n\nThe most common way to configure \nRequireJS\n is by adding all necessary entries to the \nrequire_config.js\n file within the root folder of the application.\nEverything configured there will be used when loading widget and control AMD modules.\nIf, for example, a widget needs a special library to fulfill its task, this library can be configured as a module in there and the widget will have access to it via the normal AMD module definition syntax.\n\n\nAlthough this will work and may be sufficient for small projects where custom widgets are tightly coupled to the application, this adds complexity when attempting to share widgets or controls.\nIn this case every developer who wants to use that artifact in his application, has to know about these requirements and adjust the \nrequire_config.js\n of his application accordingly.\nAs if this isn't worse enough, over time this global configuration will grow and probably become a maintenance hell.\n\n\nThe Individual Way\n\n\nTo solve this problem, \nLaxarJS\n supports placing \nRequireJS\n configuration locally within a widget or control directory.\nAll configuration that is specific to an artifact and not already satisfied by the configuration of the application can then be placed there.\nSince \nRequireJS\n does not support this out-of-the-box, \nLaxarJS\n implements the support for distributed configuration itself during the build process.\n\n\nHow it works\n\n\nThe magic happens inside the \ngrunt-laxar\n grunt tasks:\nRunning the \nlaxar-build\n task now also triggers running the \nlaxar-merge-require-config\n task.\nThis task walks through all widget and control directories reachable from a flow, collects all \nrequire_config.js\n files and merges them with the application specific \nrequire_config.js\n found in the root directory of the application.\nThe result will be written under the folder for generated flow artifacts (e.g. \nvar/flows/main/require_config.js\n for a flow called \nmain\n).\n\n\nIt is assumed that the configuration is saved as a global \nrequire\n variable within the \nrequire_config.js\n.\n\n\nFor example:\n\n\nvar\n \nrequire\n \n=\n \n{\n\n   \npaths\n:\n \n{\n\n      \nmarked\n:\n \nmarked/lib/marked\n\n   \n},\n\n   \npackages\n:\n \n[\n\n      \n{\n\n         \nname\n:\n \nURI\n,\n\n         \nlocation\n:\n \nURIjs/src\n,\n\n         \nmain\n:\n \nURI\n\n      \n}\n\n   \n]\n\n\n};\n\n\n\n\n\n\nThis will \nnot\n work:\n\n\nwindow\n.\nrequire\n \n=\n \n{\n\n  \n// this won\nt work ....\n\n\n};\n\n\n// or\n\n\nrequire\n.\nconfig\n(\n \n{\n\n   \n// this won\nt work, too ...\n\n\n}\n \n);\n\n\n\n\n\n\nWhen merging the configuration the \nrequire_config.js\n found in the application root is used as starting point.\nWhenever in another configuration a \nshim\n, \ndeps\n or \npackage\n configuration is found, it is added to the resulting configuration.\nAlready existing entries will not be overwritten.\nHence the application always wins.\n\n\npaths\n will be merged likewise, with the only difference, that a different path for an already configured module will be added as mapping under the path of the artifact.\nIf for example the application configures the path for \nunderscore\n as \nunderscore/dist/underscore\n but the widget (which is for example located under \nincludes/widgets/category/my-widget\n) defines \nunderscore\n as \nlodash/dist/lodash\n, the following mapping will be added:\n\n\n{\n\n   \nmap\n:\n \n{\n\n      \nincludes/widgets/category/my-widget\n \n:\n \n{\n\n         \nunderscore\n:\n \nlodash/dist/lodash\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nEverything under \nmap\n in the artifact configuration will prefixed with the path to the artifact before adding it to the resulting configuration.\nThis ensures it will only be enabled for the correct artifact.\nThe result looks similar to the example for paths above.\n\n\nAll other available \nRequireJS\n configuration will simply be added, if not set already.\nIf e.g. \nbaseUrl\n is defined in the \nrequire_config.js\n of the application, a value from a widget's \nrequire_config.js\n will be ignored.", 
            "title": "Configuring RequireJS for Widgets and Controls"
        }, 
        {
            "location": "/manuals/configuring_requirejs/#configuring-requirejs-for-widgets-and-controls", 
            "text": "\u00ab return to the manuals", 
            "title": "Configuring RequireJS for Widgets and Controls"
        }, 
        {
            "location": "/manuals/configuring_requirejs/#the-need-for-configuration", 
            "text": "Widgets and Controls perform very different tasks and are of varying complexity.\nIn many cases only the event bus is needed as communication interface and all logic is contained within the implementation of an artifact.  Preliminary readings:   Widgets and Activities  Infrastructure and Tools   However, sooner or later one will come to a point, where third party libraries are useful or even necessary for a widget or control, or where own code should be extracted into a separate library.\nWhen using such external dependencies, it is never a good idea to assume a specific location for it.\nInstead, a widget should add a dependency to an according  named module , where the actual location of a module can then be configured independently by using the  configuration API of RequireJS .", 
            "title": "The Need for Configuration"
        }, 
        {
            "location": "/manuals/configuring_requirejs/#the-one-file-fits-all-way", 
            "text": "The most common way to configure  RequireJS  is by adding all necessary entries to the  require_config.js  file within the root folder of the application.\nEverything configured there will be used when loading widget and control AMD modules.\nIf, for example, a widget needs a special library to fulfill its task, this library can be configured as a module in there and the widget will have access to it via the normal AMD module definition syntax.  Although this will work and may be sufficient for small projects where custom widgets are tightly coupled to the application, this adds complexity when attempting to share widgets or controls.\nIn this case every developer who wants to use that artifact in his application, has to know about these requirements and adjust the  require_config.js  of his application accordingly.\nAs if this isn't worse enough, over time this global configuration will grow and probably become a maintenance hell.", 
            "title": "The One-File-Fits-All Way"
        }, 
        {
            "location": "/manuals/configuring_requirejs/#the-individual-way", 
            "text": "To solve this problem,  LaxarJS  supports placing  RequireJS  configuration locally within a widget or control directory.\nAll configuration that is specific to an artifact and not already satisfied by the configuration of the application can then be placed there.\nSince  RequireJS  does not support this out-of-the-box,  LaxarJS  implements the support for distributed configuration itself during the build process.", 
            "title": "The Individual Way"
        }, 
        {
            "location": "/manuals/configuring_requirejs/#how-it-works", 
            "text": "The magic happens inside the  grunt-laxar  grunt tasks:\nRunning the  laxar-build  task now also triggers running the  laxar-merge-require-config  task.\nThis task walks through all widget and control directories reachable from a flow, collects all  require_config.js  files and merges them with the application specific  require_config.js  found in the root directory of the application.\nThe result will be written under the folder for generated flow artifacts (e.g.  var/flows/main/require_config.js  for a flow called  main ).  It is assumed that the configuration is saved as a global  require  variable within the  require_config.js .  For example:  var   require   =   { \n    paths :   { \n       marked :   marked/lib/marked \n    }, \n    packages :   [ \n       { \n          name :   URI , \n          location :   URIjs/src , \n          main :   URI \n       } \n    ]  };   This will  not  work:  window . require   =   { \n   // this won t work ....  };  // or  require . config (   { \n    // this won t work, too ...  }   );   When merging the configuration the  require_config.js  found in the application root is used as starting point.\nWhenever in another configuration a  shim ,  deps  or  package  configuration is found, it is added to the resulting configuration.\nAlready existing entries will not be overwritten.\nHence the application always wins.  paths  will be merged likewise, with the only difference, that a different path for an already configured module will be added as mapping under the path of the artifact.\nIf for example the application configures the path for  underscore  as  underscore/dist/underscore  but the widget (which is for example located under  includes/widgets/category/my-widget ) defines  underscore  as  lodash/dist/lodash , the following mapping will be added:  { \n    map :   { \n       includes/widgets/category/my-widget   :   { \n          underscore :   lodash/dist/lodash \n       } \n    }  }   Everything under  map  in the artifact configuration will prefixed with the path to the artifact before adding it to the resulting configuration.\nThis ensures it will only be enabled for the correct artifact.\nThe result looks similar to the example for paths above.  All other available  RequireJS  configuration will simply be added, if not set already.\nIf e.g.  baseUrl  is defined in the  require_config.js  of the application, a value from a widget's  require_config.js  will be ignored.", 
            "title": "How it works"
        }, 
        {
            "location": "/manuals/providing_controls/", 
            "text": "Controls and Libraries\n\n\n\u00ab return to the manuals\n\n\nIn LaxarJS, any non-trivial HTML element, \nHTML5 Web Component\n or \nAngularJS directive\n is considered a \ncontrol\n.\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nTo provide their business logic, widgets and activities often depend on libraries, which might be created by third parties or simply be used to share common functionality.\nIn the latter case, be sure not to couple your controllers to tightly, e.g. a shared libraries should not allow to share state.\n\n\nHere are some examples of controls:\n\n\n* a select box\n* a date picker\n* an accordion control\n* a tab control\n\n\n\n\n\nLaxarJS helps when developing a custom control by managing and loading its AngularJS module, as well as its theme-dependent CSS style sheet for you.\nIf (and only if) you \nuse\n a control in one or more widgets, LaxarJS will load its CSS according to the current \ntheme\n, just like with widgets and layouts.\nWhen you remove the control from your widget, or the widget from your page, its code and assets will no longer increase your application footprint.\nThis allows you to create and distribute large libraries of controls without fear of application bloat.\n\n\nCreating or Integrating a Control\n\n\nWhile HTML5 Web Components are very interesting, the current browser support is limited.\nFor this reason, LaxarJS currently only covers the creation of a control as an AngularJS directive.\n\n\nOf course you can still use Web Components, jQuery UI or any other way of creating controls in your widgets, but LaxarJS currently will not manage assets for them.\nThe recommended way for now is therefore to wrap such controls in an AngularJS directive.\nThis can be done either for a single widget by simply adding a directive to its module, or by providing a standalone control as described in the following.\n\n\nCreating a Control using an AngularJS directive\n\n\nLaxarJS does not care whether your control is installed through bower or if it is located somewhere else within your project, as long as its directory can be found by \nRequireJS\n.\nLet us try to create a control \nmy-clock-control\n that displays a digital clock to the user.\n\n\nRequireJS Path\n\n\nFirst, choose a location for your control within your application, such as \nincludes/controls/my-clock\n.\nIn the require configuration, you will need configure the path to your new control:\n\n\npaths\n:\n \n{\n\n   \n// ...\n\n   \nmy-clock-control\n:\n \n../includes/controls/my-clock-control\n\n\n}\n\n\n\n\n\n\nThis assumes that \nbower_components\n is your RequireJS \nbaseUrl\n.\nNote that using this base URL has the advantage that no RequireJS configuration is necessary when using a control that was installed through Bower, as long as widgets use the bower-registered name when referencing the control.\n\n\nThe Control Descriptor\n\n\nJust like widgets, controls have a small JSON descriptor \n(control.json)\n which instructs the runtime on how to load the control.\nHere is the descriptor for our clock control:\n\n\n{\n\n   \nname\n:\n \nmy-clock-control\n,\n\n   \nintegration\n:\n \n{\n\n      \ntechnology\n:\n \nangular\n\n   \n}\n\n\n}\n\n\n\n\n\n\nTo ensure compatibility between each widget and its controls, both must use the same \nintegration technology\n.\nSince LaxarJS 1.1, \"angular\" and \"plain\" are supported for controls out-of-the-box, and other technologies can be added through \nadapters\n, such as the \nlaxar-react-adapter\n.\nThe \nname\n helps the LaxarJS runtime to load the correct AngularJS module and the right CSS styles.\nSo, even if the directory or the RequireJS paths were something else, the runtime would still be able to load the control.\n\n\nAngularJS Directive\n\n\nNow let us create the AngularJS module for the control, in \nincludes/controls/my-clock-control/my-clock-control.js\n:\n\n\ndefine\n(\n \n[\n \nangular\n,\n \ntext!./my-clock-control.html\n \n],\n \nfunction\n(\n \nng\n,\n \nclockTemplate\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \nvar\n \nmodule\n \n=\n \nng\n.\nmodule\n(\n \nmyClockControl\n,\n \n[]\n \n);\n\n\n   \nmodule\n.\nfilter\n(\n \nmyClockDigits\n,\n \nfunction\n()\n \n{\n\n      \nreturn\n \nfunction\n(\n \nnumber\n \n)\n \n{\n\n         \nreturn\n \n(\n \nnumber\n \n \n10\n \n?\n \n0\n \n:\n \n \n)\n \n+\n \nnumber\n;\n\n      \n}\n\n   \n}\n \n);\n\n\n   \nreturn\n \nmodule\n.\ndirective\n(\n \nmyClock\n,\n \n[\n \n$timeout\n,\n \nfunction\n(\n \n$timeout\n \n)\n \n{\n\n      \nreturn\n \n{\n\n         \nrestrict\n:\n \nE\n,\n\n         \ntemplate\n:\n \nclockTemplate\n,\n\n         \nlink\n:\n \nfunction\n(\n \n$scope\n \n)\n \n{\n\n            \ntick\n();\n\n            \nfunction\n \ntick\n()\n \n{\n\n               \n$scope\n.\ndate\n \n=\n \nnew\n \nDate\n();\n\n               \n$timeout\n(\n \ntick\n,\n \n1000\n \n);\n\n            \n}\n\n         \n}\n\n      \n};\n\n\n   \n}\n \n]\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\nWe use a prefix \n(my)\n for the control and for the filter- and directive-names to avoid collisions with other controls and directives, as well as future HTML elements.\nMake sure to return the AngularJS module from your AMD module as shown here, so that LaxarJS can use it when bootstrapping your application.\n\n\nAngularJS Template\n\n\nTo add an actual Let us create a simple template at \nincludes/controls/my-clock-control/my-clock-control.html\n.\n\n\nspan\n \nclass=\nmy-clock\n\n   {{ date.getHours() | myClockDigits }}:{{ date.getMinutes() | myClockDigits }}:{{ date.getSeconds() | myClockDigits }}\n\n/span\n\n\n\n\n\n\nIt is recommended to use the control name as a prefix for any custom CSS classes, to avoid collision with other controls and libraries.\n\n\nThe CSS Style Sheet\n\n\nTo automatically load your CSS depending on the theme, it has to be placed into a sub-directory \ndefault.theme/css\n of your require path and its file name must correspond to the control descriptor.\nIn case of the clock control, the correct path would be \nincludes/controls/my-clock-control/default.theme/my-clock-control.css\n.\n\n\n.my-clock\n \n{\n\n   \nfont-family\n:\n \nTimes New Roman\n,\n \nserif\n;\n\n   \nfont-weight\n:\n \nbold\n;\n\n   \nfont-size\n:\n \n36px\n;\n\n   \nborder\n:\n \n3px\n \ndouble\n \nblack\n;\n\n   \npadding\n:\n \n3px\n;\n\n\n}\n\n\n\n\n\n\nUsing a Control from a Widget\n\n\nAny widget that uses our clock should declare its AMD dependency using \ncontrols\n entry in its \nwidget.json\n:\n\n\ncontrols\n:\n \n[\n \nmy-clock-control\n \n]\n,\n\n\n\n\n\n\nThis allows the runtime to load the RequireJS module and to register the AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application.\n\n\nTo actually get the control onto the screen, you have to reference it from your widget's HTML template:\n\n\nh3\nMy Widget, now with 100% more 24h-clock!\n/h3\n\n\nmy-clock\n/my-clock\n\n\n\n\n\n\nAfter adding your widget to a page, you may inspect your timepiece in the browser:\n\n\n\n\nCreating or Integrating a Library\n\n\nAdding custom libraries is even simpler than adding controls, because usually they do not need to load theme-specific CSS or to have their AngularJS modules managed (if they do, try turning them into controls or activities respectively).\nJust put the library somewhere within your project (preferably using Bower) and make sure that it can be referenced using a RequireJS path.\nIf the library is not AMD-compatible, you may need to add RequireJS \nshim configuration\n in order to load it.\nUsually, a specific artifact (widget, activity or control) will depend on your library, so that it makes sense to add the library to that artifact's \nbower.json\n.", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#controls-and-libraries", 
            "text": "\u00ab return to the manuals  In LaxarJS, any non-trivial HTML element,  HTML5 Web Component  or  AngularJS directive  is considered a  control .\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities   To provide their business logic, widgets and activities often depend on libraries, which might be created by third parties or simply be used to share common functionality.\nIn the latter case, be sure not to couple your controllers to tightly, e.g. a shared libraries should not allow to share state.  Here are some examples of controls:  * a select box\n* a date picker\n* an accordion control\n* a tab control  LaxarJS helps when developing a custom control by managing and loading its AngularJS module, as well as its theme-dependent CSS style sheet for you.\nIf (and only if) you  use  a control in one or more widgets, LaxarJS will load its CSS according to the current  theme , just like with widgets and layouts.\nWhen you remove the control from your widget, or the widget from your page, its code and assets will no longer increase your application footprint.\nThis allows you to create and distribute large libraries of controls without fear of application bloat.", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-control", 
            "text": "While HTML5 Web Components are very interesting, the current browser support is limited.\nFor this reason, LaxarJS currently only covers the creation of a control as an AngularJS directive.  Of course you can still use Web Components, jQuery UI or any other way of creating controls in your widgets, but LaxarJS currently will not manage assets for them.\nThe recommended way for now is therefore to wrap such controls in an AngularJS directive.\nThis can be done either for a single widget by simply adding a directive to its module, or by providing a standalone control as described in the following.", 
            "title": "Creating or Integrating a Control"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-a-control-using-an-angularjs-directive", 
            "text": "LaxarJS does not care whether your control is installed through bower or if it is located somewhere else within your project, as long as its directory can be found by  RequireJS .\nLet us try to create a control  my-clock-control  that displays a digital clock to the user.", 
            "title": "Creating a Control using an AngularJS directive"
        }, 
        {
            "location": "/manuals/providing_controls/#requirejs-path", 
            "text": "First, choose a location for your control within your application, such as  includes/controls/my-clock .\nIn the require configuration, you will need configure the path to your new control:  paths :   { \n    // ... \n    my-clock-control :   ../includes/controls/my-clock-control  }   This assumes that  bower_components  is your RequireJS  baseUrl .\nNote that using this base URL has the advantage that no RequireJS configuration is necessary when using a control that was installed through Bower, as long as widgets use the bower-registered name when referencing the control.", 
            "title": "RequireJS Path"
        }, 
        {
            "location": "/manuals/providing_controls/#the-control-descriptor", 
            "text": "Just like widgets, controls have a small JSON descriptor  (control.json)  which instructs the runtime on how to load the control.\nHere is the descriptor for our clock control:  { \n    name :   my-clock-control , \n    integration :   { \n       technology :   angular \n    }  }   To ensure compatibility between each widget and its controls, both must use the same  integration technology .\nSince LaxarJS 1.1, \"angular\" and \"plain\" are supported for controls out-of-the-box, and other technologies can be added through  adapters , such as the  laxar-react-adapter .\nThe  name  helps the LaxarJS runtime to load the correct AngularJS module and the right CSS styles.\nSo, even if the directory or the RequireJS paths were something else, the runtime would still be able to load the control.", 
            "title": "The Control Descriptor"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-directive", 
            "text": "Now let us create the AngularJS module for the control, in  includes/controls/my-clock-control/my-clock-control.js :  define (   [   angular ,   text!./my-clock-control.html   ],   function (   ng ,   clockTemplate   )   { \n    use strict ; \n\n    var   module   =   ng . module (   myClockControl ,   []   ); \n\n    module . filter (   myClockDigits ,   function ()   { \n       return   function (   number   )   { \n          return   (   number     10   ?   0   :     )   +   number ; \n       } \n    }   ); \n\n    return   module . directive (   myClock ,   [   $timeout ,   function (   $timeout   )   { \n       return   { \n          restrict :   E , \n          template :   clockTemplate , \n          link :   function (   $scope   )   { \n             tick (); \n             function   tick ()   { \n                $scope . date   =   new   Date (); \n                $timeout (   tick ,   1000   ); \n             } \n          } \n       }; \n\n    }   ]   );  }   );   We use a prefix  (my)  for the control and for the filter- and directive-names to avoid collisions with other controls and directives, as well as future HTML elements.\nMake sure to return the AngularJS module from your AMD module as shown here, so that LaxarJS can use it when bootstrapping your application.", 
            "title": "AngularJS Directive"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-template", 
            "text": "To add an actual Let us create a simple template at  includes/controls/my-clock-control/my-clock-control.html .  span   class= my-clock \n   {{ date.getHours() | myClockDigits }}:{{ date.getMinutes() | myClockDigits }}:{{ date.getSeconds() | myClockDigits }} /span   It is recommended to use the control name as a prefix for any custom CSS classes, to avoid collision with other controls and libraries.", 
            "title": "AngularJS Template"
        }, 
        {
            "location": "/manuals/providing_controls/#the-css-style-sheet", 
            "text": "To automatically load your CSS depending on the theme, it has to be placed into a sub-directory  default.theme/css  of your require path and its file name must correspond to the control descriptor.\nIn case of the clock control, the correct path would be  includes/controls/my-clock-control/default.theme/my-clock-control.css .  .my-clock   { \n    font-family :   Times New Roman ,   serif ; \n    font-weight :   bold ; \n    font-size :   36px ; \n    border :   3px   double   black ; \n    padding :   3px ;  }", 
            "title": "The CSS Style Sheet"
        }, 
        {
            "location": "/manuals/providing_controls/#using-a-control-from-a-widget", 
            "text": "Any widget that uses our clock should declare its AMD dependency using  controls  entry in its  widget.json :  controls :   [   my-clock-control   ] ,   This allows the runtime to load the RequireJS module and to register the AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application.  To actually get the control onto the screen, you have to reference it from your widget's HTML template:  h3 My Widget, now with 100% more 24h-clock! /h3  my-clock /my-clock   After adding your widget to a page, you may inspect your timepiece in the browser:", 
            "title": "Using a Control from a Widget"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-library", 
            "text": "Adding custom libraries is even simpler than adding controls, because usually they do not need to load theme-specific CSS or to have their AngularJS modules managed (if they do, try turning them into controls or activities respectively).\nJust put the library somewhere within your project (preferably using Bower) and make sure that it can be referenced using a RequireJS path.\nIf the library is not AMD-compatible, you may need to add RequireJS  shim configuration  in order to load it.\nUsually, a specific artifact (widget, activity or control) will depend on your library, so that it makes sense to add the library to that artifact's  bower.json .", 
            "title": "Creating or Integrating a Library"
        }, 
        {
            "location": "/manuals/creating_themes/", 
            "text": "Creating Themes\n\n\n\u00ab return to the manuals\n\n\nSometimes you would like to use \none widget\n in \ntwo or more applications\n.\nFor this, usually you want the widget to \nbehave identically\n, but \nlook differently\n.\nAlternatively, sometimes you would like to offer the same application in different appearances.\nLaxarJS has the concept of \nthemes\n to help you achieve these things.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\n\n\nWhy Themes?\n\n\nLaxarJS ships with a so-called \ndefault theme\n, which is actually just \nBootstrap CSS\n together with \nFont Awesome\n and a few additional classes.\nThere are several ways to add your own styles.\n\n\nFrom Ad-Hoc Styles to Theme Folders\u2026\n\n\nUsually, you will need to add some CSS classes of your own.\nFor example, the vast majority of web application needs some styling for the page background and positioning or custom header- and footer-areas.\nTo include such \nad-hoc styles\n, you \ncould\n simply add a CSS file of your own to the project, and load it from the \ndebug.html\n and \nindex.html\n files using the \nlink\n tag.\nHowever, it is \nrecommended\n to add these styles to your main application layout instead, into a sub-folder called \ndefault.theme/css\n.\n\n\nThe \nbenefit\n of using such a \ntheme folder\n is that\n\n\n* your CSS will be _bundled and compressed_ together with Bootstrap (no `\nlink\n` tag needed) and that\n* you can support different _themes_ simply by adding more `.theme` folders.\n\n\n\n\n\nDue to the first point, using the theme folders is useful and recommended \neven\n if you only use (and maybe customize) the default theme.\n\n\n\u2026and to Custom Themes\n\n\nAs soon as you use multiple page layouts, the previous approach does not really scale anymore: you would have to duplicate your global styles to all of them.\nIn these cases, creating your own theme is definitely recommended.\nA detailed explanation of \ncreating a theme\n is given below.\n\n\nA Note on Compass/SCSS\n\n\nWhen using theme folders or entire themes, the runtime will only ever look at \n.css\n files in \ncss\n sub-folders.\nThis means that it is entirely \nup to you\n which (if any) CSS authoring tools you would like to use.\n\n\nThat being said, we use Compass/SCSS to create themes, and the default-theme is based on the SCSS version of Bootstrap.\nUsing this approach makes it very easy to create a custom theme just by changing some Bootstrap SCSS variables.\nAlso, by using SCSS variables defined in the theme, widgets and controls can provide a consistent appearance.\nAfter explaining themes in general, further down we give instructions on \ncreating an SCSS theme\n.\n\n\n\n\nCreating Your Own Theme\n\n\nLet us create our own theme for an existing application, the \nLaxarJS ShopDemo\n.\nThe ShopDemo brings it's own \n\"cube.theme\"\n, which is implemented by augmenting Bootstrap with some changes and custom additions, such as the circle icons used with the headlines.\n\n\n\n\nAbove:\n The LaxarJS ShopDemo using the \ncube\n theme\n\n\nHowever, the demo also works with just the default theme, provided by LaxarJS UiKit, although admittedly it does not look quite as pretty:\n\n\n\n\nAbove:\n The LaxarJS ShopDemo using the \ndefault\n theme\n\n\nA Custom Theme Using Plain CSS\n\n\nSince all applications seem to offer a \"dark\" look these days, let us try to achieve this for our shop demo app.\nFortunately, there are several collections of nice bootstrap themes available for free.\nOn the site \nBootswatch\n for example, you will find the theme \ndarkly\n, which looks like it might work for us.\n\n\nThe only thing that is actually \nrequired\n for a theme to work are a configuration entry and a CSS file in the right place.\nPut the pre-built \ndarkly css\n into the right place, which is \nincludes/themes/darkly.theme/css/theme.css\n.\nThe path prefix \nincludes/themes/\n may be changed using the RequireJS configuration path \nlaxar-path-themes\n.\nIn the LaxarJS configuration (usually \napplication/application.js\n), change the property \nlaxar.theme\n from \n\"default\"\n to \n\"darkly\"\n.\nThis causes the LaxarJS runtime to use the new theme.\n\n\nBecause the ShopDemo uses \nFont Awesome\n, we need to add an import to the top of our CSS file for that as well:\n\n\n@import\n \nurl\n(\n//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css\n)\n;\n\n\n\n\n\n\nBefore opening the application in the browser, make sure to restart the development server, so that the new files are picked up.\nAnd \nvoil\u00e0\n, we have a dark web shop:\n\n\n\n\nAbove:\n The all-new ShopDemo using the \ndarkly\n theme, hopefully not for any shady business\n\n\nOf course, there are still some rough spots that need additional work:\nFor example, the widget headers look much better using the original LaxarJS demo theme.\n\n\nLet's fix that using \nwidget-specific styles:\n\nThe widget styles use a \ncategory/name\n directory structure, similar to that of the actual widgets.\nHere are some suggestions for a nicer look, to be put under \nwidgets/shop-demo\n:\n\n\n\n\narticle-browser-widget\n: \narticle-browser-widget/css/article-browser-widget.css\n\n\n\n\nHere we color the icon, the headline to match the logo, and the currently selected article to match the details widget.\n\n\n/** Customize header and icon color: */\n\n\n.article-browser-widget\n \nh3\n \ni\n \n{\n\n  \ncolor\n:\n \n#F90\n;\n\n\n}\n\n\n\n.article-browser-widget\n \nth\n \n{\n\n  \nbackground-color\n:\n \n#F90\n;\n\n  \ncolor\n:\n \n#222222\n;\n\n\n}\n\n\n\n/** Highlight the selected article. */\n\n\n.article-browser-widget\n \ntr\n.selected\n \ntd\n \n{\n\n  \nfont-weight\n:\n \nbold\n;\n\n  \nbackground\n:\n \n#3498DB\n;\n\n\n}\n\n\n\n\n\n\n\n\narticle-teaser-widget\n: \narticle-teaser-widget/css/article-teaser-widget.css\n\n\n\n\nHere we color the icon and the headline to match the button.\n\n\n/** Customize header and icon color: */\n\n\n.article-teaser-widget\n \nh3\n \ni\n \n{\n\n   \ncolor\n:\n \n#3498DB\n;\n\n\n}\n\n\n\n.article-teaser-widget\n \nh4\n \n{\n\n   \nbackground-color\n:\n \n#3498DB\n;\n\n   \npadding\n:\n \n8px\n;\n\n\n}\n\n\n\n\n\n\n\n\nshopping-cart-widget\n: \nshopping-cart-widget/css/shopping-cart-widget.css\n\n\n\n\nAgain, we color the icon and the headline to match the button.\n\n\n/** Customize header and icon color: */\n\n\n.shopping-cart-widget\n \nh3\n \ni\n \n{\n\n   \ncolor\n:\n \n#00bc8c\n;\n\n\n}\n\n\n\n.shopping-cart-widget\n \nth\n \n{\n\n   \nbackground-color\n:\n \n#00bc8c\n;\n\n\n}\n\n\n\n/** plus/minus buttons */\n\n\n.shopping-cart-widget\n \n.app-increase-quantity\n \n{\n\n   \ntext-align\n:\n \nright\n \n!important\n;\n\n\n}\n\n\n\n.shopping-cart-widget\n \n.app-increase-buttons\n \n{\n\n   \npadding\n:\n \n0\n;\n\n   \npadding-top\n:\n \n6px\n;\n\n   \nwidth\n:\n \n40px\n;\n\n\n}\n\n\n\n.shopping-cart-widget\n \n.app-increase-buttons\n \nbutton\n \n{\n\n   \npadding\n:\n \n0\n;\n\n\n}\n\n\n\n\n\n\nNow we have four different CSS files.\nOf course, we do not want users to download an additional CSS file for each widget that we use.\nInstead, we use \ngrunt laxar-dist\n to create a merged version, which we may load through the \nindex.html\n.\n\n\n\n\nAbove:\n The all-new ShopDemo using the \ndarkly\n theme with widget styles. Not too shabby, eh?\n\n\nHave a look at the \ndark theme in action\n.\n\n\nOf course, there are still some areas of improvements to this way of styling widgets.\nFor example, if we would like to change the shade of blue that is used in our theme, we would have to update multiple source code locations.\nIt would be better to have some way to define these values in our theme and reuse them from individual widgets.  \n\n\n\n\nAdding a Theme using Compass/SCSS\n\n\nTo support centralized variables, you can use a \ncompiles-to-CSS\n language such as \nSCSS/SASS\n or \nless\n.\nAt the LaxarJS team we like \nCompass\n, which is built on top of SCSS.\nFortunately, an SCSS-version of the darkly theme is available, and can be installed using \nBower\n.\n\n\nOur SCSS theme uses a single central \ncompass/config.rb\n for the theme itself, and for individual widgets.\nThe \nconfig.rb\n has a similar role for SCSS as the \nrequire_config.js\n has for the project's javascript modules: it tells Compass where to find SCSS libraries.\nWhen compiling widget CSS, the path to the config should be passed on the command line:\n\n\ncompass compile -c /path/to/shop-demo/includes/themes/darkly_scss.theme/compass/config.rb\n\n\n\n\n\nWith the \nright config\n in place, the \nSCSS for our theme\n is little more than a couple of imports.\nExecute \ncompass\n from any parent folder containing the \nscss\n, \ncss\n and possibly also \nfonts\n and \nimages\n directories.\nNote that you can probably configure your editor or IDE to always pass the \n-c\n option correctly, otherwise you can create a shell alias.\nYou can also automatically generate the correct arguments by using \ngrunt-laxar-compass\n, which also supports live recompilation as SCSS files change.\n\n\nThe advantage of using an SCSS theme is that we can now write concise widget styles using central variables.\nAs an example, here is the SCSS file for the \narticle-browser-widget\n:\n\n\n@import\n \nvariables_all\n;\n\n\n\n.article-browser-widget\n \n{\n\n\n  \nh3\n \ni\n \n{\n\n    \ncolor\n:\n \n$app-color-logo\n;\n\n  \n}\n\n\n  \nth\n \n{\n\n    \nbackground-color\n:\n \n$app-color-logo\n;\n\n    \ncolor\n:\n \n$body-bg\n;\n\n  \n}\n\n\n  \ntr\n.selected\n \ntd\n \n{\n\n    \nfont-weight\n:\n \nbold\n;\n\n    \nbackground\n:\n \n$brand-info\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\nWhich CSS framework and tool chain to use (if any) is ultimately up to you.\nThe \nshop demo on github\n contains the \ndarkly\n theme both as a \nplain CSS version\n, and as an \nSCSS version\n.\n\n\nThe Bootstrap framework incurs some degree of boilerplate, but makes it relatively easy to reuse widgets across applications, and to find controls that work with your theme out of the box.\n\n\nHow the Runtime Finds CSS\n\n\nAs mentioned above, the LaxarJS runtime and grunt tasks do not care \nhow\n you create your CSS.\nHowever, these tools need to find it, so it is important \nwhere\n the CSS files are.\nFor details on how CSS and other assets are loaded, have a look at the \nasset lookup manual\n.\n\n\nIn general, the lookup order goes like this:\n\n\n1. if there are _theme-specified styles_ for an artifact (bundled with the application theme in use), then use those\n2. if there are _theme-specified styles_ for an artifact (bundled with the artifact itself), then use those\n3. else if there are _default styles_ for an artifact then use those\n4. else load _nothing_\n\n\n\n\n\nOf course, \nload nothing\n means that it is completely fine for a widget not to have its any CSS styles.\nIf it was missing an HTML template on the other hand, that would simply be an error.", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#creating-themes", 
            "text": "\u00ab return to the manuals  Sometimes you would like to use  one widget  in  two or more applications .\nFor this, usually you want the widget to  behave identically , but  look differently .\nAlternatively, sometimes you would like to offer the same application in different appearances.\nLaxarJS has the concept of  themes  to help you achieve these things.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Writing Pages", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#why-themes", 
            "text": "LaxarJS ships with a so-called  default theme , which is actually just  Bootstrap CSS  together with  Font Awesome  and a few additional classes.\nThere are several ways to add your own styles.", 
            "title": "Why Themes?"
        }, 
        {
            "location": "/manuals/creating_themes/#from-ad-hoc-styles-to-theme-folders", 
            "text": "Usually, you will need to add some CSS classes of your own.\nFor example, the vast majority of web application needs some styling for the page background and positioning or custom header- and footer-areas.\nTo include such  ad-hoc styles , you  could  simply add a CSS file of your own to the project, and load it from the  debug.html  and  index.html  files using the  link  tag.\nHowever, it is  recommended  to add these styles to your main application layout instead, into a sub-folder called  default.theme/css .  The  benefit  of using such a  theme folder  is that  * your CSS will be _bundled and compressed_ together with Bootstrap (no ` link ` tag needed) and that\n* you can support different _themes_ simply by adding more `.theme` folders.  Due to the first point, using the theme folders is useful and recommended  even  if you only use (and maybe customize) the default theme.", 
            "title": "From Ad-Hoc Styles to Theme Folders\u2026"
        }, 
        {
            "location": "/manuals/creating_themes/#and-to-custom-themes", 
            "text": "As soon as you use multiple page layouts, the previous approach does not really scale anymore: you would have to duplicate your global styles to all of them.\nIn these cases, creating your own theme is definitely recommended.\nA detailed explanation of  creating a theme  is given below.", 
            "title": "\u2026and to Custom Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#a-note-on-compassscss", 
            "text": "When using theme folders or entire themes, the runtime will only ever look at  .css  files in  css  sub-folders.\nThis means that it is entirely  up to you  which (if any) CSS authoring tools you would like to use.  That being said, we use Compass/SCSS to create themes, and the default-theme is based on the SCSS version of Bootstrap.\nUsing this approach makes it very easy to create a custom theme just by changing some Bootstrap SCSS variables.\nAlso, by using SCSS variables defined in the theme, widgets and controls can provide a consistent appearance.\nAfter explaining themes in general, further down we give instructions on  creating an SCSS theme .", 
            "title": "A Note on Compass/SCSS"
        }, 
        {
            "location": "/manuals/creating_themes/#creating-your-own-theme", 
            "text": "Let us create our own theme for an existing application, the  LaxarJS ShopDemo .\nThe ShopDemo brings it's own  \"cube.theme\" , which is implemented by augmenting Bootstrap with some changes and custom additions, such as the circle icons used with the headlines.   Above:  The LaxarJS ShopDemo using the  cube  theme  However, the demo also works with just the default theme, provided by LaxarJS UiKit, although admittedly it does not look quite as pretty:   Above:  The LaxarJS ShopDemo using the  default  theme", 
            "title": "Creating Your Own Theme"
        }, 
        {
            "location": "/manuals/creating_themes/#a-custom-theme-using-plain-css", 
            "text": "Since all applications seem to offer a \"dark\" look these days, let us try to achieve this for our shop demo app.\nFortunately, there are several collections of nice bootstrap themes available for free.\nOn the site  Bootswatch  for example, you will find the theme  darkly , which looks like it might work for us.  The only thing that is actually  required  for a theme to work are a configuration entry and a CSS file in the right place.\nPut the pre-built  darkly css  into the right place, which is  includes/themes/darkly.theme/css/theme.css .\nThe path prefix  includes/themes/  may be changed using the RequireJS configuration path  laxar-path-themes .\nIn the LaxarJS configuration (usually  application/application.js ), change the property  laxar.theme  from  \"default\"  to  \"darkly\" .\nThis causes the LaxarJS runtime to use the new theme.  Because the ShopDemo uses  Font Awesome , we need to add an import to the top of our CSS file for that as well:  @import   url ( //maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css ) ;   Before opening the application in the browser, make sure to restart the development server, so that the new files are picked up.\nAnd  voil\u00e0 , we have a dark web shop:   Above:  The all-new ShopDemo using the  darkly  theme, hopefully not for any shady business  Of course, there are still some rough spots that need additional work:\nFor example, the widget headers look much better using the original LaxarJS demo theme.  Let's fix that using  widget-specific styles: \nThe widget styles use a  category/name  directory structure, similar to that of the actual widgets.\nHere are some suggestions for a nicer look, to be put under  widgets/shop-demo :   article-browser-widget :  article-browser-widget/css/article-browser-widget.css   Here we color the icon, the headline to match the logo, and the currently selected article to match the details widget.  /** Customize header and icon color: */  .article-browser-widget   h3   i   { \n   color :   #F90 ;  }  .article-browser-widget   th   { \n   background-color :   #F90 ; \n   color :   #222222 ;  }  /** Highlight the selected article. */  .article-browser-widget   tr .selected   td   { \n   font-weight :   bold ; \n   background :   #3498DB ;  }    article-teaser-widget :  article-teaser-widget/css/article-teaser-widget.css   Here we color the icon and the headline to match the button.  /** Customize header and icon color: */  .article-teaser-widget   h3   i   { \n    color :   #3498DB ;  }  .article-teaser-widget   h4   { \n    background-color :   #3498DB ; \n    padding :   8px ;  }    shopping-cart-widget :  shopping-cart-widget/css/shopping-cart-widget.css   Again, we color the icon and the headline to match the button.  /** Customize header and icon color: */  .shopping-cart-widget   h3   i   { \n    color :   #00bc8c ;  }  .shopping-cart-widget   th   { \n    background-color :   #00bc8c ;  }  /** plus/minus buttons */  .shopping-cart-widget   .app-increase-quantity   { \n    text-align :   right   !important ;  }  .shopping-cart-widget   .app-increase-buttons   { \n    padding :   0 ; \n    padding-top :   6px ; \n    width :   40px ;  }  .shopping-cart-widget   .app-increase-buttons   button   { \n    padding :   0 ;  }   Now we have four different CSS files.\nOf course, we do not want users to download an additional CSS file for each widget that we use.\nInstead, we use  grunt laxar-dist  to create a merged version, which we may load through the  index.html .   Above:  The all-new ShopDemo using the  darkly  theme with widget styles. Not too shabby, eh?  Have a look at the  dark theme in action .  Of course, there are still some areas of improvements to this way of styling widgets.\nFor example, if we would like to change the shade of blue that is used in our theme, we would have to update multiple source code locations.\nIt would be better to have some way to define these values in our theme and reuse them from individual widgets.", 
            "title": "A Custom Theme Using Plain CSS"
        }, 
        {
            "location": "/manuals/creating_themes/#adding-a-theme-using-compassscss", 
            "text": "To support centralized variables, you can use a  compiles-to-CSS  language such as  SCSS/SASS  or  less .\nAt the LaxarJS team we like  Compass , which is built on top of SCSS.\nFortunately, an SCSS-version of the darkly theme is available, and can be installed using  Bower .  Our SCSS theme uses a single central  compass/config.rb  for the theme itself, and for individual widgets.\nThe  config.rb  has a similar role for SCSS as the  require_config.js  has for the project's javascript modules: it tells Compass where to find SCSS libraries.\nWhen compiling widget CSS, the path to the config should be passed on the command line:  compass compile -c /path/to/shop-demo/includes/themes/darkly_scss.theme/compass/config.rb  With the  right config  in place, the  SCSS for our theme  is little more than a couple of imports.\nExecute  compass  from any parent folder containing the  scss ,  css  and possibly also  fonts  and  images  directories.\nNote that you can probably configure your editor or IDE to always pass the  -c  option correctly, otherwise you can create a shell alias.\nYou can also automatically generate the correct arguments by using  grunt-laxar-compass , which also supports live recompilation as SCSS files change.  The advantage of using an SCSS theme is that we can now write concise widget styles using central variables.\nAs an example, here is the SCSS file for the  article-browser-widget :  @import   variables_all ;  .article-browser-widget   { \n\n   h3   i   { \n     color :   $app-color-logo ; \n   } \n\n   th   { \n     background-color :   $app-color-logo ; \n     color :   $body-bg ; \n   } \n\n   tr .selected   td   { \n     font-weight :   bold ; \n     background :   $brand-info ; \n   }  }   Which CSS framework and tool chain to use (if any) is ultimately up to you.\nThe  shop demo on github  contains the  darkly  theme both as a  plain CSS version , and as an  SCSS version .  The Bootstrap framework incurs some degree of boilerplate, but makes it relatively easy to reuse widgets across applications, and to find controls that work with your theme out of the box.", 
            "title": "Adding a Theme using Compass/SCSS"
        }, 
        {
            "location": "/manuals/creating_themes/#how-the-runtime-finds-css", 
            "text": "As mentioned above, the LaxarJS runtime and grunt tasks do not care  how  you create your CSS.\nHowever, these tools need to find it, so it is important  where  the CSS files are.\nFor details on how CSS and other assets are loaded, have a look at the  asset lookup manual .  In general, the lookup order goes like this:  1. if there are _theme-specified styles_ for an artifact (bundled with the application theme in use), then use those\n2. if there are _theme-specified styles_ for an artifact (bundled with the artifact itself), then use those\n3. else if there are _default styles_ for an artifact then use those\n4. else load _nothing_  Of course,  load nothing  means that it is completely fine for a widget not to have its any CSS styles.\nIf it was missing an HTML template on the other hand, that would simply be an error.", 
            "title": "How the Runtime Finds CSS"
        }, 
        {
            "location": "/manuals/adapters/", 
            "text": "Creating an Adapter for a new Widget Technology\n\n\n\u00ab return to the manuals\n\n\nLaxarJS widgets do not have to be written using AngularJS.\nWhile \nour own widgets\n are usually written in AngularJS, this should not prevent you from using an (MVC) framework of your choice, such as \nBackbone.js\n, \nKnockout\n or \nReact\n.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\nInfrastructure and Tools\n\n\n\n\nBecause widgets communicate through the event bus only, you could rewrite any widget within your application in any framework you like, and none of the other widgets would be any the wiser.\nThis is a great way to upgrade step-by-step from an older technology to newer tools, because only a single widget at a time is at risk, not your entire application.\n\n\nOf course, to achieve a great user experience, you do not want to include an excessive number of frameworks and libraries into your application:\nAs you add libraries, page load times will increase and with it user satisfaction will suffer.\nHowever, LaxarJS does not want you to be locked into using any specific implementation technology for your widgets.\nIf used appropriately, \ncustom widget adapters\n can make it easier by leaps and bounds to integrate with legacy code or third-party widgets, simply helping you to be more productive.\n\n\nEven if you are not interested in writing your own widget adapter, lecture of this manual is a good way to gain an in-depth understanding on the LaxarJS widget lifecycle.\n\n\nThe Role of Widget Adapters\n\n\nThe \nInfrastructure and Tools\n manual explains how the page controller sets up widgets and activities when entering a page.\nSince that is a somewhat simplified explanation, let us look into it in more detail:\n\n\n\n\n\n\nThe \npage controller\n uses the \npage loader\n to expand compositions and to obtain a single static model of all areas on a page, and for each area, a model of its configured widgets.\nAt this point, the composition parameter names have been substituted by their values and unique widget IDs have been generated, but default values for the widget features have not been applied yet.\n\n\n\n\n\n\nFor each configured widget instance, the page controller asks the \nwidget loader\n to provide it with a widget adapter for that instance, to control widget lifecycle.\nThe widget controller written in JavaScript has already been loaded as an AMD module when entering the application.\nThe loader fetches the \nwidget.json\n, and knows how to get the widget template and CSS style sheet, if applicable.\nOf course, all assets are loaded only once, even if a widget is instantiated several times during the lifetime of an application or even on the same page.\nAll widgets are loaded asynchronously and in parallel, so there is no unnecessary delay.\nIn production mode, all assets are served from the configured file listings, so that this process may happen very quickly.\n\n\n\n\n\n\nAs soon as the widget loader has loaded the \nwidget.json\n for a widget instance, it validates the feature configuration and fills in missing default values.\nNext, it sets up an event-bus wrapper for the widget, that always fills in the \nsender\n (on publish) and \nsubscriber\n (on subscribe) with the widget id.\nThis wrapper also ensures that the widget is unsubscribed from all events when the page is teared down later on.\n\n\n\n\n\n\nNow all that is left to do is kicking off the widget controller with the augmented feature configuration, and loading and instantiating the widget template.\nBoth of these steps are specific to the implementation technology of the widget.\nFor AngularJS, a new \nscope\n is created for the controller, and the controller class is instantiated using the AngularJS \n$controller\n service.\nAs soon as the widget becomes visible (usually right away, but possibly only after its containing popup/tab/panel/... is shown), the template is compiled, linked to the new scope, and inserted into the page DOM.\nThese tasks are performed by the \nwidget adapter\n, selected based on the integration technology that is declared in the \nwidget.json.\n\nLaxarJS ships with adapters for two integration technologies: \nangular\n and \nplain\n.\nThe \nplain\n adapter requires no additional dependencies, and is meant for widgets that directly access the browser DOM for their rendering.\n\n\n\n\n\n\nThe Integration Technology API\n\n\nEach widget integration technology is implemented as an AMD module with these properties:\n\n\n\n\n\n\nThe \ntechnology\n is a string that identifies the widget adapter.\n  It is compared to the \nintegration.technology\n field of each \nwidget.json\n to determine which adapter must be used for each widget in the application.\n\n\n\n\n\n\nThe method \nbootstrap\n is called once during application startup to initialize support for the integration technology.\n  It receives an array of AMD-modules, one for each matching widget module used by the application.\n  The API of the widget modules depends on the integration technology, but usually there is at least a \nname\n to associate the modules to their \nwidget.json,\n a method to instantiate a controller for a given widget instance, and possibly a method to set up a view.\n  For the \nangular\n integration, the widget module simply yields the corresponding AngularJS module, so that controllers can be instantiated by using the AngularJS \n$controller\n service.\n  For the \nplain\n integration, the widget module must have a method \ncreate\n to instantiate the controller, and optionally an array \ninjections\n to specify services required by the widget, such as the event bus.\n  These injections are used as arguments to \ncreate\n in the order that they are listed in \ninjections\n.\n\n\n\n\n\n\nThe method \ncreate\n is a factory that actually creates the widget adapter for a given widget instance.\n  Each widget instance has its own adapter instance, so that the adapter is free to maintain state information specific to the current widget instance, as may be required by the integration technology.\n  For each widget to be instantiated, \ncreate\n is called with an \nenvironment\n object containing the instance configuration and other context information for the widget controller, chiefly the instance's handle to the event bus.\n\n\n\n\n\n\nOptionally an adapter may provide a method called \napplyViewChanges\n.\n  Whenever the \nLaxarJS\n runtime carried out some task that may have tampered with the model of one or more widgets, like the asynchronous delivery of event bus events, this method gets called.\n  It should then do whatever necessary to achieve consistency again.\n  In case of \nAngularJS\n this is a call to \n$rootScope.$apply()\n, while the plain adapter simply does nothing.\n\n\n\n\n\n\nBefore going into details on the widget adapter API, let us have a look at the environment that is used to create widget adapters.\n\n\nThe Widget Loader Environment\n\n\nBefore creating an adapter, the widget loader collects all required information and bundles it into an \nenvironment\n object.\nThe environment has the following properties:\n\n\n\n\n\n\nThe \ncontext\n object contains information that may be of use to the widget controller:\n\n\n\n\n\n\neventBus\n: a handle to the event bus instance for this widget\n\n\n\n\n\n\nfeatures\n: the complete feature configuration for this instance, with defaults filled in from the widget configuration schema.\n\n\n\n\n\n\nid\n: a function that takes a string and returns a unique ID that may be given to a DOM-element of this widget instance.\nThis is mainly intended to associate form controls with their labels (using the HTML attributes \nid\n and \nfor\n), without breaking multiple widget instances on a single page.\n\n\n\n\n\n\nwidget\n: only rarely needed, this object provides additional meta information about the widget.\nThere is the containing \narea\n name, the instance \nid\n as a string and the \npath\n that was used to instantiate the widget.\n\n\n\n\n\n\n\n\n\n\nAdapters are supposed to make the context available to widget controllers, preferably through an injection \naxContext\n.\n  The \nangular\n adapter provides this injection as a lightweight alternative to the \n$scope\n injection, which has the same properties.\n\n\n\n\n\n\nThe \nanchorElement\n is a standard HTMLElement meant to contain all widget view UI.\n  If the adapter uses a templating system, the instantiated template should be appended to this anchor.\n  It automatically gets assigned an ID matching the widget ID, which is useful to identify a widget within the DOM, and a CSS class which should be used to restrict styles to the widget.\n  If necessary, Widgets may manipulate DOM outside of their anchor, for example to show an overlay.\n  But if they do, they are responsible for cleanup, and they should never modify the DOM of other widgets.\n\n\n\n\n\n\nThe \nspecification\n contains the widget meta information from the \nwidget.json.\n\n  This information is not intended to be passed through to the widget controller.\n  Instead, it may help the widget adapter to determine the widget name, and if the current widget is a regular widget or an activity.\n  Depending on the integration technology, different fields from the specification may be useful.\n\n\n\n\n\n\nHaving been created from an environment, all widget adapter instances expose the same set of methods which are called by their widget loader to control widget setup and teardown.\n\n\nThe Widget Adapter API\n\n\nAll widget adapters must implement the following four methods, to support creation and destruction of controller and view:\n\n\n\n\ncreateController\n: called to instantiate the widget controller.\n  The argument is a config map, currently only having an \nonBeforeControllerCreation\n function as single property.\n  This function acts as integration point for widget tests and should be called by the adapter just before the controller is instantiated.\n  It expects the \nenvironment\n as first and all readily prepared injections for the widget as second argument.\n\n\n\n\nWhen instantiating the widget controller, the adapter must provide it with the \ncontext\n from the widget loader environment.\n  Because the view has not been setup at this point in time, the adapter should not yet manipulate the anchor element, nor make it available to the widget controller.\n\n\n\n\n\n\ndomAttachTo\n: called with a widget area as the first argument, and an optional (template) HTML string as the second argument.\n  The adapter is supposed to instantiate the template based on its implementation technology, and to associate it to the widget controller.\n  Depending on the technology, this may happen through binding, for example through the shared \nscope\n created by the \nangular\n adapter.\n  Alternatively, the adapter may call some technology-specific API of the controller and hand over the template.\n  The instantiated template should be appended to the anchor element, which in turn should be appended to the widget area element.\n  If there is no template, as is usually the case with activities or sometimes with very simple widgets that only need CSS, the value \nnull\n is passed as the second parameter.\n  In this case, it is up to the widget adapter to decide if the anchor should be added to the DOM anyway, usually based on whether the type is \nwidget\n or \nactivity\n.\n\n\n\n\n\n\ndomDetach\n: the counterpart to \ndomAttachTo\n, this method is used to remove the view from the containing widget area, temporarily or permanently.\n  The widget adapter may teardown the template completely, or keep it \"warm\" for reattachment.\n  LaxarJS may ask widget adapters to detach their DOM and later to attach it again, for example to suspend the widget views within a popup window.\n\n\n\n\n\n\ndestroy\n: called only once when a widget instance is removed, usually because the user is navigating away from a page.\n  It is not guaranteed that \nany\n of the other methods has been called at this point in time, but \ndestroy\n is supposed to tidy up everything that has been done at this point in time.\n\n\n\n\n\n\nFor a simple example of a user-defined widget adapter, have a look at this \nBackbone.js adapter\n.\n\n\nUsing a Custom Adapter in a Project\n\n\nTo use a custom integration technology, the corresponding AMD-module must be passed to the LaxarJS \nbootstrap\n method.\nThis means that when working on a project that was created by the \nLaxarJS Yeoman generator\n, the \ninit.js\n must \nrequire\n the corresponding module, wrap it in an array and pass that array to \nax.bootstrap\n.\nOf course, the widgets written for this integration technology must state so in their \nwidget.json.", 
            "title": "Creating an Adapter for a new Widget Technology"
        }, 
        {
            "location": "/manuals/adapters/#creating-an-adapter-for-a-new-widget-technology", 
            "text": "\u00ab return to the manuals  LaxarJS widgets do not have to be written using AngularJS.\nWhile  our own widgets  are usually written in AngularJS, this should not prevent you from using an (MVC) framework of your choice, such as  Backbone.js ,  Knockout  or  React .  Preliminary readings:   Widgets and Activities  Infrastructure and Tools   Because widgets communicate through the event bus only, you could rewrite any widget within your application in any framework you like, and none of the other widgets would be any the wiser.\nThis is a great way to upgrade step-by-step from an older technology to newer tools, because only a single widget at a time is at risk, not your entire application.  Of course, to achieve a great user experience, you do not want to include an excessive number of frameworks and libraries into your application:\nAs you add libraries, page load times will increase and with it user satisfaction will suffer.\nHowever, LaxarJS does not want you to be locked into using any specific implementation technology for your widgets.\nIf used appropriately,  custom widget adapters  can make it easier by leaps and bounds to integrate with legacy code or third-party widgets, simply helping you to be more productive.  Even if you are not interested in writing your own widget adapter, lecture of this manual is a good way to gain an in-depth understanding on the LaxarJS widget lifecycle.", 
            "title": "Creating an Adapter for a new Widget Technology"
        }, 
        {
            "location": "/manuals/adapters/#the-role-of-widget-adapters", 
            "text": "The  Infrastructure and Tools  manual explains how the page controller sets up widgets and activities when entering a page.\nSince that is a somewhat simplified explanation, let us look into it in more detail:    The  page controller  uses the  page loader  to expand compositions and to obtain a single static model of all areas on a page, and for each area, a model of its configured widgets.\nAt this point, the composition parameter names have been substituted by their values and unique widget IDs have been generated, but default values for the widget features have not been applied yet.    For each configured widget instance, the page controller asks the  widget loader  to provide it with a widget adapter for that instance, to control widget lifecycle.\nThe widget controller written in JavaScript has already been loaded as an AMD module when entering the application.\nThe loader fetches the  widget.json , and knows how to get the widget template and CSS style sheet, if applicable.\nOf course, all assets are loaded only once, even if a widget is instantiated several times during the lifetime of an application or even on the same page.\nAll widgets are loaded asynchronously and in parallel, so there is no unnecessary delay.\nIn production mode, all assets are served from the configured file listings, so that this process may happen very quickly.    As soon as the widget loader has loaded the  widget.json  for a widget instance, it validates the feature configuration and fills in missing default values.\nNext, it sets up an event-bus wrapper for the widget, that always fills in the  sender  (on publish) and  subscriber  (on subscribe) with the widget id.\nThis wrapper also ensures that the widget is unsubscribed from all events when the page is teared down later on.    Now all that is left to do is kicking off the widget controller with the augmented feature configuration, and loading and instantiating the widget template.\nBoth of these steps are specific to the implementation technology of the widget.\nFor AngularJS, a new  scope  is created for the controller, and the controller class is instantiated using the AngularJS  $controller  service.\nAs soon as the widget becomes visible (usually right away, but possibly only after its containing popup/tab/panel/... is shown), the template is compiled, linked to the new scope, and inserted into the page DOM.\nThese tasks are performed by the  widget adapter , selected based on the integration technology that is declared in the  widget.json. \nLaxarJS ships with adapters for two integration technologies:  angular  and  plain .\nThe  plain  adapter requires no additional dependencies, and is meant for widgets that directly access the browser DOM for their rendering.", 
            "title": "The Role of Widget Adapters"
        }, 
        {
            "location": "/manuals/adapters/#the-integration-technology-api", 
            "text": "Each widget integration technology is implemented as an AMD module with these properties:    The  technology  is a string that identifies the widget adapter.\n  It is compared to the  integration.technology  field of each  widget.json  to determine which adapter must be used for each widget in the application.    The method  bootstrap  is called once during application startup to initialize support for the integration technology.\n  It receives an array of AMD-modules, one for each matching widget module used by the application.\n  The API of the widget modules depends on the integration technology, but usually there is at least a  name  to associate the modules to their  widget.json,  a method to instantiate a controller for a given widget instance, and possibly a method to set up a view.\n  For the  angular  integration, the widget module simply yields the corresponding AngularJS module, so that controllers can be instantiated by using the AngularJS  $controller  service.\n  For the  plain  integration, the widget module must have a method  create  to instantiate the controller, and optionally an array  injections  to specify services required by the widget, such as the event bus.\n  These injections are used as arguments to  create  in the order that they are listed in  injections .    The method  create  is a factory that actually creates the widget adapter for a given widget instance.\n  Each widget instance has its own adapter instance, so that the adapter is free to maintain state information specific to the current widget instance, as may be required by the integration technology.\n  For each widget to be instantiated,  create  is called with an  environment  object containing the instance configuration and other context information for the widget controller, chiefly the instance's handle to the event bus.    Optionally an adapter may provide a method called  applyViewChanges .\n  Whenever the  LaxarJS  runtime carried out some task that may have tampered with the model of one or more widgets, like the asynchronous delivery of event bus events, this method gets called.\n  It should then do whatever necessary to achieve consistency again.\n  In case of  AngularJS  this is a call to  $rootScope.$apply() , while the plain adapter simply does nothing.    Before going into details on the widget adapter API, let us have a look at the environment that is used to create widget adapters.", 
            "title": "The Integration Technology API"
        }, 
        {
            "location": "/manuals/adapters/#the-widget-loader-environment", 
            "text": "Before creating an adapter, the widget loader collects all required information and bundles it into an  environment  object.\nThe environment has the following properties:    The  context  object contains information that may be of use to the widget controller:    eventBus : a handle to the event bus instance for this widget    features : the complete feature configuration for this instance, with defaults filled in from the widget configuration schema.    id : a function that takes a string and returns a unique ID that may be given to a DOM-element of this widget instance.\nThis is mainly intended to associate form controls with their labels (using the HTML attributes  id  and  for ), without breaking multiple widget instances on a single page.    widget : only rarely needed, this object provides additional meta information about the widget.\nThere is the containing  area  name, the instance  id  as a string and the  path  that was used to instantiate the widget.      Adapters are supposed to make the context available to widget controllers, preferably through an injection  axContext .\n  The  angular  adapter provides this injection as a lightweight alternative to the  $scope  injection, which has the same properties.    The  anchorElement  is a standard HTMLElement meant to contain all widget view UI.\n  If the adapter uses a templating system, the instantiated template should be appended to this anchor.\n  It automatically gets assigned an ID matching the widget ID, which is useful to identify a widget within the DOM, and a CSS class which should be used to restrict styles to the widget.\n  If necessary, Widgets may manipulate DOM outside of their anchor, for example to show an overlay.\n  But if they do, they are responsible for cleanup, and they should never modify the DOM of other widgets.    The  specification  contains the widget meta information from the  widget.json. \n  This information is not intended to be passed through to the widget controller.\n  Instead, it may help the widget adapter to determine the widget name, and if the current widget is a regular widget or an activity.\n  Depending on the integration technology, different fields from the specification may be useful.    Having been created from an environment, all widget adapter instances expose the same set of methods which are called by their widget loader to control widget setup and teardown.", 
            "title": "The Widget Loader Environment"
        }, 
        {
            "location": "/manuals/adapters/#the-widget-adapter-api", 
            "text": "All widget adapters must implement the following four methods, to support creation and destruction of controller and view:   createController : called to instantiate the widget controller.\n  The argument is a config map, currently only having an  onBeforeControllerCreation  function as single property.\n  This function acts as integration point for widget tests and should be called by the adapter just before the controller is instantiated.\n  It expects the  environment  as first and all readily prepared injections for the widget as second argument.   When instantiating the widget controller, the adapter must provide it with the  context  from the widget loader environment.\n  Because the view has not been setup at this point in time, the adapter should not yet manipulate the anchor element, nor make it available to the widget controller.    domAttachTo : called with a widget area as the first argument, and an optional (template) HTML string as the second argument.\n  The adapter is supposed to instantiate the template based on its implementation technology, and to associate it to the widget controller.\n  Depending on the technology, this may happen through binding, for example through the shared  scope  created by the  angular  adapter.\n  Alternatively, the adapter may call some technology-specific API of the controller and hand over the template.\n  The instantiated template should be appended to the anchor element, which in turn should be appended to the widget area element.\n  If there is no template, as is usually the case with activities or sometimes with very simple widgets that only need CSS, the value  null  is passed as the second parameter.\n  In this case, it is up to the widget adapter to decide if the anchor should be added to the DOM anyway, usually based on whether the type is  widget  or  activity .    domDetach : the counterpart to  domAttachTo , this method is used to remove the view from the containing widget area, temporarily or permanently.\n  The widget adapter may teardown the template completely, or keep it \"warm\" for reattachment.\n  LaxarJS may ask widget adapters to detach their DOM and later to attach it again, for example to suspend the widget views within a popup window.    destroy : called only once when a widget instance is removed, usually because the user is navigating away from a page.\n  It is not guaranteed that  any  of the other methods has been called at this point in time, but  destroy  is supposed to tidy up everything that has been done at this point in time.    For a simple example of a user-defined widget adapter, have a look at this  Backbone.js adapter .", 
            "title": "The Widget Adapter API"
        }, 
        {
            "location": "/manuals/adapters/#using-a-custom-adapter-in-a-project", 
            "text": "To use a custom integration technology, the corresponding AMD-module must be passed to the LaxarJS  bootstrap  method.\nThis means that when working on a project that was created by the  LaxarJS Yeoman generator , the  init.js  must  require  the corresponding module, wrap it in an array and pass that array to  ax.bootstrap .\nOf course, the widgets written for this integration technology must state so in their  widget.json.", 
            "title": "Using a Custom Adapter in a Project"
        }, 
        {
            "location": "/manuals/events/", 
            "text": "Events and Publish-Subscribe\n\n\n\u00ab return to the manuals\n\n\nThe key concept that distinguishes LaxarJS applications from other AngularJS applications is the \npublish-subscribe\n (or \npub/sub)\n architecture.\nIt helps to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nLaxarJS consistently uses the term \nevents\n rather than \nmessages\n, to point out two key aspects of its pub/sub-architecture:\n * events convey information about \nwhat happened\n (rather than \nwho is receiver\n)\n * delivery is always \nasynchronous\n (using an \nevent loop\n)\n\n\nFor these reasons, you may also think of this pattern as a variation on the \nhollywood principle\n (\"Don't call us, we'll call you\").\n\n\nFor efficient processing, LaxarJS ties into the AngularJS \n$digest\n-cycle.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.\n\n\nThe Event Bus\n\n\nAll events are published to and delivered by the \nevent bus\n:\nThe event bus manages \nname-based\n (or \ntopic-based)\n \nevent subscriptions\n for all interested widgets and activities (the \nsubscribers)\n:\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.\n\n\nEach event has a \nname\n containing a summary of what happened, and a \npayload\n carrying additional information.\n\n\nEvent Names\n\n\nEvent names summarize \nwhat happened\n, possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.\n\n\nAn event name is a string, formed by a sequence of one or more \ntopics\n that are separated by \n.\n (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more \nsub-topics\n separated by \n-\n (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by\n\n\n* _either_ an upper case letter followed by a sequence of upper case letters and numbers\n* _or_ a lower case letter followed by a sequence of mixed case letters and numbers\n\n\n\n\n\nThese rules also exist as a formal \ngrammar\n for thorough people.\n\n\nThese are examples for \nvalid\n event names:\n\n\n* `didReplace.myShoppingCart`\n* `takeActionRequest.searchArticles`\n* `didTakeAction.searchArticles.SUCCESS`\n* `willEndLifecycle`\n* `didValidate.popup-user2`\n\n\n\n\n\nInvalid\n event names include:\n\n\n* `DidReplace.myShoppingCart`: _invalid,_ first topic starts upper case but contains lower case letters\n* `.searchArticles.SUCCESS`: _invalid,_ empty topic is not allowed\n* `didUpdate.1up`: _invalid_, topic must not start with a number\n\n\n\n\n\nNaming Best Practices and Event Patterns\n\n\nGood event names start with a very general \nverb-based first topic\n, broadly describing \nwhat\n happened.\nThat topic is often followed by a more specific \nobject-based second topic\n, describing \nwhere\n (or \nto what\n) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event \ndidValidate.popup-user2\n informs all interested subscribers, that the second user has been validated by a widget \nwithin a popup\n.\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a \nmodal third topic\n, broadly describing \nhow\n something happened (e.g. to communicate an outcome such as \nSUCCESS\n or \nERROR\n).\n\n\nOf course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.\n\n\nIt is recommended wherever possible for widgets to use one or more of the established \nevent patterns\n:\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few \ncore patterns\n are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project \nLaxarJS Patterns\n.\nEven without using the LaxarJS Patterns \nlibrary\n, widget authors are very much encouraged to use the \nevent vocabularies\n whenever meaningful.\n\n\nEvent Payload\n\n\nAn event does not only have a name, but also a \npayload\n.\nAny JavaScript object that can be directly represented as \nJSON\n can be used as a payload.\nThis allows for the object to contain instances of \nstring\n, \narray\n, \nnumber\n, \nboolean\n and \nobject\n, including \nnull\n.\nOn the other hand, it excludes\nundefined\n, \nDate\n, \nRegExp\n and custom classes.\n\n\nThe event bus will \ncreate a copy\n of the payload \nfor each subscriber\n that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.\n\n\nHowever, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache).\n\n\n\n\nTwo-Way Communication or the Request/Will/Did Mechanism\n\n\nSometimes a widget has to request for some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about \nwho\n actually performs the request, but it is interested in \nwhen\n the request has been fully processed by all respondents, and what is the outcome.\n\n\nAs an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a \nCAPTCHA\n.\nAnother widget offering a \nComplete Sign-Up\n button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective sign-up details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the aforementioned CAPTCHA-using widget.\n\n\nUsing the \nRequest/Will/Did\n mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:\n\n\n\n\n\n\nThe individual widgets are \nconfigured\n on the page to work with a common \nregistrationForm\n resource.\n   On instantiation, the input widgets offering validation subscribe to \nvalidateRequest\n events for this resource.\n\n\n\n\n\n\nWhen the user activates the \nComplete Sign-Up\n button, the registration widget issues a \nvalidateRequest.registrationForm\n event, indicating that\n\n\n\n\na validation has been requested \n(what happened)\n and\n\n\nit concerns the resource \nregistrationForm\n \n(where\n it happened).\n\n\n\n\n\n\n\n\nThe registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.\n\n\n\n\n\n\nDuring delivery, the input widgets supporting validation receive the request and publish a \nwillValidate.registrationForm\n event to indicate that\n\n\n\n\na validation has been initiated \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n.\n\n\n\n\n\n\n\n\nEach widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either \ndidValidate.registrationForm.SUCCESS\n or \ndidValidate.registrationForm.ERROR\n conveying that\n\n\n\n\na validation has been performed \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n and\n\n\nthe way the validation turned out \n(how)\n.\n\n\n\n\n\n\n\n\nOnce all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the \nsign-up\n REST request may be performed.\n\n\n\n\n\n\nThis mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its \n\"didValidate\"\n events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.\n\n\nValidation and other patterns are described in the following section.\n\n\n\n\nPattern Reference\n\n\nA few event patterns are supported directly by LaxarJS, while others are described in the \nLaxarJS Patterns\n library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.\n\n\n\n\nCore Patterns\n\n\nThe core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.\n\n\nPage Lifecycle\n\n\nAfter all widget controllers have been instantiated, the runtime publishes a \nbeginLifecycleRequest\n event.\nWidgets that need to publish events on page load should do so \nafter\n receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.\n\n\nBefore \nnavigating\n away from a page, the runtime publishes the \nendLifecycleRequest\n event.\nWidgets that need to save state to a service should respond with a \nwillEndLifecycle\n event, perform their housekeeping and publish an \ndidEndLifecycle\n when done.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbeginLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that publishing of events is safe now\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nthe lifecycle ID (currently, this is always \n\"default\"\n)\n\n\n\n\n\n\nwillBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer page rendering (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page rendering may commence (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nendLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that the page is about to be destroyed\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nwillEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer tear down of the page (if necessary)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page tear down may commence (after deferring it)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\n\n\n\n\nNavigation\n\n\nWidgets and activities may initiate navigation using a \nnavigateRequest.{target}\n event, substituting an actual navigation target instead of the placeholder \n{target}\n.\nThe event is interpreted by the LaxarJS runtime as follows:\n\n\n* if _target_ is `\n_self\n`, the runtime will simply propagate its place-parameters by publishing a `didNavigate` event right away\n* if _target_ is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place\n* otherwise, if _target_ is a place within the flow definition, the runtime will initiate navigation to that place\n* otherwise, nothing will happen.\n\n\n\n\n\nWhen \ninitiating navigation\n, the LaxarJS runtime will:\n\n\n1. extract any place parameters from the event payload of the request event\n2. publish a `willNavigate.{target}` event with the corresponding target and parameters\n3. publish an `endLifecycle` event and wait for any respondents\n4. perform navigation by destroying the current page and loading the page associated with the new place\n3. publish a `beginLifecycle` event and wait for any respondents\n5. publish a `didNavigate.{target}` event, with the corresponding target and parameters as well as the resolved place\n\n\n\n\n\nHere is the summary of navigation events:\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnavigateRequest.{target}\n\n\n\n\npublished by widgets and activities to indicate that a navigation has been requested\n\n\n\n\n\n\n\n\ntarget\n\n\nthe navigation target (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\n\n\ndata\n\n\na map from place parameter names to parameter values\n\n\n\n\n\n\nwillNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has started\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\ndidNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has finished\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\n\n\nplace\n\n\nthe actual place that was navigated to, now the current place\n\n\n\n\n\n\n\n\nMore information on navigation is available in the \n\"Flow and Places\" manual\n.\n\n\nLocales and i18n\n\n\nEvents related to locales are described in the \n\"i18n\" manual\n.\n\n\nMore Patterns\n\n\nThe patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the \nLaxarJS Patterns documentation\n.\n\n\nEvent Reference\n\n\nThe single relevant API provided by LaxarJS is the event bus.\nThis section lists the exact details of using it, and on how event names may be constructed.\n\n\nThe Event Bus API\n\n\nThe event bus is available to widgets and activities through \n$scope.eventBus\n.\nIt has only a few essential methods that allow to implement all patterns mentioned above.\n\n\n\n\nsubscribe( eventPattern, callback [, options] )\n\n\n\n\nCreates a subscription on the event bus.\n\n\n  - The `eventPattern` is a prefix for events to subscribe to:\n Events that start with the given sequence of (sub-)topics will be handled by this subscription.\n For example, a subscription to the pattern `didSave` will be triggered for the event `didSave.myDocument` as well as for the event `didSave.preferences-main`.\n Most of the time, widgets are only interested in very specific events related to resources they work with or actions they handle, so they use patterns such as `didReplace.someResource` where `someResource` is given by the page configuration.\n\n  - The `callback` is the function which will be called to process any matching events.\n Event subscription callbacks receive two arguments:\n          + The `event` is this subscriber\ns copy of the payload, as published by the sender of the event.\n          + The `meta` object contains additional information about the event, in particular the `sender` (identified by a string) and the `name` (under which the event was published).\n\n  - The `options` are usually not required for widgets:\n Using `options.subscriberId`, the subscriber can identify itself to the event bus.\n However, the LaxarJS runtime decorates each widget\ns event bus such that this option is always set correctly.\n\n\n\n\n\nThe method \nsubscribe\n does not return a value.\n\n\n\n\npublish( eventName, payload [, options ] )\n\n\n\n\nPublishes an event to all interested subscribers.\n  Delivery is asynchronous: control is returned to the caller immediately, and delivery will be performed afterwards, together with an AngularJS digest cycle.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.\n\n\n- The `eventName` is used to identify matching subscribers.\nIt is matched against the `eventPattern` of any subscriptions.\n\n- The `payload` will be delivered as the `event` parameter to any matching subscriber callbacks.\nIt is copied right away, making it safe to modify afterwards.\n\n- The `options` are usually not required for widgets:\nBy setting `options.deliverToSender` to `false`, widgets can ignore their own events, which can sometimes be necessary to avoid loops.\n\n\n\n\n\nThe method \npublish\n returns a promise that is resolved after the event has been processed by all matching subscribers.\n\n\n\n\npublishAndGatherReplies( requestEventName, payload [, options ] )\n\n\n\n\nPublishes a \nrequest event\n, gathers all \nwill\n-responses during delivery and then waits for all outstanding \ndid\n-responses.\n  The parameters \npayload\n and \noptions\n are equivalent to the regular \npublish\n-method.\n  Returns a promise that is resolved when all \ndid\n-responses have been received.\n\n\nThis information should help to get started with the event bus and intentionally omits a lot of details.\nFor full information, refer to the \nEventBus module\n.\n\n\n\n\nEvent Name Grammar\n\n\nThis is the formal grammar for event names, in \nEBNF\n:\n\n\nevent-name\n \n::\n=\n \ntopic-id\n \n[\n \n.\n \ntopic-id\n \n]\n*\n\n\ntopic-id\n \n::=\n \nsub-topic-id\n \n[\n \n-\n \nsub-topic-id\n \n]\n*\n\n\nsub-topic-id\n \n::=\n \n[\na-z\n][\n+\na-zA-Z0-9\n]\n*\n \n|\n \n[\nA-Z\n][\n+\nA-Z0-9\n]\n*", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#events-and-publish-subscribe", 
            "text": "\u00ab return to the manuals  The key concept that distinguishes LaxarJS applications from other AngularJS applications is the  publish-subscribe  (or  pub/sub)  architecture.\nIt helps to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).  Preliminary readings:   LaxarJS Core Concepts   LaxarJS consistently uses the term  events  rather than  messages , to point out two key aspects of its pub/sub-architecture:\n * events convey information about  what happened  (rather than  who is receiver )\n * delivery is always  asynchronous  (using an  event loop )  For these reasons, you may also think of this pattern as a variation on the  hollywood principle  (\"Don't call us, we'll call you\").  For efficient processing, LaxarJS ties into the AngularJS  $digest -cycle.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#the-event-bus", 
            "text": "All events are published to and delivered by the  event bus :\nThe event bus manages  name-based  (or  topic-based)   event subscriptions  for all interested widgets and activities (the  subscribers) :\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.  Each event has a  name  containing a summary of what happened, and a  payload  carrying additional information.", 
            "title": "The Event Bus"
        }, 
        {
            "location": "/manuals/events/#event-names", 
            "text": "Event names summarize  what happened , possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.  An event name is a string, formed by a sequence of one or more  topics  that are separated by  .  (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more  sub-topics  separated by  -  (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by  * _either_ an upper case letter followed by a sequence of upper case letters and numbers\n* _or_ a lower case letter followed by a sequence of mixed case letters and numbers  These rules also exist as a formal  grammar  for thorough people.  These are examples for  valid  event names:  * `didReplace.myShoppingCart`\n* `takeActionRequest.searchArticles`\n* `didTakeAction.searchArticles.SUCCESS`\n* `willEndLifecycle`\n* `didValidate.popup-user2`  Invalid  event names include:  * `DidReplace.myShoppingCart`: _invalid,_ first topic starts upper case but contains lower case letters\n* `.searchArticles.SUCCESS`: _invalid,_ empty topic is not allowed\n* `didUpdate.1up`: _invalid_, topic must not start with a number", 
            "title": "Event Names"
        }, 
        {
            "location": "/manuals/events/#naming-best-practices-and-event-patterns", 
            "text": "Good event names start with a very general  verb-based first topic , broadly describing  what  happened.\nThat topic is often followed by a more specific  object-based second topic , describing  where  (or  to what ) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event  didValidate.popup-user2  informs all interested subscribers, that the second user has been validated by a widget  within a popup .\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a  modal third topic , broadly describing  how  something happened (e.g. to communicate an outcome such as  SUCCESS  or  ERROR ).  Of course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.  It is recommended wherever possible for widgets to use one or more of the established  event patterns :\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few  core patterns  are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project  LaxarJS Patterns .\nEven without using the LaxarJS Patterns  library , widget authors are very much encouraged to use the  event vocabularies  whenever meaningful.", 
            "title": "Naming Best Practices and Event Patterns"
        }, 
        {
            "location": "/manuals/events/#event-payload", 
            "text": "An event does not only have a name, but also a  payload .\nAny JavaScript object that can be directly represented as  JSON  can be used as a payload.\nThis allows for the object to contain instances of  string ,  array ,  number ,  boolean  and  object , including  null .\nOn the other hand, it excludes undefined ,  Date ,  RegExp  and custom classes.  The event bus will  create a copy  of the payload  for each subscriber  that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.  However, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache).", 
            "title": "Event Payload"
        }, 
        {
            "location": "/manuals/events/#two-way-communication-or-the-requestwilldid-mechanism", 
            "text": "Sometimes a widget has to request for some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about  who  actually performs the request, but it is interested in  when  the request has been fully processed by all respondents, and what is the outcome.  As an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a  CAPTCHA .\nAnother widget offering a  Complete Sign-Up  button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective sign-up details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the aforementioned CAPTCHA-using widget.  Using the  Request/Will/Did  mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:    The individual widgets are  configured  on the page to work with a common  registrationForm  resource.\n   On instantiation, the input widgets offering validation subscribe to  validateRequest  events for this resource.    When the user activates the  Complete Sign-Up  button, the registration widget issues a  validateRequest.registrationForm  event, indicating that   a validation has been requested  (what happened)  and  it concerns the resource  registrationForm   (where  it happened).     The registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.    During delivery, the input widgets supporting validation receive the request and publish a  willValidate.registrationForm  event to indicate that   a validation has been initiated  (what)  and  that it concerns the  registrationForm  resource  (where) .     Each widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either  didValidate.registrationForm.SUCCESS  or  didValidate.registrationForm.ERROR  conveying that   a validation has been performed  (what)  and  that it concerns the  registrationForm  resource  (where)  and  the way the validation turned out  (how) .     Once all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the  sign-up  REST request may be performed.    This mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its  \"didValidate\"  events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.  Validation and other patterns are described in the following section.", 
            "title": "Two-Way Communication or the Request/Will/Did Mechanism"
        }, 
        {
            "location": "/manuals/events/#pattern-reference", 
            "text": "A few event patterns are supported directly by LaxarJS, while others are described in the  LaxarJS Patterns  library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.", 
            "title": "Pattern Reference"
        }, 
        {
            "location": "/manuals/events/#core-patterns", 
            "text": "The core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.", 
            "title": "Core Patterns"
        }, 
        {
            "location": "/manuals/events/#page-lifecycle", 
            "text": "After all widget controllers have been instantiated, the runtime publishes a  beginLifecycleRequest  event.\nWidgets that need to publish events on page load should do so  after  receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.  Before  navigating  away from a page, the runtime publishes the  endLifecycleRequest  event.\nWidgets that need to save state to a service should respond with a  willEndLifecycle  event, perform their housekeeping and publish an  didEndLifecycle  when done.     Event name  Payload Attribute  Description      beginLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that publishing of events is safe now     lifecycleId  the lifecycle ID (currently, this is always  \"default\" )    willBeginLifecycle.{lifecycleId}   published by widgets and activities to defer page rendering (not recommended)     lifecycleId  see above    didBeginLifecycle.{lifecycleId}   published by widgets and activities when page rendering may commence (not recommended)     lifecycleId  see above    endLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that the page is about to be destroyed     lifecycleId  see above    willEndLifecycle.{lifecycleId}   published by widgets and activities to defer tear down of the page (if necessary)     lifecycleId  see above    didEndLifecycle.{lifecycleId}   published by widgets and activities when page tear down may commence (after deferring it)     lifecycleId  see above", 
            "title": "Page Lifecycle"
        }, 
        {
            "location": "/manuals/events/#navigation", 
            "text": "Widgets and activities may initiate navigation using a  navigateRequest.{target}  event, substituting an actual navigation target instead of the placeholder  {target} .\nThe event is interpreted by the LaxarJS runtime as follows:  * if _target_ is ` _self `, the runtime will simply propagate its place-parameters by publishing a `didNavigate` event right away\n* if _target_ is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place\n* otherwise, if _target_ is a place within the flow definition, the runtime will initiate navigation to that place\n* otherwise, nothing will happen.  When  initiating navigation , the LaxarJS runtime will:  1. extract any place parameters from the event payload of the request event\n2. publish a `willNavigate.{target}` event with the corresponding target and parameters\n3. publish an `endLifecycle` event and wait for any respondents\n4. perform navigation by destroying the current page and loading the page associated with the new place\n3. publish a `beginLifecycle` event and wait for any respondents\n5. publish a `didNavigate.{target}` event, with the corresponding target and parameters as well as the resolved place  Here is the summary of navigation events:     Event name  Payload Attribute  Description      navigateRequest.{target}   published by widgets and activities to indicate that a navigation has been requested     target  the navigation target (used in the payload  as well as  in the event name)     data  a map from place parameter names to parameter values    willNavigate.{target}   published by the runtime to indicate that navigation has started     target ,  data  see above    didNavigate.{target}   published by the runtime to indicate that navigation has finished     target ,  data  see above     place  the actual place that was navigated to, now the current place     More information on navigation is available in the  \"Flow and Places\" manual .", 
            "title": "Navigation"
        }, 
        {
            "location": "/manuals/events/#locales-and-i18n", 
            "text": "Events related to locales are described in the  \"i18n\" manual .", 
            "title": "Locales and i18n"
        }, 
        {
            "location": "/manuals/events/#more-patterns", 
            "text": "The patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the  LaxarJS Patterns documentation .", 
            "title": "More Patterns"
        }, 
        {
            "location": "/manuals/events/#event-reference", 
            "text": "The single relevant API provided by LaxarJS is the event bus.\nThis section lists the exact details of using it, and on how event names may be constructed.", 
            "title": "Event Reference"
        }, 
        {
            "location": "/manuals/events/#the-event-bus-api", 
            "text": "The event bus is available to widgets and activities through  $scope.eventBus .\nIt has only a few essential methods that allow to implement all patterns mentioned above.   subscribe( eventPattern, callback [, options] )   Creates a subscription on the event bus.    - The `eventPattern` is a prefix for events to subscribe to:\n Events that start with the given sequence of (sub-)topics will be handled by this subscription.\n For example, a subscription to the pattern `didSave` will be triggered for the event `didSave.myDocument` as well as for the event `didSave.preferences-main`.\n Most of the time, widgets are only interested in very specific events related to resources they work with or actions they handle, so they use patterns such as `didReplace.someResource` where `someResource` is given by the page configuration.\n\n  - The `callback` is the function which will be called to process any matching events.\n Event subscription callbacks receive two arguments:\n          + The `event` is this subscriber s copy of the payload, as published by the sender of the event.\n          + The `meta` object contains additional information about the event, in particular the `sender` (identified by a string) and the `name` (under which the event was published).\n\n  - The `options` are usually not required for widgets:\n Using `options.subscriberId`, the subscriber can identify itself to the event bus.\n However, the LaxarJS runtime decorates each widget s event bus such that this option is always set correctly.  The method  subscribe  does not return a value.   publish( eventName, payload [, options ] )   Publishes an event to all interested subscribers.\n  Delivery is asynchronous: control is returned to the caller immediately, and delivery will be performed afterwards, together with an AngularJS digest cycle.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.  - The `eventName` is used to identify matching subscribers.\nIt is matched against the `eventPattern` of any subscriptions.\n\n- The `payload` will be delivered as the `event` parameter to any matching subscriber callbacks.\nIt is copied right away, making it safe to modify afterwards.\n\n- The `options` are usually not required for widgets:\nBy setting `options.deliverToSender` to `false`, widgets can ignore their own events, which can sometimes be necessary to avoid loops.  The method  publish  returns a promise that is resolved after the event has been processed by all matching subscribers.   publishAndGatherReplies( requestEventName, payload [, options ] )   Publishes a  request event , gathers all  will -responses during delivery and then waits for all outstanding  did -responses.\n  The parameters  payload  and  options  are equivalent to the regular  publish -method.\n  Returns a promise that is resolved when all  did -responses have been received.  This information should help to get started with the event bus and intentionally omits a lot of details.\nFor full information, refer to the  EventBus module .", 
            "title": "The Event Bus API"
        }, 
        {
            "location": "/manuals/events/#event-name-grammar", 
            "text": "This is the formal grammar for event names, in  EBNF :  event-name   :: =   topic-id   [   .   topic-id   ] *  topic-id   ::=   sub-topic-id   [   -   sub-topic-id   ] *  sub-topic-id   ::=   [ a-z ][ + a-zA-Z0-9 ] *   |   [ A-Z ][ + A-Z0-9 ] *", 
            "title": "Event Name Grammar"
        }, 
        {
            "location": "/manuals/flow_and_places/", 
            "text": "Flow and Places\n\n\n\u00ab return to the manuals\n\n\nEvery application consisting of more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a \nflow\n defining a set of \nplaces\n in a declarative fashion.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nConfiguration\n\n\nWriting Pages\n\n\n\n\nEach place corresponds to a single page that should be rendered, or some other content displayed to the user.\nCurrently the definition of one single flow file is possible, which can by default be found within the application at the path \napplication/flow/flow.json\n.\nThis can be adjusted as \nlaxar-path-flow\n in the \nrequire configuration\n of your application.\n\n\nLet us start with an example for a simple \nflow.json\n file:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nentry\n:\n \n{\n\n         \nredirectTo\n:\n \npageOne\n\n      \n},\n\n\n      \npageOne/:userId\n:\n \n{\n\n         \npage\n:\n \nfirst_page\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nA flow definition is always a JSON object having the root property \nplaces\n, which in turn is a map.\nEach entry of that map consists of the place's URL template as key and a definition of what should happen when reaching that place as value.\nFor LaxarJS an URL template always starts with a constant prefix, possibly consisting of multiple segments separated by slashes, containing optional \nparameters\n.\nThe syntax is taken from AngularJS, where variable parts of a URL are always prefixed by a colon.\nWithin the flow, the constant prefix of a place is interpreted as its \nidentifier\n.\nThus the second place in the example has the identifier \npageOne\n and one parameter, called \nuserId\n.\n\n\nThe identifier \nentry\n of the first place is always interpreted as the default place to navigate to if either no place was provided or if the requested place was not found within the flow.\nMost commonly it will just redirect to another existing place, that for example handles user login or application startup.\nJust as in plain AngularJS, routing a redirect is configured using the \nredirectTo\n keyword and naming the place identifier to navigate to.\nIn this example we simply navigate without providing a value for the \nuserId\n parameter to the place \npageOne\n.\nAny place that simply redirects to another place cannot do any meaningful in addition to that.\nControl is directly passed on to the redirection target.\n\n\nIn contrast to that, the place \npageOne\n specifies a page that should be loaded by using the key \npage\n in its definition.\nBy default all pages are searched in the \napplication/pages/\n directory with the \n.json\n suffix automatically appended when omitted.\nJust like the path to the flow file, this can also be reconfigured in the \nrequire configuration\n of your application as \nlaxar-path-pages\n.\nSo whenever this place is visited, the according page with all of its configured widgets is loaded and displayed.\n\n\nPlaces\n\n\nAs said before the syntax for places is based on the URL template syntax from AngularJS and in fact AngularJS' routing is used internally.\nWithin the flow, those URL templates have some additional meaning as they are being used as an identifier for places.\nThus a few strict rules are added to the basic AngularJS URL template rules:\n\n\n\n\nA URL always consists of one or more segments separated by slashes \n/\n.\n\n\nEach segment can either be a constant alphanumeric character string or a parameter, which is an alphanumeric character string prefixed by colon.\n\n\nA URL always starts with a unique non empty list of constant segments, which can optionally be followed by a list of parameters.\nParameters and constant segments may not appear interleaved.\n\n\nWildcards are not supported\n\n\n\n\nExamples of valid places thus are the following:\n\n\n\n\nuserListing\n\n\nuser/:userId\n\n\ncars/vans/:manufacturer/:model\n\n\n\n\nIn contrast these places would all be considered invalid:\n\n\n\n\n:userId\n: A place \nmust\n start with a non-empty constant segment\n\n\nuser/:userId/car\n: As soon as there is a parameter, no more constant segments may appear\n\n\nuser/:names*\n or \nuser/:names?\n: Wildcards are \nnot\n supported\n\n\n\n\nThese rules may seem very restrictive but they enable LaxarJS to make some assumptions and optimizations based on the URL template.\nAdditionally a URL should not encode too much sensitive information directly, as this might lead to security issues and bulky URLs.\nInstead only some domain information should be passed on between pages, that enables the widgets of the next place to fulfill their specific tasks.\n\n\nTargets\n\n\nNavigation is triggered from within a widget by issuing a \nnavigateRequest\n event expressing the desired next location within the application and providing values for place parameters.\nHow that works in practice can be read in the separate manual covering \nevents\n.\nUsing these events it is possible to always navigate directly from place to place.\nNevertheless this would instantly lead to a tight coupling between the widget triggering navigation events and the definition of places within the flow.\nInstead a widget or a page (by means of the feature configuration for a widget) should only know about semantic navigation targets reachable from their current location (roughly comparable to \nrelations\n in \nREST\n).\n\n\nIn LaxarJS this is achieved by the concept of \ntargets\n:\nEach place can define a mapping from semantic target identifier valid only for this place to the identifier of another place within the flow.\n\n\nAn example (for brevity the \nentry\n place is omitted):\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nintroduction/:userId\n:\n \n{\n\n         \npage\n:\n \nintroduction\n,\n\n         \ntargets\n:\n \n{\n\n            \nnext\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \ninterests/:userId\n:\n \n{\n\n         \npage\n:\n \ninterests\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \nintroduction\n,\n\n            \nnext\n:\n \nprofession\n,\n\n            \nhelp\n:\n \nprofessionHelp\n\n         \n}\n\n      \n},\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \ninterests\n,\n\n            \nhelp\n:\n \nprofessionHelp\n\n         \n}\n\n      \n},\n\n\n      \ninterestsHelp/:userId\n:\n \n{\n\n         \npage\n:\n \ninterests_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \nprofessionHelp/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \nprofession\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis flow is typical for a wizard-like application, as it allows a forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called \nintroduction\n, which simply displays a page and just lets the user navigate to the \nnext\n target, which would be resolved to the place \ninterests\n.\nHere a page is displayed where the user can input his interests, e.g. his hobbies or music taste.\nAs we are in the middle of a wizard, there is a \nprevious\n target reachable now in addition to the \nnext\n and \nhelp\n targets.\nUnsurprisingly the \nprevious\n target references the place \nintroduction\n again.\nThe \nnext\n target instead leads us to another new place with identifier \nprofession\n.\nThe \nprofession\n place may only lead us back to the \ninterests\n place via the \nprevious\n target.\n\n\nMay be some pages have some tricky input components or there are some advices for which things to share.\nThis is where the \nhelp\n targets come into play.\nBoth, the \ninterests\n and the \nprofession\n page, have such a target.\nNevertheless the places behind these targets are different depending on the source page.\nThis makes understanding of navigation concepts simple and provides contextual semantics.\nReturning from the help pages works in a similar way via the \nback\n targets leading to the respective places.\n\n\nEntry Points\n\n\nThe previous sections covered the concepts of navigation within the scope of one LaxarJS application.\nAdditionally it is also often necessary to integrate a use case implemented as a LaxarJS application within the context of another external application.\nFor example the process of collecting data on interests and profession could be part of a larger application creating a personal profile of a person.\nThe host application might have been be implemented in a totally different technology, like \nRuby on Rails\n or \nJSP\n.\nThere should be some way for this application to give control to the LaxarJS application and pass in some parameters.\n\n\nThis is achieved by the concept of \nentry points\n.\nEntry points define possible ways for how to enter an application and which place to navigate to once this entry point is selected.\nLet us add entry points to our example:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n\n      \nentry\n:\n \n{\n\n         \nentryPoints\n:\n \n{\n\n            \nenterInterests\n:\n \ninterests\n,\n\n            \nenterProfession\n:\n \nprofession\n\n         \n}\n\n      \n},\n\n\n      \nintroduction/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \ninterests/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \n...\n\n      \n},\n\n\n      \n...\n\n   \n}\n\n\n}\n\n\n\n\n\n\nApart from the key \nentryPoints\n this is very similar to the definition of targets within the \nflow.json\n.\nThe difference mainly comes from their usage when passing control from the external application to this application:\nAn entry point is selected by configuring it in the global \nwindow.laxar\n \nconfiguration object\n as \nwindow.laxar.flow.entryPoint\n property.\nThis property is an object with key \ntarget\n denoting the name of the entry point to select and an optional map under the \nparameters\n with the values for the possible place parameters.\n\n\nSo let us assume a JSP renders the bootstrapping code for the LaxarJS application, selects the \nenterInterests\n entry point and passes the user ID to the JavaScript frontend:\n\n\n!DOCTYPE html\n\n\nhtml\n\n   \nhead\n!-- contents omitted --\n/head\n\n   \nbody\n\n      \ndiv\n \ndata-ng-view\n \nstyle=\ndisplay: none\n/div\n\n      \ndiv\n \ndata-ax-page\n/div\n\n\n      \nscript \nsrc=\napplication/application.js\n/script\n\n      \nscript \nsrc=\nrequire_config.js\n/script\n\n      \nscript\n\n         \nwindow\n.\nlaxar\n.\nflow\n \n=\n \n{\n\n            \nentryPoint\n:\n \n{\n\n               \ntarget\n:\n \nenterInterests\n,\n\n               \nparameters\n:\n \n{\n\n                  \nuserId\n:\n \n%= currentUserId %\n\n               \n}\n\n            \n}\n\n         \n};\n\n      \n/script\n\n      \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n   \n/body\n\n\n/html\n\n\n\n\n\n\nBy using this mechanism the external application, in this example a simple JSP, is in control of how our application is entered.\n\n\nExit Points\n\n\nExit points\n work the other way around:\nHere the external application may define a map of different exit points, which in fact are simple JavaScript functions, and the LaxarJS application selects which one to call when navigating to a specific target.\nConfiguration of possible exit points also takes place in the global \nwindow.laxar\n \nconfiguration object\n  as \nwindow.laxar.flow.exitPoints\n property.\n\n\nHere we added two possible exit points to our example:\n\n\n!DOCTYPE html\n\n\nhtml\n\n   \nhead\n!-- contents omitted --\n/head\n\n   \nbody\n\n      \ndiv\n \ndata-ng-view\n \nstyle=\ndisplay: none\n/div\n\n      \ndiv\n \ndata-ax-page\n/div\n\n\n      \nscript \nsrc=\napplication/application.js\n/script\n\n      \nscript \nsrc=\nrequire_config.js\n/script\n\n      \nscript\n\n         \nwindow\n.\nlaxar\n.\nflow\n \n=\n \n{\n\n            \nentryPoint\n:\n \n{\n\n               \ntarget\n:\n \nenterInterests\n,\n\n               \nparameters\n:\n \n{\n\n                  \nuserId\n:\n \n%= currentUserId %\n\n               \n}\n\n            \n},\n\n            \nexitPoints\n:\n \n{\n\n               \nsaveProfile\n:\n \nfunction\n(\n \nparameters\n \n)\n \n{\n\n                  \n// Do whatever is necessary here to pass control back to the JSP application ...\n\n               \n},\n\n               \ncancelProcess\n:\n \nfunction\n(\n \nparameters\n \n)\n \n{\n\n                  \n// Do whatever is necessary here to pass control back to the JSP application ...\n\n               \n}\n\n            \n}\n\n         \n};\n\n      \n/script\n\n      \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n   \n/body\n\n\n/html\n\n\n\n\n\n\nAll arguments passed to the target referencing an exit point during navigation will be forwarded as map to the according function in the \nexitPoints\n map.\n\n\nFor this example two targets using the new exit points are defined (irrelevant places omitted for brevity):\n\n\n{\n\n   \nplaces\n:\n \n{\n\n\n      \nprofession/:userId\n:\n \n{\n\n         \npage\n:\n \nprofession\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \ninterests\n,\n\n            \nhelp\n:\n \nprofessionHelp\n,\n\n            \ncancel\n:\n \ncancel\n,\n\n            \nsave\n:\n \nsave\n\n         \n}\n\n      \n},\n\n\n      \nsave/:userId/:profession\n:\n \n{\n\n         \nexitPoint\n:\n \nsaveProfile\n\n      \n},\n\n\n      \ncancel/:userId/:reasonForCancellation\n:\n \n{\n\n         \nexitPoint\n:\n \ncancelProcess\n\n      \n}\n\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIf the user decides to save his information by navigating to the target \nsave\n, the exit point \nsaveProfile\n with values for the parameters \nuserId\n and \nprofession\n will be called.\nOn the other hand, if the user cancels the process by navigating to the target \ncancel\n, the exit point \ncancelProcess\n with values for the parameters \nuserId\n and \nreasonForCancellation\n will get invoked.\n\n\nUsing the simple mechanisms introduced here, most integration scenarios into external applications should be possible.\nTo learn how to trigger navigation from within widgets and activities, you should go on reading the \nevents documentation\n and learn about the \nnavigateRequest\n and \ndidNavigate\n events.", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#flow-and-places", 
            "text": "\u00ab return to the manuals  Every application consisting of more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a  flow  defining a set of  places  in a declarative fashion.  Preliminary readings:   LaxarJS Core Concepts  Configuration  Writing Pages   Each place corresponds to a single page that should be rendered, or some other content displayed to the user.\nCurrently the definition of one single flow file is possible, which can by default be found within the application at the path  application/flow/flow.json .\nThis can be adjusted as  laxar-path-flow  in the  require configuration  of your application.  Let us start with an example for a simple  flow.json  file:  { \n    places :   { \n       entry :   { \n          redirectTo :   pageOne \n       }, \n\n       pageOne/:userId :   { \n          page :   first_page \n       } \n    }  }   A flow definition is always a JSON object having the root property  places , which in turn is a map.\nEach entry of that map consists of the place's URL template as key and a definition of what should happen when reaching that place as value.\nFor LaxarJS an URL template always starts with a constant prefix, possibly consisting of multiple segments separated by slashes, containing optional  parameters .\nThe syntax is taken from AngularJS, where variable parts of a URL are always prefixed by a colon.\nWithin the flow, the constant prefix of a place is interpreted as its  identifier .\nThus the second place in the example has the identifier  pageOne  and one parameter, called  userId .  The identifier  entry  of the first place is always interpreted as the default place to navigate to if either no place was provided or if the requested place was not found within the flow.\nMost commonly it will just redirect to another existing place, that for example handles user login or application startup.\nJust as in plain AngularJS, routing a redirect is configured using the  redirectTo  keyword and naming the place identifier to navigate to.\nIn this example we simply navigate without providing a value for the  userId  parameter to the place  pageOne .\nAny place that simply redirects to another place cannot do any meaningful in addition to that.\nControl is directly passed on to the redirection target.  In contrast to that, the place  pageOne  specifies a page that should be loaded by using the key  page  in its definition.\nBy default all pages are searched in the  application/pages/  directory with the  .json  suffix automatically appended when omitted.\nJust like the path to the flow file, this can also be reconfigured in the  require configuration  of your application as  laxar-path-pages .\nSo whenever this place is visited, the according page with all of its configured widgets is loaded and displayed.", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#places", 
            "text": "As said before the syntax for places is based on the URL template syntax from AngularJS and in fact AngularJS' routing is used internally.\nWithin the flow, those URL templates have some additional meaning as they are being used as an identifier for places.\nThus a few strict rules are added to the basic AngularJS URL template rules:   A URL always consists of one or more segments separated by slashes  / .  Each segment can either be a constant alphanumeric character string or a parameter, which is an alphanumeric character string prefixed by colon.  A URL always starts with a unique non empty list of constant segments, which can optionally be followed by a list of parameters.\nParameters and constant segments may not appear interleaved.  Wildcards are not supported   Examples of valid places thus are the following:   userListing  user/:userId  cars/vans/:manufacturer/:model   In contrast these places would all be considered invalid:   :userId : A place  must  start with a non-empty constant segment  user/:userId/car : As soon as there is a parameter, no more constant segments may appear  user/:names*  or  user/:names? : Wildcards are  not  supported   These rules may seem very restrictive but they enable LaxarJS to make some assumptions and optimizations based on the URL template.\nAdditionally a URL should not encode too much sensitive information directly, as this might lead to security issues and bulky URLs.\nInstead only some domain information should be passed on between pages, that enables the widgets of the next place to fulfill their specific tasks.", 
            "title": "Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#targets", 
            "text": "Navigation is triggered from within a widget by issuing a  navigateRequest  event expressing the desired next location within the application and providing values for place parameters.\nHow that works in practice can be read in the separate manual covering  events .\nUsing these events it is possible to always navigate directly from place to place.\nNevertheless this would instantly lead to a tight coupling between the widget triggering navigation events and the definition of places within the flow.\nInstead a widget or a page (by means of the feature configuration for a widget) should only know about semantic navigation targets reachable from their current location (roughly comparable to  relations  in  REST ).  In LaxarJS this is achieved by the concept of  targets :\nEach place can define a mapping from semantic target identifier valid only for this place to the identifier of another place within the flow.  An example (for brevity the  entry  place is omitted):  { \n    places :   { \n       introduction/:userId :   { \n          page :   introduction , \n          targets :   { \n             next :   interests \n          } \n       }, \n\n       interests/:userId :   { \n          page :   interests , \n          targets :   { \n             previous :   introduction , \n             next :   profession , \n             help :   professionHelp \n          } \n       }, \n\n       profession/:userId :   { \n          page :   profession , \n          targets :   { \n             previous :   interests , \n             help :   professionHelp \n          } \n       }, \n\n       interestsHelp/:userId :   { \n          page :   interests_help , \n          targets :   { \n             back :   interests \n          } \n       }, \n\n       professionHelp/:userId :   { \n          page :   profession_help , \n          targets :   { \n             back :   profession \n          } \n       } \n    }  }   This flow is typical for a wizard-like application, as it allows a forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called  introduction , which simply displays a page and just lets the user navigate to the  next  target, which would be resolved to the place  interests .\nHere a page is displayed where the user can input his interests, e.g. his hobbies or music taste.\nAs we are in the middle of a wizard, there is a  previous  target reachable now in addition to the  next  and  help  targets.\nUnsurprisingly the  previous  target references the place  introduction  again.\nThe  next  target instead leads us to another new place with identifier  profession .\nThe  profession  place may only lead us back to the  interests  place via the  previous  target.  May be some pages have some tricky input components or there are some advices for which things to share.\nThis is where the  help  targets come into play.\nBoth, the  interests  and the  profession  page, have such a target.\nNevertheless the places behind these targets are different depending on the source page.\nThis makes understanding of navigation concepts simple and provides contextual semantics.\nReturning from the help pages works in a similar way via the  back  targets leading to the respective places.", 
            "title": "Targets"
        }, 
        {
            "location": "/manuals/flow_and_places/#entry-points", 
            "text": "The previous sections covered the concepts of navigation within the scope of one LaxarJS application.\nAdditionally it is also often necessary to integrate a use case implemented as a LaxarJS application within the context of another external application.\nFor example the process of collecting data on interests and profession could be part of a larger application creating a personal profile of a person.\nThe host application might have been be implemented in a totally different technology, like  Ruby on Rails  or  JSP .\nThere should be some way for this application to give control to the LaxarJS application and pass in some parameters.  This is achieved by the concept of  entry points .\nEntry points define possible ways for how to enter an application and which place to navigate to once this entry point is selected.\nLet us add entry points to our example:  { \n    places :   { \n\n       entry :   { \n          entryPoints :   { \n             enterInterests :   interests , \n             enterProfession :   profession \n          } \n       }, \n\n       introduction/:userId :   { \n          ... \n       }, \n\n       interests/:userId :   { \n          ... \n       }, \n\n       profession/:userId :   { \n          ... \n       }, \n\n       ... \n    }  }   Apart from the key  entryPoints  this is very similar to the definition of targets within the  flow.json .\nThe difference mainly comes from their usage when passing control from the external application to this application:\nAn entry point is selected by configuring it in the global  window.laxar   configuration object  as  window.laxar.flow.entryPoint  property.\nThis property is an object with key  target  denoting the name of the entry point to select and an optional map under the  parameters  with the values for the possible place parameters.  So let us assume a JSP renders the bootstrapping code for the LaxarJS application, selects the  enterInterests  entry point and passes the user ID to the JavaScript frontend:  !DOCTYPE html  html \n    head !-- contents omitted -- /head \n    body \n       div   data-ng-view   style= display: none /div \n       div   data-ax-page /div \n\n       script  src= application/application.js /script \n       script  src= require_config.js /script \n       script \n          window . laxar . flow   =   { \n             entryPoint :   { \n                target :   enterInterests , \n                parameters :   { \n                   userId :   %= currentUserId % \n                } \n             } \n          }; \n       /script \n       script  data-main= ../init.js   src= bower_components/requirejs/require.js /script \n    /body  /html   By using this mechanism the external application, in this example a simple JSP, is in control of how our application is entered.", 
            "title": "Entry Points"
        }, 
        {
            "location": "/manuals/flow_and_places/#exit-points", 
            "text": "Exit points  work the other way around:\nHere the external application may define a map of different exit points, which in fact are simple JavaScript functions, and the LaxarJS application selects which one to call when navigating to a specific target.\nConfiguration of possible exit points also takes place in the global  window.laxar   configuration object   as  window.laxar.flow.exitPoints  property.  Here we added two possible exit points to our example:  !DOCTYPE html  html \n    head !-- contents omitted -- /head \n    body \n       div   data-ng-view   style= display: none /div \n       div   data-ax-page /div \n\n       script  src= application/application.js /script \n       script  src= require_config.js /script \n       script \n          window . laxar . flow   =   { \n             entryPoint :   { \n                target :   enterInterests , \n                parameters :   { \n                   userId :   %= currentUserId % \n                } \n             }, \n             exitPoints :   { \n                saveProfile :   function (   parameters   )   { \n                   // Do whatever is necessary here to pass control back to the JSP application ... \n                }, \n                cancelProcess :   function (   parameters   )   { \n                   // Do whatever is necessary here to pass control back to the JSP application ... \n                } \n             } \n          }; \n       /script \n       script  data-main= ../init.js   src= bower_components/requirejs/require.js /script \n    /body  /html   All arguments passed to the target referencing an exit point during navigation will be forwarded as map to the according function in the  exitPoints  map.  For this example two targets using the new exit points are defined (irrelevant places omitted for brevity):  { \n    places :   { \n\n       profession/:userId :   { \n          page :   profession , \n          targets :   { \n             previous :   interests , \n             help :   professionHelp , \n             cancel :   cancel , \n             save :   save \n          } \n       }, \n\n       save/:userId/:profession :   { \n          exitPoint :   saveProfile \n       }, \n\n       cancel/:userId/:reasonForCancellation :   { \n          exitPoint :   cancelProcess \n       } \n\n    }  }   If the user decides to save his information by navigating to the target  save , the exit point  saveProfile  with values for the parameters  userId  and  profession  will be called.\nOn the other hand, if the user cancels the process by navigating to the target  cancel , the exit point  cancelProcess  with values for the parameters  userId  and  reasonForCancellation  will get invoked.  Using the simple mechanisms introduced here, most integration scenarios into external applications should be possible.\nTo learn how to trigger navigation from within widgets and activities, you should go on reading the  events documentation  and learn about the  navigateRequest  and  didNavigate  events.", 
            "title": "Exit Points"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/", 
            "text": "Infrastructure and Tools\n\n\n\u00ab return to the manuals\n\n\nWhat does actually happen when you navigate to a LaxarJS page using the browser?\nHow does LaxarJS load your widgets, their assets and styles?\nAnd what is the difference between the \ndebug.html\n and \nindex.html\n in the application template?\nRead on to understand the inner workings of a LaxarJS application.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\n\n\nNote:\n with LaxarJS v1.1.0, the grunt-based infrastructure has been completely overhauled.\nFor the previous manual, make sure to browse the \nv1.0.0 documentation\n.\n\n\n\n\nApplication Lifecycle\n\n\nThe \nLaxarJS Yeoman generator\n contains a \ndebug.html\n contains all code needed to bootstrap you application during development.\nAdditionally, there is an \nindex.html\n that shows how to run the application using optimized scripts and assets.\n\n\nIn your own application, you do not have to actually use these files:\nInstead you may copy the relevant parts into a \nRuby on Rails\n or \nDjango\n template, or into a \nJSP\n and bootstrap LaxarJS from there.\n\n\nScaffolding\n\n\nLet us dissect the startup process of a LaxarJS application based on the \ndebug.html\n, only that we have removed everything that is not absolutely required:\n\n\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n!-- ... optional: meta elements, title, page blocker styles go here ... --\n/head\n\n\nbody\n\n  \ndiv\n \ndata-ax-page\n/div\n\n  \ndiv\n \ndata-ng-view\n/div\n\n\n  \nscript \ndata-ax-application-mode=\nDEBUG\n \nsrc=\napplication/application.js\n/script\n\n  \nscript \nsrc=\nrequire_config.js\n/script\n\n  \nscript \ndata-main=\n../init.js\n \nsrc=\nbower_components/requirejs/require.js\n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\n\nWhat do the individual elements mean?\n\n\n* The `axPage` directive determines where LaxarJS will place the layout for the current page.\n\n* The `ngView` directive integrates the [$ngRoute](https://docs.angularjs.org/api/ngRoute)-service, which the [LaxarJS flow](./flow_and_places.md) uses for URL routing.\n\n* The `application/application.js` contains the [LaxarJS configuration](./configuration.md) for your application.\nThe `data-ax-application-mode` attribute allows to differentiate configuration between _DEBUG_ and _PRODUCTION_ mode.\nIt allows you to use bundled CSS, HTML and JSON assets for production, while always using their fresh source version during development.\nThe attribute is not used by LaxarJS itself, but only by the `application.js` which is under your control, so using it is a convention rather than an API.\n\n* The `require_config.js` configures paths to libraries for [AMD-loading](http://requirejs.org/docs/whyamd.html).\nThese may be your own libraries or 3rd party libraries installed through [Bower](http://bower.io/).\n\n* Finally, [RequireJS](http://requirejs.org) is loaded to bootstrap your application:\nThe `data-main` tells RequireJS where to find the initialization code (`init.js`), which is the entry point to all AMD-modules for your application.\nAngularJS modules are automatically loaded for any [widgets/activities](./widgets_and_activities.md) and [controls](./providing_controls.md) that are reachable from your [flow](./flow_and_places.md):\nA LaxarJS grunt task prepares this list whenever you `npm install` your application or `npm start` the development server, so usually you will not to have manage AngularJS modules manually.\nFor production (`grunt optimize`, see below), all RequireJS dependencies are combined and minified by default.\n\n\n\n\n\nThe HTML files in the application template also contain an optional \naxPageFade\n and associated styles.\nThis creates an overlay that covers your application with a white layer during navigation and then fades out, to may make loading a bit nicer on the eyes.\nHowever, this may not be right for all applications, so feel free to remove the overlay, or replace it with a custom version.\n\n\nStartup\n\n\nSo, let us see what happens once all required JavaScript modules are available:\n\n\n1. The `init.js` collects all AngularJS module dependencies for your application and passes them to `laxar.bootstrap()`.\n\n2. `laxar.bootstrap()` just sets up a logging mechanism and invokes the AngularJS `ng.bootstrap` with the collected dependencies.\n This sets up your application modules and their dependencies as well as all internal LaxarJS services and `ngRoute`.\n During initialization, LaxarJS integrates with `ngRoute`, to take over navigation handling.\n\n3. `ngRoute` triggers the LaxarJS _flow controller_ which selects a page from the [flow definition](./flow_and_places.md), based on the current URL.\n\n4. The flow controller instantiates a _page controller_ for the current page.\n\n5. The page controller loads and inserts the page layout and instantiates the controllers for widgets and activities.\n Also, it loads the widget HTML templates and their CSS (during development).\n Widgets and activities controllers may already start to make HTTP requests if they need to while their view is being setup.\n\n6. When all controllers have been instantiated, the page controller publishes the `beginLifecycleRequest` event to signal that widgets may start publishing events themselves.\n Then, all widget templates are instantiated, inserted into the layout DOM and linked to their controllers\n scopes.\n\n7. Finally, the page controller signals to the flow controller that navigation is complete, upon which the flow controller publishes the `didNavigateEvent`.\n This allows widgets to handle their URL place parameters, and from now on they may publish navigate requests for further navigation.\n\n\n\n\n\nFrom this point on, the LaxarJS runtime interacts only through the event bus with widgets and activities.\nThe only exception to this rule is the \npage teardown\n caused by \nnavigation\n, either \nindirectly\n through a widget, or \ndirectly\n by changing the URL in the browser.\n\n\nTeardown\n\n\nBefore navigating away from a page, widgets receive \nwillNavigate\n events. If the page is actually being left (alternatively, there may just have been an update to the URL parameters of the current page) an \nendLifecycleRequest\n event is published, before the widget scopes are destroyed through the regular AngularJS mechanism.\nHowever, when the user simply closes the browser window, this is not always guaranteed.\nIf navigating to a new page, the startup process (described above) is repeated, starting at step 3.\n\n\nThe File Resource Provider\n\n\nInternally, LaxarJS uses a single service to provide HTML, CSS and JSON assets used to instantiate widgets and controls:\nThe \nfile resource provider\n is used to find out if a given template or style sheet is available for the current theme.\nIt uses \nresource listings\n (JSON files) to answer these queries without actually going to the web server.\n\n\nResource listings also contain bundled resource contents to avoid HTTP requests in production (not during development).\nIf your application causes a lot of HTTP requests for widget templates and CSS during production, it is likely due to a misconfiguration of the resource listings.\nThe listings are generated by one of the LaxarJS \ngrunt tasks\n, which are described next.\n\n\nLaxarJS Development Tools\n\n\nMost modern single page applications are no longer developed using just a text editor, and instead rely on additional development- and build-tools.\nThe npm module \ngrunt-laxar\n provides the tooling to run LaxarJS applications and to optimize their assets.\nIt consists of several \ngrunt\n tasks that help to manage the assets and dependencies used by your application, as well as a development server to simplify the development process.\nThe application template contains a grunt configuration file (\nGruntfile.js\n) that will work for most scenarios, but feel free to modify the configuration if you would like to add your own tools to the build pipeline.\n\n\nLaxarJS Grunt Tasks\n\n\nFollowing are the most important LaxarJS grunt tasks.\nTo actually run the tasks, you will usually run one of the short \nalias tasks\n defined to the end of the \nGruntfile.js\n (see below).\nNone of the tasks is strictly necessary to develop and run your application, but in concert they go a long way to avoid manual work or boilerplate code and to allow for an optimized user experience.\nIn other words: you will not want to do without them.\n\n\nFor the full story on the LaxarJS grunt tasks, consult the \ngrunt-laxar documentation\n.\nThe following list just gives a quick overview of the available tasks and what their job is.\nDuring day-to-day work, you will likely only use the alias tasks described in the next section, and will not have to deal with these tasks. However, this information may improve your understanding of LaxarJS:\n\n\n* `laxar-configure` dynamically configures settings for all other grunt-laxar tasks based on your application flows.\nOften, this is the only task needing manual configuration ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-configure.md)).\n\n* `laxar-artifacts` collects all artifacts for a given flow and prepares a JSON model from them. This model is used by the other build-tasks and can also be queried by the `laxar-info` task  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-artifacts.md)).\n\n* `laxar-resources` prepares the *resources listing* in JSON format for a given flow, based on the artifacts model described above (more). These listings are consulted by the LaxarJS runtime to determine if a widget has HTML/CSS assets for a given theme, and (in production mode) to obtain their contents  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-resources.md)).\n\n* `laxar-merge-require-config` combines `require_configuration.js` fragments from all artifacts of a given flow, helping you to automatically setup your AMD path configuration. Keep in mind, that widgets and controls have to provide these files for automatic configuration to work  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-merge-require-config.md)).\n\n* `laxar-dependencies` uses the artifacts model to prepare a list of AMD modules comprising the flow artifacts, and to collect them into a *dependencies* module. These modules are loaded by RequireJS during application bootstrap, or (for production) during creation of an optimized bundle ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-dependencies.md)).\n\n* `laxar-build` prepares *configuration*, *artifacts*, *resources* and *dependencies* for all configured flows, using the building-block tasks described above ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-build.md)).\n\n* `laxar-dist-css` uses the artifacts model to collect all CSS files that are used by a given flow artifacts, and kicks off [grunt-contrib-cssmin](https://www.npmjs.com/package/grunt-contrib-cssmin) to assemble the CSS files into an optimized bundle ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-dist-css.md)).\n\n* `laxar-dist-js` creates an optimized javascript bundle from the application dependencies, using [r.js](https://www.npmjs.com/package/grunt-contrib-requirejs)  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-dist-js.md)).\n\n* `laxar-dist` prepares optimizes *CSS* and *JavaScript* bundles, using the building-block tasks described above ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-dist.md)).\n\n* `laxar-configure-watch` prepares configuration for the [watch](https://www.npmjs.com/package/grunt-contrib-watch) task based on the artifacts model ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-configure-watch.md)).\n\n* `laxar-develop` launches a development server, using the building-block tasks described above to prepare all build artifacts and to configure watch for live-reload functionality ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-develop.md)).\n\n* `laxar-test` runs all widgets\n spec tests in a headless web browser, using [Karma](http://karma-runner.github.io) and [PhantomJS](http://phantomjs.org/).\nThis is a useful starting point to setup continuous integration for your project  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-test.md)).\n\n\n\n\n\nTask Aliases\n\n\nThe aliases make sure that task dependencies are observed, plus they are easier to remember and type than the full tasks.\nTo use them, define them in your \nGruntfile.js\n or create your application from the current Yeoman generator (recommended).\n\n\n* `build` creates file listings and application dependencies, automatically runs when you start the development server\n\n* `optimize` makes sure that CSS and JavaScript are available for release\n\n* `start` starts the development server (see below), and watches for file changes (see below)\n\n* `test` runs your widget tests.\n\n\n\n\n\nThe LaxarJS Development Server\n\n\nThe development server based on \nConnect middleware\n helps to run your application without having to setup a full-blown web server.\nIt polls for changes to your widgets and automatically refreshes the browser by injecting a \nlive reload\n script.\nBy default, the development server runs on port 8000, but this can be configured in the Gruntfile.\nAdditional directories to be watched for live reload can also be reconfigured.\nThis may be necessary if you are developing a library within in your project, and that library does not belong to a specific widget.\n\n\nOther Toolchains\n\n\nAs you have seen, the LaxarJS tools provide a lot of useful functionality.\nHowever the \nruntime\n does not require that grunt-laxar is installed, it just depends on the right files in the \nvar\n directory.\nIn fact, when deploying your application to a web server, you may omit the node modules entirely.\n\n\nThis means that nothing stops you from using a different tool chain, say one that is based on \ngulp.js\n, as long as it produces the right assets.\nHopefully though, the tools provided with LaxarJS serve as a useful stepping stone towards your perfect build process.", 
            "title": "Infrastructure and Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#infrastructure-and-tools", 
            "text": "\u00ab return to the manuals  What does actually happen when you navigate to a LaxarJS page using the browser?\nHow does LaxarJS load your widgets, their assets and styles?\nAnd what is the difference between the  debug.html  and  index.html  in the application template?\nRead on to understand the inner workings of a LaxarJS application.  Preliminary readings:   LaxarJS Core Concepts    Note:  with LaxarJS v1.1.0, the grunt-based infrastructure has been completely overhauled.\nFor the previous manual, make sure to browse the  v1.0.0 documentation .", 
            "title": "Infrastructure and Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#application-lifecycle", 
            "text": "The  LaxarJS Yeoman generator  contains a  debug.html  contains all code needed to bootstrap you application during development.\nAdditionally, there is an  index.html  that shows how to run the application using optimized scripts and assets.  In your own application, you do not have to actually use these files:\nInstead you may copy the relevant parts into a  Ruby on Rails  or  Django  template, or into a  JSP  and bootstrap LaxarJS from there.", 
            "title": "Application Lifecycle"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#scaffolding", 
            "text": "Let us dissect the startup process of a LaxarJS application based on the  debug.html , only that we have removed everything that is not absolutely required:  !DOCTYPE html  html  head !-- ... optional: meta elements, title, page blocker styles go here ... -- /head  body \n   div   data-ax-page /div \n   div   data-ng-view /div \n\n   script  data-ax-application-mode= DEBUG   src= application/application.js /script \n   script  src= require_config.js /script \n   script  data-main= ../init.js   src= bower_components/requirejs/require.js /script  /body  /html   What do the individual elements mean?  * The `axPage` directive determines where LaxarJS will place the layout for the current page.\n\n* The `ngView` directive integrates the [$ngRoute](https://docs.angularjs.org/api/ngRoute)-service, which the [LaxarJS flow](./flow_and_places.md) uses for URL routing.\n\n* The `application/application.js` contains the [LaxarJS configuration](./configuration.md) for your application.\nThe `data-ax-application-mode` attribute allows to differentiate configuration between _DEBUG_ and _PRODUCTION_ mode.\nIt allows you to use bundled CSS, HTML and JSON assets for production, while always using their fresh source version during development.\nThe attribute is not used by LaxarJS itself, but only by the `application.js` which is under your control, so using it is a convention rather than an API.\n\n* The `require_config.js` configures paths to libraries for [AMD-loading](http://requirejs.org/docs/whyamd.html).\nThese may be your own libraries or 3rd party libraries installed through [Bower](http://bower.io/).\n\n* Finally, [RequireJS](http://requirejs.org) is loaded to bootstrap your application:\nThe `data-main` tells RequireJS where to find the initialization code (`init.js`), which is the entry point to all AMD-modules for your application.\nAngularJS modules are automatically loaded for any [widgets/activities](./widgets_and_activities.md) and [controls](./providing_controls.md) that are reachable from your [flow](./flow_and_places.md):\nA LaxarJS grunt task prepares this list whenever you `npm install` your application or `npm start` the development server, so usually you will not to have manage AngularJS modules manually.\nFor production (`grunt optimize`, see below), all RequireJS dependencies are combined and minified by default.  The HTML files in the application template also contain an optional  axPageFade  and associated styles.\nThis creates an overlay that covers your application with a white layer during navigation and then fades out, to may make loading a bit nicer on the eyes.\nHowever, this may not be right for all applications, so feel free to remove the overlay, or replace it with a custom version.", 
            "title": "Scaffolding"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#startup", 
            "text": "So, let us see what happens once all required JavaScript modules are available:  1. The `init.js` collects all AngularJS module dependencies for your application and passes them to `laxar.bootstrap()`.\n\n2. `laxar.bootstrap()` just sets up a logging mechanism and invokes the AngularJS `ng.bootstrap` with the collected dependencies.\n This sets up your application modules and their dependencies as well as all internal LaxarJS services and `ngRoute`.\n During initialization, LaxarJS integrates with `ngRoute`, to take over navigation handling.\n\n3. `ngRoute` triggers the LaxarJS _flow controller_ which selects a page from the [flow definition](./flow_and_places.md), based on the current URL.\n\n4. The flow controller instantiates a _page controller_ for the current page.\n\n5. The page controller loads and inserts the page layout and instantiates the controllers for widgets and activities.\n Also, it loads the widget HTML templates and their CSS (during development).\n Widgets and activities controllers may already start to make HTTP requests if they need to while their view is being setup.\n\n6. When all controllers have been instantiated, the page controller publishes the `beginLifecycleRequest` event to signal that widgets may start publishing events themselves.\n Then, all widget templates are instantiated, inserted into the layout DOM and linked to their controllers  scopes.\n\n7. Finally, the page controller signals to the flow controller that navigation is complete, upon which the flow controller publishes the `didNavigateEvent`.\n This allows widgets to handle their URL place parameters, and from now on they may publish navigate requests for further navigation.  From this point on, the LaxarJS runtime interacts only through the event bus with widgets and activities.\nThe only exception to this rule is the  page teardown  caused by  navigation , either  indirectly  through a widget, or  directly  by changing the URL in the browser.", 
            "title": "Startup"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#teardown", 
            "text": "Before navigating away from a page, widgets receive  willNavigate  events. If the page is actually being left (alternatively, there may just have been an update to the URL parameters of the current page) an  endLifecycleRequest  event is published, before the widget scopes are destroyed through the regular AngularJS mechanism.\nHowever, when the user simply closes the browser window, this is not always guaranteed.\nIf navigating to a new page, the startup process (described above) is repeated, starting at step 3.", 
            "title": "Teardown"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#the-file-resource-provider", 
            "text": "Internally, LaxarJS uses a single service to provide HTML, CSS and JSON assets used to instantiate widgets and controls:\nThe  file resource provider  is used to find out if a given template or style sheet is available for the current theme.\nIt uses  resource listings  (JSON files) to answer these queries without actually going to the web server.  Resource listings also contain bundled resource contents to avoid HTTP requests in production (not during development).\nIf your application causes a lot of HTTP requests for widget templates and CSS during production, it is likely due to a misconfiguration of the resource listings.\nThe listings are generated by one of the LaxarJS  grunt tasks , which are described next.", 
            "title": "The File Resource Provider"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#laxarjs-development-tools", 
            "text": "Most modern single page applications are no longer developed using just a text editor, and instead rely on additional development- and build-tools.\nThe npm module  grunt-laxar  provides the tooling to run LaxarJS applications and to optimize their assets.\nIt consists of several  grunt  tasks that help to manage the assets and dependencies used by your application, as well as a development server to simplify the development process.\nThe application template contains a grunt configuration file ( Gruntfile.js ) that will work for most scenarios, but feel free to modify the configuration if you would like to add your own tools to the build pipeline.", 
            "title": "LaxarJS Development Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#laxarjs-grunt-tasks", 
            "text": "Following are the most important LaxarJS grunt tasks.\nTo actually run the tasks, you will usually run one of the short  alias tasks  defined to the end of the  Gruntfile.js  (see below).\nNone of the tasks is strictly necessary to develop and run your application, but in concert they go a long way to avoid manual work or boilerplate code and to allow for an optimized user experience.\nIn other words: you will not want to do without them.  For the full story on the LaxarJS grunt tasks, consult the  grunt-laxar documentation .\nThe following list just gives a quick overview of the available tasks and what their job is.\nDuring day-to-day work, you will likely only use the alias tasks described in the next section, and will not have to deal with these tasks. However, this information may improve your understanding of LaxarJS:  * `laxar-configure` dynamically configures settings for all other grunt-laxar tasks based on your application flows.\nOften, this is the only task needing manual configuration ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-configure.md)).\n\n* `laxar-artifacts` collects all artifacts for a given flow and prepares a JSON model from them. This model is used by the other build-tasks and can also be queried by the `laxar-info` task  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-artifacts.md)).\n\n* `laxar-resources` prepares the *resources listing* in JSON format for a given flow, based on the artifacts model described above (more). These listings are consulted by the LaxarJS runtime to determine if a widget has HTML/CSS assets for a given theme, and (in production mode) to obtain their contents  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-resources.md)).\n\n* `laxar-merge-require-config` combines `require_configuration.js` fragments from all artifacts of a given flow, helping you to automatically setup your AMD path configuration. Keep in mind, that widgets and controls have to provide these files for automatic configuration to work  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-merge-require-config.md)).\n\n* `laxar-dependencies` uses the artifacts model to prepare a list of AMD modules comprising the flow artifacts, and to collect them into a *dependencies* module. These modules are loaded by RequireJS during application bootstrap, or (for production) during creation of an optimized bundle ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-dependencies.md)).\n\n* `laxar-build` prepares *configuration*, *artifacts*, *resources* and *dependencies* for all configured flows, using the building-block tasks described above ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-build.md)).\n\n* `laxar-dist-css` uses the artifacts model to collect all CSS files that are used by a given flow artifacts, and kicks off [grunt-contrib-cssmin](https://www.npmjs.com/package/grunt-contrib-cssmin) to assemble the CSS files into an optimized bundle ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-dist-css.md)).\n\n* `laxar-dist-js` creates an optimized javascript bundle from the application dependencies, using [r.js](https://www.npmjs.com/package/grunt-contrib-requirejs)  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-dist-js.md)).\n\n* `laxar-dist` prepares optimizes *CSS* and *JavaScript* bundles, using the building-block tasks described above ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-dist.md)).\n\n* `laxar-configure-watch` prepares configuration for the [watch](https://www.npmjs.com/package/grunt-contrib-watch) task based on the artifacts model ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/internal/laxar-configure-watch.md)).\n\n* `laxar-develop` launches a development server, using the building-block tasks described above to prepare all build artifacts and to configure watch for live-reload functionality ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-develop.md)).\n\n* `laxar-test` runs all widgets  spec tests in a headless web browser, using [Karma](http://karma-runner.github.io) and [PhantomJS](http://phantomjs.org/).\nThis is a useful starting point to setup continuous integration for your project  ([more](https://github.com/LaxarJS/grunt-laxar/blob/master/docs/tasks/laxar-test.md)).", 
            "title": "LaxarJS Grunt Tasks"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#task-aliases", 
            "text": "The aliases make sure that task dependencies are observed, plus they are easier to remember and type than the full tasks.\nTo use them, define them in your  Gruntfile.js  or create your application from the current Yeoman generator (recommended).  * `build` creates file listings and application dependencies, automatically runs when you start the development server\n\n* `optimize` makes sure that CSS and JavaScript are available for release\n\n* `start` starts the development server (see below), and watches for file changes (see below)\n\n* `test` runs your widget tests.", 
            "title": "Task Aliases"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#the-laxarjs-development-server", 
            "text": "The development server based on  Connect middleware  helps to run your application without having to setup a full-blown web server.\nIt polls for changes to your widgets and automatically refreshes the browser by injecting a  live reload  script.\nBy default, the development server runs on port 8000, but this can be configured in the Gruntfile.\nAdditional directories to be watched for live reload can also be reconfigured.\nThis may be necessary if you are developing a library within in your project, and that library does not belong to a specific widget.", 
            "title": "The LaxarJS Development Server"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#other-toolchains", 
            "text": "As you have seen, the LaxarJS tools provide a lot of useful functionality.\nHowever the  runtime  does not require that grunt-laxar is installed, it just depends on the right files in the  var  directory.\nIn fact, when deploying your application to a web server, you may omit the node modules entirely.  This means that nothing stops you from using a different tool chain, say one that is based on  gulp.js , as long as it produces the right assets.\nHopefully though, the tools provided with LaxarJS serve as a useful stepping stone towards your perfect build process.", 
            "title": "Other Toolchains"
        }, 
        {
            "location": "/manuals/installing_controls/", 
            "text": "Installing Controls\n\n\n\u00ab return to the manuals\n\n\nYou can use third party controls or the LaxarJS controls which are available via Bower.\nAlternatively you can clone them using git.\nWe published our controls on \ngithub\n.\n\n\nUsage\n\n\nTo use a control in a widget, configure the path to the control in the RequireJS configuration of the application.\nThe expected path has to be relative to the RequireJS \nbaseUrl\n configured for the application.\n\n\nFor example, assuming that your \nbaseUrl\n is \n'bower_components'\n and the directory \nincludes\n has the same root as the \nbower_components\n, add the following to the \npaths\n section of your \nrequire_config.js\n to use the \n'myControl'\n:\n\n\nmy-control\n:\n \n../includes/controls/my-control\n\n\n\n\n\n\nNow reference the control from the \nwidget.json\n of the widget:\n\n\ncontrols\n:\n \n[\n \nmy-control\n \n]\n\n\n\n\n\n\nUse it as a custom attribute in the HTML template of the widget:\n\n\ndiv\n \nmy-control\n/div", 
            "title": "Installing Controls"
        }, 
        {
            "location": "/manuals/installing_controls/#installing-controls", 
            "text": "\u00ab return to the manuals  You can use third party controls or the LaxarJS controls which are available via Bower.\nAlternatively you can clone them using git.\nWe published our controls on  github .", 
            "title": "Installing Controls"
        }, 
        {
            "location": "/manuals/installing_controls/#usage", 
            "text": "To use a control in a widget, configure the path to the control in the RequireJS configuration of the application.\nThe expected path has to be relative to the RequireJS  baseUrl  configured for the application.  For example, assuming that your  baseUrl  is  'bower_components'  and the directory  includes  has the same root as the  bower_components , add the following to the  paths  section of your  require_config.js  to use the  'myControl' :  my-control :   ../includes/controls/my-control   Now reference the control from the  widget.json  of the widget:  controls :   [   my-control   ]   Use it as a custom attribute in the HTML template of the widget:  div   my-control /div", 
            "title": "Usage"
        }, 
        {
            "location": "/manuals/installing_widgets/", 
            "text": "Installing Third Party Widgets\n\n\n\u00ab return to the manuals\n\n\nOne of \nthe advantages\n of LaxarJS is the concept of isolated, reusable widgets.\nThis begs the question as to how an existing LaxarJS widget can be added to your application.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\n\n\nInstalling Widgets Using Bower\n\n\nStarting with LaxarJS v1.1.0, widgets and activities can be installed using Bower.\nBesides being a simple way to download a widget, Bower helps you to install and manage widget dependencies such as controls and libraries.\n\n\n1. Obtain Widget \n Dependencies\n\n\nAssuming that the widget has been registered as a Bower package named \nlaxar-headline-widget\n, you can install it into your project like this:\n\n\n$\n bower install --save laxar-headline-widget\n\n\n\n\n\nThis will also automatically install the latest version along with its Bower dependencies.\nTo reference this widget from a JSON page definition, set the \nwidget\n field to \n'amd:laxar-headline-widget'\n.\nThis will cause LaxarJS to use RequireJS in order to find the widget in the \nbower_components\n folder.\n\n\n2. Configure Paths for RequireJS\n\n\nCheck the widget documentation to find out if any RequireJS paths need to be configured.\nStarting with \ngrunt-laxar\n v1.1.0, automatic setup is performed for any widgets that have a \nrequire_config.js\n.\n\n\nInstalling Widgets Manually\n\n\nCurrently, widgets must be installed manually in three steps, of which usually only the first is required.\nThere are plans to automate the installation in the future using bower.\n\n\n1. Obtain the Widget\n\n\nNew widgets have to be installed into a sub-folder of \nincludes/widgets/\n just like any widgets that you create yourself.\nUsually, you will simply \nclone\n the required widgets from a git repository, or add them as \ngit submodules\n.\n\n\nIn this example, the LaxarJS headline widget in Version 1.0.0 is obtained through \ngit submodule\n:\n\n\n$ \ngit submodule add \n\\\n\n    https://github.com/laxarjs/ax-headline-widget.git \n\\\n\n    includes/widgets/laxarjs/ax-headline-widget\n\n$ \ncd \nincludes/widgets/laxarjs/ax-headline-widget\n\n$ \ngit checkout v1.0.0\n\n\n\n\n\nInstead of using git, you can also simply copy a widget from another project, unpack it from a zip archive, or obtain it in any other way.\nYou just have to make sure that the widget files are located under \nincludes/widgets/\nsome-path\n and then you can use the value of \nsome-path\n to reference the widget from your pages.\nFor widgets obtained from GitHub, this path is usually equivalent to the \nuser\n/\nrepository\n information.\nIn the example, the path is \nlaxarjs/ax-headline-widget\n.\n\n\n2. Obtain the Dependencies\n\n\nSome widgets have extra dependencies that should be listed in the \ndependencies\n section of the \nbower.json\n file.\nYou should compare your widget's bower dependencies to those of your application, adding missing dependencies.\nUsually, you can automate that process using \nbower\n itself:\n\n\nbower install --save ./includes/widgets/category/widget\n\n\n\n\n\nNote:\n This will also install the widget itself as a bower component, which is not actually needed but also should not hurt.\n\n\n3. Configure Paths for RequireJS\n\n\nThis is only relevant if your widget has its own bower-dependencies (step 2):\nThe \nInstallation\n section of your widget should tell you if any changes need to be made to your RequireJS configuration.\nUsually, you will need to ensure that all bower-dependencies have a corresponding require-path configuration.\n\n\nHaving followed these steps, you can now add the new widget to a page by specifying the \nartifact\n value from step 1 in your page configuration.", 
            "title": "Installing Third Party Widgets"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-third-party-widgets", 
            "text": "\u00ab return to the manuals  One of  the advantages  of LaxarJS is the concept of isolated, reusable widgets.\nThis begs the question as to how an existing LaxarJS widget can be added to your application.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Writing Pages", 
            "title": "Installing Third Party Widgets"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-widgets-using-bower", 
            "text": "Starting with LaxarJS v1.1.0, widgets and activities can be installed using Bower.\nBesides being a simple way to download a widget, Bower helps you to install and manage widget dependencies such as controls and libraries.", 
            "title": "Installing Widgets Using Bower"
        }, 
        {
            "location": "/manuals/installing_widgets/#1-obtain-widget-dependencies", 
            "text": "Assuming that the widget has been registered as a Bower package named  laxar-headline-widget , you can install it into your project like this:  $  bower install --save laxar-headline-widget  This will also automatically install the latest version along with its Bower dependencies.\nTo reference this widget from a JSON page definition, set the  widget  field to  'amd:laxar-headline-widget' .\nThis will cause LaxarJS to use RequireJS in order to find the widget in the  bower_components  folder.", 
            "title": "1. Obtain Widget &amp; Dependencies"
        }, 
        {
            "location": "/manuals/installing_widgets/#2-configure-paths-for-requirejs", 
            "text": "Check the widget documentation to find out if any RequireJS paths need to be configured.\nStarting with  grunt-laxar  v1.1.0, automatic setup is performed for any widgets that have a  require_config.js .", 
            "title": "2. Configure Paths for RequireJS"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-widgets-manually", 
            "text": "Currently, widgets must be installed manually in three steps, of which usually only the first is required.\nThere are plans to automate the installation in the future using bower.", 
            "title": "Installing Widgets Manually"
        }, 
        {
            "location": "/manuals/installing_widgets/#1-obtain-the-widget", 
            "text": "New widgets have to be installed into a sub-folder of  includes/widgets/  just like any widgets that you create yourself.\nUsually, you will simply  clone  the required widgets from a git repository, or add them as  git submodules .  In this example, the LaxarJS headline widget in Version 1.0.0 is obtained through  git submodule :  $  git submodule add  \\ \n    https://github.com/laxarjs/ax-headline-widget.git  \\ \n    includes/widgets/laxarjs/ax-headline-widget $  cd  includes/widgets/laxarjs/ax-headline-widget $  git checkout v1.0.0  Instead of using git, you can also simply copy a widget from another project, unpack it from a zip archive, or obtain it in any other way.\nYou just have to make sure that the widget files are located under  includes/widgets/ some-path  and then you can use the value of  some-path  to reference the widget from your pages.\nFor widgets obtained from GitHub, this path is usually equivalent to the  user / repository  information.\nIn the example, the path is  laxarjs/ax-headline-widget .", 
            "title": "1. Obtain the Widget"
        }, 
        {
            "location": "/manuals/installing_widgets/#2-obtain-the-dependencies", 
            "text": "Some widgets have extra dependencies that should be listed in the  dependencies  section of the  bower.json  file.\nYou should compare your widget's bower dependencies to those of your application, adding missing dependencies.\nUsually, you can automate that process using  bower  itself:  bower install --save ./includes/widgets/category/widget  Note:  This will also install the widget itself as a bower component, which is not actually needed but also should not hurt.", 
            "title": "2. Obtain the Dependencies"
        }, 
        {
            "location": "/manuals/installing_widgets/#3-configure-paths-for-requirejs", 
            "text": "This is only relevant if your widget has its own bower-dependencies (step 2):\nThe  Installation  section of your widget should tell you if any changes need to be made to your RequireJS configuration.\nUsually, you will need to ensure that all bower-dependencies have a corresponding require-path configuration.  Having followed these steps, you can now add the new widget to a page by specifying the  artifact  value from step 1 in your page configuration.", 
            "title": "3. Configure Paths for RequireJS"
        }, 
        {
            "location": "/manuals/i18n/", 
            "text": "Internationalizing a Widget\n\n\n\u00ab return to the manuals\n\n\nIn LaxarJS, internationalization \n(i18n)\n of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nLocales and Language Tags: I18n in LaxarJS\n\n\nLaxarJS distinguishes \nlocales\n and \nlanguage tags\n for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a \nRFC-5646\n language tag like \"en-US\", which can change over time.\nThe locale corresponds to the audience for which a language tag should be valid.\nIf you have only one audience (regular users), using only \ndefault\n should be fine.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the \nchangeLocaleRequest.{locale}\n event.\n\n\nExample: To change the language tag of the locale \nmyLocale\n to \nde-DE\n, the following event has to be published:\n\n\n$scope\n.\neventBus\n.\npublish\n(\n \nchangeLocaleRequest.myLocale.\n,\n\n    \n{\n\n        \nlocale\n:\n \nmyLocale\n,\n\n        \nlanguageTag\n:\n \nde-DE\n\n    \n}\n\n\n);\n\n\n\n\n\n\nIf a widget is interested in changes to \nmyLocale\n, it would subscribe to the corresponding \ndidChangeLocale\n-event, which is published by the LaxarJS flow-controller:\n\n\n$scope\n.\neventBus\n.\nsubscribe\n(\n \ndidChangeLocale.myLocale.\n,\n \nfunction\n(\n \nevent\n \n)\n \n{\n\n   \nax\n.\nlog\n.\ninfo\n(\n \nI have received tag [0] for locale [1]\n,\n \nevent\n.\nlanguageTag\n,\n \nevent\n.\nlocale\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nWidgets can use the language tags that they receive over the event bus to \nlocalize\n internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with \ni18n\n:\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen-US\n:\n \nUpload file\n,\n\n    \nde-DE\n:\n \nDatei hochladen\n\n\n}\n\n\n\n\n\n\nLaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.\n\n\nWriting an I18n-Capable Widget\n\n\nTo be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry \ncontrols\n in the \nwidget.json\n.\nIf missing, this entry must be created:\n\n\ncontrols\n:\n \n[\n\n    \nlaxar_uikit/controls/i18n\n\n\n]\n\n\n\n\n\n\nNext, we have to add a feature \ni18n\n.\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example \nen-GB\n) is then used to localize internationalized values.\n\n\ni18n\n:\n \n{\n\n   \ndescription\n:\n \nWhich locale to use for displaying this widget.\n,\n\n   \ntype\n:\n \nobject\n,\n\n   \nproperties\n:\n \n{\n\n      \nlocale\n:\n \n{\n\n         \ntype\n:\n \nstring\n,\n\n         \ndescription\n:\n \nThe topic under which to expect the locale for this widget.\n,\n\n         \ndefault\n:\n \ndefault\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIf not already done, we import the Laxar-Patterns library into the widget controller (\nmy_widget.js\n).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right \ndidChangeLocale\n-events for us, by using the feature configuration that we added in the previous step:\n\n\ndefine\n(\n \n[\n   \n   \nlaxar-patterns\n\n\n],\n \nfunction\n(\n \npatterns\n \n)\n \n{\n\n   \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n \n);\n\n   \n...\n\n\n}\n\n\n\n\n\n\nAny updates to the i18n-locale received over the event bus will now be saved under \n$scope.i18n\n, along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:\n\n\n$scope.i\n18\nn\n \n=\n \n{\n      \n   \nlocale:\n \ndefault\n,\n\n   \ntags:\n \n{\n\n      \ndefault\n:\n \nen-US\n,\n\n      \ncustomer\n:\n \nde-DE\n,\n\n      \nsupport\n:\n \nen-GB\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIn the HTML template we can now use the angular filter \naxLocalize\n to convert an i18nHtmlText to a string:\n\n\np\n \ndata-ng-bind-html=\nmodel.i18nHtmlText | axLocalize:i18n\n/p\n\n\n\n\n\n\nThe filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses \n$scope.i18n.locale\n (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen-US\n:\n \nUpload file \nem\nnow\n/em\n,\n\n    \nde-DE\n:\n \nDatei \nem\njetzt\n/em\n hochladen\n\n\n}\n\n\n\n\n\n\nLocalizing Values in the Controller\n\n\nIn some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.\n\n\np\n \ndata-ng-bind-html=\nmodel.htmlVeryLongDocument\n/p\n\n\n\n\n\n\nTo achieve this, we obtain a \nlocalize\n function when we subscribe the widget to the \ndidChangeLocale\n event.\nLike the \naxLocalize\n-directive, this function automatically uses the current language tag:\n\n\nvar\n \nlocalize\n \n=\n \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n,\n \n{\n\n    \nonChange\n:\n \nupdateLocalization\n\n\n}\n \n).\nlocalizer\n();\n\n\n\n\n\n\nNow, we can transform any object with language tag properties to a string using the \nlocalize\n function:\n\n\nfunction\n \nupdateLocalization\n()\n \n{\n\n   \nvar\n \ndocumentUrl\n \n=\n \nlocalize\n(\n \n$scope\n.\nfeatures\n.\ni18nDocumentUrl\n \n);\n\n   \n$http\n.\nget\n(\n \ndocumentUrl\n \n).\nthen\n(\n \nfunction\n(\n \nresponse\n \n)\n \n{\n\n      \n$scope\n.\nmodel\n.\nhtmlVeryLongDocument\n \n=\n \nresponse\n.\ndata\n;\n\n   \n}\n \n);\n\n\n}", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#internationalizing-a-widget", 
            "text": "\u00ab return to the manuals  In LaxarJS, internationalization  (i18n)  of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.  Preliminary readings:   Widgets and Activities", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#locales-and-language-tags-i18n-in-laxarjs", 
            "text": "LaxarJS distinguishes  locales  and  language tags  for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a  RFC-5646  language tag like \"en-US\", which can change over time.\nThe locale corresponds to the audience for which a language tag should be valid.\nIf you have only one audience (regular users), using only  default  should be fine.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the  changeLocaleRequest.{locale}  event.  Example: To change the language tag of the locale  myLocale  to  de-DE , the following event has to be published:  $scope . eventBus . publish (   changeLocaleRequest.myLocale. , \n     { \n         locale :   myLocale , \n         languageTag :   de-DE \n     }  );   If a widget is interested in changes to  myLocale , it would subscribe to the corresponding  didChangeLocale -event, which is published by the LaxarJS flow-controller:  $scope . eventBus . subscribe (   didChangeLocale.myLocale. ,   function (   event   )   { \n    ax . log . info (   I have received tag [0] for locale [1] ,   event . languageTag ,   event . locale   );  }   );   Widgets can use the language tags that they receive over the event bus to  localize  internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with  i18n :  i18nHtmlText :   { \n     en-US :   Upload file , \n     de-DE :   Datei hochladen  }   LaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.", 
            "title": "Locales and Language Tags: I18n in LaxarJS"
        }, 
        {
            "location": "/manuals/i18n/#writing-an-i18n-capable-widget", 
            "text": "To be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry  controls  in the  widget.json .\nIf missing, this entry must be created:  controls :   [ \n     laxar_uikit/controls/i18n  ]   Next, we have to add a feature  i18n .\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example  en-GB ) is then used to localize internationalized values.  i18n :   { \n    description :   Which locale to use for displaying this widget. , \n    type :   object , \n    properties :   { \n       locale :   { \n          type :   string , \n          description :   The topic under which to expect the locale for this widget. , \n          default :   default \n       } \n    }  }   If not already done, we import the Laxar-Patterns library into the widget controller ( my_widget.js ).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right  didChangeLocale -events for us, by using the feature configuration that we added in the previous step:  define (   [    \n    laxar-patterns  ],   function (   patterns   )   { \n    patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n   ); \n    ...  }   Any updates to the i18n-locale received over the event bus will now be saved under  $scope.i18n , along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:  $scope.i 18 n   =   {       \n    locale:   default , \n    tags:   { \n       default :   en-US , \n       customer :   de-DE , \n       support :   en-GB \n    }  }   In the HTML template we can now use the angular filter  axLocalize  to convert an i18nHtmlText to a string:  p   data-ng-bind-html= model.i18nHtmlText | axLocalize:i18n /p   The filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses  $scope.i18n.locale  (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.  i18nHtmlText :   { \n     en-US :   Upload file  em now /em , \n     de-DE :   Datei  em jetzt /em  hochladen  }", 
            "title": "Writing an I18n-Capable Widget"
        }, 
        {
            "location": "/manuals/i18n/#localizing-values-in-the-controller", 
            "text": "In some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.  p   data-ng-bind-html= model.htmlVeryLongDocument /p   To achieve this, we obtain a  localize  function when we subscribe the widget to the  didChangeLocale  event.\nLike the  axLocalize -directive, this function automatically uses the current language tag:  var   localize   =   patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n ,   { \n     onChange :   updateLocalization  }   ). localizer ();   Now, we can transform any object with language tag properties to a string using the  localize  function:  function   updateLocalization ()   { \n    var   documentUrl   =   localize (   $scope . features . i18nDocumentUrl   ); \n    $http . get (   documentUrl   ). then (   function (   response   )   { \n       $scope . model . htmlVeryLongDocument   =   response . data ; \n    }   );  }", 
            "title": "Localizing Values in the Controller"
        }, 
        {
            "location": "/manuals/configuration/", 
            "text": "LaxarJS Configuration in an Application\n\n\n\u00ab return to the manuals\n\n\nLaxarJS has a built-in configuration API which is available to libraries and widgets as \nlaxar.configuration\n.\nIn contrast to the bower- and RequireJS-configuration, this configuration is designed to be used at application run time.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nWhat is LaxarJS Configuration Used for?\n\n\nWhen writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration, placed in the page definitions.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.\n\n\nIn other cases, LaxarJS itself needs to be configured, for example to determine the theme, file listing URIs, available locales and so on.\nThe \nLaxarJS Core\n configuration options are listed below.\n\n\nConfiguration Structure\n\n\nConfiguration keys are simple JSON paths, reflecting a hierarchical configuration structure.\nThe configuration API looks for the configuration values within the \nlaxar\n property of the global object (\nwindow\n).\n\n\nLibraries, widgets and activities may define their own configuration keys, but must always use the \nlib.\n prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example, \nLaxarJS UiKit\n controls use the prefix \nlib.laxar-uikit.controls\n for their configuration options.\nKeys without the \nlib.\n-prefix are used by \nLaxarJS Core\n.\n\n\nThe Configuration API\n\n\nThe LaxarJS configuration exposes a single method \nlaxar.configuration.get( key, fallback )\n.\nThe \nkey\n-parameter is the path within the configuration object (\nwindow.laxar\n), and the (optional) \nfallback\n is returned as a default value if the key was not set in the configuration.\n\n\nFor example, a module \nmy_module\n may allow to enable some kind of compatibility behavior for a special \nfoo\n environment by exposing a boolean configuration \nfooCompatibility\n.\nBy default, the option should be disabled as compatibility with foo involves jumping through some hoops.\nThe module \nmy_module\n would then access the option like this:\n\n\ndefine\n(\n \n[\n \nlaxar\n \n],\n \nfunction\n(\n \nax\n \n)\n \n{\n\n  \nfunction\n \nsetup\n()\n \n{\n\n     \nvar\n \nrespectFoo\n \n=\n \nax\n.\nconfiguration\n.\nget\n(\n \nlib.my_module.fooCompatibility\n,\n \nfalse\n \n);\n\n     \nif\n(\n \nrespectFoo\n \n)\n \n{\n\n        \n// ... jump though some hoops ...\n\n        \nreturn\n \n{\n \nhoops\n:\n \nJUMPED\n \n};\n\n     \n}\n\n     \nreturn\n \n{};\n\n  \n}\n\n\n}\n \n);\n\n\n\n\n\n\nAnd the corresponding configuration block to enable foo-compatibility would then look like this:\n\n\nwindow\n.\nlaxar\n \n=\n \n{\n\n   \n// ...\n\n   \nlib\n:\n \n{\n\n      \nmy_module\n:\n \n{\n\n         \nfooCompatibility\n:\n \ntrue\n\n      \n},\n\n      \n// ...\n\n   \n}\n\n\n};\n\n\n\n\n\n\nTesting a Module that Uses Configuration\n\n\nTo test the behavior of a module with test-controlled configuration options, one can simply spy on the method \nconfiguration.get\n.\nHere is an exemplary jasmine test for a module \nmy_module\n, which tries to test the module behavior with foo-compatibility enabled.\n\n\ndefine\n(\n \n[\n \nlaxar\n,\n \nmy_module\n \n],\n \nfunction\n(\n \nax\n,\n \nmyModule\n \n)\n \n{\n\n   \ndescribe\n(\n \na my_module with foo compatibility enabled\n,\n \nfunction\n()\n \n{\n\n      \nbeforeEach\n(\n \nfunction\n()\n \n{\n\n         \nvar\n \norigGet\n \n=\n \nax\n.\nconfiguration\n.\nget\n;\n\n         \nvar\n \nhoops\n;\n\n         \nspyOn\n(\n \nax\n.\nconfiguration\n,\n \nget\n \n).\nandCallFake\n(\n \nfunction\n(\n \nkey\n,\n \nfallback\n \n)\n \n{\n\n            \nreturn\n \nkey\n \n===\n \nlib.my_module.fooCompatibility\n \n?\n \ntrue\n \n:\n \norigGet\n(\n \nkey\n,\n \nfallback\n \n);\n\n         \n}\n \n);\n\n         \nhoops\n \n=\n \nsetup\n();\n\n      \n}\n \n);\n\n      \nit\n(\n \njumps through some hoops\n,\n \nfunction\n()\n \n{\n\n           \nexpect\n(\n \nhoops\n \n).\ntoBe\n(\n \nJUMPED\n \n);\n\n      \n}\n \n);\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nInjecting Configuration into an AngularJS module\n\n\nInstead of using RequireJS, AngularJS modules such as widgets can have the configuration module injected by requesting the service \n'Configuration'\n.\nIn cases where configuration is injected, an \nangularMocks.module\n provider may be defined during testing instead of the approach described above.\n\n\nAvailable Configuration Keys in \nLaxarJS Core\n\n\nThe following configuration options are available in \nLaxarJS Core\n.\nFor options available in \nLaxarJS UiKit\n, have a look at the \nrespective documentation\n.\n\n\n\n\n\n\n\n\nKey\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\n''\n\n\nThe name of the LaxarJS application\n\n\n\n\n\n\ndescription\n\n\n''\n\n\nA short application description\n\n\n\n\n\n\ntheme\n\n\n'default'\n\n\nWhich theme to use for the application. The suffix \n.theme\n is added automatically.\n\n\n\n\n\n\n:-----------------------------------\n\n\n:--------------------\n\n\n:------------------------------------------------------------------\n\n\n\n\n\n\neventBusTimeoutMs\n\n\n120000\n\n\nThe maximum delay (in milliseconds) to wait for a \ndid...\n event to be published, after it was announced by a \nwill...\n event.\n\n\n\n\n\n\ni18n.locales\n\n\n{ 'default': 'en' }\n\n\nWhich language tag to use for the default locale, and possibly for other locales.\n\n\n\n\n\n\nlogging.http.header\n\n\nnull\n\n\nIf set, an \n$http\n interceptor is registered to add the log tags (such as PLCE for the current place and INST for the client instance ID) to outgoing \n$http\n requests, under the configured header field (e.g. \n-x-myapp-tags\n).\n\n\n\n\n\n\nlogging.levels\n\n\n{}\n\n\nAdditional log levels with name and severity, for example \n{ NOTICE: 350 }\n. The predefined severities reach from \n100\n for \nTRACE\n to \n600\n for \nFATAL\n.\n\n\n\n\n\n\nlogging.threshold\n\n\n'INFO'\n\n\nThe log level which is required for messages to be logged (one of \nTRACE\n, \nDEBUG\n, \nINFO\n, \nWARN\n, \nERROR\n or \nFATAL\n)\n\n\n\n\n\n\nfileListings\n\n\n{}\n\n\nA mapping from application directories to file listing names or directly to their content objects. The listings help to save unnecessary HTTP 404 requests (for example, to determine if a widget has custom styles for the current theme), and are generated by \ngrunt-laxar\n.\n\n\n\n\n\n\nflow.entryPoint\n\n\nnull\n\n\nIf the browser URL cannot be controlled by the LaxarJS application (for example, when integrating with a legacy system), the target and place-parameters can be set here in the form \n{ target: 'my_flow_target', parameters: { myParam: 'xyz' } }\n.\n\n\n\n\n\n\nflow.exitPoints\n\n\n{}\n\n\nAllows to delegate handling of a navigation target to a different (legacy) system by specifying callbacks for individual navigation targets. Has the form \n{ exitFnName: function( parameters ) { /* ... */ } }\n where \nexitFnName\n matches the value specified as an \n'exitPoint'\n within the \nflow.json\n.\n\n\n\n\n\n\nstoragePrefix\n\n\nnull\n\n\nAllows to set a prefix for local- and session-storage keys when using \nlaxar.storage\n. If \nnull\n a prefix is generated from the configured \nname\n.\n\n\n\n\n\n\nuseEmbeddedFileListings\n\n\nfalse\n\n\nWhole files may be embedded into the file listings by \ngrunt-laxar\n to save even more HTTP-requests. During development, these embeddings may be stale and should not be used (use \nfalse\n) while in production, they are beneficial (use \ntrue\n).\n\n\n\n\n\n\nuseMergedCss\n\n\nfalse\n\n\nSimilar to \nuseEmbeddedFileListings\n, this option controls an optimization: If \ntrue\n, the runtime loads a concatenated CSS style sheet produced by \ngrunt-laxar\n instead of per-artifact style sheets to improve performance. If \nfalse\n, CSS-files are requested individually, which is mostly useful during development. The value is automatically \ntrue\n if a \nlink\n element with the \ndata-ax-merged-css\n attribute exists on the page.", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#laxarjs-configuration-in-an-application", 
            "text": "\u00ab return to the manuals  LaxarJS has a built-in configuration API which is available to libraries and widgets as  laxar.configuration .\nIn contrast to the bower- and RequireJS-configuration, this configuration is designed to be used at application run time.  Preliminary readings:   Widgets and Activities", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#what-is-laxarjs-configuration-used-for", 
            "text": "When writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration, placed in the page definitions.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.  In other cases, LaxarJS itself needs to be configured, for example to determine the theme, file listing URIs, available locales and so on.\nThe  LaxarJS Core  configuration options are listed below.", 
            "title": "What is LaxarJS Configuration Used for?"
        }, 
        {
            "location": "/manuals/configuration/#configuration-structure", 
            "text": "Configuration keys are simple JSON paths, reflecting a hierarchical configuration structure.\nThe configuration API looks for the configuration values within the  laxar  property of the global object ( window ).  Libraries, widgets and activities may define their own configuration keys, but must always use the  lib.  prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example,  LaxarJS UiKit  controls use the prefix  lib.laxar-uikit.controls  for their configuration options.\nKeys without the  lib. -prefix are used by  LaxarJS Core .", 
            "title": "Configuration Structure"
        }, 
        {
            "location": "/manuals/configuration/#the-configuration-api", 
            "text": "The LaxarJS configuration exposes a single method  laxar.configuration.get( key, fallback ) .\nThe  key -parameter is the path within the configuration object ( window.laxar ), and the (optional)  fallback  is returned as a default value if the key was not set in the configuration.  For example, a module  my_module  may allow to enable some kind of compatibility behavior for a special  foo  environment by exposing a boolean configuration  fooCompatibility .\nBy default, the option should be disabled as compatibility with foo involves jumping through some hoops.\nThe module  my_module  would then access the option like this:  define (   [   laxar   ],   function (   ax   )   { \n   function   setup ()   { \n      var   respectFoo   =   ax . configuration . get (   lib.my_module.fooCompatibility ,   false   ); \n      if (   respectFoo   )   { \n         // ... jump though some hoops ... \n         return   {   hoops :   JUMPED   }; \n      } \n      return   {}; \n   }  }   );   And the corresponding configuration block to enable foo-compatibility would then look like this:  window . laxar   =   { \n    // ... \n    lib :   { \n       my_module :   { \n          fooCompatibility :   true \n       }, \n       // ... \n    }  };", 
            "title": "The Configuration API"
        }, 
        {
            "location": "/manuals/configuration/#testing-a-module-that-uses-configuration", 
            "text": "To test the behavior of a module with test-controlled configuration options, one can simply spy on the method  configuration.get .\nHere is an exemplary jasmine test for a module  my_module , which tries to test the module behavior with foo-compatibility enabled.  define (   [   laxar ,   my_module   ],   function (   ax ,   myModule   )   { \n    describe (   a my_module with foo compatibility enabled ,   function ()   { \n       beforeEach (   function ()   { \n          var   origGet   =   ax . configuration . get ; \n          var   hoops ; \n          spyOn (   ax . configuration ,   get   ). andCallFake (   function (   key ,   fallback   )   { \n             return   key   ===   lib.my_module.fooCompatibility   ?   true   :   origGet (   key ,   fallback   ); \n          }   ); \n          hoops   =   setup (); \n       }   ); \n       it (   jumps through some hoops ,   function ()   { \n            expect (   hoops   ). toBe (   JUMPED   ); \n       }   ); \n    }   );  }   );", 
            "title": "Testing a Module that Uses Configuration"
        }, 
        {
            "location": "/manuals/configuration/#injecting-configuration-into-an-angularjs-module", 
            "text": "Instead of using RequireJS, AngularJS modules such as widgets can have the configuration module injected by requesting the service  'Configuration' .\nIn cases where configuration is injected, an  angularMocks.module  provider may be defined during testing instead of the approach described above.", 
            "title": "Injecting Configuration into an AngularJS module"
        }, 
        {
            "location": "/manuals/configuration/#available-configuration-keys-in-laxarjs-core", 
            "text": "The following configuration options are available in  LaxarJS Core .\nFor options available in  LaxarJS UiKit , have a look at the  respective documentation .     Key  Default  Description      name  ''  The name of the LaxarJS application    description  ''  A short application description    theme  'default'  Which theme to use for the application. The suffix  .theme  is added automatically.    :-----------------------------------  :--------------------  :------------------------------------------------------------------    eventBusTimeoutMs  120000  The maximum delay (in milliseconds) to wait for a  did...  event to be published, after it was announced by a  will...  event.    i18n.locales  { 'default': 'en' }  Which language tag to use for the default locale, and possibly for other locales.    logging.http.header  null  If set, an  $http  interceptor is registered to add the log tags (such as PLCE for the current place and INST for the client instance ID) to outgoing  $http  requests, under the configured header field (e.g.  -x-myapp-tags ).    logging.levels  {}  Additional log levels with name and severity, for example  { NOTICE: 350 } . The predefined severities reach from  100  for  TRACE  to  600  for  FATAL .    logging.threshold  'INFO'  The log level which is required for messages to be logged (one of  TRACE ,  DEBUG ,  INFO ,  WARN ,  ERROR  or  FATAL )    fileListings  {}  A mapping from application directories to file listing names or directly to their content objects. The listings help to save unnecessary HTTP 404 requests (for example, to determine if a widget has custom styles for the current theme), and are generated by  grunt-laxar .    flow.entryPoint  null  If the browser URL cannot be controlled by the LaxarJS application (for example, when integrating with a legacy system), the target and place-parameters can be set here in the form  { target: 'my_flow_target', parameters: { myParam: 'xyz' } } .    flow.exitPoints  {}  Allows to delegate handling of a navigation target to a different (legacy) system by specifying callbacks for individual navigation targets. Has the form  { exitFnName: function( parameters ) { /* ... */ } }  where  exitFnName  matches the value specified as an  'exitPoint'  within the  flow.json .    storagePrefix  null  Allows to set a prefix for local- and session-storage keys when using  laxar.storage . If  null  a prefix is generated from the configured  name .    useEmbeddedFileListings  false  Whole files may be embedded into the file listings by  grunt-laxar  to save even more HTTP-requests. During development, these embeddings may be stale and should not be used (use  false ) while in production, they are beneficial (use  true ).    useMergedCss  false  Similar to  useEmbeddedFileListings , this option controls an optimization: If  true , the runtime loads a concatenated CSS style sheet produced by  grunt-laxar  instead of per-artifact style sheets to improve performance. If  false , CSS-files are requested individually, which is mostly useful during development. The value is automatically  true  if a  link  element with the  data-ax-merged-css  attribute exists on the page.", 
            "title": "Available Configuration Keys in LaxarJS Core"
        }, 
        {
            "location": "/manuals/widgets_and_activities/", 
            "text": "Widgets and Activities\n\n\n\u00ab return to the manuals\n\n\nWidgets and activities are the \n\"work horse\"\n of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nWidget Responsibilities\n\n\nBefore starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question: \nWhat goal does this widget help the user to accomplish?\n\nAre you thinking about a very broadly applicable, technical task such as \n\"allow the user to enter a date\"\n or \n\"allow the user to delete a data row\"\n?\nIn this case you might want to implement this functionality as a \ncontrol\n (an AngularJS directive or an HTML5 web component) and use it \nwithin\n one or more of your widgets.\n\n\nUsually, widgets correspond to significant areas of the screen and are composed from multiple controls.\nThey are built with a \nspecific user-goal\n in mind, such as \n\"allow the user to book a flight\"\n or \n\"allow the user to review shopping cart contents\"\n.\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of the thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?\n\n\nWhen to use Activities\n\n\nActivities are \n\"invisible widgets\"\n that are used to \nfetch and manage application resources\n.\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nThis makes activities perform a role similar to AngularJS services.\nThe advantage over services is that using activities puts the \npage author\n in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.\nAlthough these configurations are not impossible to achieve using AngularJS dependency injection and -services, using LaxarJS activities makes the connections declarative and visible.\n\n\nActivities may also serve as a \nmediator\n between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.\n\n\nHow to Create a Widget\n\n\nThe easiest way to create a widget is to use the \nLaxarJS Yeoman generator\n.\nCheck out the \nREADME\n on how to obtain it, and how to use it for creating an application.\n\n\nStart by creating a sub-directory for your new widget within the LaxarJS application.\nEach widget in an application lives within a sub-folder of the \nwidget root\n (\nincludes/widgets\n by default).\nTo change the widget root you can modify the RequireJS-path \n'laxar-path-widgets'\n in the require configuration.\nThe widget path \nincludes/widgets/shopping-cart-widget\n is used as an example path throughout this manual.\n\n\nThe last component of the widget path is the \nwidget name\n:\nIt has to be unique throughout an application and should be written in lower case letters with components separated by dashes.\nRegular widget names always end in \n-widget\n whereas activities always end in \n-activity\n.\n\n\nTo create the actual widget, run:\n\n\ncd \nincludes/widgets/shopping-cart-widget\nyo laxarjs:widget\n\n\n\n\n\nThe generator will ask for some details on the widget such as license and author, but you can always edit this information in the widget sources afterwards.\nIn the following steps, it is assumed that you used the widget name \nshopping-cart-widget\n as above.\n\n\nWidget Files\n\n\nA newly created widget contains the following files:\n\n\n\n\nwidget.json\n\n\n\n\nThis \nwidget specification\n contains meta-data about your widget that is used by the LaxarJS framework.\n  It allows you to describe the configuration options of your widget features as a JSON schema.\n\n\n\n\nbower.json\n\n\n\n\nThis specifies the \ndependencies\n of your widget for use with \nBower\n.\n  While not used directly by LaxarJS, it is the key to automated and isolated widget tests.\n\n\n\n\nshopping-cart-widget.js\n\n\n\n\nThe \nbusiness logic\n of your shopping cart (like calculating a total or changing item quantities) as an \nAngularJS controller\n.\n  When your controller is instantiated by the LaxarJS runtime, it will receive an AngularJS scope (the model) and a reference to the event bus, which allows for communication with the world.\n  When built for release, all controllers and their RequireJS-dependencies are bundled into a single, compressed JavaScript file.\n\n\n\n\ndefault.theme/shopping-cart-widget.html\n\n\n\n\nThe \nAngularJS HTML template\n defining the \nappearance\n of your widget.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The \nBootstrap CSS\n classes are available by convention to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all), but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be preloaded within a single JSON file when your application is packaged for release.\n\n\n\n\ndefault.theme/(s)css/shopping-cart-widget.(s)css\n\n\n\n\nWidget-specific \nstyle definitions\n.\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS (or \nSCSS\n folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, the framework will load it when the widget is used in an application, and bundle it for release.\n\n\nLaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom \ntheme\n.\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead \nmore about themes\n once you are familiar with creating and using widgets.\n\n\nWidget Files for Testing\n\n\nThe sub folder \nspec\n contains the widget spec test and associated resources.\nNone of these files are loaded during regular application runtime:\n\n\n\n\nspec/spec_runner.html\n\n\n\n\nFor convenience, LaxarJS provides a spec runner for each new widget, to run jasmine spec tests in the browser.\n  This file does not need to be touched at all.\n\n\n\n\nspec/spec_runner.js\n\n\n\n\nConfiguration for the spec test.\n  This file needs to be modified only if widget-specific external dependencies are required during testing.\n\n\n\n\nspec/shopping-cart-widget.spec.js\n\n\n\n\nThis is the actual \njasmine\n spec test.\n  The test harness (providing a simulated LaxarJS event bus) has already been prepared for you.\n\n\nImplementing a Controller\n\n\nTo write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means\n\n\n\n\n\n\nsumming the contents of the cart\n\n\n\n\n\n\nincreasing or decreasing the quantity of individual positions within the cart.\n\n\n\n\n\n\nThe Yeoman generator has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart, this might be an appropriate starting implementation based on some dummy data:\n\n\n// ...\n\n\n\nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n   \n$scope\n.\nmodel\n \n=\n \n[\n\n      \n{\n \nlabel\n:\n \nDairy Dreams\n,\n \nprice\n:\n \n5.25\n,\n \namount\n:\n \n1\n \n},\n\n      \n{\n \nlabel\n:\n \nMilky Mocha\n,\n \nprice\n:\n \n12.75\n,\n \namount\n:\n \n3\n \n},\n\n      \n{\n \nlabel\n:\n \nFreezing Frapp\u00e9\n,\n \nprice\n:\n \n18.25\n,\n \namount\n:\n \n1\n \n}\n\n   \n];\n\n\n   \n$scope\n.\nincrement\n \n=\n \nfunction\n(\n \nitem\n \n)\n \n{\n\n      \n++\nitem\n.\namount\n;\n\n   \n};\n\n\n   \n$scope\n.\ndecrement\n \n=\n \nfunction\n(\n \nitem\n \n)\n \n{\n\n      \nitem\n.\namount\n \n=\n \nMath\n.\nmax\n(\n \n0\n,\n \nitem\n.\namount\n \n-\n \n1\n \n);\n\n   \n};\n\n\n   \n$scope\n.\ntotal\n \n=\n \nfunction\n(\n \nrows\n \n)\n \n{\n\n      \nreturn\n \nrows\n.\nreduce\n(\n \nfunction\n(\n \nacc\n,\n \nnext\n \n)\n \n{\n\n         \nreturn\n \nacc\n \n+\n \nnext\n.\nprice\n*\nnext\n.\namount\n;\n\n      \n},\n \n0\n \n);\n\n   \n};\n\n\n}\n\n\n\n// ...\n\n\n\n\n\n\nWe can see that a widget controller in LaxarJS works just like any other AngularJS controller.\nOf course things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.\n\n\nCreating a Template\n\n\nThe purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:\n\n\nh4\n \nng-bind-html=\nfeatures.headline.htmlText\n/h4\n\n\ntable\n \nclass=\ntable\n\n   \nthead\n\n   \ntr\n\n      \nth\nBeverage\n/th\n\n      \nth\n \nclass=\ncart-amount\nPrice\n/th\n\n      \nth\n \nclass=\ncart-price\nAmount\n/th\n\n      \nth\n/th\n\n   \n/tr\n\n   \n/thead\n\n   \ntfoot\n\n   \ntr\n\n      \nth\n \ncolspan=\n3\n \nclass=\ncart-price\n{{ total( model ) }}\n/th\n\n      \nth\n/th\n\n   \n/tr\n\n   \n/tfoot\n\n   \ntr\n \nng-repeat=\nitem in model\n\n      \ntd\n{{ item.label }}\n/td\n\n      \ntd\n \nclass=\ncart-amount\n{{ item.amount }}\n/td\n\n      \ntd\n \nclass=\ncart-price\n{{ item.price }}\n/td\n\n      \ntd\n\n         \nbutton\n \ndata-ng-click=\ndecrement( item )\n \nclass=\nbtn btn-xs\ni\n \nclass=\nfa fa-minus\n \n/\n/button\n\n         \nbutton\n \ndata-ng-click=\nincrement( item )\n \nclass=\nbtn btn-xs\ni\n \nclass=\nfa fa-plus\n \n/\n/button\n\n      \n/td\n\n   \n/tr\n\n\n/table\n\n\n\n\n\n\nNote that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that \nmodel\n, \ndecrement\n, \nincrement\n and \ntotal\n will be available upon template instantiation.\nThe \nfeatures\n property used within the headline comes from the \nwidget configuration\n, which is described below.\n\n\nAdding Some Style\n\n\nA widget may be styled using CSS.\nLaxarJS supports generating the CSS from SCSS source files, allowing to place common definitions for font size, color and much more within a shared \"theme\" folder.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under \ndefault.theme/css/shopping-cart-widget.css\n.\nOnce you are familiar with the basics, read the article on \ncreating themes\n for more information.\n\n\nThanks to Bootstrap this widget does not require a lot of fancy styling:\n\n\n.shopping-cart-widget\n \n.cart-amount\n,\n\n\n.shopping-cart-widget\n \n.cart-price\n \n{\n\n   \ntext-align\n:\n \nright\n;\n\n\n}\n\n\n\n\n\n\nFor best encapsulation, selectors should be prefixed with the widget class (\nshopping-cart-widget\n) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here (\ncart-amount\n, \ncart-price\n), just as you would prefix custom AngularJS elements or attributes when creating a directive.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.\n\n\nConfiguration Options\n\n\nWhen looking at the template, you might have wondered where the \nfeatures.headline.htmlText\n came from.\nThis is a \nfeature configuration\n option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we make it configurable by adding a feature entry to the \nwidget.json\n:\n\n\n{\n\n   \nname\n:\n \nshopping-cart-widget\n,\n\n   \ndescription\n:\n \nAllows Users to Review and Modify Purchase Items\n,\n\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nheadline\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nhtmlText\n:\n \n{\n\n                  \ntype\n:\n \nstring\n,\n\n                  \ndescription\n:\n \nThe HTML headline content.\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe \nwidget features\n are a \nJSON schema\n document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.\nSee the \nreference section\n for details on the widget specification.\n\n\nChecking out the Result\n\n\nBefore we can take a look at the widget, we will need to integrate it into the page provided by the application template (\napplication/pages/page1.json\n).\n\n\n{\n\n   \nlayout\n:\n \none_column\n,\n\n\n   \nareas\n:\n \n{\n\n      \nactivities\n:\n \n[],\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[\n\n          \n{\n\n             \nwidget\n:\n \nshopping-cart-widget\n,\n\n             \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \nhtmlText\n:\n \nMy Shopping Cart\n\n                \n}\n\n             \n}\n\n          \n}\n\n      \n],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThere is another manual to learn more about \nwriting pages\n.\n\n\nNow we can start the development web server provided by LaxarJS, from the application root:\n\n\nnpm install \n# if you have not already\n\nnpm start\n\n\n\n\n\nNavigate to \nhttp://localhost:8000/debug.html\n to admire the fruits of your labor:\n\n\n\n\nNow that you have learned the basics in creating widgets, take a closer look at widget testing.\n\n\nTesting a Widget\n\n\nOne of the major goals of LaxarJS is to simplify the development \nand testing\n of isolated components.\nFor this reason, the testing infrastructure for your widget has already been added when using \ngenerator laxarjs:widget\n.\n\n\nWriting Spec-Tests\n\n\nLaxarJS still contains a testing framework, which is deprecated starting from version 1.1.0 onwards.\nFor backwards compatibility it won't be removed until the next major release 2.0.0 of LaxarJS, but when starting a new application, usage is discouraged.\nInstead the new, self-contained \nLaxarJS Mocks\n framework should be used.\nThere you'll also find manuals and \nan introduction\n on how to test widgets in isolation\n\n\nIntroduction valid up to LaxarJS 1.1.0:\n\n\nLaxarJS contains a testing infrastructure to mock out the LaxarJS runtime, effectively running your widget in a sandbox or \ntest bed\n as it is called in LaxarJS.\nA skeleton spec is already provided for you:\nIt contains code to prepare the test bed with sample configuration and to instantiate your controller.\n\n\nTo mock out AngularJS services such as \n$http\n you can work with \nngMocks\n just like you would do without LaxarJS.\nTo add a simple test for our widget, replace the existing dummy test\n\n\nit\n(\n \nstill needs some tests.\n \n);\n\n\n\n\n\n\nwith a more useful spec:\n\n\nit\n(\n \nallows to calculate a total of its contents\n,\n \nfunction\n()\n \n{\n\n    \nexpect\n(\n \ntestBed_\n.\nscope\n.\ntotal\n(\n \ntestBed_\n.\nscope\n.\nmodel\n \n)\n \n).\ntoEqual\n(\n \n61.75\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nTests get more interesting when you instrument the testbed to publish mock events to be handled by the widget controller, and in turn to inspect events published by the widget.\nFor more details on testing event bus communication, refer to the \narticle on events\n.\n\n\nRunning the Test\n\n\nNow make sure that the development web server is still running and check out the test results using the \nprovided spec runner\n:\n\n\n\n\nAlternatively, you can run the tests for all your widgets from the command line:\n\n\nnpm\n \ntest\n\n\n\n\n\n\nLaxarJS provides \ngrunt tasks\n for testing that automatically set up and run \nPhantomJS\n for you, so you should not run into problems accessing the DOM.\nHopefully this makes it simple to set up continuous integration for your application.\n\n\n\n\nLaxarJS Widget Reference\n\n\nBuilding on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and the properties available on the \n$scope\n in case of an AngularJS widget.\n\n\nThe Widget Specification Format\n\n\nEach widget has a \nwidget.json\n file which is also called \nwidget specification\n.\nLaxarJS contains a \nwidget schema definition\n that defines the exact format of this file.\nThese are the most important widget properties:\n\n\n\n\nname\n\n\n\n\nThis required field contains the \nCamelCase\n version of the widget's directory name.\n\n\n\n\ndescription\n\n\n\n\nWhat this widget is about.\n  Ideally, this contains the main \nuser-goal\n mentioned in the first section.\n\n\n\n\nfeatures\n\n\n\n\nThe widget features.\n  This is a JSON schema document that documents all configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.\n\n\n\n\ncompatibility\n\n\n\n\nAn optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to \nopt in\n to breaking LaxarJS changes (similarly to the Python \nimport from future\n construct), without harming widgets that do not yet support these changes.\n\n\n\n\ncontrols\n\n\n\n\nAn optional list of LaxarJS controls used by this widget.\n  Each control is represented by its RequireJS path.\n  This allows the LaxarJS runtime to automatically load the AngularJS modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to \nProviding Controls\n for on loading user interface components and their resources in this manner.\n\n\nThe Widget Scope\n\n\nThe widget controller and the template have access to the widget scope.\nThe scope may be used by widget controllers to communicate with directives such as \nngForm\n.\nTo avoid entanglement, multiple widgets (even if nested) do \nnot\n communicate through the scope but \nalways use the event bus\n for this.\n\n\n\n\n$scope.eventBus\n\n\n\n\nMost of the time, this is the only LaxarJS scope property used by widget controllers.\n  Of course, controllers will almost always add their own properties.\n\n\n\n\n$scope.widget.id\n\n\n\n\nA unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect \nlabel\n and \ninput\n elements in an HTML form.", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widgets-and-activities", 
            "text": "\u00ab return to the manuals  Widgets and activities are the  \"work horse\"  of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.  Preliminary readings:   LaxarJS Core Concepts", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-responsibilities", 
            "text": "Before starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question:  What goal does this widget help the user to accomplish? \nAre you thinking about a very broadly applicable, technical task such as  \"allow the user to enter a date\"  or  \"allow the user to delete a data row\" ?\nIn this case you might want to implement this functionality as a  control  (an AngularJS directive or an HTML5 web component) and use it  within  one or more of your widgets.  Usually, widgets correspond to significant areas of the screen and are composed from multiple controls.\nThey are built with a  specific user-goal  in mind, such as  \"allow the user to book a flight\"  or  \"allow the user to review shopping cart contents\" .\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of the thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?", 
            "title": "Widget Responsibilities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#when-to-use-activities", 
            "text": "Activities are  \"invisible widgets\"  that are used to  fetch and manage application resources .\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nThis makes activities perform a role similar to AngularJS services.\nThe advantage over services is that using activities puts the  page author  in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.\nAlthough these configurations are not impossible to achieve using AngularJS dependency injection and -services, using LaxarJS activities makes the connections declarative and visible.  Activities may also serve as a  mediator  between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.", 
            "title": "When to use Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#how-to-create-a-widget", 
            "text": "The easiest way to create a widget is to use the  LaxarJS Yeoman generator .\nCheck out the  README  on how to obtain it, and how to use it for creating an application.  Start by creating a sub-directory for your new widget within the LaxarJS application.\nEach widget in an application lives within a sub-folder of the  widget root  ( includes/widgets  by default).\nTo change the widget root you can modify the RequireJS-path  'laxar-path-widgets'  in the require configuration.\nThe widget path  includes/widgets/shopping-cart-widget  is used as an example path throughout this manual.  The last component of the widget path is the  widget name :\nIt has to be unique throughout an application and should be written in lower case letters with components separated by dashes.\nRegular widget names always end in  -widget  whereas activities always end in  -activity .  To create the actual widget, run:  cd  includes/widgets/shopping-cart-widget\nyo laxarjs:widget  The generator will ask for some details on the widget such as license and author, but you can always edit this information in the widget sources afterwards.\nIn the following steps, it is assumed that you used the widget name  shopping-cart-widget  as above.", 
            "title": "How to Create a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files", 
            "text": "A newly created widget contains the following files:   widget.json   This  widget specification  contains meta-data about your widget that is used by the LaxarJS framework.\n  It allows you to describe the configuration options of your widget features as a JSON schema.   bower.json   This specifies the  dependencies  of your widget for use with  Bower .\n  While not used directly by LaxarJS, it is the key to automated and isolated widget tests.   shopping-cart-widget.js   The  business logic  of your shopping cart (like calculating a total or changing item quantities) as an  AngularJS controller .\n  When your controller is instantiated by the LaxarJS runtime, it will receive an AngularJS scope (the model) and a reference to the event bus, which allows for communication with the world.\n  When built for release, all controllers and their RequireJS-dependencies are bundled into a single, compressed JavaScript file.   default.theme/shopping-cart-widget.html   The  AngularJS HTML template  defining the  appearance  of your widget.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The  Bootstrap CSS  classes are available by convention to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all), but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be preloaded within a single JSON file when your application is packaged for release.   default.theme/(s)css/shopping-cart-widget.(s)css   Widget-specific  style definitions .\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS (or  SCSS  folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, the framework will load it when the widget is used in an application, and bundle it for release.  LaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom  theme .\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead  more about themes  once you are familiar with creating and using widgets.", 
            "title": "Widget Files"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files-for-testing", 
            "text": "The sub folder  spec  contains the widget spec test and associated resources.\nNone of these files are loaded during regular application runtime:   spec/spec_runner.html   For convenience, LaxarJS provides a spec runner for each new widget, to run jasmine spec tests in the browser.\n  This file does not need to be touched at all.   spec/spec_runner.js   Configuration for the spec test.\n  This file needs to be modified only if widget-specific external dependencies are required during testing.   spec/shopping-cart-widget.spec.js   This is the actual  jasmine  spec test.\n  The test harness (providing a simulated LaxarJS event bus) has already been prepared for you.", 
            "title": "Widget Files for Testing"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#implementing-a-controller", 
            "text": "To write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means    summing the contents of the cart    increasing or decreasing the quantity of individual positions within the cart.    The Yeoman generator has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart, this might be an appropriate starting implementation based on some dummy data:  // ...  function   Controller (   $scope   )   { \n    $scope . model   =   [ \n       {   label :   Dairy Dreams ,   price :   5.25 ,   amount :   1   }, \n       {   label :   Milky Mocha ,   price :   12.75 ,   amount :   3   }, \n       {   label :   Freezing Frapp\u00e9 ,   price :   18.25 ,   amount :   1   } \n    ]; \n\n    $scope . increment   =   function (   item   )   { \n       ++ item . amount ; \n    }; \n\n    $scope . decrement   =   function (   item   )   { \n       item . amount   =   Math . max (   0 ,   item . amount   -   1   ); \n    }; \n\n    $scope . total   =   function (   rows   )   { \n       return   rows . reduce (   function (   acc ,   next   )   { \n          return   acc   +   next . price * next . amount ; \n       },   0   ); \n    };  }  // ...   We can see that a widget controller in LaxarJS works just like any other AngularJS controller.\nOf course things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.", 
            "title": "Implementing a Controller"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#creating-a-template", 
            "text": "The purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:  h4   ng-bind-html= features.headline.htmlText /h4  table   class= table \n    thead \n    tr \n       th Beverage /th \n       th   class= cart-amount Price /th \n       th   class= cart-price Amount /th \n       th /th \n    /tr \n    /thead \n    tfoot \n    tr \n       th   colspan= 3   class= cart-price {{ total( model ) }} /th \n       th /th \n    /tr \n    /tfoot \n    tr   ng-repeat= item in model \n       td {{ item.label }} /td \n       td   class= cart-amount {{ item.amount }} /td \n       td   class= cart-price {{ item.price }} /td \n       td \n          button   data-ng-click= decrement( item )   class= btn btn-xs i   class= fa fa-minus   / /button \n          button   data-ng-click= increment( item )   class= btn btn-xs i   class= fa fa-plus   / /button \n       /td \n    /tr  /table   Note that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that  model ,  decrement ,  increment  and  total  will be available upon template instantiation.\nThe  features  property used within the headline comes from the  widget configuration , which is described below.", 
            "title": "Creating a Template"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#adding-some-style", 
            "text": "A widget may be styled using CSS.\nLaxarJS supports generating the CSS from SCSS source files, allowing to place common definitions for font size, color and much more within a shared \"theme\" folder.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under  default.theme/css/shopping-cart-widget.css .\nOnce you are familiar with the basics, read the article on  creating themes  for more information.  Thanks to Bootstrap this widget does not require a lot of fancy styling:  .shopping-cart-widget   .cart-amount ,  .shopping-cart-widget   .cart-price   { \n    text-align :   right ;  }   For best encapsulation, selectors should be prefixed with the widget class ( shopping-cart-widget ) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here ( cart-amount ,  cart-price ), just as you would prefix custom AngularJS elements or attributes when creating a directive.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.", 
            "title": "Adding Some Style"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#configuration-options", 
            "text": "When looking at the template, you might have wondered where the  features.headline.htmlText  came from.\nThis is a  feature configuration  option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we make it configurable by adding a feature entry to the  widget.json :  { \n    name :   shopping-cart-widget , \n    description :   Allows Users to Review and Modify Purchase Items , \n\n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          headline :   { \n             type :   object , \n             properties :   { \n                htmlText :   { \n                   type :   string , \n                   description :   The HTML headline content. \n                } \n             } \n          } \n       } \n    }  }   The  widget features  are a  JSON schema  document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.\nSee the  reference section  for details on the widget specification.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#checking-out-the-result", 
            "text": "Before we can take a look at the widget, we will need to integrate it into the page provided by the application template ( application/pages/page1.json ).  { \n    layout :   one_column , \n\n    areas :   { \n       activities :   [], \n       header :   [], \n       content :   [ \n           { \n              widget :   shopping-cart-widget , \n              features :   { \n                 headline :   { \n                    htmlText :   My Shopping Cart \n                 } \n              } \n           } \n       ], \n       footer :   [] \n    }  }   There is another manual to learn more about  writing pages .  Now we can start the development web server provided by LaxarJS, from the application root:  npm install  # if you have not already \nnpm start  Navigate to  http://localhost:8000/debug.html  to admire the fruits of your labor:   Now that you have learned the basics in creating widgets, take a closer look at widget testing.", 
            "title": "Checking out the Result"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#testing-a-widget", 
            "text": "One of the major goals of LaxarJS is to simplify the development  and testing  of isolated components.\nFor this reason, the testing infrastructure for your widget has already been added when using  generator laxarjs:widget .", 
            "title": "Testing a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#writing-spec-tests", 
            "text": "LaxarJS still contains a testing framework, which is deprecated starting from version 1.1.0 onwards.\nFor backwards compatibility it won't be removed until the next major release 2.0.0 of LaxarJS, but when starting a new application, usage is discouraged.\nInstead the new, self-contained  LaxarJS Mocks  framework should be used.\nThere you'll also find manuals and  an introduction  on how to test widgets in isolation  Introduction valid up to LaxarJS 1.1.0:  LaxarJS contains a testing infrastructure to mock out the LaxarJS runtime, effectively running your widget in a sandbox or  test bed  as it is called in LaxarJS.\nA skeleton spec is already provided for you:\nIt contains code to prepare the test bed with sample configuration and to instantiate your controller.  To mock out AngularJS services such as  $http  you can work with  ngMocks  just like you would do without LaxarJS.\nTo add a simple test for our widget, replace the existing dummy test  it (   still needs some tests.   );   with a more useful spec:  it (   allows to calculate a total of its contents ,   function ()   { \n     expect (   testBed_ . scope . total (   testBed_ . scope . model   )   ). toEqual (   61.75   );  }   );   Tests get more interesting when you instrument the testbed to publish mock events to be handled by the widget controller, and in turn to inspect events published by the widget.\nFor more details on testing event bus communication, refer to the  article on events .", 
            "title": "Writing Spec-Tests"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#running-the-test", 
            "text": "Now make sure that the development web server is still running and check out the test results using the  provided spec runner :   Alternatively, you can run the tests for all your widgets from the command line:  npm   test   LaxarJS provides  grunt tasks  for testing that automatically set up and run  PhantomJS  for you, so you should not run into problems accessing the DOM.\nHopefully this makes it simple to set up continuous integration for your application.", 
            "title": "Running the Test"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#laxarjs-widget-reference", 
            "text": "Building on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and the properties available on the  $scope  in case of an AngularJS widget.", 
            "title": "LaxarJS Widget Reference"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-widget-specification-format", 
            "text": "Each widget has a  widget.json  file which is also called  widget specification .\nLaxarJS contains a  widget schema definition  that defines the exact format of this file.\nThese are the most important widget properties:   name   This required field contains the  CamelCase  version of the widget's directory name.   description   What this widget is about.\n  Ideally, this contains the main  user-goal  mentioned in the first section.   features   The widget features.\n  This is a JSON schema document that documents all configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.   compatibility   An optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to  opt in  to breaking LaxarJS changes (similarly to the Python  import from future  construct), without harming widgets that do not yet support these changes.   controls   An optional list of LaxarJS controls used by this widget.\n  Each control is represented by its RequireJS path.\n  This allows the LaxarJS runtime to automatically load the AngularJS modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to  Providing Controls  for on loading user interface components and their resources in this manner.", 
            "title": "The Widget Specification Format"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#the-widget-scope", 
            "text": "The widget controller and the template have access to the widget scope.\nThe scope may be used by widget controllers to communicate with directives such as  ngForm .\nTo avoid entanglement, multiple widgets (even if nested) do  not  communicate through the scope but  always use the event bus  for this.   $scope.eventBus   Most of the time, this is the only LaxarJS scope property used by widget controllers.\n  Of course, controllers will almost always add their own properties.   $scope.widget.id   A unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect  label  and  input  elements in an HTML form.", 
            "title": "The Widget Scope"
        }, 
        {
            "location": "/manuals/visibility_events/", 
            "text": "Working with Visibility Events\n\n\n\u00ab return to the manuals\n\n\nVisibility events help to improve performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nEvents and Publish/Subscribe\n\n\nWriting Pages\n\n\n\n\nNote that while this manual is rather longish, there is a \nTL;DR\n at the bottom.\n\n\nWhy Visibility Events?\n\n\nSome widgets perform \nexpensive\n operations such as:\n\n\n- loading and/or display of large amounts of data\n- loading and/or rendering large images and/or movies\n- using expensive controls for things like charts, animations etc.\n- measuring DOM-elements for parameterizing animations\n- providing *widget areas* which may in turn host expensive widgets.\n\n\n\n\n\nIf a widget does one or more expensive thing, it should only do so while the widget itself is \nvisible\n to the user.\nFrequently, widgets are \nhidden\n from the user, on page entry or afterwards, due to being nested:\n\n\n- within an invisible (closed) popup/popover\n- within an invisible accordion area\n- within an invisible tab area\n- within an invisible show/hide-area.\n\n\n\n\n\nThe so-called \nvisibility events\n help widgets to determine whether their contents may be seen by the user.\n\n\nIf a visibility event tells a widget that it is \nhidden\n, the widget may stop performing any expensive operations.\nIf another visibility event tells a widget that it is \nvisible\n (again), that widget may not necessarily be within the visible portion of the page at that time, but might be scrolled into view at any moment.\n\n\nCaveat\n\n\nAs with all performance optimizations, be careful not to optimize overly eagerly.\nFirst, LaxarJS performs several optimizations automatically as outlined below.\nAlso, visibility events may complicate your widget implementations unnecessarily, especially in small applications.\n\n\nHowever, unfortunately optimization often \nis\n necessary: client side web-applications sometimes tend to be slow to load or to feel sluggish, especially on mobile devices.\nIf you are not satisfied with your application's performance, try to identify the heavy hitting widgets in you application and to control their behavior first.\nAlso, make sure that visibility event handling can actually help you:\nIf there are activities on your page causing tons of REST-requests, chances are that optimizing based on visibility may not help at all.\n\n\nHandling Visibility Events\n\n\nAn initial set of visibility events is published on page entry by the LaxarJS runtime, after \nbeginLifecycleRequest\n but before \ndidNavigate\n. Widgets may subsequently publish their own visibility events to signal changes to areas that they provide.\nThese changes are then propagated to nested widget areas by the runtime.\n\n\nThe following section will explain how widgets can access and utilize visibility information.\nAfterwards, details follow on \ncontrolling\n visibility through events.\n\n\nAutomatic Handling\n\n\nThe LaxarJS runtime maintains a internal visibility status flag for each widget and for each area.\nEven for the widgets that do not care about visibility at all (the majority), the runtime uses this information to determine when the widget DOM is prepared and added to the page DOM, since this may be an expensive process itself.\nWith AngularJS for example, widget HTML must be compiled and linked, creating all nested directive instances.\n\n\nNote that widget DOM is \nnot destroyed\n again after the initial attach, until the page is left by the user.\nIf a widget uses a template with a large number of bindings, it may be beneficial to \ncut off\n these bindings when invisible, for example by using \nngIf\n in an AngularJS widget (next section).\n\n\nManual Handling in Controllers \n Templates\n\n\nWidget controllers can subscribe to \ndidChangeAreaVisibility.{area}.{visible}\n events.\n\n\n* Instead of `area`, the name of the surrounding widget area should be used.\nThe event payload contains the area name as well, under an attribute `.area`.\nFor subscribing, this name available from the `axContext` injection (AngularJS: `$scope`) as attribute `.widget.area`.\n\n* The `visible` value (`true` or `false`) confers the new visibility status of the area and is usually not pre-selected when subscribing.\nThe event payload contains this status as well , under a boolean attribute `.visible`.\n\n\n\n\n\nTo simplify handling, the \nvisibility handler\n in the utility library \nLaxarJS Patterns\n may be used.\nHere is an example for an AngularJS widget:\n\n\ndefine\n(\n \n[\n \nangular\n,\n \nlaxar-patterns\n \n],\n \nfunction\n(\n \nng\n,\n \npatterns\n \n)\n \n{\n\n   \nController\n.\n$inject\n \n=\n \n[\n \n$scope\n \n];\n\n   \nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n      \npatterns\n.\nvisibility\n.\nhandlerFor\n(\n \n$scope\n,\n \n{\n\n         \nonShow\n:\n \nstartExpensiveStuff\n,\n\n         \nonHide\n:\n \nstopExpensiveStuff\n\n      \n}\n \n);\n\n   \n}\n\n   \n// ...\n\n\n}\n \n);\n\n\n\n\n\n\nIn the \nHTML-template\n, \nng-if=\"isVisible\"\n may be used to toggle (portions of) the template based on visibility.\nNot that this is not useful to speed up initial rendering, due to the automatic DOM handling described above.\nThe scope-property \nisVisible\n is maintained by the visibility handler as well, so make sure to have the controller instantiate it.\n\n\nManual Handling in Directives\n\n\nAngularJS directives get special support through the \naxVisibilityService\n injection.\nUsually, controls (such as directives) should not interact with the event bus directly:\nbecause their lifetime is coupled to the DOM, they might not receive arbitrary events.\nSo, usually the widget controller should pass visibility information to controls using some kind of binding.\n\n\nHowever, AngularJS directives may also use the visibility service provided by the runtime, to handle visibility themselves.\nFor example, imagine a clock directive that renders an animated, analogue clock.\nNaturally, the clock animation should pause while the widget containing the clock is invisible:\n\n\nmodule\n.\ndirective\n(\n \nmyClockControl\n,\n \n[\n\n   \naxVisibilityService\n,\n\n   \nfunction\n(\n \nvisibilityService\n \n)\n \n{\n\n      \nreturn\n \n{\n\n         \nlink\n:\n \nfunction\n(\n \nscope\n \n)\n \n{\n\n            \nvar\n \nhandler\n \n=\n \nvisibilityService\n.\nhandlerFor\n(\n \nscope\n \n)\n\n               \n.\nonShow\n(\n \nstartClockAnimation\n \n)\n\n               \n.\nonHide\n(\n \nstopClockAnimation\n \n);\n\n            \nif\n(\n \nhandler\n.\nisVisible\n()\n \n)\n \n{\n\n               \nstartClockAnimation\n();\n\n            \n}\n\n            \n// ...\n\n         \n}\n\n      \n};\n\n   \n}\n\n\n]\n \n);\n\n\n\n\n\n\nAnother example: the \nlaxar-show-hide-widget\n contains a directive that measures the contents of an embedded area in order to control an animation.\nOnly while the widget is visible should measurement and animation be used, simply switching states at other times.\nFor this, the visibility service is used as well.\n\n\nControlling Visibility through Events\n\n\nMost widgets just need to \nreact\n to visibility changes.\nOther widgets \nprovide\n areas themselves, directly (like the \nlaxar-accordion-widget\n) or through embedded layouts (like the \nlaxar-popup-widget\n).\n\n\nControlling visibility of embedded areas from a widget includes two tasks:\n\n\n* responding two visibility requests for the provided widget areas\n\n* trigger visibility requests to inform the runtime and other widgets after actively changing an area\ns visibility.\n\n\n\n\n\nLet us have a detailed look into both tasks.\n\n\nResponding to Visibility Requests\n\n\nInitially the LaxarJS runtime publishes \nchangeAreaVisibility.{area}.{visible}\n events for all areas directly within top-level areas, asking them to publish a visibility status for any areas provided by them.\n\n\n* again, `area` is the name of the widget area of interest\n\n* `visible` is the visibility state of the surrounding area, (`true` for all regular top-level areas, but `false` for the generated `popups` and `popovers` areas).\n\n\n\n\n\nWidgets that want to control their area's visibility may now respond with \ndidChangeAreaVisibility.{area}.{visible}\n events containing the actual new visibility state.\nIf there is no reply for a widget area (for example because the providing widget does not know or care about visibility events), the runtime publishes the \ndidChangeVisibility\n event itself, using the default \nvisible\n value from the request.\nNext, all directly nested areas are processed in the same manner, until \"bottom\" is reached.\n\n\nThis process is also used to implement visibility changes that happen later during the lifetime of the page.\nFor example, a \nlaxar-accordion-widget\n embedded within the contents of a \nlaxar-popup-widget\n will be queried for the visibility of its areas when the popup is opened or closed.\n\n\nThe visibility handler of \nlaxar-patterns\n offers help in responding to visibility requests:\n\n\ndefine\n(\n \n[\n \nangular\n,\n \nlaxar-patterns\n \n],\n \nfunction\n(\n \nng\n,\n \npatterns\n \n)\n \n{\n\n   \nController\n.\n$inject\n \n=\n \n[\n \n$scope\n \n];\n\n   \nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n      \npatterns\n.\nvisibility\n.\nhandlerFor\n(\n \n$scope\n \n)\n\n         \n.\nonAnyAreaRequest\n(\n \nfunction\n(\n \nname\n \n)\n \n{\n\n            \n// something like:\n\n            \nreturn\n \n$scope\n.\nisVisible\n \n\n                \nname\n \n===\n \nmodel\n.\nmyCurrentArea\n;\n\n         \n}\n \n);\n\n   \n}\n\n   \n// ...\n\n\n}\n \n);\n\n\n\n\n\n\nThe property \n$scope.isVisible\n maintained by the visibility handler is used to quickly access the current visibility state of the surrounding area.\nThe value \nmodel.myCurrentArea\n might be use by the widget to e.g. store the name of the area that was selected by the user, such as the current tab content in a tab-navigation widget.\n\n\nChanging Visibility of Provided Areas\n\n\nAfter a widget has modified the visibility of its provided areas, it must publish corresponding \nchangeAreaVisibilityRequest\n-Events.\nThe \nvisible\n-parameter of these events must be set to the new target value, taking into account the visibility of the surrounding area.\n\n\nAgain, an example using laxar-patterns:\n\n\ndefine\n(\n \n[\n \nangular\n,\n \nlaxar-patterns\n \n],\n \nfunction\n(\n \nng\n,\n \npatterns\n \n)\n \n{\n\n   \nController\n.\n$inject\n \n=\n \n[\n \n$scope\n \n];\n\n   \nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n      \nvar\n \npublisher\n \n=\n\n         \npatterns\n.\nvisibility\n.\nrequestPublisherForArea\n(\n\n            \n$scope\n,\n \n$scope\n.\nwidget\n.\nid\n \n+\n \n.myArea\n \n);\n\n      \n$scope\n.\nonAreaClicked\n \n=\n \nfunction\n()\n \n{\n\n         \npublisher\n(\n \ntrue\n \n);\n\n      \n}\n\n   \n}\n\n   \n// ...\n\n\n}\n \n);\n\n\n\n\n\n\nNote that the widget may very well respond to its own visibility requests.\n\n\nThe basic principle of this pattern is similar to that of \ntakeActionRequest\n events:\nEven though the controlling widget knows that it is going to handle the request itself, it still starts the visibility modification with a request.\nThis informs other widgets and especially the runtime of the visibility change.\n\n\nChanging Visibility of a Directly Embedded Layout\n\n\nSome widgets such as the \nlaxar-popup-widget\n directly load \nlayouts\n which in turn provide widget areas.\nFor these widgets, requesting a visibility change for individual areas is not possible, because the name of the areas is not known.\n\n\nTo trigger re-evaluation of these areas, containing widgets may trigger \nchangeWidgetVisibilityRequest.{widget-id}.{visible}\n events.\nThe ID can be read from the \n$scope\n (or \naxContext\n respectively) as \n.widget.id\n.\n\n\nThe runtime then automatically triggers visibility requests for the embedded areas.\n\n\nSummary (TL;DR)\n\n\n* Visibility events help to improve render times and to reduce CPU- and memory-use.\n\n* Widgets may *react* to visibility changes by processing `didChangeAreaVisibility` events, directly or through the laxar-patterns visibility handler.\n\n* The runtime publishes `didChangeAreaVisibility` events before`didNavigate`.\n\n* AngularJS directives can use the `axVisibilityService` for simplified handling without help from their containing widget.\n\n* Widgets that provide areas and that influence the visibility of those areas *should control* visibility by responding to `changeAreaVisibilityRequest` events. They should also trigger such requests after initiating a visibility change to any of their provided areas.", 
            "title": "Working with Visibility Events"
        }, 
        {
            "location": "/manuals/visibility_events/#working-with-visibility-events", 
            "text": "\u00ab return to the manuals  Visibility events help to improve performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Events and Publish/Subscribe  Writing Pages   Note that while this manual is rather longish, there is a  TL;DR  at the bottom.", 
            "title": "Working with Visibility Events"
        }, 
        {
            "location": "/manuals/visibility_events/#why-visibility-events", 
            "text": "Some widgets perform  expensive  operations such as:  - loading and/or display of large amounts of data\n- loading and/or rendering large images and/or movies\n- using expensive controls for things like charts, animations etc.\n- measuring DOM-elements for parameterizing animations\n- providing *widget areas* which may in turn host expensive widgets.  If a widget does one or more expensive thing, it should only do so while the widget itself is  visible  to the user.\nFrequently, widgets are  hidden  from the user, on page entry or afterwards, due to being nested:  - within an invisible (closed) popup/popover\n- within an invisible accordion area\n- within an invisible tab area\n- within an invisible show/hide-area.  The so-called  visibility events  help widgets to determine whether their contents may be seen by the user.  If a visibility event tells a widget that it is  hidden , the widget may stop performing any expensive operations.\nIf another visibility event tells a widget that it is  visible  (again), that widget may not necessarily be within the visible portion of the page at that time, but might be scrolled into view at any moment.", 
            "title": "Why Visibility Events?"
        }, 
        {
            "location": "/manuals/visibility_events/#caveat", 
            "text": "As with all performance optimizations, be careful not to optimize overly eagerly.\nFirst, LaxarJS performs several optimizations automatically as outlined below.\nAlso, visibility events may complicate your widget implementations unnecessarily, especially in small applications.  However, unfortunately optimization often  is  necessary: client side web-applications sometimes tend to be slow to load or to feel sluggish, especially on mobile devices.\nIf you are not satisfied with your application's performance, try to identify the heavy hitting widgets in you application and to control their behavior first.\nAlso, make sure that visibility event handling can actually help you:\nIf there are activities on your page causing tons of REST-requests, chances are that optimizing based on visibility may not help at all.", 
            "title": "Caveat"
        }, 
        {
            "location": "/manuals/visibility_events/#handling-visibility-events", 
            "text": "An initial set of visibility events is published on page entry by the LaxarJS runtime, after  beginLifecycleRequest  but before  didNavigate . Widgets may subsequently publish their own visibility events to signal changes to areas that they provide.\nThese changes are then propagated to nested widget areas by the runtime.  The following section will explain how widgets can access and utilize visibility information.\nAfterwards, details follow on  controlling  visibility through events.", 
            "title": "Handling Visibility Events"
        }, 
        {
            "location": "/manuals/visibility_events/#automatic-handling", 
            "text": "The LaxarJS runtime maintains a internal visibility status flag for each widget and for each area.\nEven for the widgets that do not care about visibility at all (the majority), the runtime uses this information to determine when the widget DOM is prepared and added to the page DOM, since this may be an expensive process itself.\nWith AngularJS for example, widget HTML must be compiled and linked, creating all nested directive instances.  Note that widget DOM is  not destroyed  again after the initial attach, until the page is left by the user.\nIf a widget uses a template with a large number of bindings, it may be beneficial to  cut off  these bindings when invisible, for example by using  ngIf  in an AngularJS widget (next section).", 
            "title": "Automatic Handling"
        }, 
        {
            "location": "/manuals/visibility_events/#manual-handling-in-controllers-templates", 
            "text": "Widget controllers can subscribe to  didChangeAreaVisibility.{area}.{visible}  events.  * Instead of `area`, the name of the surrounding widget area should be used.\nThe event payload contains the area name as well, under an attribute `.area`.\nFor subscribing, this name available from the `axContext` injection (AngularJS: `$scope`) as attribute `.widget.area`.\n\n* The `visible` value (`true` or `false`) confers the new visibility status of the area and is usually not pre-selected when subscribing.\nThe event payload contains this status as well , under a boolean attribute `.visible`.  To simplify handling, the  visibility handler  in the utility library  LaxarJS Patterns  may be used.\nHere is an example for an AngularJS widget:  define (   [   angular ,   laxar-patterns   ],   function (   ng ,   patterns   )   { \n    Controller . $inject   =   [   $scope   ]; \n    function   Controller (   $scope   )   { \n       patterns . visibility . handlerFor (   $scope ,   { \n          onShow :   startExpensiveStuff , \n          onHide :   stopExpensiveStuff \n       }   ); \n    } \n    // ...  }   );   In the  HTML-template ,  ng-if=\"isVisible\"  may be used to toggle (portions of) the template based on visibility.\nNot that this is not useful to speed up initial rendering, due to the automatic DOM handling described above.\nThe scope-property  isVisible  is maintained by the visibility handler as well, so make sure to have the controller instantiate it.", 
            "title": "Manual Handling in Controllers &amp; Templates"
        }, 
        {
            "location": "/manuals/visibility_events/#manual-handling-in-directives", 
            "text": "AngularJS directives get special support through the  axVisibilityService  injection.\nUsually, controls (such as directives) should not interact with the event bus directly:\nbecause their lifetime is coupled to the DOM, they might not receive arbitrary events.\nSo, usually the widget controller should pass visibility information to controls using some kind of binding.  However, AngularJS directives may also use the visibility service provided by the runtime, to handle visibility themselves.\nFor example, imagine a clock directive that renders an animated, analogue clock.\nNaturally, the clock animation should pause while the widget containing the clock is invisible:  module . directive (   myClockControl ,   [ \n    axVisibilityService , \n    function (   visibilityService   )   { \n       return   { \n          link :   function (   scope   )   { \n             var   handler   =   visibilityService . handlerFor (   scope   ) \n                . onShow (   startClockAnimation   ) \n                . onHide (   stopClockAnimation   ); \n             if (   handler . isVisible ()   )   { \n                startClockAnimation (); \n             } \n             // ... \n          } \n       }; \n    }  ]   );   Another example: the  laxar-show-hide-widget  contains a directive that measures the contents of an embedded area in order to control an animation.\nOnly while the widget is visible should measurement and animation be used, simply switching states at other times.\nFor this, the visibility service is used as well.", 
            "title": "Manual Handling in Directives"
        }, 
        {
            "location": "/manuals/visibility_events/#controlling-visibility-through-events", 
            "text": "Most widgets just need to  react  to visibility changes.\nOther widgets  provide  areas themselves, directly (like the  laxar-accordion-widget ) or through embedded layouts (like the  laxar-popup-widget ).  Controlling visibility of embedded areas from a widget includes two tasks:  * responding two visibility requests for the provided widget areas\n\n* trigger visibility requests to inform the runtime and other widgets after actively changing an area s visibility.  Let us have a detailed look into both tasks.", 
            "title": "Controlling Visibility through Events"
        }, 
        {
            "location": "/manuals/visibility_events/#responding-to-visibility-requests", 
            "text": "Initially the LaxarJS runtime publishes  changeAreaVisibility.{area}.{visible}  events for all areas directly within top-level areas, asking them to publish a visibility status for any areas provided by them.  * again, `area` is the name of the widget area of interest\n\n* `visible` is the visibility state of the surrounding area, (`true` for all regular top-level areas, but `false` for the generated `popups` and `popovers` areas).  Widgets that want to control their area's visibility may now respond with  didChangeAreaVisibility.{area}.{visible}  events containing the actual new visibility state.\nIf there is no reply for a widget area (for example because the providing widget does not know or care about visibility events), the runtime publishes the  didChangeVisibility  event itself, using the default  visible  value from the request.\nNext, all directly nested areas are processed in the same manner, until \"bottom\" is reached.  This process is also used to implement visibility changes that happen later during the lifetime of the page.\nFor example, a  laxar-accordion-widget  embedded within the contents of a  laxar-popup-widget  will be queried for the visibility of its areas when the popup is opened or closed.  The visibility handler of  laxar-patterns  offers help in responding to visibility requests:  define (   [   angular ,   laxar-patterns   ],   function (   ng ,   patterns   )   { \n    Controller . $inject   =   [   $scope   ]; \n    function   Controller (   $scope   )   { \n       patterns . visibility . handlerFor (   $scope   ) \n          . onAnyAreaRequest (   function (   name   )   { \n             // something like: \n             return   $scope . isVisible   \n                 name   ===   model . myCurrentArea ; \n          }   ); \n    } \n    // ...  }   );   The property  $scope.isVisible  maintained by the visibility handler is used to quickly access the current visibility state of the surrounding area.\nThe value  model.myCurrentArea  might be use by the widget to e.g. store the name of the area that was selected by the user, such as the current tab content in a tab-navigation widget.", 
            "title": "Responding to Visibility Requests"
        }, 
        {
            "location": "/manuals/visibility_events/#changing-visibility-of-provided-areas", 
            "text": "After a widget has modified the visibility of its provided areas, it must publish corresponding  changeAreaVisibilityRequest -Events.\nThe  visible -parameter of these events must be set to the new target value, taking into account the visibility of the surrounding area.  Again, an example using laxar-patterns:  define (   [   angular ,   laxar-patterns   ],   function (   ng ,   patterns   )   { \n    Controller . $inject   =   [   $scope   ]; \n    function   Controller (   $scope   )   { \n       var   publisher   = \n          patterns . visibility . requestPublisherForArea ( \n             $scope ,   $scope . widget . id   +   .myArea   ); \n       $scope . onAreaClicked   =   function ()   { \n          publisher (   true   ); \n       } \n    } \n    // ...  }   );   Note that the widget may very well respond to its own visibility requests.  The basic principle of this pattern is similar to that of  takeActionRequest  events:\nEven though the controlling widget knows that it is going to handle the request itself, it still starts the visibility modification with a request.\nThis informs other widgets and especially the runtime of the visibility change.", 
            "title": "Changing Visibility of Provided Areas"
        }, 
        {
            "location": "/manuals/visibility_events/#changing-visibility-of-a-directly-embedded-layout", 
            "text": "Some widgets such as the  laxar-popup-widget  directly load  layouts  which in turn provide widget areas.\nFor these widgets, requesting a visibility change for individual areas is not possible, because the name of the areas is not known.  To trigger re-evaluation of these areas, containing widgets may trigger  changeWidgetVisibilityRequest.{widget-id}.{visible}  events.\nThe ID can be read from the  $scope  (or  axContext  respectively) as  .widget.id .  The runtime then automatically triggers visibility requests for the embedded areas.", 
            "title": "Changing Visibility of a Directly Embedded Layout"
        }, 
        {
            "location": "/manuals/visibility_events/#summary-tldr", 
            "text": "* Visibility events help to improve render times and to reduce CPU- and memory-use.\n\n* Widgets may *react* to visibility changes by processing `didChangeAreaVisibility` events, directly or through the laxar-patterns visibility handler.\n\n* The runtime publishes `didChangeAreaVisibility` events before`didNavigate`.\n\n* AngularJS directives can use the `axVisibilityService` for simplified handling without help from their containing widget.\n\n* Widgets that provide areas and that influence the visibility of those areas *should control* visibility by responding to `changeAreaVisibilityRequest` events. They should also trigger such requests after initiating a visibility change to any of their provided areas.", 
            "title": "Summary (TL;DR)"
        }, 
        {
            "location": "/manuals/writing_compositions/", 
            "text": "Writing Compositions\n\n\n\u00ab return to the manuals\n\n\nAlthough inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this may  not be sufficient. \nCompositions\n are here to help you.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWriting Pages\n\n\n\n\nVery often most of a base page fits for all pages but some small things need to be adjusted for some of the pages that could otherwise be reused throughout the application.\nAnother use case is to enable the reuse of a bundle of widgets multiple times within one page, each time only with some different configuration.\n\n\nAll of this can be achieved by using compositions.\nThe idea behind compositions is, that they provide a widget like interface regarding their addition to a page (or another composition) and the internals of a page fragment, bundling some widgets and other compositions.\nA composition thus has two basic properties: \nareas\n, like a page and \nfeatures\n like a widget.\nA third more advanced property, namely \nmergedFeatures\n, will be explained later.\n\n\nInstead we will start with the simple \npopup_composition\n we referenced above:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n,\n\n                     \nformat\n:\n \ntopic\n,\n\n                     \naxRole\n:\n \ninlet\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-popup-widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nfinish\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis example already shows some of the additional characteristics that go beyond the two properties \nfeatures\n and \nareas\n.\nLet us start from the beginning:\n\n\nFirst there is the \nfeatures\n object, that for simple cases looks just like a feature specification of a widget.\nHere you can define all the features that your composition needs to be configurable from the outside.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.\n\n\nSecondly there is the \nareas\n map and here there is already something noteworthy: The first area is simply named \n.\n.\nAll widgets and compositions within this special area will replace the reference of the composition within the area of the page including the composition.\nSo if we take the \nlast example\n of the chapter \nLayouts and Areas\n, this will be the area named \ncontent\n.\n\n\nFurthermore the two strings \n\"${features.openPopup.onActions}\"\n and \n\"${topic:closeAction}\"\n are worth noticing as they demonstrate another main feature of the composition concept.\nThose strings are expressions that will be evaluated by the page loader when assembling the complete page from its parts and are replaced by actual values as follows:\nThe \n\"${features.openPopup.onActions}\"\n expression is a reference to a feature defined within the \nfeatures\n object and will hold the value configured in the page including the composition.\nThus applied to the \nexample of the writing pages manual\n, this will result in the array \n[ \"next\" ]\n.\nOn the other hand the \n\"${topic:closeAction}\"\n expression generates a page wide unique event topic compatible string based on the local identifier \ncloseAction\n.\nThe result could thus be something like \n\"popupComposition-id0+closeAction\"\n, which is in fact the id generated for the composition itself, plus the local identifier.\nThese \ntopic expressions\n prevent naming collisions with topics of the page, other compositions or multiple usages of the same composition within the same page.\nThey should always be used when there is the need to have an identifier that is only used within the scope of a composition.\n\n\nNotice that these expressions are only written as a string to be JSON compatible and that no string interpolation takes place.\nThus something like \n\"myPrefix${topic:closeAction}\"\n would \nnot\n be interpreted when assembling the page and simply be used as is.\n\n\nThe assembled page thus looks similar to this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-popup-widget\n,\n\n            \nid\n:\n \npopupComposition-id0-popup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \npopupComposition-id0+CloseAction\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopupComposition-id0-popup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \npopupComposition-id0+CloseAction\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nNote how also the id of the exported area was automatically adjusted to \n\"popupComposition-id0-popup.content\"\n to prevent naming clashes.\n\n\nIn our example it is currently only possible to close the \nlaxar-popup-widget\n from within itself via an action event published by the \nlaxar-command-bar-widget\n.\nWhat if we additionally would like to close the popup on demand from outside based on another action?\nThis is where the concept of \nmerged features\n comes into play.\n\nMerged features\n allow us to merge or better concatenate two arrays, where one array is defined as a feature for the composition and the second array is defined in the \nmergedFeatures\n object.\nSyntactically this is achieved via a map under the key \nmergedFeatures\n where the key of each entry is the path to the array in the features and the value is the array to merge this value with.\n\n\nThis should become clear when looking at our adjusted example:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n,\n\n                     \nformat\n:\n \ntopic\n,\n\n                     \naxRole\n:\n \ninlet\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \nclosePopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \ndefault\n:\n \n[],\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n,\n\n                     \nformat\n:\n \ntopic\n,\n\n                     \naxRole\n:\n \ninlet\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nmergedFeatures\n:\n \n{\n\n      \nclosePopup.onActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-popup-widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n${features.closePopup.onActions}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHere we added the possibility to configured close actions for the \nlaxar-popup-widget\n as feature \nclosePopup.onActions\n.\nFor this we then added an entry in the \nmergedFeatures\n map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the \nlaxar-popup-widget\n.\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the \nopenPopup.onActions\n feature.\nFor the configuration of the \nlaxar-command-bar-widget\n nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.\n\n\nAppendix:\n\n\nExemplary page from \nwriting pages\n manual\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-html-display-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#writing-compositions", 
            "text": "\u00ab return to the manuals  Although inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this may  not be sufficient.  Compositions  are here to help you.  Preliminary readings:   LaxarJS Core Concepts  Writing Pages   Very often most of a base page fits for all pages but some small things need to be adjusted for some of the pages that could otherwise be reused throughout the application.\nAnother use case is to enable the reuse of a bundle of widgets multiple times within one page, each time only with some different configuration.  All of this can be achieved by using compositions.\nThe idea behind compositions is, that they provide a widget like interface regarding their addition to a page (or another composition) and the internals of a page fragment, bundling some widgets and other compositions.\nA composition thus has two basic properties:  areas , like a page and  features  like a widget.\nA third more advanced property, namely  mergedFeatures , will be explained later.  Instead we will start with the simple  popup_composition  we referenced above:  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string , \n                      format :   topic , \n                      axRole :   inlet \n                   } \n                } \n             } \n          } \n       } \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   amd:laxar-popup-widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   [   ${topic:closeAction}   ] \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   amd:laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   amd:laxar-command-bar-widget , \n             features :   { \n                close :   { \n                   finish :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   This example already shows some of the additional characteristics that go beyond the two properties  features  and  areas .\nLet us start from the beginning:  First there is the  features  object, that for simple cases looks just like a feature specification of a widget.\nHere you can define all the features that your composition needs to be configurable from the outside.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.  Secondly there is the  areas  map and here there is already something noteworthy: The first area is simply named  . .\nAll widgets and compositions within this special area will replace the reference of the composition within the area of the page including the composition.\nSo if we take the  last example  of the chapter  Layouts and Areas , this will be the area named  content .  Furthermore the two strings  \"${features.openPopup.onActions}\"  and  \"${topic:closeAction}\"  are worth noticing as they demonstrate another main feature of the composition concept.\nThose strings are expressions that will be evaluated by the page loader when assembling the complete page from its parts and are replaced by actual values as follows:\nThe  \"${features.openPopup.onActions}\"  expression is a reference to a feature defined within the  features  object and will hold the value configured in the page including the composition.\nThus applied to the  example of the writing pages manual , this will result in the array  [ \"next\" ] .\nOn the other hand the  \"${topic:closeAction}\"  expression generates a page wide unique event topic compatible string based on the local identifier  closeAction .\nThe result could thus be something like  \"popupComposition-id0+closeAction\" , which is in fact the id generated for the composition itself, plus the local identifier.\nThese  topic expressions  prevent naming collisions with topics of the page, other compositions or multiple usages of the same composition within the same page.\nThey should always be used when there is the need to have an identifier that is only used within the scope of a composition.  Notice that these expressions are only written as a string to be JSON compatible and that no string interpolation takes place.\nThus something like  \"myPrefix${topic:closeAction}\"  would  not  be interpreted when assembling the page and simply be used as is.  The assembled page thus looks similar to this:  { \n    layout :   popups/layout_one , \n    areas :   { \n       header :   [ \n          { \n             widget :   amd:laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   amd:laxar-command-bar-widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             widget :   amd:laxar-popup-widget , \n             id :   popupComposition-id0-popup , \n             features :   { \n                open :   { \n                   onActions :   [   next   ] \n                }, \n                close :   { \n                   onActions :   [   popupComposition-id0+CloseAction   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   amd:laxar-html-display-widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ], \n       popupComposition-id0-popup.content :   [ \n          { \n             widget :   amd:laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   amd:laxar-command-bar-widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   popupComposition-id0+CloseAction \n                } \n             } \n          } \n       ] \n    }  }   Note how also the id of the exported area was automatically adjusted to  \"popupComposition-id0-popup.content\"  to prevent naming clashes.  In our example it is currently only possible to close the  laxar-popup-widget  from within itself via an action event published by the  laxar-command-bar-widget .\nWhat if we additionally would like to close the popup on demand from outside based on another action?\nThis is where the concept of  merged features  comes into play. Merged features  allow us to merge or better concatenate two arrays, where one array is defined as a feature for the composition and the second array is defined in the  mergedFeatures  object.\nSyntactically this is achieved via a map under the key  mergedFeatures  where the key of each entry is the path to the array in the features and the value is the array to merge this value with.  This should become clear when looking at our adjusted example:  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string , \n                      format :   topic , \n                      axRole :   inlet \n                   } \n                } \n             } \n          }, \n          closePopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   default :   [], \n                   items :   { \n                      type :   string , \n                      format :   topic , \n                      axRole :   inlet \n                   } \n                } \n             } \n          } \n       } \n    }, \n    mergedFeatures :   { \n       closePopup.onActions :   [   ${topic:closeAction}   ] \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   amd:laxar-popup-widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   ${features.closePopup.onActions} \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   amd:laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   amd:laxar-command-bar-widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   Here we added the possibility to configured close actions for the  laxar-popup-widget  as feature  closePopup.onActions .\nFor this we then added an entry in the  mergedFeatures  map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the  laxar-popup-widget .\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the  openPopup.onActions  feature.\nFor the configuration of the  laxar-command-bar-widget  nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#appendix", 
            "text": "", 
            "title": "Appendix:"
        }, 
        {
            "location": "/manuals/writing_compositions/#exemplary-page-from-writing-pages-manual", 
            "text": "{ \n    layout :   popups/layout_one , \n    areas :   { \n       header :   [ \n          { \n             widget :   amd:laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   amd:laxar-command-bar-widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             composition :   popup_composition , \n             features :   { \n                openPopup :   { \n                   onActions :   [   next   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   amd:laxar-html-display-bar-widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ] \n    }  }", 
            "title": "Exemplary page from writing pages manual"
        }, 
        {
            "location": "/manuals/writing_pages/", 
            "text": "Writing Pages\n\n\n\u00ab return to the manuals\n\n\nPages are written in a declarative fashion using the JSON format.\nThey are defined using a simple object with some specific properties that will be explained in this document.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nLayouts and Areas\n\n\nFirst of all a page should specify the layout which defines the available widget areas and how they are arranged visually when rendered by the web browser.\nIf a page is intended to be used as a base page for \ninheritance\n, the layout property should be omitted.\nThis is because only one page in an extension chain may define a layout and this most probably will be one at the bottom of the hierarchy.\n\n\nConfiguring the layout is done via the \nlayout\n property of the page object.\nIts value is the name of the layout which is in turn a relative path within the layout folder to where the specific layout's assets are located.\nIf for example the desired layout is located at \npopups/layout_one\n, the corresponding page (without any widgets so far) would look like this:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n\n\n}\n\n\n\n\n\n\nNow let us assume the HTML file of \npopups/layout_one\n looks like this:\n\n\n\n\ndiv\n\n   \ndiv\n \nax-widget-area=\nheader\n/div\n\n   \ndiv\n \nax-widget-area=\ncontent\n/div\n\n   \ndiv\n \nax-widget-area=\nfooter\n/div\n\n\n/div\n\n\n\n\n\n\nObviously there are three areas available, that can be occupied by widgets on the page.\nTo do so, we add another top-level key \nareas\n parallel to\nlayout\n.\nIts value is a map, where each key is the name of a widget area defined in the layout and the values are arrays, that will later list the widgets to render.\nWithout any widgets yet, We thus get the following page file:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWhen adding widgets to an area, the order is important, as this is the order in which the widgets will be rendered in the DOM.\nEach entry in the array is an object that can either reference a widget or a \ncomposition\n.\nIt thus needs to specify either \nwidget\n or \ncomposition\n as key.\nAdditionally a page wide unique (even over inheritance) \nid\n property can be provided.\nThis can be useful for debugging and is mandatory in case a widget provides one or more embedded areas, such as those created by the \nlaxar-popup-widget\n.\nFinally it is possible to provide the configuration for features of a widget or a composition under the key \nfeatures\n.\n\n\nHere is the example with some simple, exemplary content:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe object under \nfeatures\n needs to satisfy the schema defined for the features of the according widget in the file \nwidget.json\n.\nWhen loading a page and its widgets, LaxarJS will actually validate the configuration provided in the page against the widget's schema and throw an error in case one or more constraints are violated.\n\n\nEmbedded Layouts\n\n\nThere are use cases where it is not sufficient to reference one single page layout and place all widgets of a page within that layout, but where more flexibility is needed.\nEspecially when trying to reuse existing layouts, it may be necessary to embedded another layout within the area of a global page layout.\n\n\nTo support this hassle-free, layouts are first-class citizens just as widgets or \ncompositions\n within areas.\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nareas\n:\n \n{\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nlayout\n:\n \nother_layouts/small_columns\n,\n\n            \nid\n:\n \nembedded\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nembedded.left\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nsomeResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nAs seen in the example from above simply the key \nlayout\n should be used instead of \nwidget\n.\nIts value is - just like the main \nlayout\n property of a page - the path of a specific layout directory within the layout folder of the application.\nProviding an \nid\n is obligatory since otherwise it would be impossible to reference a widget area defined within the layout.\nUnder the assumption that the layout \nother_layouts/small_columns\n exports a widget area named \nleft\n, we can now insert widgets into it using the area name \nembedded.left\n for it.\n\n\nNote that providing \nfeatures\n to a layout entry does not lead to an error, but simply is ignored.\n\n\nInheritance\n\n\nThe most simple way to reuse parts of a page specification is by inheritance.\nDue to the intentional lack of complex additional inheritance features it is also the most limited way of specification reuse.\nNevertheless it has its valid use cases as in every user interface there are some elements that never change across pages.\nThese should be extracted into one or more base pages, that define no layout and can be reused by all other pages defining the layout necessary to display their contents.\n\n\nValid candidate widgets for base pages are application headlines, informational notes in a footer area or activities providing common tasks for all pages.\nLet us apply this to our example from above and extract the \nlaxar-headline-widget\n into a base page called \nbase_page.json\n.\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWe now can modify our original page using the keyword \nextends\n that references the base page relatively to the root path for all pages.\nThe parts already provided by the base page can then be deleted:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nextends\n:\n \nbase_page\n,\n\n   \nareas\n:\n \n{\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup_composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIt is also possible to add widgets to an area, that is already filled with one or more widgets in the base page.\nThose widgets in the extending page will be appended to the according area and thus appear after the base widgets in the DOM.\nIf a widget of the extending page should explicitly be added before another widget of a base page, this can be achieved using the keyword \ninsertBeforeId\n.\nNote that for this to work it's necessary to provide an \nid\n property for the according widget in the base page.\n\n\nLet us assume we wanted to add another additional headline in one extending page.\nWe therefore change the base page first and add an id to the existing headline:\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \nid\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHence the page that has the need to add content can reference the given id using \ninsertBeforeId\n like this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout_one\n,\n\n   \nextends\n:\n \nbase_page\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \namd:laxar-headline-widget\n,\n\n            \ninsertBeforeId\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \ni18nHtmlText\n:\n \nYou just won one billion dollar!\n\n                \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n \n ... some widgets ... \n \n],\n\n      \nfooter\n:\n \n[\n \n ... some widgets ... \n \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis is all one needs to build basic pages for LaxarJS.\nIt might become necessary to split pages into smaller, possibly reusable chunks, which is the task compositions where designed for.\nSo if the need arises, read on in the manual for \nwriting compositions\n.", 
            "title": "Writing Pages"
        }, 
        {
            "location": "/manuals/writing_pages/#writing-pages", 
            "text": "\u00ab return to the manuals  Pages are written in a declarative fashion using the JSON format.\nThey are defined using a simple object with some specific properties that will be explained in this document.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities", 
            "title": "Writing Pages"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/", 
            "text": "Writing Widget Controllers\n\n\n\u00ab return to the manuals\n\n\nThe basic layout and properties of a widget controller and its module depend on the underlying integration technology.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nAs soon as the controller has been instantiated, communication mostly takes place over the event bus using common \nevents\n, and all functionality is written in the style specific to the corresponding technology.\nAdditionally some libraries may be used to simplify recurring tasks, like e.g. \nLaxarJS Patterns\n for common event bus interaction patterns.\n\n\nThe purpose of this manual is to describe how a basic setup for a widget using one of the built-in technologies is established.\n\n\nSelecting an Integration Technology\n\n\nThe selection of an integration technology takes place in the \nwidget.json\n of each widget.\n\n\nFor example:\n\n\n{\n\n   \nname\n:\n \nmy-plain-widget\n,\n\n   \nintegration\n:\n \n{\n\n      \ntype\n:\n \nwidget\n,\n\n      \ntechnology\n:\n \nplain\n\n   \n},\n\n   \nfeatures\n:\n \n{\n \n...\n \n}\n\n\n}\n\n\n\n\n\n\nFor now this is limited to \nangular\n and \nplain\n.\nIn case you developed \nyour own widget adapter\n, this is of course available as well under the name the adapter exports as \ntechnology\n property.\n\n\nAvailable Integration Technologies\n\n\nOut of the box LaxarJS currently supports two different integration technologies:\nPlain Javascript widgets and widgets defining an \nAngularJS\n module and controller.\nIn the following both technologies are described.\n\n\nNote that for the time being all widgets have to be defined as \nAMD module\n, since this is the way LaxarJS bootstraps them.\n\n\nPlain JavaScript Widgets\n\n\nPlain JavaScript widgets are bootstrapped without any specific library or framework.\nThis allows the implementation of a widget in pure vanilla JavaScript, or the direct usage of smaller, non-invasive libraries for rendering and controller implementation.\nFor example a chart widget can be implemented using just \nD3.js\n directly, to render a chart into an SVG element.\nEven more obviously activities can be implemented using the \nplain\n integration technology, because there is no need at all for a UI rendering library.\n\n\nWhen implementing a plain widget, its AMD module must simply return an object with three properties, where two are mandatory:\n\n\n\n\n\n\nname\n: this is the name of the widget's module and \nmust\n equal the \nname\n property from the \nwidget.json\n.\n Note that this is different from AngularJS widgets, where \ncamelCased\n names are used).\n\n\n\n\n\n\ncreate\n: this is the bootstrapping function for a controller instance.\n\n\n\n\n\n\nIn case of an activity (which has no HTML template) there is no need to return anything in here.\n  If on the other hand a widget should have its UI rendered as child of the area it was added to, this function \nmust\n return an object with a \nrenderTo\n function as single property.\n  This function will be called as soon as the widget instance is attached to the DOM.\n  It receives the wrapper \ndiv\n element created by the widget adapter as single argument.\n  When this function is called, the contents of the HTML template have already been added to this element as \ninnerHTML\n.\n\n\nThe parameters of the \ncreate\n function must correspond to the optional \ninjections\n, explained in the following.\n\n\n\n\ninjections\n: an optional listing of services to inject into the \ncreate\n function.\n  Each item is the name of a service to inject into a new controller instance.\n  The order in this list determines the order the services are passed into the \ncreate\n function.\n\n\n\n\nAvailable injections\n are listed below.\n\n\nAn example of a simple plain widget, called \nmy-plain-widget\n:\n\n\ndefine\n(\n \n[\n \nlaxar-patterns\n \n],\n \nfunction\n(\n \npatterns\n \n)\n \n{\n\n\n   \nreturn\n \n{\n\n      \nname\n:\n \nmy-plain-widget\n,\n\n      \ninjections\n:\n \n[\n \naxContext\n \n],\n\n      \ncreate\n:\n \nfunction\n(\n \ncontext\n \n)\n \n{\n\n         \n// LaxarJS Patterns works great with plain widgets.\n\n         \n// The configured resource will be managed on `context.resources.myResource`\n\n         \npatterns\n.\nresources\n.\nhandlerFor\n(\n \ncontext\n \n)\n\n            \n.\nregisterResourceFromFeature\n(\n \nmyResource\n \n);\n\n\n         \nif\n(\n \ncontext\n.\nfeatures\n.\nfancyFeature\n.\nsomething\n \n)\n \n{\n\n            \n// do something fancy if the feature is set\n\n         \n}\n\n\n         \nreturn\n \n{\n\n            \nrenderTo\n:\n \nfunction\n(\n \nelement\n \n)\n \n{\n\n               \n// The widget has been attached to the DOM and initialize its DOM representation:\n\n               \nelement\n.\nquerySelector\n(\n \n.output\n \n).\ninnerHTML\n \n=\n \nHello World\n;\n\n            \n}\n\n         \n};\n\n\n      \n}\n\n   \n};\n\n\n\n}\n \n);\n\n\n\n\n\n\nNote that this widget is using the \nlaxar-patterns\n library to manage resource events.\nOf course, using this library is completely optional.\n\n\nAssume this as the accompanying template:\n\n\nh1\nMy Plain Widget\n/h1\n\n\nspan\n \nclass=\noutput\n/span\n\n\n\n\n\n\nWhen the LaxarJS runtime calls \nrenderTo\n with the anchor element, the \nh1\n and \nspan\n elements are already appended to it.\nHence, the call to \nquerySelector\n will successfully return the \nspan\n with class \noutput\n, and its HTML content is set to \"Hello World\".\nAnything else, like including and using external libraries for example, is left to the user.\n\n\nAngularJS (1.x) Widgets\n\n\nIn contrast to plain widgets, AngularJS widgets are defined by using standard AngularJS modules:\n\n\nThe AMD module must return an AngularJS module as its sole export, following the AngularJS naming scheme, where the module name \nmust\n equal the \nname\n property in the \nwidget.json\n in camel-case notation with lower-case first letter.\nThe widget controller must use the module name as well, but with \"Controller\" appended and an upper-case first letter (taken from \nJohn Papa's style guide\n, which is referenced from \nthe official AngularJS blog\n).\nIf for example the widget is called \nmy-first-angular-widget\n, the module would be named \nmyFirstAngularWidget\n and the controller \nMyFirstAngularWidgetController\n in consequence.\n\n\nJust like with plain widgets, the template will be wrapped in a \ndiv\n element and automatically appended to the DOM subtree of the corresponding widget area.\nAdditionally, after compilation the template is linked to an AngularJS Scope, which can be injected into the controller as \n$scope\n.\nAll injections mentioned for plain widgets are also available via default AngularJS DI mechanisms, in addition to those offered by AngularJS out of the box.\nIt is also possible to define widget-specific directives, filters and services directly on the widget module.\nThere are no artificial restrictions for AngularJS widgets, but when creating a directive or service that might be of use to other widget authors, consider extracting it into a separate \ncontrol\n.\n\n\nHere is an example using AngularJS as technology to achieve the same as with the plain widget above (only that we'll call it \nmy-angular-widget\n here):\n\n\ndefine\n(\n \n[\n \nangular\n,\n \nlaxar-patterns\n \n],\n \nfunction\n(\n \nng\n,\n \npatterns\n \n)\n \n{\n\n\n   \n// We always use named injections to be save when applying minification.\n\n   \n// We chose this rather strange syntax utilizing function hoisting, to prevent from\n\n   \n// too many array brackets and nevertheless have the names next to the actual\n\n   \n// controller arguments. Feel free to write this anyway you like and feel\n\n   \n// comfortable with when defining controllers in AngularJS.\n\n   \nController\n.\n$inject\n(\n \n$scope\n \n);\n\n\n   \nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n\n      \n// In AngularJS we set scope properties and never manipulate the DOM directly\n\n      \n// from within a controller.\n\n      \n$scope\n.\nmyString\n \n=\n \nHello World\n;\n\n\n      \n// Notice how we can use $scope instead of axContext here, as both provide the\n\n      \n// same relevant properties for the patterns library.\n\n      \npatterns\n.\nresources\n.\nhandlerFor\n(\n \n$scope\n \n)\n\n         \n.\nregisterResourceFromFeature\n(\n \nmyResource\n \n);\n\n\n      \nif\n(\n \ncontext\n.\nfeatures\n.\nfancyFeature\n.\nsomething\n \n)\n \n{\n\n         \n// do something fancy if the feature is set\n\n      \n}\n\n   \n}\n\n\n   \n// Finally, we return the module with our controller.\n\n   \nreturn\n \nng\n.\nmodule\n(\n \nmyAngularWidget\n \n)\n\n      \n.\ncontroller\n(\n \nMyAngularWidgetController\n,\n \nController\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\nThe template then looks like this:\n\n\nh1\nMy Angular Widget\n/h1\n\n\nspan\n \nclass=\noutput\n{{ myString }}\n/span\n\n\n\n\n\n\nAvailable Injections\n\n\nFor both integration types the same basic set of injectable services or objects is available.\nIn case of AngularJS widgets it is of course possible to add more services to the list via standard dependency injection mechanisms.\nOn the other hand the \n$scope\n is not available for plain widgets, but \naxContext\n should provide all the useful parts.\nBut out of the box these are the injections provided by LaxarJS:\n\n\n\n\n\n\naxEventBus\n: the \nevent bus\n instance for this widget.\n\n\n\n\n\n\naxFeatures\n: the features configured for this widget by the containing page (more on \nconfiguration options\n and \nwriting pages\n).\n\n\n\n\n\n\naxContext\n: this is a complete object containing all configuration and API specifically available to this widget instance and has mostly the same properties as the \n$scope\n injection  of an AngularJS widget.\n  The \naxEventBus\n and \naxFeatures\n injections explained before are available as \neventBus\n and \nfeatures\n properties of \naxContext\n.\n  In addition the context provides an \nid\n function to generate globally unique ids using a short, local reference, and a \nwidget\n object providing some more details of the widget instance.\n  While the \nid\n function should always be used when creating ids within a widget, the \nwidget\n property should simply be ignored.\n\n\n\n\n\n\naxFlowService\n: a service offering help in working with the application flow, to e.g. create links for navigation to a place or target.\n  So if for example you don't want navigation to happen only through events, but would like to use accessible \na\n elements, you can find the right tools there.\n  Have a look at the \nflow API\n for further information.\n\n\n\n\n\n\nRuntime Services\n: all injectable services defined in the runtime services of LaxarJS.\n  For detailed information on the available services have a look at the \nruntime services API\n.\n\n\n\n\n\n\nImportant note\n: The \naxGlobalEventBus\n from the runtime services should \nnever\n be used directly in a widget implementation, unless you know exactly what you are doing.\n  Firstly, the sender information will not automatically be set for you when publishing events through the global event bus, and secondly subscriptions won't get removed when the widget instance is destroyed due to navigation.\n  Especially the latter can have a severe impact, as this introduces a memory leak, possibly over the full function scope of the widget controller.\n  In this situation, the memory would only get released when navigating away from the LaxarJS application or refreshing the page via browser refresh.\n\n\nBYOA (Bring Your Own Adapter)\n\n\nIf the existing integration technologies don't satisfy your needs and you need to implement your own adapter, just have a look at the \nmanual on adapters\n.\nThe built-in adapters are a good reference to start with.", 
            "title": "Writing Widget Controllers"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/#writing-widget-controllers", 
            "text": "\u00ab return to the manuals  The basic layout and properties of a widget controller and its module depend on the underlying integration technology.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities   As soon as the controller has been instantiated, communication mostly takes place over the event bus using common  events , and all functionality is written in the style specific to the corresponding technology.\nAdditionally some libraries may be used to simplify recurring tasks, like e.g.  LaxarJS Patterns  for common event bus interaction patterns.  The purpose of this manual is to describe how a basic setup for a widget using one of the built-in technologies is established.", 
            "title": "Writing Widget Controllers"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/#selecting-an-integration-technology", 
            "text": "The selection of an integration technology takes place in the  widget.json  of each widget.  For example:  { \n    name :   my-plain-widget , \n    integration :   { \n       type :   widget , \n       technology :   plain \n    }, \n    features :   {   ...   }  }   For now this is limited to  angular  and  plain .\nIn case you developed  your own widget adapter , this is of course available as well under the name the adapter exports as  technology  property.", 
            "title": "Selecting an Integration Technology"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/#available-integration-technologies", 
            "text": "Out of the box LaxarJS currently supports two different integration technologies:\nPlain Javascript widgets and widgets defining an  AngularJS  module and controller.\nIn the following both technologies are described.  Note that for the time being all widgets have to be defined as  AMD module , since this is the way LaxarJS bootstraps them.", 
            "title": "Available Integration Technologies"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/#plain-javascript-widgets", 
            "text": "Plain JavaScript widgets are bootstrapped without any specific library or framework.\nThis allows the implementation of a widget in pure vanilla JavaScript, or the direct usage of smaller, non-invasive libraries for rendering and controller implementation.\nFor example a chart widget can be implemented using just  D3.js  directly, to render a chart into an SVG element.\nEven more obviously activities can be implemented using the  plain  integration technology, because there is no need at all for a UI rendering library.  When implementing a plain widget, its AMD module must simply return an object with three properties, where two are mandatory:    name : this is the name of the widget's module and  must  equal the  name  property from the  widget.json .\n Note that this is different from AngularJS widgets, where  camelCased  names are used).    create : this is the bootstrapping function for a controller instance.    In case of an activity (which has no HTML template) there is no need to return anything in here.\n  If on the other hand a widget should have its UI rendered as child of the area it was added to, this function  must  return an object with a  renderTo  function as single property.\n  This function will be called as soon as the widget instance is attached to the DOM.\n  It receives the wrapper  div  element created by the widget adapter as single argument.\n  When this function is called, the contents of the HTML template have already been added to this element as  innerHTML .  The parameters of the  create  function must correspond to the optional  injections , explained in the following.   injections : an optional listing of services to inject into the  create  function.\n  Each item is the name of a service to inject into a new controller instance.\n  The order in this list determines the order the services are passed into the  create  function.   Available injections  are listed below.  An example of a simple plain widget, called  my-plain-widget :  define (   [   laxar-patterns   ],   function (   patterns   )   { \n\n    return   { \n       name :   my-plain-widget , \n       injections :   [   axContext   ], \n       create :   function (   context   )   { \n          // LaxarJS Patterns works great with plain widgets. \n          // The configured resource will be managed on `context.resources.myResource` \n          patterns . resources . handlerFor (   context   ) \n             . registerResourceFromFeature (   myResource   ); \n\n          if (   context . features . fancyFeature . something   )   { \n             // do something fancy if the feature is set \n          } \n\n          return   { \n             renderTo :   function (   element   )   { \n                // The widget has been attached to the DOM and initialize its DOM representation: \n                element . querySelector (   .output   ). innerHTML   =   Hello World ; \n             } \n          }; \n\n       } \n    };  }   );   Note that this widget is using the  laxar-patterns  library to manage resource events.\nOf course, using this library is completely optional.  Assume this as the accompanying template:  h1 My Plain Widget /h1  span   class= output /span   When the LaxarJS runtime calls  renderTo  with the anchor element, the  h1  and  span  elements are already appended to it.\nHence, the call to  querySelector  will successfully return the  span  with class  output , and its HTML content is set to \"Hello World\".\nAnything else, like including and using external libraries for example, is left to the user.", 
            "title": "Plain JavaScript Widgets"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/#angularjs-1x-widgets", 
            "text": "In contrast to plain widgets, AngularJS widgets are defined by using standard AngularJS modules:  The AMD module must return an AngularJS module as its sole export, following the AngularJS naming scheme, where the module name  must  equal the  name  property in the  widget.json  in camel-case notation with lower-case first letter.\nThe widget controller must use the module name as well, but with \"Controller\" appended and an upper-case first letter (taken from  John Papa's style guide , which is referenced from  the official AngularJS blog ).\nIf for example the widget is called  my-first-angular-widget , the module would be named  myFirstAngularWidget  and the controller  MyFirstAngularWidgetController  in consequence.  Just like with plain widgets, the template will be wrapped in a  div  element and automatically appended to the DOM subtree of the corresponding widget area.\nAdditionally, after compilation the template is linked to an AngularJS Scope, which can be injected into the controller as  $scope .\nAll injections mentioned for plain widgets are also available via default AngularJS DI mechanisms, in addition to those offered by AngularJS out of the box.\nIt is also possible to define widget-specific directives, filters and services directly on the widget module.\nThere are no artificial restrictions for AngularJS widgets, but when creating a directive or service that might be of use to other widget authors, consider extracting it into a separate  control .  Here is an example using AngularJS as technology to achieve the same as with the plain widget above (only that we'll call it  my-angular-widget  here):  define (   [   angular ,   laxar-patterns   ],   function (   ng ,   patterns   )   { \n\n    // We always use named injections to be save when applying minification. \n    // We chose this rather strange syntax utilizing function hoisting, to prevent from \n    // too many array brackets and nevertheless have the names next to the actual \n    // controller arguments. Feel free to write this anyway you like and feel \n    // comfortable with when defining controllers in AngularJS. \n    Controller . $inject (   $scope   ); \n\n    function   Controller (   $scope   )   { \n\n       // In AngularJS we set scope properties and never manipulate the DOM directly \n       // from within a controller. \n       $scope . myString   =   Hello World ; \n\n       // Notice how we can use $scope instead of axContext here, as both provide the \n       // same relevant properties for the patterns library. \n       patterns . resources . handlerFor (   $scope   ) \n          . registerResourceFromFeature (   myResource   ); \n\n       if (   context . features . fancyFeature . something   )   { \n          // do something fancy if the feature is set \n       } \n    } \n\n    // Finally, we return the module with our controller. \n    return   ng . module (   myAngularWidget   ) \n       . controller (   MyAngularWidgetController ,   Controller   );  }   );   The template then looks like this:  h1 My Angular Widget /h1  span   class= output {{ myString }} /span", 
            "title": "AngularJS (1.x) Widgets"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/#available-injections", 
            "text": "For both integration types the same basic set of injectable services or objects is available.\nIn case of AngularJS widgets it is of course possible to add more services to the list via standard dependency injection mechanisms.\nOn the other hand the  $scope  is not available for plain widgets, but  axContext  should provide all the useful parts.\nBut out of the box these are the injections provided by LaxarJS:    axEventBus : the  event bus  instance for this widget.    axFeatures : the features configured for this widget by the containing page (more on  configuration options  and  writing pages ).    axContext : this is a complete object containing all configuration and API specifically available to this widget instance and has mostly the same properties as the  $scope  injection  of an AngularJS widget.\n  The  axEventBus  and  axFeatures  injections explained before are available as  eventBus  and  features  properties of  axContext .\n  In addition the context provides an  id  function to generate globally unique ids using a short, local reference, and a  widget  object providing some more details of the widget instance.\n  While the  id  function should always be used when creating ids within a widget, the  widget  property should simply be ignored.    axFlowService : a service offering help in working with the application flow, to e.g. create links for navigation to a place or target.\n  So if for example you don't want navigation to happen only through events, but would like to use accessible  a  elements, you can find the right tools there.\n  Have a look at the  flow API  for further information.    Runtime Services : all injectable services defined in the runtime services of LaxarJS.\n  For detailed information on the available services have a look at the  runtime services API .    Important note : The  axGlobalEventBus  from the runtime services should  never  be used directly in a widget implementation, unless you know exactly what you are doing.\n  Firstly, the sender information will not automatically be set for you when publishing events through the global event bus, and secondly subscriptions won't get removed when the widget instance is destroyed due to navigation.\n  Especially the latter can have a severe impact, as this introduces a memory leak, possibly over the full function scope of the widget controller.\n  In this situation, the memory would only get released when navigating away from the LaxarJS application or refreshing the page via browser refresh.", 
            "title": "Available Injections"
        }, 
        {
            "location": "/manuals/writing_widget_controllers/#byoa-bring-your-own-adapter", 
            "text": "If the existing integration technologies don't satisfy your needs and you need to implement your own adapter, just have a look at the  manual on adapters .\nThe built-in adapters are a good reference to start with.", 
            "title": "BYOA (Bring Your Own Adapter)"
        }
    ]
}