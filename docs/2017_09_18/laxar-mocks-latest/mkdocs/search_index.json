{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS Mocks \n\n\n\n\nThe companion testing framework for LaxarJS widgets.\n\n\n\n\n\n   Take a look at the \ndocumentation site\n to browse documentation for all releases of this artifact.\n\n\n\nWhat is LaxarJS Mocks?\n\n\nLaxarJS Mocks\n simplifies writing tests for \nLaxarJS\n widgets, and helps running them.\n\n\nIt is a library that allows you to instantiate a testing sandbox for widgets, and that helps you to mock the services and the lifecycle events that LaxarJS provides.\nUse \nLaxarJS Mocks\n on top of Jasmine to setup and load a widget just like in an actual application.\nThe available APIs then support you in instrumenting and inspecting the widget under test.\n\n\nAlthough most widgets only have little direct dependency on \nLaxarJS\n (often they use only its event bus) and should mostly follow the best practices for their rendering technology such as \nAngularJS\n, \nReact\n or \nVue.js\n, they rely on a specific setup process provided by the LaxarJS runtime and tools.\n\n\nThis setup process includes\n - acquiring relevant assets (such as templates and stylesheets),\n - providing configuration and services (such as the event bus),\n - creation of the controller and rendering at the right time,\n - publishing the initial lifecycle events.\n\n\nLaxarJS Mocks\n provides a programmatic interface to control this process and to load a widget within a test.\nIt comes with the \nlaxar-mocks/spec-loader\n for webpack, which makes sure that all controls and assets required for a widget test are collected, and that the appropriate adapter is loaded.\n\n\nFor an introduction to \nLaxarJS Mocks\n and details on test runner setup, have a look at the \nmanuals\n.\nAdditionally the \nAPI docs\n provide detailed information on the configuration, instrumentation and inspection options.\n\n\nGetting Started\n\n\nUsually, LaxarJS projects are started from the \nYeoman Generator for LaxarJS 2.x\n, which automatically sets up LaxarJS Mocks for you, along with webpack and karma.\nIf you need to perform a manual setup, for example as part of upgrading a LaxarJS 1.x project, there is an additional \nsetup manual\n.\n\n\nHacking the Library\n\n\nInstead of using a pre-compiled library within a project, you can also clone this repository:\n\n\ngit clone https://github.com/LaxarJS/laxar-mocks.git\n\n\ncd laxar-mocks\n\n\nnpm install\n\n\n\n\n\n\nTo see changes in your application, either configure your project to work with the sources (e.g. by using webpack), or rebuild the webpack bundles by running \nnpm run dist\n.\n\n\nTo run the automated karma tests:\n\n\nnpm test\n\n\n\n\n\n\nTo generate HTML spec runners for opening in your web browser, so that you can e.g. use the browser's developer tools:\n\n\nnpm start\n\n\n\n\n\n\nNow you open the spec-runner by browsing to http://localhost:8081/dist/spec/laxar-mocks.spec.html.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs-mocks", 
            "text": "The companion testing framework for LaxarJS widgets.   \n   Take a look at the  documentation site  to browse documentation for all releases of this artifact.", 
            "title": "LaxarJS Mocks"
        }, 
        {
            "location": "/#what-is-laxarjs-mocks", 
            "text": "LaxarJS Mocks  simplifies writing tests for  LaxarJS  widgets, and helps running them.  It is a library that allows you to instantiate a testing sandbox for widgets, and that helps you to mock the services and the lifecycle events that LaxarJS provides.\nUse  LaxarJS Mocks  on top of Jasmine to setup and load a widget just like in an actual application.\nThe available APIs then support you in instrumenting and inspecting the widget under test.  Although most widgets only have little direct dependency on  LaxarJS  (often they use only its event bus) and should mostly follow the best practices for their rendering technology such as  AngularJS ,  React  or  Vue.js , they rely on a specific setup process provided by the LaxarJS runtime and tools.  This setup process includes\n - acquiring relevant assets (such as templates and stylesheets),\n - providing configuration and services (such as the event bus),\n - creation of the controller and rendering at the right time,\n - publishing the initial lifecycle events.  LaxarJS Mocks  provides a programmatic interface to control this process and to load a widget within a test.\nIt comes with the  laxar-mocks/spec-loader  for webpack, which makes sure that all controls and assets required for a widget test are collected, and that the appropriate adapter is loaded.  For an introduction to  LaxarJS Mocks  and details on test runner setup, have a look at the  manuals .\nAdditionally the  API docs  provide detailed information on the configuration, instrumentation and inspection options.", 
            "title": "What is LaxarJS Mocks?"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Usually, LaxarJS projects are started from the  Yeoman Generator for LaxarJS 2.x , which automatically sets up LaxarJS Mocks for you, along with webpack and karma.\nIf you need to perform a manual setup, for example as part of upgrading a LaxarJS 1.x project, there is an additional  setup manual .", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#hacking-the-library", 
            "text": "Instead of using a pre-compiled library within a project, you can also clone this repository:  git clone https://github.com/LaxarJS/laxar-mocks.git  cd laxar-mocks  npm install   To see changes in your application, either configure your project to work with the sources (e.g. by using webpack), or rebuild the webpack bundles by running  npm run dist .  To run the automated karma tests:  npm test   To generate HTML spec runners for opening in your web browser, so that you can e.g. use the browser's developer tools:  npm start   Now you open the spec-runner by browsing to http://localhost:8081/dist/spec/laxar-mocks.spec.html.", 
            "title": "Hacking the Library"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv2.0.0\n\n\nv2.0.0-rc.2\n\n\n\n\n#58\n: fixed dependencies in package.json\n\n\n\n\nv2.0.0-rc.1\n\n\n\n\n#57\n: documentation: fixed broken link\n\n\n\n\nv2.0.0-rc.0\n\n\n\n\n#56\n: use laxar-infrastructure, upgrade to latest laxar and laxar-tooling\n\n\n\n\nv2.0.0-beta.4\n\n\n\n\n#55\n: adjusted to LaxarJS/laxar#447\n\n\n#54\n: removed misleading comment regarding promise-patching\n\n\n\n\nv2.0.0-beta.3\n\n\n\n\n#53\n: adapted to the new LaxarJS bootstrapping API (LaxarJS/laxar#437)\n\n\n#52\n: tearDown: complain if \ndone\n callback is missing\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv2.0.0-beta.2\n\n\n\n\n\n\n#48\n: removed initial \ndidChangeTheme\n event\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#49\n: event bus error details are now forwarded to the console\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#47\n: project: \nlaxar-widget-service-mocks\n have been removed from the bundle\n\n\n\n\n\n\nv2.0.0-beta.1\n\n\n\n\n\n\n#46\n: pass spec fixtures using the \ninit\n method\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#45\n: publish \nendLifecycleRequest\n on tearDown\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\nv2.0.0-beta.0\n\n\n\n\n#44\n: eventBus: added error handler\n\n\n#43\n: fixed line numbers in spec-loader output\n\n\n#40\n: updated manual for v2.0.0\n\n\n\n\nv2.0.0-alpha.3\n\n\n\n\n\n\n#31\n: added \naxMocks.widget.whenServicesAvailable\n to intercept and configure widget injections from tests\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#42\n: fixed injection of visibility mock\n\n\n\n\n#41\n: new \nsetupForWidget\n API, deprecated \ncreateSetupForWidget\n\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv2.0.0-alpha.2\n\n\n\n\n#39\n: added \"browser\" target to \npackage.json\n\n\n#38\n: fixed reporting of AJV validation errors\n\n\n\n\nv2.0.0-alpha.1\n\n\n\n\n#37\n: adapted to laxar API change (LaxarJS/laxar#413)\n\n\n#35\n: project: updated dev-dependencies, upgraded to webpack 2\n\n\n#33\n: features: validate widget features at runtime\n\n\n#34\n: services: a mocked area helper service can now be injected\n\n\n#32\n: adapters with asynchronous create method are now supported\n\n\n#28\n: fixed mock injections for axAssets and axConfiguration\n\n\n#27\n: updated for LaxarJS v2.0 compatibility (laxar#358)\n\n\n\n\nv2.0.0-alpha.0\n\n\n\n\n\n\n#26\n: updated for LaxarJS v2.0 compatibility\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#24\n: documentation: added missing information on the widget ID\n\n\n\n\n\n\nv1.0.0\n\n\n\n\n#23\n: project: updated copyright year in file header\n\n\n\n\nv1.0.0-alpha.1\n\n\n\n\n#21\n: respect flush/applyViewChanges interaction\n\n\n\n\nv1.0.0-alpha.0\n\n\n\n\n#17\n: added missing API doc entries\n\n\n#19\n: allowed adding \nflush()\n method to \nax.fn.debounce\n results\n\n\n#20\n: added mock promise factory support for \nlaxar._tooling.provideQ\n\n\n#18\n: eventBus: made mock use correct promise factory\n\n\n\n\nv0.6.0\n\n\n\n\n#16\n: fixed optionality of options in createSetupForWidget\n\n\n\n\nv0.5.0\n\n\n\n\n#15\n: allow custom technology adapters\n\n\n#14\n: pass axControls to widget loader\n\n\n\n\nv0.4.0\n\n\n\n\n#12\n: adapters: adjust to changes in LaxarJS tooling API\n\n\n#13\n: project: renamed to laxar-mocks\n\n\n#11\n: example: fixed one-off bug in HTML spec-runner\n\n\n\n\n#9\n: example: spec-runner now takes URL parameter for config-lookup\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#7\n: example: fixed license header of spec-runner config\n\n\n\n\n\n\nv0.3.0\n\n\n\n\n\n\n#6\n: use different paths to access jasmine and jasmine2, use opt-in config for new test-runner\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#7\n: project: relaxed version constraint for angular-mocks (1.3.16 -\n ~1.3.17 || ~1.4.2)\n\n\n\n\n#8\n: fixed example boot sequence (removed jasmine boot)\n\n\n\n\n#5\n: added Travis-CI build integration\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#4\n: Fixed dependency to Jasmine\n\n\n\n\n#3\n: Fixed construction of test paths for RequireJS\n\n\n\n\nv0.2.0\n\n\n\n\n#1\n: added some tests\n\n\n\n\nv0.1.0", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v200", 
            "text": "", 
            "title": "v2.0.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc2", 
            "text": "#58 : fixed dependencies in package.json", 
            "title": "v2.0.0-rc.2"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc1", 
            "text": "#57 : documentation: fixed broken link", 
            "title": "v2.0.0-rc.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc0", 
            "text": "#56 : use laxar-infrastructure, upgrade to latest laxar and laxar-tooling", 
            "title": "v2.0.0-rc.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta4", 
            "text": "#55 : adjusted to LaxarJS/laxar#447  #54 : removed misleading comment regarding promise-patching", 
            "title": "v2.0.0-beta.4"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta3", 
            "text": "#53 : adapted to the new LaxarJS bootstrapping API (LaxarJS/laxar#437)  #52 : tearDown: complain if  done  callback is missing\n        + NEW FEATURE: see ticket for details", 
            "title": "v2.0.0-beta.3"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta2", 
            "text": "#48 : removed initial  didChangeTheme  event\n        +  BREAKING CHANGE:  see ticket for details    #49 : event bus error details are now forwarded to the console\n        + NEW FEATURE: see ticket for details    #47 : project:  laxar-widget-service-mocks  have been removed from the bundle", 
            "title": "v2.0.0-beta.2"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta1", 
            "text": "#46 : pass spec fixtures using the  init  method\n        +  BREAKING CHANGE:  see ticket for details    #45 : publish  endLifecycleRequest  on tearDown\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-beta.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta0", 
            "text": "#44 : eventBus: added error handler  #43 : fixed line numbers in spec-loader output  #40 : updated manual for v2.0.0", 
            "title": "v2.0.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha3", 
            "text": "#31 : added  axMocks.widget.whenServicesAvailable  to intercept and configure widget injections from tests\n        + NEW FEATURE: see ticket for details    #42 : fixed injection of visibility mock   #41 : new  setupForWidget  API, deprecated  createSetupForWidget \n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.3"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha2", 
            "text": "#39 : added \"browser\" target to  package.json  #38 : fixed reporting of AJV validation errors", 
            "title": "v2.0.0-alpha.2"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha1", 
            "text": "#37 : adapted to laxar API change (LaxarJS/laxar#413)  #35 : project: updated dev-dependencies, upgraded to webpack 2  #33 : features: validate widget features at runtime  #34 : services: a mocked area helper service can now be injected  #32 : adapters with asynchronous create method are now supported  #28 : fixed mock injections for axAssets and axConfiguration  #27 : updated for LaxarJS v2.0 compatibility (laxar#358)", 
            "title": "v2.0.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha0", 
            "text": "#26 : updated for LaxarJS v2.0 compatibility\n        +  BREAKING CHANGE:  see ticket for details    #24 : documentation: added missing information on the widget ID", 
            "title": "v2.0.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v100", 
            "text": "#23 : project: updated copyright year in file header", 
            "title": "v1.0.0"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha1", 
            "text": "#21 : respect flush/applyViewChanges interaction", 
            "title": "v1.0.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha0", 
            "text": "#17 : added missing API doc entries  #19 : allowed adding  flush()  method to  ax.fn.debounce  results  #20 : added mock promise factory support for  laxar._tooling.provideQ  #18 : eventBus: made mock use correct promise factory", 
            "title": "v1.0.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v060", 
            "text": "#16 : fixed optionality of options in createSetupForWidget", 
            "title": "v0.6.0"
        }, 
        {
            "location": "/CHANGELOG/#v050", 
            "text": "#15 : allow custom technology adapters  #14 : pass axControls to widget loader", 
            "title": "v0.5.0"
        }, 
        {
            "location": "/CHANGELOG/#v040", 
            "text": "#12 : adapters: adjust to changes in LaxarJS tooling API  #13 : project: renamed to laxar-mocks  #11 : example: fixed one-off bug in HTML spec-runner   #9 : example: spec-runner now takes URL parameter for config-lookup\n        + NEW FEATURE: see ticket for details    #7 : example: fixed license header of spec-runner config", 
            "title": "v0.4.0"
        }, 
        {
            "location": "/CHANGELOG/#v030", 
            "text": "#6 : use different paths to access jasmine and jasmine2, use opt-in config for new test-runner\n        +  BREAKING CHANGE:  see ticket for details    #7 : project: relaxed version constraint for angular-mocks (1.3.16 -  ~1.3.17 || ~1.4.2)   #8 : fixed example boot sequence (removed jasmine boot)   #5 : added Travis-CI build integration\n        + NEW FEATURE: see ticket for details    #4 : Fixed dependency to Jasmine   #3 : Fixed construction of test paths for RequireJS", 
            "title": "v0.3.0"
        }, 
        {
            "location": "/CHANGELOG/#v020", 
            "text": "#1 : added some tests", 
            "title": "v0.2.0"
        }, 
        {
            "location": "/CHANGELOG/#v010", 
            "text": "", 
            "title": "v0.1.0"
        }, 
        {
            "location": "/api/laxar-mocks/", 
            "text": "laxar-mocks\n\n\nA testing framework for LaxarJS widgets.\n\n\nContents\n\n\nModule Members\n\n\n\n\nTEST_WIDGET_ID\n\n\ninit()\n\n\ntearDown()\n\n\ntriggerStartupEvents()\n\n\nsetupForWidget()\n\n\ncreateSetupForWidget()\n\n\n\n\nTypes\n\n\n\n\nWidget\n\n\nWidget.configure()\n\n\nWidget.whenServicesAvailable()\n\n\nWidget.load()\n\n\nWidget.render()\n\n\n\n\n\n\n\n\nModule Members\n\n\nTEST_WIDGET_ID \nString\n\n\nThe ID used for the widget instance loaded in the test environment.\n\n\ninit( specFixtures )\n\n\nAllows to provide assets and configuration to be used for testing a widget.\n\n\nThis should be used by tooling such as the LaxarJS spec-loader to specify spec fixtures in advance.\n\n\nOptions passed by the spec-test to \n#setupForWidget\n will take precedence over these values.\n\n\nWhen using the spec-loader, something like the following code will be generated:\n\n\n(\n \nrequire\n(\n \nlaxar-mocks\n \n).\ninit\n(\n \n{\n\n   \ndescriptor\n:\n \nrequire\n(\n \n../widget.json\n \n),\n\n   \nartifacts\n:\n \nrequire\n(\n \nlaxar-loader?widget=example-widget\n \n),\n\n   \nadapter\n:\n \nrequire\n(\n \nlaxar-\n \n+\n \nfixtures\n.\ndescriptor\n.\nintegration\n.\ntechnology\n \n+\n \n-adapter\n \n)\n\n\n}\n \n);\n\n\n// ... spec test code ...\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nspecFixtures\n\n\nObject\n\n\nmodules and artifacts that are required for running the widget spec test\n\n\n\n\n\n\nspecFixtures.descriptor\n\n\nObject\n\n\nthe widget's JSON descriptor, containing name, integration and feature validation schema\n\n\n\n\n\n\nspecFixtures.artifacts\n\n\nObject\n\n\nan artifacts listing containing modules and assets for the widget under test and its required controls. Usually generated using the \nlaxar-tooling\n library, or the \nlaxar-loader\n for webpack\n\n\n\n\n\n\nspecFixtures.adapter\n\n\nObject\n\n\nan adapter module for the integration technology of the widget under test. Omit for \"plain\" widgets\n\n\n\n\n\n\n\n\ntearDown( done, optionalOptions )\n\n\nRemoves any DOM fragments of the widget and calls the appropriate destructors. It is advised to call\nthis once in an \nafterEach\n call. Passing this function directly to \nafterEach\n is recommended to ensure\nthat cleanup of the test case does not interfere with any followup test.\n\n\nExample.\n\n\nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndone\n\n\nFunction\n\n\ndone callback for asynchronous teardown. Omitting this leads to a warning as it can cause problems that are hard to diagnose afterwards\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\noptional map of options\n\n\n\n\n\n\noptionalOptions.publishEndLifecycleRequest=true\n\n\nObject\n\n\nif set to true (default), publish the endLifecycleRequest event to give the widget under test an opportunity to clean up between test runs. You may want to disable this in order to manually test the cleanup behavior in a dedicated test case\n\n\n\n\n\n\n\n\ntriggerStartupEvents( optionalEvents )\n\n\nTriggers all events normally published by the runtime after instantiation of the controller. This\nincludes the following events, listed with their payloads in the order they are published:\n\n\nDefault Lifecycle Events\n\n\n1. didChangeLocale.default:\n\n\n{\n\n   \nlocale\n:\n \ndefault\n,\n\n   \nlanguageTag\n:\n \nen\n\n\n}\n\n\n\n\n\n\n2. beginLifecycleRequest.default:\n\n\n{\n\n   \nlifecycleId\n:\n \ndefault\n\n\n}\n\n\n\n\n\n\n3. didChangeAreaVisibility.content.true:\n\n\n{\n\n   \narea\n:\n \ncontent\n,\n\n   \nvisible\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n4. didNavigate.testing:\n\n\n{\n\n   \nplace\n:\n \ntesting\n,\n\n   \ntarget\n:\n \n_self\n,\n\n   \ndata\n:\n \n{}\n\n\n}\n\n\n\n\n\n\nCustomizing the Lifecycle Events\n\n\nVia the \noptionalEvents\n argument it is possible to add events with different topic suffixes, to\noverwrite events defined above, or to completely prevent from triggering any of the events. To do so\npass a map, where the primary topics are the keys where each value is a map from topic suffix to\npayload. If the value is \nnull\n, the specific event is not published.\n\n\nExample:\n\n\naxMocks\n.\ntriggerStartupEvents\n(\n \n{\n\n   \nbeginLifecycleRequest\n:\n \n{\n\n      \ndefault\n:\n \nnull\n\n   \n},\n\n   \ndidChangeLocale\n:\n \n{\n\n      \nalternative\n:\n \n{\n\n         \nlocale\n:\n \nalternative\n,\n\n         \nlanguageTag\n:\n \nde\n\n      \n}\n\n   \n},\n\n   \ndidNavigate\n:\n \n{\n\n      \ntesting\n:\n \n{\n\n         \nplace\n:\n \ntesting\n,\n\n         \ntarget\n:\n \n_self\n,\n\n         \ndata\n:\n \n{\n\n            \nuser\n:\n \nPeter\n,\n\n            \narticleId\n:\n \n1234\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n \n);\n\n\n\n\n\n\nThe effect of this call is the following:\n\n\n\n\nNo \nbeginLifecycleRequest\n event is published, since the only pre-configured one is set to \nnull\n.\n\n\n\n\nThere will be two \ndidChangeLocale\n events: \ndidChangeLocale.default\n, carrying the language tag \nen\n\n   in its payload, and \ndidChangeLocale.alternative\n, carrying the language tag \nde\n in its payload.\n\n\n\n\n\n\nThe parameters of the \ndidNavigate.testing\n event are changed to be\n   \n{ user: 'Peter', articleId: '1234' }\n.\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalEvents\n\n\nObject\n\n\noptional map of user defined events\n\n\n\n\n\n\n\n\nsetupForWidget( optionalOptions )\n\n\nCreates the setup function for a widget test, using fixtures that were provided through \n#init\n.\n\n\nThis is the recommended way to setup your widget test. For this to work without manully providing options,\nthis module's \ninit\n method must must have been called already, providing \ndescriptor\n, \nadapter\n and\n\nartifacts\n.\n\n\nWhen webpack loads spec-tests through the \nlaxar-mocks/spec-loader\n, fixtures are provided automatically.\nTo manually provide these fixtures, controlling every aspect of your test environment, pass them using the\nnamed \noptionalOptions\n parameter.\n\n\nThe returned function is asynchronous and should simply be passed to \nbeforeEach\n. By doing so, the Jasmine\n\ndone\n callback is handled under the hood.\n\n\nExample (ES 2015) \nexample-widget.spec.js\n:\n\n\nimport\n \n*\n \nas\n \naxMocks\n \nfrom\n \nlaxar-mocks\n;\n\n\n\ndescribe\n(\n \nAn ExampleWidget\n,\n \n()\n \n=\n \n{\n\n   \nbeforeEach\n(\n \ntesting\n.\nsetupForWidget\n()\n \n);\n\n   \n// ... widget configuration, loading and your tests ...\n\n   \nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\noptional map of options\n\n\n\n\n\n\noptionalOptions.adapter=undefined\n\n\nObject\n\n\na widget-adapter matching the integration technology of the widget; omit if \"plain\"\n\n\n\n\n\n\noptionalOptions.artifacts={}\n\n\nObject\n\n\nartifacts listing for this widget and its controls. Because it is hard to manually produce this correctly, using the laxar-mocks spec-loader is recommended\n\n\n\n\n\n\noptionalOptions.configuration={ baseHref: '/' }\n\n\nObject\n\n\nmock configuration data to use for the \naxConfiguration\n injection of the widget\n\n\n\n\n\n\noptionalOptions.descriptor={}\n\n\nObject\n\n\nthe contents of this widget's \nwidget.json\n, including the JSON schema for the widget features\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function to directly pass to \nbeforeEach\n, accepting a Jasmine \ndone\n callback\n\n\n\n\n\n\n\n\ncreateSetupForWidget( descriptor, optionalOptions )\n\n\nCreates the setup function for a widget test, using user-provided fixtures.\n\n\nThis function exists for backwards compatibility with LaxarJS v1. It is recommended to use\n\n#setupForWidget\n instead, which does not expect the user to provide descriptor, artifacts listing\nand adapter module and instead relies on external tooling (such as the \nlaxar-mocks/spec-loader\n).\n\n\nThe returned function is asynchronous and should simply be passed to \nbeforeEach\n. By doing so, the Jasmine\n\ndone\n callback is handled under the hood.\n\n\nNote:\n This method has been deprecated. Use \n#setupForWidget\n instead.\n\n\nExample (ES 2015) \nexample-widget.spec.js\n:\n\n\nimport\n \n*\n \nas\n \naxMocks\n \nfrom\n \nlaxar-mocks\n;\n\n\n\ndescribe\n(\n \nAn ExampleWidget\n,\n \n()\n \n=\n \n{\n\n   \nbeforeEach\n(\n \ntesting\n.\ncreateSetupForWidget\n(\n \ndescriptor\n,\n \n{\n\n      \nartifacts\n:\n \n{\n\n         \n// ... should be generated, see laxar-tooling project for details ...\n\n      \n},\n\n      \nadapter\n:\n \nrequire\n(\n \nlaxar-my-adapter\n \n)\n\n   \n}\n \n)\n \n);\n\n\n   \n// ... widget configuration, loading and your tests ...\n\n\n   \nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndescriptor\n\n\nObject\n\n\nthe widget descriptor (taken from \nwidget.json\n)\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\noptional map of options\n\n\n\n\n\n\noptionalOptions.adapter=laxar.plainAdapter\n\n\nObject\n\n\na technology adapter to use for this widget. When using a custom integration technology (something other than \"plain\" or \"angular\"), pass the adapter module using this option.\n\n\n\n\n\n\noptionalOptions.artifacts={}\n\n\nObject\n\n\nan artifacts listing containing all assets for the widget and its controls\n\n\n\n\n\n\noptionalOptions.configuration={}\n\n\nObject\n\n\nmock configuration data to use for the \naxConfiguration\n injection of the widget\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function to directly pass to \nbeforeEach\n, accepting a Jasmine \ndone\n callback\n\n\n\n\n\n\n\n\nTypes\n\n\nWidget\n\n\nThe API to instrument and inspect the widget under test. In addition to the listed methods it has all\ninjections for the specific widget technology set as properties. E.g. for every widget technology there\nwill be \naxEventBus\n and \naxContext\n properties, but for AngularJS widgets there will be an additional\n\n$scope\n property. Note that these are only available after \nload()\n has been called and the widget\ncontroller is loaded.\n\n\nThe methods of the event bus instance available as \naxEventBus\n are already provided with\n\nJasmine spies\n.\n\n\nWidget.configure( keyOrConfiguration, optionalValue )\n\n\nAllows the user to configures the widget features before loading.\n\n\nConfiguration may be specified using\n - a configuration object, similar to a \nfeatures\n key within a page descriptor,\n - a combination of feature path and value, allowing to conveniently override individual values.\n\n\nShorthands may be used:\n\n\nbeforeEach\n(\n \n()\n \n=\n \n{\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \nsearch.resource\n,\n \nsearch\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nIf no previous configuration was given for other \nsearch\n sub-keys, this is equivalent to the following:\n\n\nbeforeEach\n(\n \n()\n \n=\n \n{\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \n{\n\n      \nsearch\n:\n \n{\n\n         \nresource\n:\n \nsearch\n\n      \n}\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyOrConfiguration\n\n\nString\n, \nObject\n\n\neither an object for the full features configuration or the path to the property to configure\n\n\n\n\n\n\noptionalValue\n\n\n*\n\n\nif \nkeyOrConfiguration\n is a string, this is the value to set the feature configuration to\n\n\n\n\n\n\n\n\nWidget.whenServicesAvailable( callback )\n\n\nAllows the user to configures an additional callback, to be run when widget services are available.\n\n\nTo register multiple callbacks (for example, from nested beforeEach blocks), call this method multiple\ntimes.\nCallbacks will be executed  when the widget services are available, just before instantiating the\nwidget controller. They will be executed with a single parameter: the object of named injections,\nusually the mock implementations. Just like at runtime, injections will be instantiated on access. The\nregistered callbacks can configure these injections, or replace them with custom (mock) objects.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\na callback to be run\n\n\n\n\n\n\n\n\nWidget.load( done )\n\n\nLoads the given widget and instantiates its controller. As this function is asynchronous, it receives\na Jasmine \ndone\n callback that is called when the widget is ready.\n\n\nThe instance ID (\naxContext.widget.id\n) for widgets loaded by laxar-mocks is always \ntestWidget\n.\nTheir containing widget area is always \ncontent\n.\n\n\nThe simplest way to call this function is by passing it to its own \nbeforeEach\n call:\n\n\nbeforeEach\n(\n \ntesting\n.\nwidget\n.\nload\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndone\n\n\nFunction\n\n\ncallback to notify Jasmine that the asynchronous widget loading has finished\n\n\n\n\n\n\n\n\nWidget.render()\n\n\nRenders the widget's template by calling the appropriate widget adapter and appends it within a\ncontainer div to the test's DOM. The widget DOM fragement will be returned in order to simulate\nuser interaction on it. Calling \ntearDown()\n will remove it again.\n\n\nNote that calling this method for an activity has no effect and hence is unnessecary.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNode\n\n\nthe widget DOM fragment", 
            "title": "laxar-mocks"
        }, 
        {
            "location": "/api/laxar-mocks/#contents", 
            "text": "Module Members   TEST_WIDGET_ID  init()  tearDown()  triggerStartupEvents()  setupForWidget()  createSetupForWidget()   Types   Widget  Widget.configure()  Widget.whenServicesAvailable()  Widget.load()  Widget.render()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/laxar-mocks/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters", 
            "text": "Property  Type  Description      specFixtures  Object  modules and artifacts that are required for running the widget spec test    specFixtures.descriptor  Object  the widget's JSON descriptor, containing name, integration and feature validation schema    specFixtures.artifacts  Object  an artifacts listing containing modules and assets for the widget under test and its required controls. Usually generated using the  laxar-tooling  library, or the  laxar-loader  for webpack    specFixtures.adapter  Object  an adapter module for the integration technology of the widget under test. Omit for \"plain\" widgets", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters_1", 
            "text": "Property  Type  Description      done  Function  done callback for asynchronous teardown. Omitting this leads to a warning as it can cause problems that are hard to diagnose afterwards    optionalOptions  Object  optional map of options    optionalOptions.publishEndLifecycleRequest=true  Object  if set to true (default), publish the endLifecycleRequest event to give the widget under test an opportunity to clean up between test runs. You may want to disable this in order to manually test the cleanup behavior in a dedicated test case", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#default-lifecycle-events", 
            "text": "1. didChangeLocale.default:  { \n    locale :   default , \n    languageTag :   en  }   2. beginLifecycleRequest.default:  { \n    lifecycleId :   default  }   3. didChangeAreaVisibility.content.true:  { \n    area :   content , \n    visible :   true  }   4. didNavigate.testing:  { \n    place :   testing , \n    target :   _self , \n    data :   {}  }", 
            "title": "Default Lifecycle Events"
        }, 
        {
            "location": "/api/laxar-mocks/#customizing-the-lifecycle-events", 
            "text": "Via the  optionalEvents  argument it is possible to add events with different topic suffixes, to\noverwrite events defined above, or to completely prevent from triggering any of the events. To do so\npass a map, where the primary topics are the keys where each value is a map from topic suffix to\npayload. If the value is  null , the specific event is not published.  Example:  axMocks . triggerStartupEvents (   { \n    beginLifecycleRequest :   { \n       default :   null \n    }, \n    didChangeLocale :   { \n       alternative :   { \n          locale :   alternative , \n          languageTag :   de \n       } \n    }, \n    didNavigate :   { \n       testing :   { \n          place :   testing , \n          target :   _self , \n          data :   { \n             user :   Peter , \n             articleId :   1234 \n          } \n       } \n    }  }   );   The effect of this call is the following:   No  beginLifecycleRequest  event is published, since the only pre-configured one is set to  null .   There will be two  didChangeLocale  events:  didChangeLocale.default , carrying the language tag  en \n   in its payload, and  didChangeLocale.alternative , carrying the language tag  de  in its payload.    The parameters of the  didNavigate.testing  event are changed to be\n    { user: 'Peter', articleId: '1234' } .", 
            "title": "Customizing the Lifecycle Events"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters_2", 
            "text": "Property  Type  Description      optionalEvents  Object  optional map of user defined events", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#example-es-2015-example-widgetspecjs", 
            "text": "import   *   as   axMocks   from   laxar-mocks ;  describe (   An ExampleWidget ,   ()   =   { \n    beforeEach (   testing . setupForWidget ()   ); \n    // ... widget configuration, loading and your tests ... \n    afterEach (   axMocks . tearDown   );  }   );", 
            "title": "Example (ES 2015) example-widget.spec.js:"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters_3", 
            "text": "Property  Type  Description      optionalOptions  Object  optional map of options    optionalOptions.adapter=undefined  Object  a widget-adapter matching the integration technology of the widget; omit if \"plain\"    optionalOptions.artifacts={}  Object  artifacts listing for this widget and its controls. Because it is hard to manually produce this correctly, using the laxar-mocks spec-loader is recommended    optionalOptions.configuration={ baseHref: '/' }  Object  mock configuration data to use for the  axConfiguration  injection of the widget    optionalOptions.descriptor={}  Object  the contents of this widget's  widget.json , including the JSON schema for the widget features", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#returns", 
            "text": "Type  Description      Function  a function to directly pass to  beforeEach , accepting a Jasmine  done  callback", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar-mocks/#example-es-2015-example-widgetspecjs_1", 
            "text": "import   *   as   axMocks   from   laxar-mocks ;  describe (   An ExampleWidget ,   ()   =   { \n    beforeEach (   testing . createSetupForWidget (   descriptor ,   { \n       artifacts :   { \n          // ... should be generated, see laxar-tooling project for details ... \n       }, \n       adapter :   require (   laxar-my-adapter   ) \n    }   )   ); \n\n    // ... widget configuration, loading and your tests ... \n\n    afterEach (   axMocks . tearDown   );  }   );", 
            "title": "Example (ES 2015) example-widget.spec.js:"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters_4", 
            "text": "Property  Type  Description      descriptor  Object  the widget descriptor (taken from  widget.json )    optionalOptions  Object  optional map of options    optionalOptions.adapter=laxar.plainAdapter  Object  a technology adapter to use for this widget. When using a custom integration technology (something other than \"plain\" or \"angular\"), pass the adapter module using this option.    optionalOptions.artifacts={}  Object  an artifacts listing containing all assets for the widget and its controls    optionalOptions.configuration={}  Object  mock configuration data to use for the  axConfiguration  injection of the widget", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#returns_1", 
            "text": "Type  Description      Function  a function to directly pass to  beforeEach , accepting a Jasmine  done  callback", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar-mocks/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters_5", 
            "text": "Property  Type  Description      keyOrConfiguration  String ,  Object  either an object for the full features configuration or the path to the property to configure    optionalValue  *  if  keyOrConfiguration  is a string, this is the value to set the feature configuration to", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters_6", 
            "text": "Property  Type  Description      callback  Function  a callback to be run", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#parameters_7", 
            "text": "Property  Type  Description      done  Function  callback to notify Jasmine that the asynchronous widget loading has finished", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks/#returns_2", 
            "text": "Type  Description      Node  the widget DOM fragment", 
            "title": "Returns"
        }, 
        {
            "location": "/manuals/", 
            "text": "Manuals\n\n\n\n\nIntroduction LaxarJS Mocks\n\n\n\n\nAn example spec test intended as a blueprint for your own tests, but with step-by-step instructions.\n\n\n\n\nComing From LaxarJS Mocks 1.x\n\n\n\n\nInformation for developers that have worked with LaxarJS Mocks 1.x before.\n\n\n\n\nSpec-Runner Setup\n\n\n\n\nInstructions for manually setting up the spec-runner in a project.\n  Usually, the generator should be used.", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Introduction LaxarJS Mocks   An example spec test intended as a blueprint for your own tests, but with step-by-step instructions.   Coming From LaxarJS Mocks 1.x   Information for developers that have worked with LaxarJS Mocks 1.x before.   Spec-Runner Setup   Instructions for manually setting up the spec-runner in a project.\n  Usually, the generator should be used.", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/migration/", 
            "text": "\u00ab return to the manuals\n\n\nComing from LaxarJS Mocks 1.x\n\n\nThese are the major changes when coming from LaxarJS Mocks version 1.x:\n\n\nRequires LaxarJS 2.x\n\n\nThis library works together with LaxarJS 2.x and the corresponding technology adapters.\n\n\nNo More Copy/Pasting Spec-Runnner Files\n\n\nBoth \nspec_runner.js\n and \nspec_runner.html\n are no longer needed.\n\n\nHTML and JS boilerplate code for the test runner is now generated on-the-fly, and should be removed from your repository.\nAlso, the HTML-runner contained hard-coded paths to Jasmine, which could cause test problems when widgets were moved around in a project -- this should no longer be a concern.\nFor details, refer to the \nsetup manual\n.\n\n\nLaxarJS Services are Mocked Out-of-the-Box:\n\n\nWhen using LaxarJS injections such as \naxConfiguration\n, \naxFlowService\n or \naxVisibility\n, these are now mocked automatically.\nPreviously, only the \naxEventBus\n injection was always mocked.\nYou can use a callback to configure or to replace these mocks just before creating your widget controller.\n\n\nAlso, widget services can now be interacted with \nbefore\n the widget controller is instantiated:\nThe new \nwhenServicesAvailable\n hook allows to intercept and configure or replace LaxarJS widget service mocks.\n\n\nSimplified Testbed Setup\n\n\nNo more need for loading the descriptor yourself;\nno more need to specify \nknownMissingResources\n in order to avoid 404 Requests for the CSS stylesheets of your widget's controls.\nThe spec-loader makes sure that all assets have already been loaded if and only if they exist.\nBecause of that, you should now use the parameterless \nsetupForWidget()\n instead of \ncreateSetupForWidget( descriptor, options )\n.\n\n\nMVC-Agnostic\n\n\nNo more built-in assumptions regarding AngularJS.\nNeither LaxarJS Core nor LaxarJS Mocks make assumptions on wether AngularJS is used or not.\nFramework-specific test-code is handled by the adapters.", 
            "title": "Coming from LaxarJS Mocks 1.x"
        }, 
        {
            "location": "/manuals/migration/#coming-from-laxarjs-mocks-1x", 
            "text": "These are the major changes when coming from LaxarJS Mocks version 1.x:", 
            "title": "Coming from LaxarJS Mocks 1.x"
        }, 
        {
            "location": "/manuals/migration/#requires-laxarjs-2x", 
            "text": "This library works together with LaxarJS 2.x and the corresponding technology adapters.", 
            "title": "Requires LaxarJS 2.x"
        }, 
        {
            "location": "/manuals/migration/#no-more-copypasting-spec-runnner-files", 
            "text": "Both  spec_runner.js  and  spec_runner.html  are no longer needed.  HTML and JS boilerplate code for the test runner is now generated on-the-fly, and should be removed from your repository.\nAlso, the HTML-runner contained hard-coded paths to Jasmine, which could cause test problems when widgets were moved around in a project -- this should no longer be a concern.\nFor details, refer to the  setup manual .", 
            "title": "No More Copy/Pasting Spec-Runnner Files"
        }, 
        {
            "location": "/manuals/migration/#laxarjs-services-are-mocked-out-of-the-box", 
            "text": "When using LaxarJS injections such as  axConfiguration ,  axFlowService  or  axVisibility , these are now mocked automatically.\nPreviously, only the  axEventBus  injection was always mocked.\nYou can use a callback to configure or to replace these mocks just before creating your widget controller.  Also, widget services can now be interacted with  before  the widget controller is instantiated:\nThe new  whenServicesAvailable  hook allows to intercept and configure or replace LaxarJS widget service mocks.", 
            "title": "LaxarJS Services are Mocked Out-of-the-Box:"
        }, 
        {
            "location": "/manuals/migration/#simplified-testbed-setup", 
            "text": "No more need for loading the descriptor yourself;\nno more need to specify  knownMissingResources  in order to avoid 404 Requests for the CSS stylesheets of your widget's controls.\nThe spec-loader makes sure that all assets have already been loaded if and only if they exist.\nBecause of that, you should now use the parameterless  setupForWidget()  instead of  createSetupForWidget( descriptor, options ) .", 
            "title": "Simplified Testbed Setup"
        }, 
        {
            "location": "/manuals/migration/#mvc-agnostic", 
            "text": "No more built-in assumptions regarding AngularJS.\nNeither LaxarJS Core nor LaxarJS Mocks make assumptions on wether AngularJS is used or not.\nFramework-specific test-code is handled by the adapters.", 
            "title": "MVC-Agnostic"
        }, 
        {
            "location": "/manuals/introduction/", 
            "text": "\u00ab return to the manuals\n\n\nIntroduction to LaxarJS Mocks\n\n\nBefore going into details, we will introduce the testing framework by showing an example and use that to describe the individual steps usually found in a widget test.\nComing from LaxarJS 1.x, the \nmigration guide\n may help.\nIf you are already familiar with the basics, you may want to browse the \nAPI docs\n instead.\n\n\nAn Example Test\n\n\nThe following is a simple test for a \nplain\n widget.\nConsult your adapter's documentation to find any additional information for your integration technology.\n\n\nBelow the example, each of the enumerated points is described in more detail.\nNote that some of the steps are optional, depending on your testing needs.\n\n\n// 1. Module Definition, Imports\n\n\nimport\n \n*\n \nas\n \naxMocks\n \nfrom\n \nlaxar-mocks\n;\n\n\n\ndescribe\n(\n \nAn example-widget\n,\n \n()\n \n=\n \n{\n\n\n   \n// 2. Testbed Setup, creates axMocks.widget for the widget under test\n\n   \nbeforeEach\n(\n \naxMocks\n.\nsetupForWidget\n()\n \n);\n\n\n   \nbeforeEach\n(\n \n()\n \n=\n \n{\n\n      \n// 3. Widget Configuration (as needed by the widget)\n\n      \naxMocks\n.\nwidget\n.\nconfigure\n(\n \n{\n\n         \nexample\n:\n \n{\n\n            \nresource\n:\n \nexampleResource\n,\n\n            \naction\n:\n \nexampleAction\n\n         \n}\n\n      \n}\n \n);\n\n\n      \n// 4. Optional: Configuring and/or Replacing Widget Services\n\n      \naxMocks\n.\nwidget\n.\nwhenServicesAvailable\n(\n \nservices\n \n=\n \n{\n\n         \nservices\n.\naxFlowService\n.\nconstructAbsoluteUrl\n\n            \n.\nand\n.\ncallFake\n(\n \ntarget\n \n=\n \ntarget\n \n===\n \nnext\n \n?\n \n/step2\n \n:\n \n/default\n \n);\n\n         \nservices\n.\naxId\n \n=\n \nsuffix\n \n=\n \n`\nABC\n-\n$\n{\nsuffix\n}\n`\n;\n\n      \n}\n \n);\n\n   \n}\n \n);\n\n\n   \n// 5. Loading the Widget, and instantiating the controller\n\n   \nbeforeEach\n(\n \naxMocks\n.\nwidget\n.\nload\n \n);\n\n\n   \n// 6.  Optional: Simulating Startup Events\n\n   \nbeforeEach\n(\n \naxMocks\n.\ntriggerStartupEvents\n \n);\n\n\n   \n// 7. Optional: Rendering the Widget DOM\n\n   \nlet\n \nwidgetDom\n;\n\n   \nbeforeEach\n(\n \n()\n \n=\n \n{\n \nwidgetDom\n \n=\n \naxMocks\n.\nwidget\n.\nrender\n();\n \n}\n \n);\n\n\n   \n// 8. Tests\n\n   \nit\n(\n \nsubscribes to didReplace events for the example resource\n,\n \n()\n \n=\n \n{\n\n      \nexpect\n(\n \naxMocks\n.\nwidget\n.\naxEventBus\n.\nsubscribe\n \n)\n\n         \n.\ntoHaveBeenCalledWith\n(\n \ndidReplace.exampleResource\n,\n \njasmine\n.\nany\n(\n \nFunction\n \n)\n \n);\n\n   \n}\n \n);\n\n\n   \nit\n(\n \nuses the flow service to generate a \nnext\n link\n,\n \n()\n \n=\n \n{\n\n      \nexpect\n(\n \naxMocks\n.\nwidget\n.\naxFlowService\n.\nconstructAbsoluteUrl\n \n)\n\n         \n.\ntoHaveBeenCalledWith\n(\n \nnext\n,\n \n{}\n \n);\n\n   \n}\n \n);\n\n\n   \n// 9. Optional: DOM-Tests\n\n   \nit\n(\n \nrenders a link refering to the \nnext\n target\n,\n \n()\n \n=\n \n{\n\n      \nexpect\n(\n \nwidgetDom\n.\nquerySelector\n(\n \na\n \n).\nhref\n \n).\ntoEqual\n(\n \n/step2\n \n);\n\n   \n}\n \n);\n\n\n   \nit\n(\n \nrenders an input with matching label\n,\n \n()\n \n=\n \n{\n\n      \nexpect\n(\n \nwidgetDom\n.\nquerySelector\n(\n \ninput\n \n).\nid\n \n).\ntoEqual\n(\n \nABC-myInput\n \n);\n\n      \nexpect\n(\n \nwidgetDom\n.\nquerySelector\n(\n \nlabel\n \n).\nfor\n \n).\ntoEqual\n(\n \nABC-myInput\n \n);\n\n   \n}\n \n);\n\n\n   \n// 10. Testbed Tear-Down\n\n   \nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\nThe individual steps are explained below in more detail.\n\n\n1. Module Definition, Imports\n\n\nFor simplicity, this test is written as an ES2015 module, but other styles (CommonJS, AMD) should work just fine.\nThe LaxarJS spec-loader takes care of loading the widget itself and its dependencies, such as controls.\n\n\n2. Testbed Setup\n\n\nLaxarJS mocks has already been provisioned with information on the widget's assets, so no arguments need to be passed here\nTo spare the user from handling of asynchronous tasks in the \nJasmine\n environment, \naxMocks.setupForWidget()\n returns an asynchronous function suitable for use with \nbeforeEach\n, so the parentheses \nmust not\n be removed.\n\n\n3. Widget Configuration\n\n\nNext, we configure the features of the widget instance.\nThe same information that you would configure as \nfeatures\n within a page when developing an application can be passed to the method \naxMocks.widget.configure\n.\nFor convenience it's also possible to use an \nattribute path\n together with a single value as arguments.\nThis is especially useful if the widget gets pre-configured in an outer \ndescribe\n block and is adjusted deeper in a nested structure.\n\n\nThis means that alternatively we could have written:\n\n\nbeforeEach\n(\n \n()\n \n=\n \n{\n\n   \naxMocks\n.\nwidget\n.\nconfigure\n(\n \nexample.resource\n,\n \nexampleResource\n \n);\n\n   \naxMocks\n.\nwidget\n.\nconfigure\n(\n \nexample.action\n,\n \nexampleAction\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\n4. \nOptional:\n Configuring and/or Replacing Widget Services\n\n\nNext, some of the LaxarJS widget services are modified for the test.\nBecause LaxarJS Mocks automatically injects service mocks with appropriate Jasmine spies for all widget services provided by LaxarJS, you will often be able to skip this step.\nIn this case, we'd like to test the URLs generated by the widget, so we modify the \naxFlowService\n mock to generate URLs of our choosing, that we can check against our expectations below.\n\n\nNote\n that this callback has to complete \nsynchronously\n.\nYou cannot complete the surrounding \nbeforeEach\n block by calling its \ndone\n parameter from this callback because LaxarJS Mocks \nonly stores\n the callback for now, and will only run it when \naxMocks.widget.load\n is called.\n\n\n5. Loading the Widget\n\n\nHere we tell LaxarJS to actually instantiate the widget controller.\nSince the API of the LaxarJS widget loader is asynchronous, the \naxMocks.widget.load\n method is asynchronous as well and thus expects a \nJasmine\n \ndone\n callback.\nAgain, to keep tests simple, \nload\n doesn't need to be called directly, but can be passed directly to \nbeforeEach\n.\nMake sure to load the widget only \nafter\n all configuration and service mocks have been prepared, because afterwards calls to \naxMocks.widget.configure\n and \naxMocks.widget.whenServicesAvailable\n will have no effect.\n\n\n6. \nOptional:\n Simulating Startup Events\n\n\nWhen a page is loaded within a \nLaxarJS\n application, the runtime publishes several \nlifecycle events\n.\nMany widgets don't actually care for these events and only subscribe to custom events such as \ndidReplace\n or \ntakeActionRequest\n.\nOther widgets may depend on \ncore events\n like \ndidChangeLocale\n or \ndidNavigate\n with certain parameters.\n\n\nFor testing a widget's response to core events without duplicating too much of the associated logic within every test, the function \naxMocks.triggerStartupEvents\n publishes all events that the runtime would publish, in the same order.\n\n\nThe method also allows to modify these events or skip some of them completely.\nFor further information on event configuration have a look at the \nAPI docs\n.\n\n\n7. \nOptional:\n Rendering the Widget DOM\n\n\nNaturally this step does not apply to activities, since they do not influence the DOM and in particular have no visual representation.\nCalling \naxMocks.widget.render()\n for activities isn't harmful, but simply has no effect.\n\n\nFor widgets, their template is processed by the underlying technology adapter, wrapped in a \nDIV\n element and the resulting DOM node returned.\nThis is not different from the rendering process in a regular application.\nInstead of appending the DOM to a widget area, it is appended to the body element of the test.\nIt is removed again before the next test run would render its DOM or when calling \naxMocks.tearDown\n.\n\n\n8. Tests\n\n\nNow you're set up to write your actual tests.\nAt this point the widget controller is instantiated, the (optional) DOM fragment has been rendered and all relevant runtime events were published.\n\n\nProbably you want to group your tests into functional use cases via \nJasmine\n \ndescribe\n functions.\nIn this case it is sometimes a good thing to postpone the calls to \naxMocks.widget.load\n, \naxMocks.widget.render\n and \naxMocks.triggerStartupEvents\n.\nThis allows you to structure the test in isolated \ndescribe\n blocks, to adjust configuration and service mocks for each block as needed and only afterwards to actually instantiate the widget and fire up your tests.\n\n\n9. \nOptional:\n DOM-Tests\n\n\nUsing the DOM rendered in step 8, you can now run DOM-tests to check your widget's HTML representation.\nThis is only relevant for widgets that you would like to write DOM-tests for.\nWe recommend using the standard DOM APIs for this, but nothing prevents you from using a helper library such as jQuery.\n\n\n10. Testbed Tear-Down\n\n\nEvery widget test should call \naxMocks.tearDown\n in a \nJasmine\n \nafterEach\n block or simply pass it to \nafterEach\n as a callback.\nThis ensures that after each test run the DOM is cleaned up and the widget with all its dependencies is destroyed.\nIf this is omitted, it cannot be guaranteed previous test runs do not influence the current test run.\n\n\nNote that you should \navoid changing global state\n in your widget module, as LaxarJS Mocks cannot detect nor revert those changes during tear-down.\nHowever, side-effecting widget services such as \naxStorage\n are provided as mocks and are automatically reset between test runs.\n\n\nMore Information\n\n\nFor more in-depth documentation, refer to the \nAPI docs\n.", 
            "title": "Introduction to LaxarJS Mocks"
        }, 
        {
            "location": "/manuals/introduction/#introduction-to-laxarjs-mocks", 
            "text": "Before going into details, we will introduce the testing framework by showing an example and use that to describe the individual steps usually found in a widget test.\nComing from LaxarJS 1.x, the  migration guide  may help.\nIf you are already familiar with the basics, you may want to browse the  API docs  instead.", 
            "title": "Introduction to LaxarJS Mocks"
        }, 
        {
            "location": "/manuals/introduction/#an-example-test", 
            "text": "The following is a simple test for a  plain  widget.\nConsult your adapter's documentation to find any additional information for your integration technology.  Below the example, each of the enumerated points is described in more detail.\nNote that some of the steps are optional, depending on your testing needs.  // 1. Module Definition, Imports  import   *   as   axMocks   from   laxar-mocks ;  describe (   An example-widget ,   ()   =   { \n\n    // 2. Testbed Setup, creates axMocks.widget for the widget under test \n    beforeEach (   axMocks . setupForWidget ()   ); \n\n    beforeEach (   ()   =   { \n       // 3. Widget Configuration (as needed by the widget) \n       axMocks . widget . configure (   { \n          example :   { \n             resource :   exampleResource , \n             action :   exampleAction \n          } \n       }   ); \n\n       // 4. Optional: Configuring and/or Replacing Widget Services \n       axMocks . widget . whenServicesAvailable (   services   =   { \n          services . axFlowService . constructAbsoluteUrl \n             . and . callFake (   target   =   target   ===   next   ?   /step2   :   /default   ); \n          services . axId   =   suffix   =   ` ABC - $ { suffix } ` ; \n       }   ); \n    }   ); \n\n    // 5. Loading the Widget, and instantiating the controller \n    beforeEach (   axMocks . widget . load   ); \n\n    // 6.  Optional: Simulating Startup Events \n    beforeEach (   axMocks . triggerStartupEvents   ); \n\n    // 7. Optional: Rendering the Widget DOM \n    let   widgetDom ; \n    beforeEach (   ()   =   {   widgetDom   =   axMocks . widget . render ();   }   ); \n\n    // 8. Tests \n    it (   subscribes to didReplace events for the example resource ,   ()   =   { \n       expect (   axMocks . widget . axEventBus . subscribe   ) \n          . toHaveBeenCalledWith (   didReplace.exampleResource ,   jasmine . any (   Function   )   ); \n    }   ); \n\n    it (   uses the flow service to generate a  next  link ,   ()   =   { \n       expect (   axMocks . widget . axFlowService . constructAbsoluteUrl   ) \n          . toHaveBeenCalledWith (   next ,   {}   ); \n    }   ); \n\n    // 9. Optional: DOM-Tests \n    it (   renders a link refering to the  next  target ,   ()   =   { \n       expect (   widgetDom . querySelector (   a   ). href   ). toEqual (   /step2   ); \n    }   ); \n\n    it (   renders an input with matching label ,   ()   =   { \n       expect (   widgetDom . querySelector (   input   ). id   ). toEqual (   ABC-myInput   ); \n       expect (   widgetDom . querySelector (   label   ). for   ). toEqual (   ABC-myInput   ); \n    }   ); \n\n    // 10. Testbed Tear-Down \n    afterEach (   axMocks . tearDown   );  }   );   The individual steps are explained below in more detail.", 
            "title": "An Example Test"
        }, 
        {
            "location": "/manuals/introduction/#1-module-definition-imports", 
            "text": "For simplicity, this test is written as an ES2015 module, but other styles (CommonJS, AMD) should work just fine.\nThe LaxarJS spec-loader takes care of loading the widget itself and its dependencies, such as controls.", 
            "title": "1. Module Definition, Imports"
        }, 
        {
            "location": "/manuals/introduction/#2-testbed-setup", 
            "text": "LaxarJS mocks has already been provisioned with information on the widget's assets, so no arguments need to be passed here\nTo spare the user from handling of asynchronous tasks in the  Jasmine  environment,  axMocks.setupForWidget()  returns an asynchronous function suitable for use with  beforeEach , so the parentheses  must not  be removed.", 
            "title": "2. Testbed Setup"
        }, 
        {
            "location": "/manuals/introduction/#3-widget-configuration", 
            "text": "Next, we configure the features of the widget instance.\nThe same information that you would configure as  features  within a page when developing an application can be passed to the method  axMocks.widget.configure .\nFor convenience it's also possible to use an  attribute path  together with a single value as arguments.\nThis is especially useful if the widget gets pre-configured in an outer  describe  block and is adjusted deeper in a nested structure.  This means that alternatively we could have written:  beforeEach (   ()   =   { \n    axMocks . widget . configure (   example.resource ,   exampleResource   ); \n    axMocks . widget . configure (   example.action ,   exampleAction   );  }   );", 
            "title": "3. Widget Configuration"
        }, 
        {
            "location": "/manuals/introduction/#4-optional-configuring-andor-replacing-widget-services", 
            "text": "Next, some of the LaxarJS widget services are modified for the test.\nBecause LaxarJS Mocks automatically injects service mocks with appropriate Jasmine spies for all widget services provided by LaxarJS, you will often be able to skip this step.\nIn this case, we'd like to test the URLs generated by the widget, so we modify the  axFlowService  mock to generate URLs of our choosing, that we can check against our expectations below.  Note  that this callback has to complete  synchronously .\nYou cannot complete the surrounding  beforeEach  block by calling its  done  parameter from this callback because LaxarJS Mocks  only stores  the callback for now, and will only run it when  axMocks.widget.load  is called.", 
            "title": "4. Optional: Configuring and/or Replacing Widget Services"
        }, 
        {
            "location": "/manuals/introduction/#5-loading-the-widget", 
            "text": "Here we tell LaxarJS to actually instantiate the widget controller.\nSince the API of the LaxarJS widget loader is asynchronous, the  axMocks.widget.load  method is asynchronous as well and thus expects a  Jasmine   done  callback.\nAgain, to keep tests simple,  load  doesn't need to be called directly, but can be passed directly to  beforeEach .\nMake sure to load the widget only  after  all configuration and service mocks have been prepared, because afterwards calls to  axMocks.widget.configure  and  axMocks.widget.whenServicesAvailable  will have no effect.", 
            "title": "5. Loading the Widget"
        }, 
        {
            "location": "/manuals/introduction/#6-optional-simulating-startup-events", 
            "text": "When a page is loaded within a  LaxarJS  application, the runtime publishes several  lifecycle events .\nMany widgets don't actually care for these events and only subscribe to custom events such as  didReplace  or  takeActionRequest .\nOther widgets may depend on  core events  like  didChangeLocale  or  didNavigate  with certain parameters.  For testing a widget's response to core events without duplicating too much of the associated logic within every test, the function  axMocks.triggerStartupEvents  publishes all events that the runtime would publish, in the same order.  The method also allows to modify these events or skip some of them completely.\nFor further information on event configuration have a look at the  API docs .", 
            "title": "6. Optional: Simulating Startup Events"
        }, 
        {
            "location": "/manuals/introduction/#7-optional-rendering-the-widget-dom", 
            "text": "Naturally this step does not apply to activities, since they do not influence the DOM and in particular have no visual representation.\nCalling  axMocks.widget.render()  for activities isn't harmful, but simply has no effect.  For widgets, their template is processed by the underlying technology adapter, wrapped in a  DIV  element and the resulting DOM node returned.\nThis is not different from the rendering process in a regular application.\nInstead of appending the DOM to a widget area, it is appended to the body element of the test.\nIt is removed again before the next test run would render its DOM or when calling  axMocks.tearDown .", 
            "title": "7. Optional: Rendering the Widget DOM"
        }, 
        {
            "location": "/manuals/introduction/#8-tests", 
            "text": "Now you're set up to write your actual tests.\nAt this point the widget controller is instantiated, the (optional) DOM fragment has been rendered and all relevant runtime events were published.  Probably you want to group your tests into functional use cases via  Jasmine   describe  functions.\nIn this case it is sometimes a good thing to postpone the calls to  axMocks.widget.load ,  axMocks.widget.render  and  axMocks.triggerStartupEvents .\nThis allows you to structure the test in isolated  describe  blocks, to adjust configuration and service mocks for each block as needed and only afterwards to actually instantiate the widget and fire up your tests.", 
            "title": "8. Tests"
        }, 
        {
            "location": "/manuals/introduction/#9-optional-dom-tests", 
            "text": "Using the DOM rendered in step 8, you can now run DOM-tests to check your widget's HTML representation.\nThis is only relevant for widgets that you would like to write DOM-tests for.\nWe recommend using the standard DOM APIs for this, but nothing prevents you from using a helper library such as jQuery.", 
            "title": "9. Optional: DOM-Tests"
        }, 
        {
            "location": "/manuals/introduction/#10-testbed-tear-down", 
            "text": "Every widget test should call  axMocks.tearDown  in a  Jasmine   afterEach  block or simply pass it to  afterEach  as a callback.\nThis ensures that after each test run the DOM is cleaned up and the widget with all its dependencies is destroyed.\nIf this is omitted, it cannot be guaranteed previous test runs do not influence the current test run.  Note that you should  avoid changing global state  in your widget module, as LaxarJS Mocks cannot detect nor revert those changes during tear-down.\nHowever, side-effecting widget services such as  axStorage  are provided as mocks and are automatically reset between test runs.", 
            "title": "10. Testbed Tear-Down"
        }, 
        {
            "location": "/manuals/introduction/#more-information", 
            "text": "For more in-depth documentation, refer to the  API docs .", 
            "title": "More Information"
        }, 
        {
            "location": "/manuals/setup/", 
            "text": "\u00ab return to the manuals\n\n\nSetup Instructions\n\n\nIn the following, we describe a setup using webpack, because this setup is supported out-of-the-box by LaxarJS and LaxarJS Mocks.\nOther module loaders and bundlers can be integrated by interfacing with \nLaxarJS Tooling\n, but that advanced use case is not covered here (the \nAPI docs\n will help you).\n\n\nGeneral project Setup\n\n\nFirst, you need to add LaxarJS Mocks as a dependency to your project:\n\n\nnpm\n \ninstall\n \n--\nsave\n-\ndev\n \nlaxar\n-\nmocks\n\n\n\n\n\n\nIt is recommended to put your widget spec tests into files with the extension \n.spec.js\n within a \nspec\n folder of each widget that you would like to test.\nFor example, a widget called \nmy-widget\n would come with a \nspec/my-widget.spec.js\n.\nThis allows you to use the webpack \nrules\n configuration for automatically loading all widget specs through the LaxarJS Mocks \nspec-loader\n.\n\n\nHere is an example excerpt for use in a \nwebpack.config.js\n:\n\n\nmodule\n.\nexports\n \n=\n \n{\n\n   \n// ... entry, resolve, ...\n\n   \nmodule\n:\n \n{\n\n      \n// ... other module config ...\n\n      \nrules\n:\n \n[\n\n         \n// ... more rules ...\n\n         \n{\n\n            \ntest\n:\n \n/spec\\/.*\\.spec\\.js$/\n,\n\n            \nloader\n:\n \nlaxar-mocks/spec-loader\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n};\n\n\n\n\n\n\nOf course, you can also use \n.jsx\n or \n.ts\n spec tests if your other loaders are setup accordingly.\n\n\nRunning Tests using Karma\n\n\nIf webpack is configured as above, you can run spec tests with karma by using \nkarma-webpack\n to preprocess your specs.\n\n\nHere is an example excerpt for use in a \nkarma.config.js\n:\n\n\nconst\n \nwebpackConfig\n \n=\n \nrequire\n(\n \n./webpack.config.js\n \n);\n\n\n// `entry` for tests is generated by karma-webpack:\n\n\ndelete\n \nwebpackConfig\n.\nentry\n;\n\n\n\nmodule\n.\nexports\n \n=\n \nfunction\n(\n \nconfig\n \n)\n \n{\n\n   \nconfig\n(\n \n{\n\n      \n// ... other karma settings ...\n\n      \nframeworks\n:\n \n[\n \njasmine\n \n],\n\n      \nfiles\n:\n \n[\n \npath/to/widget/spec/*.spec.js\n \n]\n\n      \npreprocessors\n:\n \n{\n\n         \npath/to/widget/spec/\n:\n \n[\n \nwebpack\n,\n \nsourcemap\n \n]\n\n      \n},\n\n      \nwebpack\n:\n \nwebpackConfig\n\n   \n}\n \n)\n\n\n};\n\n\n\n\n\n\nTo get all the settings right, especially when you are testing many widgets in the context of a development project, it is probably simpler to get started using the \nYeoman Generator for LaxarJS 2.x\n, which automatically prepares a working karma setup for your project.\n\n\nRunning Tests in the Browser\n\n\nKarma is great to run all of your tests each time you make a change to your project, for example in a Continuous Integration setup.\nHowever, once you get down to debugging individual test cases, possibly trying to diagnose browser-specific problems, the ability to run your spec test \nwithin a web browser\n is invaluable.\nNot only can you use the Jasmine HTML runner to drill down to individual test cases, but the powerful developer tools of modern browsers are at your disposal.\n\n\nTo help running widget spec tests in the browser without copy/pasting a lot of brittle boilerplate HTML, projects can use the \nJasmine HTML Runner Plugin for Webpack\n which is maintained by the LaxarJS team.\nAgain, projects started with the LaxarJS 2 Yeoman Generator are configured to work with the HTML runner plugin out-of-the-box:\nTo build and to browse the HTML, run \nnpm run browser-spec\n and then open your web browser at \nhttp://localhost:8180/spec-output/\n to view the tests served by the webpack-dev-server.\n\n\nFor a \nmanual setup\n, you will need to use a webpack configuration that configures the HTML spec runner:\n\n\nconst\n \nconfig\n \n=\n \n{\n\n   \n// ... your webpack configuration, including the spec-loader config shown above ...\n\n\n};\n\n\n\nconst\n \nWebpackJasmineHtmlRunnerPlugin\n \n=\n \nrequire\n(\n \nwebpack-jasmine-html-runner-plugin\n \n);\n\n\nconfig\n.\nentry\n \n=\n \nWebpackJasmineHtmlRunnerPlugin\n.\nentry\n(\n \n`\npath\n/\nto\n/\nwidgets\n/**/\nspec\n/*\n.\nspec\n.\njs\n`\n \n);\n\n\nconfig\n.\noutput\n \n=\n \n{\n\n   \npath\n:\n \npath\n.\nresolve\n(\n \npath\n.\njoin\n(\n \nprocess\n.\ncwd\n(),\n \nspec-output\n \n)\n \n),\n\n   \npublicPath\n:\n \n/spec-output/\n,\n\n   \nfilename\n:\n \n[name].bundle.js\n\n\n};\n\n\n\n\n\n\nYou should probably put the HTML spec runner configuration into a dedicated webpack configuration file used for testing, or hide it behind an environment variable, as the generator project does.", 
            "title": "Setup Instructions"
        }, 
        {
            "location": "/manuals/setup/#setup-instructions", 
            "text": "In the following, we describe a setup using webpack, because this setup is supported out-of-the-box by LaxarJS and LaxarJS Mocks.\nOther module loaders and bundlers can be integrated by interfacing with  LaxarJS Tooling , but that advanced use case is not covered here (the  API docs  will help you).", 
            "title": "Setup Instructions"
        }, 
        {
            "location": "/manuals/setup/#general-project-setup", 
            "text": "First, you need to add LaxarJS Mocks as a dependency to your project:  npm   install   -- save - dev   laxar - mocks   It is recommended to put your widget spec tests into files with the extension  .spec.js  within a  spec  folder of each widget that you would like to test.\nFor example, a widget called  my-widget  would come with a  spec/my-widget.spec.js .\nThis allows you to use the webpack  rules  configuration for automatically loading all widget specs through the LaxarJS Mocks  spec-loader .  Here is an example excerpt for use in a  webpack.config.js :  module . exports   =   { \n    // ... entry, resolve, ... \n    module :   { \n       // ... other module config ... \n       rules :   [ \n          // ... more rules ... \n          { \n             test :   /spec\\/.*\\.spec\\.js$/ , \n             loader :   laxar-mocks/spec-loader \n          } \n       ] \n    }  };   Of course, you can also use  .jsx  or  .ts  spec tests if your other loaders are setup accordingly.", 
            "title": "General project Setup"
        }, 
        {
            "location": "/manuals/setup/#running-tests-using-karma", 
            "text": "If webpack is configured as above, you can run spec tests with karma by using  karma-webpack  to preprocess your specs.  Here is an example excerpt for use in a  karma.config.js :  const   webpackConfig   =   require (   ./webpack.config.js   );  // `entry` for tests is generated by karma-webpack:  delete   webpackConfig . entry ;  module . exports   =   function (   config   )   { \n    config (   { \n       // ... other karma settings ... \n       frameworks :   [   jasmine   ], \n       files :   [   path/to/widget/spec/*.spec.js   ] \n       preprocessors :   { \n          path/to/widget/spec/ :   [   webpack ,   sourcemap   ] \n       }, \n       webpack :   webpackConfig \n    }   )  };   To get all the settings right, especially when you are testing many widgets in the context of a development project, it is probably simpler to get started using the  Yeoman Generator for LaxarJS 2.x , which automatically prepares a working karma setup for your project.", 
            "title": "Running Tests using Karma"
        }, 
        {
            "location": "/manuals/setup/#running-tests-in-the-browser", 
            "text": "Karma is great to run all of your tests each time you make a change to your project, for example in a Continuous Integration setup.\nHowever, once you get down to debugging individual test cases, possibly trying to diagnose browser-specific problems, the ability to run your spec test  within a web browser  is invaluable.\nNot only can you use the Jasmine HTML runner to drill down to individual test cases, but the powerful developer tools of modern browsers are at your disposal.  To help running widget spec tests in the browser without copy/pasting a lot of brittle boilerplate HTML, projects can use the  Jasmine HTML Runner Plugin for Webpack  which is maintained by the LaxarJS team.\nAgain, projects started with the LaxarJS 2 Yeoman Generator are configured to work with the HTML runner plugin out-of-the-box:\nTo build and to browse the HTML, run  npm run browser-spec  and then open your web browser at  http://localhost:8180/spec-output/  to view the tests served by the webpack-dev-server.  For a  manual setup , you will need to use a webpack configuration that configures the HTML spec runner:  const   config   =   { \n    // ... your webpack configuration, including the spec-loader config shown above ...  };  const   WebpackJasmineHtmlRunnerPlugin   =   require (   webpack-jasmine-html-runner-plugin   );  config . entry   =   WebpackJasmineHtmlRunnerPlugin . entry (   ` path / to / widgets /**/ spec /* . spec . js `   );  config . output   =   { \n    path :   path . resolve (   path . join (   process . cwd (),   spec-output   )   ), \n    publicPath :   /spec-output/ , \n    filename :   [name].bundle.js  };   You should probably put the HTML spec runner configuration into a dedicated webpack configuration file used for testing, or hide it behind an environment variable, as the generator project does.", 
            "title": "Running Tests in the Browser"
        }
    ]
}