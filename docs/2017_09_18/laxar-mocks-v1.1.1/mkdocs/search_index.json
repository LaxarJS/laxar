{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS Mocks \n\n\n\n\nThe companion testing framework for LaxarJS widgets.\n\n\n\n\nUse \nLaxarJS Mocks\n on top of Jasmine to setup and load a widget just like in an actual application.\nThe available APIs then support you in instrumenting and inspecting the widget under test.\n\n\nFor an introduction to \nLaxarJS Mocks\n have a look at the \nmanuals\n.\nAdditionally the \nAPI docs\n provide detailed information on the configuration, instrumentation and inspection possibilities.\n\n\nInstallation\n\n\nYour LaxarJS application might have been created from a template that already includes \nlaxar-mocks\n (check your \nbower_components\n folder).\nIf not, follow these steps:\n\n\n\n\nInstall \nlaxar-mocks\n as a Bower dependency:\n\n\n\n\nbower install --save-dev laxar-mocks\n\n\n\n\n\n\n\n\nAdd the necessary entries to your RequireJS configuration (\nrequire_config.js\n), assuming that your \nbaseUrl\n is \n'bower_components'\n:\n\n\n\n\npaths\n:\n \n{\n\n   \n// requirejs, laxar, angular, angular-mocks...\n\n\n   \n// laxar-mocks specific paths:\n\n   \nlaxar-mocks\n:\n \nlaxar-mocks/dist/laxar-mocks\n,\n\n   \njasmine2\n:\n \njasmine2/lib/jasmine-core/jasmine\n,\n\n   \npromise-polyfill\n:\n \npromise-polyfill/Promise\n\n\n}\n\n\n\n\n\n\nNote that \nJasmine 2\n is installed by Bower into its own directory to support \ndifferent versions of jasmine\n to be used by different widgets.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs-mocks", 
            "text": "The companion testing framework for LaxarJS widgets.   Use  LaxarJS Mocks  on top of Jasmine to setup and load a widget just like in an actual application.\nThe available APIs then support you in instrumenting and inspecting the widget under test.  For an introduction to  LaxarJS Mocks  have a look at the  manuals .\nAdditionally the  API docs  provide detailed information on the configuration, instrumentation and inspection possibilities.", 
            "title": "LaxarJS Mocks"
        }, 
        {
            "location": "/#installation", 
            "text": "Your LaxarJS application might have been created from a template that already includes  laxar-mocks  (check your  bower_components  folder).\nIf not, follow these steps:   Install  laxar-mocks  as a Bower dependency:   bower install --save-dev laxar-mocks    Add the necessary entries to your RequireJS configuration ( require_config.js ), assuming that your  baseUrl  is  'bower_components' :   paths :   { \n    // requirejs, laxar, angular, angular-mocks... \n\n    // laxar-mocks specific paths: \n    laxar-mocks :   laxar-mocks/dist/laxar-mocks , \n    jasmine2 :   jasmine2/lib/jasmine-core/jasmine , \n    promise-polyfill :   promise-polyfill/Promise  }   Note that  Jasmine 2  is installed by Bower into its own directory to support  different versions of jasmine  to be used by different widgets.", 
            "title": "Installation"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv1.1.1\n\n\n\n\n#36\n: relaxed laxar dependency (we use semver)\n\n\n\n\nv1.1.0\n\n\n\n\n#29\n: fixed axGlobalEventBus injection\n\n\n#24\n: documentation: added missing information on the widget ID\n\n\n\n\nv1.0.0\n\n\n\n\n#23\n: project: updated copyright year in file header\n\n\n\n\nv1.0.0-alpha.1\n\n\n\n\n#21\n: respect flush/applyViewChanges interaction\n\n\n\n\nv1.0.0-alpha.0\n\n\n\n\n#17\n: added missing API doc entries\n\n\n#19\n: allowed adding \nflush()\n method to \nax.fn.debounce\n results\n\n\n#20\n: added mock promise factory support for \nlaxar._tooling.provideQ\n\n\n#18\n: eventBus: made mock use correct promise factory\n\n\n\n\nv0.6.0\n\n\n\n\n#16\n: fixed optionality of options in createSetupForWidget\n\n\n\n\nv0.5.0\n\n\n\n\n#15\n: allow custom technology adapters\n\n\n#14\n: pass axControls to widget loader\n\n\n\n\nv0.4.0\n\n\n\n\n#12\n: adapters: adjust to changes in LaxarJS tooling API\n\n\n#13\n: project: renamed to laxar-mocks\n\n\n#11\n: example: fixed one-off bug in HTML spec-runner\n\n\n\n\n#9\n: example: spec-runner now takes URL parameter for config-lookup\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#7\n: example: fixed license header of spec-runner config\n\n\n\n\n\n\nv0.3.0\n\n\n\n\n\n\n#6\n: use different paths to access jasmine and jasmine2, use opt-in config for new test-runner\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#7\n: project: relaxed version constraint for angular-mocks (1.3.16 -\n ~1.3.17 || ~1.4.2)\n\n\n\n\n#8\n: fixed example boot sequence (removed jasmine boot)\n\n\n\n\n#5\n: added Travis-CI build integration\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#4\n: Fixed dependency to Jasmine\n\n\n\n\n#3\n: Fixed construction of test paths for RequireJS\n\n\n\n\nv0.2.0\n\n\n\n\n#1\n: added some tests\n\n\n\n\nv0.1.0", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v111", 
            "text": "#36 : relaxed laxar dependency (we use semver)", 
            "title": "v1.1.1"
        }, 
        {
            "location": "/CHANGELOG/#v110", 
            "text": "#29 : fixed axGlobalEventBus injection  #24 : documentation: added missing information on the widget ID", 
            "title": "v1.1.0"
        }, 
        {
            "location": "/CHANGELOG/#v100", 
            "text": "#23 : project: updated copyright year in file header", 
            "title": "v1.0.0"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha1", 
            "text": "#21 : respect flush/applyViewChanges interaction", 
            "title": "v1.0.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha0", 
            "text": "#17 : added missing API doc entries  #19 : allowed adding  flush()  method to  ax.fn.debounce  results  #20 : added mock promise factory support for  laxar._tooling.provideQ  #18 : eventBus: made mock use correct promise factory", 
            "title": "v1.0.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v060", 
            "text": "#16 : fixed optionality of options in createSetupForWidget", 
            "title": "v0.6.0"
        }, 
        {
            "location": "/CHANGELOG/#v050", 
            "text": "#15 : allow custom technology adapters  #14 : pass axControls to widget loader", 
            "title": "v0.5.0"
        }, 
        {
            "location": "/CHANGELOG/#v040", 
            "text": "#12 : adapters: adjust to changes in LaxarJS tooling API  #13 : project: renamed to laxar-mocks  #11 : example: fixed one-off bug in HTML spec-runner   #9 : example: spec-runner now takes URL parameter for config-lookup\n        + NEW FEATURE: see ticket for details    #7 : example: fixed license header of spec-runner config", 
            "title": "v0.4.0"
        }, 
        {
            "location": "/CHANGELOG/#v030", 
            "text": "#6 : use different paths to access jasmine and jasmine2, use opt-in config for new test-runner\n        +  BREAKING CHANGE:  see ticket for details    #7 : project: relaxed version constraint for angular-mocks (1.3.16 -  ~1.3.17 || ~1.4.2)   #8 : fixed example boot sequence (removed jasmine boot)   #5 : added Travis-CI build integration\n        + NEW FEATURE: see ticket for details    #4 : Fixed dependency to Jasmine   #3 : Fixed construction of test paths for RequireJS", 
            "title": "v0.3.0"
        }, 
        {
            "location": "/CHANGELOG/#v020", 
            "text": "#1 : added some tests", 
            "title": "v0.2.0"
        }, 
        {
            "location": "/CHANGELOG/#v010", 
            "text": "", 
            "title": "v0.1.0"
        }, 
        {
            "location": "/api/laxar-mocks.js/", 
            "text": "laxar-mocks\n\n\nA testing framework for LaxarJS widgets.\n\n\nContents\n\n\nModule Members\n\n\n\n\nwidget\n\n\nrunSpec\n\n\neventBus\n\n\ncreateSetupForWidget\n\n\ntearDown\n\n\ntriggerStartupEvents\n\n\nconfigureMockDebounce\n\n\n\n\nTypes\n\n\n\n\nWidget\n\n\nWidget#configure\n\n\nWidget#load\n\n\nWidget#render\n\n\n\n\n\n\n\n\nModule Members\n\n\nwidget\n\n\nThe \nWidget\n instrumentation instance for this test.\nAfter the setup-method (provided by \ncreateSetupForWidget\n) has been run, this also contains\nthe widget's injections.\n\n\nrunSpec()\n\n\nThis method is used by the spec-runner (HTML- or karma-based) to start running the spec suite.\n\n\neventBus\n\n\nThe \n\"test end\"\n of the LaxarJS event bus.\nTests should use this event bus instance to interact with the widget under test by publishing\nsynthetic events. Tests can also use this handle for subscribing to events published  by the widget.\n\n\nThere is also the event bus instance used by the widget itself, with spied-upon publish/subscribe\nmethods. That instance can be accessed as \naxMocks.widget.axEventBus\n.\n\n\ncreateSetupForWidget( widgetDescriptor, optionalOptions )\n\n\nCreates the setup function for a widget test. The returned function is asynchronous and should simply be\npassed to \nbeforeEach\n. By doing so, the handling of the Jasmine \ndone\n callback happens under the hood.\nTo receive the widget descriptor (i.e. the contents of the \nwidget.json\n file) the use of the RequireJS\n\n\njson\n plugin is advised.\n\n\nExample:\n\n\ndefine\n(\n \n[\n\n   \njson!../widget.json\n,\n\n   \nlaxar-mocks\n\n\n],\n \nfunction\n(\n \ndescriptor\n,\n \naxMocks\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \ndescribe\n(\n \nAn ExampleWidget\n,\n \nfunction\n()\n \n{\n\n\n      \nbeforeEach\n(\n \ntesting\n.\ncreateSetupForWidget\n(\n \ndescriptor\n \n)\n \n);\n\n\n      \n// ... widget configuration, loading and your tests\n\n\n      \nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwidgetDescriptor\n\n\nObject\n\n\nthe widget descriptor (taken from \nwidget.json\n)\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\noptional map of options\n\n\n\n\n\n\noptionalOptions.adapter\n\n\nObject\n\n\na technology adapter to use for this widget. When using a custom integration technology (something other than \"plain\" or \"angular\"), pass the adapter module using this option.\n\n\n\n\n\n\noptionalOptions.knownMissingResources\n\n\nArray\n\n\nlist of file name parts as strings or regular expressions, that are known to be absent and as such won't be found by the file resource provider and thus result in the logging of a 404 HTTP error. So whenever such an error is logged and the absence of the file is fine, an appropriate entry can be added to this configuration. Mostly CSS files are affected by this\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function to directly pass to \nbeforeEach\n, accepting a Jasmine \ndone\n callback\n\n\n\n\n\n\n\n\ntearDown()\n\n\nRemoves any DOM fragments of the widget and calls the appropriate destructors. It is advised to call\nthis once in an \nafterEach\n call. Passing this function directly to \nafterEach\n works as well.\n\n\nExample.\n\n\nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n\n\n\n\ntriggerStartupEvents( optionalEvents )\n\n\nTriggers all events normally published by the runtime after instantiation of the controller. This\nincludes the following events, listed with their according payloads in the order they are published:\n\n\n1. didChangeLocale.default:\n\n\n{\n\n   \nlocale\n:\n \ndefault\n,\n\n   \nlanguageTag\n:\n \nen\n\n\n}\n\n\n\n\n\n\n2. didChangeTheme.default:\n\n\n{\n\n   \ntheme\n:\n \ndefault\n\n\n}\n\n\n\n\n\n\n3. beginLifecycleRequest.default:\n\n\n{\n\n   \nlifecycleId\n:\n \ndefault\n\n\n}\n\n\n\n\n\n\n4. didChangeAreaVisibility.content.true:\n\n\n{\n\n   \narea\n:\n \ncontent\n,\n\n   \nvisible\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n5. didNavigate.testing:\n\n\n{\n\n   \nplace\n:\n \ntesting\n,\n\n   \ntarget\n:\n \n_self\n,\n\n   \ndata\n:\n \n{}\n\n\n}\n\n\n\n\n\n\nVia the \noptionalEvents\n argument it is possible to add events with different trailing topics, to\noverwrite events defined above, or to completely prevent from triggering one of the events. To do so\nsimply pass a map, where the primary topics are the keys and the value is a map from trailing topic to\npayload. If the value is \nnull\n, the specific event is not published.\n\n\nExample:\n\n\naxMocks\n.\ntriggerStartupEvents\n(\n \n{\n\n   \ndidChangeLocale\n:\n \n{\n\n      \nalternative\n:\n \n{\n\n         \nlocale\n:\n \nalternative\n,\n\n         \nlanguageTag\n:\n \nde\n\n      \n}\n\n   \n},\n\n   \ndidChangeTheme\n:\n \n{\n\n      \ndefault\n:\n \nnull\n\n   \n},\n\n   \ndidNavigate\n:\n \n{\n\n      \ntesting\n:\n \n{\n\n         \nplace\n:\n \ntesting\n,\n\n         \ntarget\n:\n \n_self\n,\n\n         \ndata\n:\n \n{\n\n            \nuser\n:\n \nPeter\n,\n\n            \narticleId\n:\n \n1234\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n \n);\n\n\n\n\n\n\nThe effect of this call is the following:\n\n\n\n\n\n\nThere will be two \ndidChangeLocale\n events: \ndidChangeLocale.default\n, carrying the language tag \nen\n\n   in its payload, and \ndidChangeLocale.alternative\n, carrying the language tag \nde\n in its payload.\n\n\n\n\n\n\nThere will be no \ndidChangeTheme\n event, since the only pre-configured one is set to \nnull\n.\n\n\n\n\nThe parameters of the \ndidNavigate.testing\n event are changed to be\n   \n{ user: 'Peter', articleId: '1234' }\n.\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalEvents\n\n\nObject\n\n\noptional map of user defined events\n\n\n\n\n\n\n\n\nconfigureMockDebounce()\n\n\nInstalls an \nlaxar.fn.debounce\n-compatible mock replacement that supports manual \nflush()\n.\nWhen called, \nflush\n will process all pending debounced calls,\nAdditionally, there is a \ndebounce.waiting\n array, to inspect waiting calls.\n\n\nWhen called from a \nbeforeEach\n block, only a manual flush will cause debounced calls to be processed\nwithin that block. The passing of time (wall-clock or jasmine-mock clock) will have no effect on calls\nthat were debounced in this context.\n\n\nThe mocks are automatically cleaned up after each test case.\n\n\nTypes\n\n\nWidget\n\n\nThe API to instrument and inspect the widget under test. In addition to the listed methods it has all\ninjections for the specific widget technology set as properties. E.g. for every widget technology there\nwill be \naxEventBus\n and \naxContext\n properties, but for AngularJS widgets there will be an additional\n\n$scope\n property. Note that these are only available after \nload()\n has been called and the widget\ncontroller is loaded.\n\n\nThe methods of the event bus instance available as \naxEventBus\n are already provided with\n\nJasmine spies\n.\n\n\nWidget#configure( keyOrConfiguration, optionalValue )\n\n\nConfigures the widget features before loading with the given configuration object or key/value\nentries. In fact this is what you'd normally configure under the \nfeatures\n key in a page descriptor.\n\n\nShorthands may be used:\n\n\nThis\n\n\nbeforeEach\n(\n \nfunction\n()\n \n{\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \n{\n\n      \nsearch\n:\n \n{\n\n         \nresource\n:\n \nsearch\n\n      \n}\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nis equivalent to the following shorter version\n\n\nbeforeEach\n(\n \nfunction\n()\n \n{\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \nsearch.resource\n,\n \nsearch\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyOrConfiguration\n\n\nString\n, \nObject\n\n\neither an object for the full features configuration or the path to the property to configure\n\n\n\n\n\n\noptionalValue\n\n\n*\n\n\nif \nkeyOrConfiguration\n is a string, this is the value to set the feature configuration to\n\n\n\n\n\n\n\n\nWidget#load( done )\n\n\nLoads the given widget and instantiates its controller. As this function is asynchronous, it receives\na Jasmine \ndone\n callback, that is called when the widget is ready.\n\n\nThe instance ID (\naxContext.widget.id\n) for widgets loaded by laxar-mocks is always \ntestWidget\n.\n\n\nThe simplest way to call this function is by passing it to its own \nbeforeEach\n call:\n\n\nbeforeEach\n(\n \ntesting\n.\nwidget\n.\nload\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndone\n\n\nFunction\n\n\ncallback to notify Jasmine, that the asynchronous widget loading has finished\n\n\n\n\n\n\n\n\nWidget#render()\n\n\nRenders the widget's template by calling the appropriate widget adapter and appends it within a\ncontainer div to the test's DOM. The widget DOM fragement will be returned in order to simulate\nuser interaction on it. Calling \ntesting.tearDown()\n will remove it again.\n\n\nNote that calling this method for an activity has no effect and hence is unnessecary.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNode\n\n\nthe widget DOM fragment", 
            "title": "laxar-mocks"
        }, 
        {
            "location": "/api/laxar-mocks.js/#laxar-mocks", 
            "text": "A testing framework for LaxarJS widgets.", 
            "title": "laxar-mocks"
        }, 
        {
            "location": "/api/laxar-mocks.js/#contents", 
            "text": "Module Members   widget  runSpec  eventBus  createSetupForWidget  tearDown  triggerStartupEvents  configureMockDebounce   Types   Widget  Widget#configure  Widget#load  Widget#render", 
            "title": "Contents"
        }, 
        {
            "location": "/api/laxar-mocks.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/laxar-mocks.js/#parameters", 
            "text": "Property  Type  Description      widgetDescriptor  Object  the widget descriptor (taken from  widget.json )    optionalOptions  Object  optional map of options    optionalOptions.adapter  Object  a technology adapter to use for this widget. When using a custom integration technology (something other than \"plain\" or \"angular\"), pass the adapter module using this option.    optionalOptions.knownMissingResources  Array  list of file name parts as strings or regular expressions, that are known to be absent and as such won't be found by the file resource provider and thus result in the logging of a 404 HTTP error. So whenever such an error is logged and the absence of the file is fine, an appropriate entry can be added to this configuration. Mostly CSS files are affected by this", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks.js/#returns", 
            "text": "Type  Description      Function  a function to directly pass to  beforeEach , accepting a Jasmine  done  callback", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar-mocks.js/#parameters_1", 
            "text": "Property  Type  Description      optionalEvents  Object  optional map of user defined events", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/laxar-mocks.js/#parameters_2", 
            "text": "Property  Type  Description      keyOrConfiguration  String ,  Object  either an object for the full features configuration or the path to the property to configure    optionalValue  *  if  keyOrConfiguration  is a string, this is the value to set the feature configuration to", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks.js/#parameters_3", 
            "text": "Property  Type  Description      done  Function  callback to notify Jasmine, that the asynchronous widget loading has finished", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-mocks.js/#returns_1", 
            "text": "Type  Description      Node  the widget DOM fragment", 
            "title": "Returns"
        }, 
        {
            "location": "/manuals/", 
            "text": "Manuals\n\n\n\n\n\n\nIntroduction LaxarJS Mocks\n\n\n\n\n\n\nMultiple Jasmine Versions in a Project", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Introduction LaxarJS Mocks    Multiple Jasmine Versions in a Project", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/introduction/", 
            "text": "return to the manuals\n\n\nIntroduction to LaxarJS Mocks\n\n\nLaxarJS Mocks\n aids you in writing tests for \nLaxarJS\n widgets.\nAlthough widgets themselves only have little direct dependency on \nLaxarJS\n (apart from the event bus) and should mostly follow the best practices for the underlying technology (e.g. \nAngularJS\n), they depend on a fixed setup process provided by the LaxarJS runtime.\nThis includes loading of relevant assets (such as templates and stylesheets), creation of the controller and rendering at the right time, as well as sending all initially relevant events.\n\n\nLaxarJS Mocks\n provides a simple, programmatic interface to control this process and load a widget within a test.\nWe'll introduce the testing framework by showing an example and use this to describe the individual steps usually found in a widget test.\n\n\nThis is a simple test for an \nAngularJS\n-Widget (read \nthis\n to know where to place this file):\n\n\n// 1. Module Definition\n\n\ndefine\n(\n \n[\n\n   \njson!../widget.json\n,\n\n   \nlaxar-mocks\n,\n\n   \nangular-mocks\n\n\n],\n \nfunction\n(\n \ndescriptor\n,\n \naxMocks\n,\n \nngMocks\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \ndescribe\n(\n \nAn ExampleWidget\n,\n \nfunction\n()\n \n{\n\n\n      \nvar\n \n$httpBackend\n;\n\n      \nvar\n \nwidgetDom\n;\n\n\n      \n// 2. Test Setup\n\n      \nbeforeEach\n(\n \naxMocks\n.\ncreateSetupForWidget\n(\n \ndescriptor\n,\n \n{\n\n         \nknownMissingResources\n:\n \n[\n \nax-i18n-control.css\n \n]\n\n      \n}\n \n)\n \n);\n\n\n      \n// 3. Widget Configuration\n\n      \nbeforeEach\n(\n \nfunction\n()\n \n{\n\n         \naxMocks\n.\nwidget\n.\nconfigure\n(\n \n{\n\n            \nexample\n:\n \n{\n\n               \nresource\n:\n \nexampleResource\n,\n\n               \naction\n:\n \nexampleAction\n\n            \n}\n\n         \n}\n \n);\n\n      \n}\n \n);\n\n\n      \n// 4. Loading the Widget\n\n      \nbeforeEach\n(\n \naxMocks\n.\nwidget\n.\nload\n \n);\n\n\n      \nbeforeEach\n(\n \nfunction\n()\n \n{\n\n         \n// 5. Optional: Rendering the Widget DOM\n\n         \nwidgetDom\n \n=\n \naxMocks\n.\nwidget\n.\nrender\n();\n\n\n         \n// 6. Optional: Mocking an AngularJS Injection\n\n         \nngMocks\n.\ninject\n(\n \nfunction\n(\n \n$injector\n \n)\n \n{\n\n            \n$httpBackend\n \n=\n \n$injector\n.\nget\n(\n \n$httpBackend\n \n);\n\n         \n}\n \n);\n\n\n         \n// 7.  Optional: Simulating Startup Events\n\n         \naxMocks\n.\ntriggerStartupEvents\n();\n\n      \n}\n \n);\n\n\n      \n// 8. Tests\n\n      \nit\n(\n \nsubscribes to didReplace events for the search resource\n,\n \nfunction\n()\n \n{\n\n         \nexpect\n(\n \naxMocks\n.\nwidget\n.\naxEventBus\n.\nsubscribe\n \n)\n\n            \n.\ntoHaveBeenCalledWith\n(\n \ndidReplace.exampleResource\n,\n \njasmine\n.\nany\n(\n \nFunction\n \n)\n \n);\n\n      \n}\n \n);\n\n\n      \n// 9. Test Tear-Down\n\n      \nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n   \n}\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\n1. Module Definition\n\n\nIn the AMD module definition for a widget test the first thing to depend on should usually be the widget descriptor (the contents of the \nwidget.json\n file).\nThis is the only information LaxarJS Mocks needs to determine the relevant widget and according assets to load.\nWe recommend using the \njson\n plugin for \nRequireJS\n to load the file hassle-free just as done in this example.\n\n\nAdditionally \nLaxarJS Mocks\n needs to be loaded, to gain access to the API for widget loading, instrumentation and inspection.\nWhen using the default \nRequireJS\n configuration for that package, it should be available as \nlaxar-mocks\n.\nOf course, the import of \nangular-mocks\n should only take place if really needed during testing.\nIn this example we want to use the mocked \n$httpBackend\n provided by \nAngularJS Mocks\n and thus need to import \nangular-mocks\n.\n\n\n2. Test Setup\n\n\nDue to a bunch of HTTP requests that need to take place, setting up a widget test is an asynchronous task.\nTo spare the user the handling of asynchronous tasks in the \nJasmine\n environment, \naxMocks.createSetupForWidget( descriptor )\n returns an asynchronous function suitable for use with \nbeforeEach\n.\nBesides the widget descriptor, it can optionally receive a map of configuration options.\n\n\nAvailable Options\n\n\nknownMissingResources\n\n\nA list of file name parts that are known to be absent.\nIf left unspecified, the runtime's file resource provider would try to fetch these assets for widgets and controls through HTTP, resulting in 404 errors being logged.\nSo whenever you see such an error in the log and decide that the absence of the corresponding file is fine, an appropriate entry can be added to this configuration.\nThe list entries can be strings or regular expressions.\nRegular expressions are tested against requested file names, while strings will match any file name that contains them anywhere.\n\n\nIn this example the widget uses the \ni18n\n control.\nWe already know that there is no theme, and hence no CSS file for this control, as it only provides some APIs and has no visual representation.\nWhen loading the widget from a running application, the generated file listing would yield that the file is absent and it wouldn't be loaded.\nDuring testing we have to give that hint manually, as seen in this example.\n\n\nFurther information can be found in the \napi docs\n.\n\n\n3. Widget Configuration\n\n\nIn the next step we configure the features of the widget, just as it normally happens in a page definition.\nThe object you'd put under the key \nfeatures\n can simply be passed to the method \naxMocks.widget.configure\n.\nFor convenience it's also possible to use an object attribute path and a single value as arguments.\nThis is e.g. useful if the widget gets pre-configured in an outer \ndescribe\n block and is adjusted deeper in a nested structure.\n\n\nSo here we could have also written this:\n\n\nbeforeEach\n(\n \nfunction\n()\n \n{\n\n   \naxMocks\n.\nwidget\n.\nconfigure\n(\n \nexample.resource\n,\n \nexampleResource\n \n);\n\n   \naxMocks\n.\nwidget\n.\nconfigure\n(\n \nexample.action\n,\n \nexampleAction\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\n4. Loading the Widget\n\n\nHere we tell the widget loader to actually load the widget controller.\nSince the API of the widget loader is asynchronous, the \nload\n method is asynchronous as well and thus expects a \nJasmine\n \ndone\n callback.\nAgain, to keep it as simple as possible for the user, the \nload\n method doesn't need to be called directly, but can simply be passed on to \nbeforeEach\n\nMake sure to load the widget only when all configuration has been applied, because afterwards calls to \naxMocks.widget.configure\n have no effect.\n\n\n5. Optional: Rendering the Widget DOM\n\n\nNaturally this step does not apply to activities, since they do not influence the DOM and in particular have no visual representation.\nCalling the \naxMocks.widget.render()\n for activities isn't harmful, but simply has no effect at all.\nIn case of a widget, the template is compiled by the underlying technology adapter, wrapped in a \ndiv\n element and the resulting DOM node returned.\nThis is not different from the rendering process in a regular application.\nInstead of appending the DOM to a widget area, it is appended to the body element of the test.\nIt is removed again before the next test run would render its DOM or when calling \naxMocks.tearDown\n.\n\n\n6. Optional: Mocking an AngularJS Injection\n\n\nFor this example, we assume that we're testing an \nAngularJS\n widget, which performs some backend communication, using the \n$http\n service provided by \nAngularJS\n.\n\nAngularJS Mocks\n aids us in this case, by providing the instrumentation API \n$httpBackend\n.\nTo prevent from going too much into detail, the \nAngularJS Mocks API\n should be your source of information in that regard.\n\n\n7.  Optional: Simulating Startup Events\n\n\nWhen a page within a \nLaxarJS\n application loads, the runtime publishes several initial events.\nMany widgets don't actually care for these events and only subscribe to custom events such as \ndidReplace\n or \ntakeActionRequest\n.\nOther widgets may depend on \ncore events\n like \ndidChangeLocale\n or \ndidNavigate\n with certain parameters.\n\n\nIn order to be able to test a widgets response to core events without duplicating too much of this task within every test, the method \naxMocks.triggerStartupEvents\n publishes all events the runtime would publish in the correct order.\nThe method allows to configure parts of these events or skip some of them completely.\nFor further information on event configuration have a look at the extensive \nAPI docs\n.\n\n\n8. Tests\n\n\nNow you're set up to write your actual tests.\nAt this point the widget controller is instantiated, the (optional) DOM fragment has been rendered and all relevant runtime events were published.\n\n\nProbably you want to group your tests into functional use cases via \nJasmine\n \ndescribe\n functions.\nIn this case it is sometimes a good thing to postpone the calls to \naxMocks.widget.load\n, \naxMocks.widget.render\n and \naxMocks.triggerStartupEvents\n.\nIt is then possible to structure the test in isolated \ndescribe\n blocks, to adjust the configuration for each block as needed and only afterwards call the other methods to actually fire up your tests.\n\n\n9. Test Tear-Down\n\n\nEvery widget test should call \naxMocks.tearDown\n in a \nJasmine\n \nafterEach\n block or simply pass it to \nafterEach\n as a callback.\nThis ensures, that after one test is run, the DOM is cleaned up and the widget with all its dependencies is destroyed.\nIf this is omitted, it cannot be guaranteed that remainders of the previous test run do not influence the current test run.\n\n\nDirectory Layout\n\n\nIf you generated your widget or activity using the latest template, everything should be set up correctly.\nWhen creating the widget artifacts manually, we recommend the following directory layout for the tests within the widget directory:\n\n\nexample-widget\n\n+-- example-widget.js\n+-- widget.json\n+-- spec\n    +-- example-widget.spec.js\n    +-- spec_runner.html\n    +-- spec_runner.js\n\n\n\n\n\nWhen following this structure, the AMD module definition from the top of this introduction should work for you.\nYou just have to ensure that paths such as \nlaxar-mocks\n and \nangular-mocks\n are configured correctly, as described in the README.\n\n\nWhen running the widget test in your browser, this is achieved by using the correct paths in the file \nspec_runner.html\n.\nBy default it is assumed that any widget directory can be found at the directory \nincludes/widget/\nyour category\n/\n under the application root.\nThe \nrequire_config.js\n of the application will then be loaded by stepping up to the parent directory five times (see \nhere\n for an example).\nFor tests to run, at least the paths \nrequirejs\n, \njasmine\n, \nlaxar-mocks\n and the RequireJS \njson\n plugin have to be defined in that file.\nWhen testing \nAngularJS\n widgets, the path to \nangular-mocks\n must be defined as well.\n\n\nThe next file that is loaded is \nspec_runner.js\n (an example can be found \nhere\n).\nThis file merely defines which actual test files to load and run.\nThese files are located relative to  \nspec_runner.js\n.\nOptionally you can overwrite \nRequireJS\n configuration from the application's \nrequire_config.js\n file, by setting the appropriate entries under the property \nrequireConfig\n.\nFor example, it may sometimes be a good idea to mock a large external library with a simpler stub for testing.\n\n\nFinally, the module \nexample-widget.spec.js\n defines the actual testing code.\nIf you're following these guidelines, the widget descriptor (\nwidget.json\n) can also be loaded as explained in the example, so that the widget under test can be instantiated without problems.", 
            "title": "Introduction to LaxarJS Mocks"
        }, 
        {
            "location": "/manuals/introduction/#introduction-to-laxarjs-mocks", 
            "text": "LaxarJS Mocks  aids you in writing tests for  LaxarJS  widgets.\nAlthough widgets themselves only have little direct dependency on  LaxarJS  (apart from the event bus) and should mostly follow the best practices for the underlying technology (e.g.  AngularJS ), they depend on a fixed setup process provided by the LaxarJS runtime.\nThis includes loading of relevant assets (such as templates and stylesheets), creation of the controller and rendering at the right time, as well as sending all initially relevant events.  LaxarJS Mocks  provides a simple, programmatic interface to control this process and load a widget within a test.\nWe'll introduce the testing framework by showing an example and use this to describe the individual steps usually found in a widget test.  This is a simple test for an  AngularJS -Widget (read  this  to know where to place this file):  // 1. Module Definition  define (   [ \n    json!../widget.json , \n    laxar-mocks , \n    angular-mocks  ],   function (   descriptor ,   axMocks ,   ngMocks   )   { \n    use strict ; \n\n    describe (   An ExampleWidget ,   function ()   { \n\n       var   $httpBackend ; \n       var   widgetDom ; \n\n       // 2. Test Setup \n       beforeEach (   axMocks . createSetupForWidget (   descriptor ,   { \n          knownMissingResources :   [   ax-i18n-control.css   ] \n       }   )   ); \n\n       // 3. Widget Configuration \n       beforeEach (   function ()   { \n          axMocks . widget . configure (   { \n             example :   { \n                resource :   exampleResource , \n                action :   exampleAction \n             } \n          }   ); \n       }   ); \n\n       // 4. Loading the Widget \n       beforeEach (   axMocks . widget . load   ); \n\n       beforeEach (   function ()   { \n          // 5. Optional: Rendering the Widget DOM \n          widgetDom   =   axMocks . widget . render (); \n\n          // 6. Optional: Mocking an AngularJS Injection \n          ngMocks . inject (   function (   $injector   )   { \n             $httpBackend   =   $injector . get (   $httpBackend   ); \n          }   ); \n\n          // 7.  Optional: Simulating Startup Events \n          axMocks . triggerStartupEvents (); \n       }   ); \n\n       // 8. Tests \n       it (   subscribes to didReplace events for the search resource ,   function ()   { \n          expect (   axMocks . widget . axEventBus . subscribe   ) \n             . toHaveBeenCalledWith (   didReplace.exampleResource ,   jasmine . any (   Function   )   ); \n       }   ); \n\n       // 9. Test Tear-Down \n       afterEach (   axMocks . tearDown   ); \n\n    }   );  }   );", 
            "title": "Introduction to LaxarJS Mocks"
        }, 
        {
            "location": "/manuals/introduction/#1-module-definition", 
            "text": "In the AMD module definition for a widget test the first thing to depend on should usually be the widget descriptor (the contents of the  widget.json  file).\nThis is the only information LaxarJS Mocks needs to determine the relevant widget and according assets to load.\nWe recommend using the  json  plugin for  RequireJS  to load the file hassle-free just as done in this example.  Additionally  LaxarJS Mocks  needs to be loaded, to gain access to the API for widget loading, instrumentation and inspection.\nWhen using the default  RequireJS  configuration for that package, it should be available as  laxar-mocks .\nOf course, the import of  angular-mocks  should only take place if really needed during testing.\nIn this example we want to use the mocked  $httpBackend  provided by  AngularJS Mocks  and thus need to import  angular-mocks .", 
            "title": "1. Module Definition"
        }, 
        {
            "location": "/manuals/introduction/#2-test-setup", 
            "text": "Due to a bunch of HTTP requests that need to take place, setting up a widget test is an asynchronous task.\nTo spare the user the handling of asynchronous tasks in the  Jasmine  environment,  axMocks.createSetupForWidget( descriptor )  returns an asynchronous function suitable for use with  beforeEach .\nBesides the widget descriptor, it can optionally receive a map of configuration options.", 
            "title": "2. Test Setup"
        }, 
        {
            "location": "/manuals/introduction/#available-options", 
            "text": "", 
            "title": "Available Options"
        }, 
        {
            "location": "/manuals/introduction/#knownmissingresources", 
            "text": "A list of file name parts that are known to be absent.\nIf left unspecified, the runtime's file resource provider would try to fetch these assets for widgets and controls through HTTP, resulting in 404 errors being logged.\nSo whenever you see such an error in the log and decide that the absence of the corresponding file is fine, an appropriate entry can be added to this configuration.\nThe list entries can be strings or regular expressions.\nRegular expressions are tested against requested file names, while strings will match any file name that contains them anywhere.  In this example the widget uses the  i18n  control.\nWe already know that there is no theme, and hence no CSS file for this control, as it only provides some APIs and has no visual representation.\nWhen loading the widget from a running application, the generated file listing would yield that the file is absent and it wouldn't be loaded.\nDuring testing we have to give that hint manually, as seen in this example.  Further information can be found in the  api docs .", 
            "title": "knownMissingResources"
        }, 
        {
            "location": "/manuals/introduction/#3-widget-configuration", 
            "text": "In the next step we configure the features of the widget, just as it normally happens in a page definition.\nThe object you'd put under the key  features  can simply be passed to the method  axMocks.widget.configure .\nFor convenience it's also possible to use an object attribute path and a single value as arguments.\nThis is e.g. useful if the widget gets pre-configured in an outer  describe  block and is adjusted deeper in a nested structure.  So here we could have also written this:  beforeEach (   function ()   { \n    axMocks . widget . configure (   example.resource ,   exampleResource   ); \n    axMocks . widget . configure (   example.action ,   exampleAction   );  }   );", 
            "title": "3. Widget Configuration"
        }, 
        {
            "location": "/manuals/introduction/#4-loading-the-widget", 
            "text": "Here we tell the widget loader to actually load the widget controller.\nSince the API of the widget loader is asynchronous, the  load  method is asynchronous as well and thus expects a  Jasmine   done  callback.\nAgain, to keep it as simple as possible for the user, the  load  method doesn't need to be called directly, but can simply be passed on to  beforeEach \nMake sure to load the widget only when all configuration has been applied, because afterwards calls to  axMocks.widget.configure  have no effect.", 
            "title": "4. Loading the Widget"
        }, 
        {
            "location": "/manuals/introduction/#5-optional-rendering-the-widget-dom", 
            "text": "Naturally this step does not apply to activities, since they do not influence the DOM and in particular have no visual representation.\nCalling the  axMocks.widget.render()  for activities isn't harmful, but simply has no effect at all.\nIn case of a widget, the template is compiled by the underlying technology adapter, wrapped in a  div  element and the resulting DOM node returned.\nThis is not different from the rendering process in a regular application.\nInstead of appending the DOM to a widget area, it is appended to the body element of the test.\nIt is removed again before the next test run would render its DOM or when calling  axMocks.tearDown .", 
            "title": "5. Optional: Rendering the Widget DOM"
        }, 
        {
            "location": "/manuals/introduction/#6-optional-mocking-an-angularjs-injection", 
            "text": "For this example, we assume that we're testing an  AngularJS  widget, which performs some backend communication, using the  $http  service provided by  AngularJS . AngularJS Mocks  aids us in this case, by providing the instrumentation API  $httpBackend .\nTo prevent from going too much into detail, the  AngularJS Mocks API  should be your source of information in that regard.", 
            "title": "6. Optional: Mocking an AngularJS Injection"
        }, 
        {
            "location": "/manuals/introduction/#7-optional-simulating-startup-events", 
            "text": "When a page within a  LaxarJS  application loads, the runtime publishes several initial events.\nMany widgets don't actually care for these events and only subscribe to custom events such as  didReplace  or  takeActionRequest .\nOther widgets may depend on  core events  like  didChangeLocale  or  didNavigate  with certain parameters.  In order to be able to test a widgets response to core events without duplicating too much of this task within every test, the method  axMocks.triggerStartupEvents  publishes all events the runtime would publish in the correct order.\nThe method allows to configure parts of these events or skip some of them completely.\nFor further information on event configuration have a look at the extensive  API docs .", 
            "title": "7.  Optional: Simulating Startup Events"
        }, 
        {
            "location": "/manuals/introduction/#8-tests", 
            "text": "Now you're set up to write your actual tests.\nAt this point the widget controller is instantiated, the (optional) DOM fragment has been rendered and all relevant runtime events were published.  Probably you want to group your tests into functional use cases via  Jasmine   describe  functions.\nIn this case it is sometimes a good thing to postpone the calls to  axMocks.widget.load ,  axMocks.widget.render  and  axMocks.triggerStartupEvents .\nIt is then possible to structure the test in isolated  describe  blocks, to adjust the configuration for each block as needed and only afterwards call the other methods to actually fire up your tests.", 
            "title": "8. Tests"
        }, 
        {
            "location": "/manuals/introduction/#9-test-tear-down", 
            "text": "Every widget test should call  axMocks.tearDown  in a  Jasmine   afterEach  block or simply pass it to  afterEach  as a callback.\nThis ensures, that after one test is run, the DOM is cleaned up and the widget with all its dependencies is destroyed.\nIf this is omitted, it cannot be guaranteed that remainders of the previous test run do not influence the current test run.", 
            "title": "9. Test Tear-Down"
        }, 
        {
            "location": "/manuals/introduction/#directory-layout", 
            "text": "If you generated your widget or activity using the latest template, everything should be set up correctly.\nWhen creating the widget artifacts manually, we recommend the following directory layout for the tests within the widget directory:  example-widget\n\n+-- example-widget.js\n+-- widget.json\n+-- spec\n    +-- example-widget.spec.js\n    +-- spec_runner.html\n    +-- spec_runner.js  When following this structure, the AMD module definition from the top of this introduction should work for you.\nYou just have to ensure that paths such as  laxar-mocks  and  angular-mocks  are configured correctly, as described in the README.  When running the widget test in your browser, this is achieved by using the correct paths in the file  spec_runner.html .\nBy default it is assumed that any widget directory can be found at the directory  includes/widget/ your category /  under the application root.\nThe  require_config.js  of the application will then be loaded by stepping up to the parent directory five times (see  here  for an example).\nFor tests to run, at least the paths  requirejs ,  jasmine ,  laxar-mocks  and the RequireJS  json  plugin have to be defined in that file.\nWhen testing  AngularJS  widgets, the path to  angular-mocks  must be defined as well.  The next file that is loaded is  spec_runner.js  (an example can be found  here ).\nThis file merely defines which actual test files to load and run.\nThese files are located relative to   spec_runner.js .\nOptionally you can overwrite  RequireJS  configuration from the application's  require_config.js  file, by setting the appropriate entries under the property  requireConfig .\nFor example, it may sometimes be a good idea to mock a large external library with a simpler stub for testing.  Finally, the module  example-widget.spec.js  defines the actual testing code.\nIf you're following these guidelines, the widget descriptor ( widget.json ) can also be loaded as explained in the example, so that the widget under test can be instantiated without problems.", 
            "title": "Directory Layout"
        }, 
        {
            "location": "/manuals/jasmine-compatibility/", 
            "text": "return to the manuals\n\n\nMultiple Jasmine Versions in one Project\n\n\nThe LaxarJS core in Version 1.0 already ships with built-in widget testing support for \nJasmine v1.3\n, which can be imported using the AMD reference \nlaxar/laxar_testing\n.\nHowever, in that testing framework, only widgets implemented in AngularJS are supported.\nAlso, the old builtin testing module contains several peculiarities which are sometimes confusing:\nFor example, events are delivered as a side-effect of \"ticking\" the virtual clock.\nBecause of the semantic versioning model used by LaxarJS, the old testing module will stay part of the core at least until LaxarJS v2.0 is released.\n\n\nFor the future (starting with LaxarJS v1.1.0), the \nlaxar-mocks\n library moves testing functionality out of the core.\nBesides relying on the modern \nJasmine v2.3\n, this test runner allows you to test non-angular widgets, provided that you have a corresponding \nadapter\n.\nOf course, LaxarJS aims to support widgets using the old \nlaxar/laxar_testing\n and those using the new \nlaxar-mocks\n \nwithin the same application\n.\nThis means that both types of widgets will share a set of Bower components.\nTo avoid jasmine version conflicts, the \nHTML spec-runner\n expects a \njasmine2\n path to be configured with RequireJS in order to use laxar-mocks and Jasmine v2.3.\nThis allows you to install Jasmine versions 1.x and 2.x in the same project.\nFor more information on configuring \nBower\n and \nRequireJS\n for \nlaxar-mocks\n, check out the \nInstallation\n instructions in the \nREADME\n.\n\n\nUsing the \nspec-runner configuration\n you can declare the jasmine version as well as the actual test-runner module to be used.\nThe spec-runner configuration is respected by the HTML spec-runner as well as on the command line (when you call \ngrunt test\n), through \nkarma-laxar\n.\nThis way you can choose among the testing frameworks.\n\n\nConfiguring the Spec-Runner\n\n\nA widget's spec-runner configuration (\nspec_runner.js\n) defines a property \nlaxarSpec\n on the global object (or on its module when running in node), with the following properties:\n\n\n- the `title` of the spec test\n- the `tests` to be run (AMD module files in the same folder)\n- the AMD module of the `testRunner` to use.\nFor the future and to use jasmine 2, use `\nlaxar-mocks\n`.\nIf nothing is specified, the old `\nlaxar/laxar_testing\n` will be used.\n- the `jasmineMajorVersion` to use.\nWhen using `laxar-mocks` as the _testRunner_, make sure to specify `2`.\nBy default, the major version `1` is assumed, which will work with the old testing module.\n\n\n\n\n\nUsually, everything you need has been setup correctly by the widget template when creating your widget.\nThe only time that you have to edit the spec-runner configuration is when upgrading a widget from the old builtin testing module (and Jasmine 1.3.x) to using \nlaxar-mocks\n (and Jasmine 2.3.x).", 
            "title": "Multiple Jasmine Versions in one Project"
        }, 
        {
            "location": "/manuals/jasmine-compatibility/#multiple-jasmine-versions-in-one-project", 
            "text": "The LaxarJS core in Version 1.0 already ships with built-in widget testing support for  Jasmine v1.3 , which can be imported using the AMD reference  laxar/laxar_testing .\nHowever, in that testing framework, only widgets implemented in AngularJS are supported.\nAlso, the old builtin testing module contains several peculiarities which are sometimes confusing:\nFor example, events are delivered as a side-effect of \"ticking\" the virtual clock.\nBecause of the semantic versioning model used by LaxarJS, the old testing module will stay part of the core at least until LaxarJS v2.0 is released.  For the future (starting with LaxarJS v1.1.0), the  laxar-mocks  library moves testing functionality out of the core.\nBesides relying on the modern  Jasmine v2.3 , this test runner allows you to test non-angular widgets, provided that you have a corresponding  adapter .\nOf course, LaxarJS aims to support widgets using the old  laxar/laxar_testing  and those using the new  laxar-mocks   within the same application .\nThis means that both types of widgets will share a set of Bower components.\nTo avoid jasmine version conflicts, the  HTML spec-runner  expects a  jasmine2  path to be configured with RequireJS in order to use laxar-mocks and Jasmine v2.3.\nThis allows you to install Jasmine versions 1.x and 2.x in the same project.\nFor more information on configuring  Bower  and  RequireJS  for  laxar-mocks , check out the  Installation  instructions in the  README .  Using the  spec-runner configuration  you can declare the jasmine version as well as the actual test-runner module to be used.\nThe spec-runner configuration is respected by the HTML spec-runner as well as on the command line (when you call  grunt test ), through  karma-laxar .\nThis way you can choose among the testing frameworks.", 
            "title": "Multiple Jasmine Versions in one Project"
        }, 
        {
            "location": "/manuals/jasmine-compatibility/#configuring-the-spec-runner", 
            "text": "A widget's spec-runner configuration ( spec_runner.js ) defines a property  laxarSpec  on the global object (or on its module when running in node), with the following properties:  - the `title` of the spec test\n- the `tests` to be run (AMD module files in the same folder)\n- the AMD module of the `testRunner` to use.\nFor the future and to use jasmine 2, use ` laxar-mocks `.\nIf nothing is specified, the old ` laxar/laxar_testing ` will be used.\n- the `jasmineMajorVersion` to use.\nWhen using `laxar-mocks` as the _testRunner_, make sure to specify `2`.\nBy default, the major version `1` is assumed, which will work with the old testing module.  Usually, everything you need has been setup correctly by the widget template when creating your widget.\nThe only time that you have to edit the spec-runner configuration is when upgrading a widget from the old builtin testing module (and Jasmine 1.3.x) to using  laxar-mocks  (and Jasmine 2.3.x).", 
            "title": "Configuring the Spec-Runner"
        }
    ]
}