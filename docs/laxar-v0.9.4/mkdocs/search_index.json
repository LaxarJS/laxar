{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS\n\n\nHave a look at the \nmanuals\n or the \nAPI doc\n.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs", 
            "text": "Have a look at the  manuals  or the  API doc .", 
            "title": "LaxarJS"
        }, 
        {
            "location": "/api/", 
            "text": "API Documentation", 
            "title": "Overview"
        }, 
        {
            "location": "/api/#api-documentation", 
            "text": "", 
            "title": "API Documentation"
        }, 
        {
            "location": "/manuals/", 
            "text": "return to index\n\n\nManuals\n\n\n\n\nWriting Pages", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Writing Pages", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/i18n/", 
            "text": "return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nInternationalizing a widget (i18n)\n\n\nIn LaxarJS, internationalization of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching them without reloading the page.\n\n\nConcept of i18n in LaxarJS\n\n\nLaxarJS distinguishes \nlocales\n and \nlanguage tags\n for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a language tag like \"en_US\", which can change over time.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the \nchangeLocaleRequest.{locale}\n event.\n\n\nExample: To change the language tag of the locale \nmyLocale\n to \nde_DE\n, the following event has to be published:\n\n\n$scope\n.\neventBus\n.\npublish\n(\n \nchangeLocaleRequest.myLocale.\n,\n\n    \n{\n \n        \nlocale\n:\n \nmyLocale\n,\n \n        \nlanguageTag\n:\n \nde_DE\n \n    \n}\n\n\n);\n\n\n\n\n\n\nIf a widget is interested in changes to \nmyLocale\n, it would subscribe to the corresponding \ndidChangeLocale\n-event, which is published by the LaxarJS flow-controller:\n\n\n$scope\n.\neventBus\n.\nsubscribe\n(\n \ndidChangeLocale.myLocale.\n,\n \nfunction\n(\n \nevent\n \n)\n \n{\n\n   \nax\n.\nlog\n.\ninfo\n(\n \nI have received tag [0] for locale [1]\n,\n \nevent\n.\nlanguageTag\n,\n \nevent\n.\nlocale\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nWidgets can use the language tags that they receive over the event bus to \nlocalize\n internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with \ni18n\n:\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen_US\n:\n \nUpload file\n,\n\n    \nde_DE\n:\n \nDatei hochladen\n\n\n}\n\n\n\n\n\n\nLaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.\n\n\nWriting an i18n-capable Widget\n\n\nTo be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry \ncontrols\n in the \nwidget.json\n.\nIf missing, this entry must be created:\n\n\ncontrols\n:\n \n[\n\n    \nlaxar_uikit/controls/i18n\n\n\n]\n\n\n\n\n\n\nNext, we have to add a feature \ni18n\n.\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example en_GB) is then used to localize internationalized values.\n\n\ni18n\n:\n \n{\n\n   \ndescription\n:\n \nWhich locale to use for displaying this widget.\n,\n\n   \ntype\n:\n \nobject\n,\n\n   \nproperties\n:\n \n{\n\n      \nlocale\n:\n \n{\n\n         \ntype\n:\n \nstring\n,\n\n         \ndescription\n:\n \nThe topic under which to expect the locale for this widget.\n,\n\n         \ndefault\n:\n \ndefault\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIf not already done, we import the Laxar-Patterns library into the widget controller (\nmy_widget.js\n).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right \ndidChangeLocale\n-events for us, by using the feature configuration that we added in the previous step:\n\n\ndefine\n(\n \n[\n   \n   \nlaxar_patterns\n\n\n],\n \nfunction\n(\n \npatterns\n \n)\n \n{\n\n   \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n \n);\n\n   \n...\n\n\n}\n\n\n\n\n\n\nAny updates to the i18n-locale received over the event bus will now be saved under \n$scope.i18n\n, along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:\n\n\n$scope.i\n18\nn\n \n=\n \n{\n      \n   \nlocale:\n \ndefault\n,\n\n   \ntags:\n \n{\n\n      \ndefault\n:\n \nen_US\n,\n\n      \ncustomer\n:\n \nde_DE\n,\n\n      \nsupport\n:\n \nen_GB\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIn the HTML template we can now use the angular filter \naxLocalize\n to convert an i18nHtmlText to a string:\n\n\np\n \ndata-ng-bind-html\n=\nmodel.i18nHtmlText | axLocalize:i18n\n/\np\n\n\n\n\n\n\nThe filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses \n$scope.i18n.locale\n (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.\n\n\ni18nHtmlText\n:\n \n{\n\n    \nen_US\n:\n \nUpload file \nem\nnow\n/em\n,\n\n    \nde_DE\n:\n \nDatei \nem\njetzt\n/em\n hochladen\n\n\n}\n\n\n\n\n\n\nLocalizing values in the controller\n\n\nIn some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.\n\n\np\n \ndata-ng-bind-html\n=\nmodel.htmlVeryLongDocument\n/\np\n\n\n\n\n\n\nTo achieve this, we obtain a \nlocalize\n function when we subscribe the widget to the didChangeLocale event.\nLike the \naxLocalize\n-directive, this function automatically uses the current language tag:\n\n\nvar\n \nlocalize\n \n=\n \npatterns\n.\ni18n\n.\nhandlerFor\n(\n \n$scope\n \n).\nscopeLocaleFromFeature\n(\n \ni18n\n,\n \n{\n\n    \nonChange\n:\n \nupdateLocalization\n\n\n}\n \n).\nlocalizer\n();\n\n\n\n\n\n\nThen we can transform any object with language tag properties to a string using the \nlocalize\n function:\n\n\nfunction\n \nupdateLocalization\n()\n \n{\n\n   \nvar\n \ndocumentUrl\n \n=\n \nlocalize\n(\n \n$scope\n.\nfeatures\n.\ni18nDocumentUrl\n \n);\n\n   \n$http\n.\nget\n(\n \ndocumentUrl\n \n).\nthen\n(\n \nfunction\n(\n \nresponse\n \n)\n \n{\n\n      \n$scope\n.\nmodel\n.\nhtmlVeryLongDocument\n \n=\n \nresponse\n.\ndata\n;\n\n   \n}\n \n);\n\n\n}", 
            "title": "Internationalizing a widget (i18n)"
        }, 
        {
            "location": "/manuals/i18n/#internationalizing-a-widget-i18n", 
            "text": "In LaxarJS, internationalization of widgets is optional.\nRead on if you are interested in writing widgets that support multiple languages, and even switching them without reloading the page.", 
            "title": "Internationalizing a widget (i18n)"
        }, 
        {
            "location": "/manuals/i18n/#concept-of-i18n-in-laxarjs", 
            "text": "LaxarJS distinguishes  locales  and  language tags  for internationalization.\nEach locale has a constant name like \"default\" or \"customer\" and a language tag like \"en_US\", which can change over time.\nThe language tag of a given locale can be modified through activities or widgets when the application is running.\nTo change the language tag of a locale an activity has to publish the  changeLocaleRequest.{locale}  event.  Example: To change the language tag of the locale  myLocale  to  de_DE , the following event has to be published:  $scope . eventBus . publish (   changeLocaleRequest.myLocale. , \n     {  \n         locale :   myLocale ,  \n         languageTag :   de_DE  \n     }  );   If a widget is interested in changes to  myLocale , it would subscribe to the corresponding  didChangeLocale -event, which is published by the LaxarJS flow-controller:  $scope . eventBus . subscribe (   didChangeLocale.myLocale. ,   function (   event   )   { \n    ax . log . info (   I have received tag [0] for locale [1] ,   event . languageTag ,   event . locale   );  }   );   Widgets can use the language tags that they receive over the event bus to  localize  internationalized values.\nInternationalized values are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with  i18n :  i18nHtmlText :   { \n     en_US :   Upload file , \n     de_DE :   Datei hochladen  }   LaxarJS provides some tools which help to deal with i18n.\nThey are based on the events shown above, and demonstrated in the following section.", 
            "title": "Concept of i18n in LaxarJS"
        }, 
        {
            "location": "/manuals/i18n/#writing-an-i18n-capable-widget", 
            "text": "To be able to localize internationalized values in templates, widgets can use the i18n-directives which are provided by Laxar-UiKit.\nThis is accomplished by adding the i18n control to the top-level entry  controls  in the  widget.json .\nIf missing, this entry must be created:  controls :   [ \n     laxar_uikit/controls/i18n  ]   Next, we have to add a feature  i18n .\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example en_GB) is then used to localize internationalized values.  i18n :   { \n    description :   Which locale to use for displaying this widget. , \n    type :   object , \n    properties :   { \n       locale :   { \n          type :   string , \n          description :   The topic under which to expect the locale for this widget. , \n          default :   default \n       } \n    }  }   If not already done, we import the Laxar-Patterns library into the widget controller ( my_widget.js ).\nThe i18n-handler offered by Laxar-Patterns subscribes the widget to the right  didChangeLocale -events for us, by using the feature configuration that we added in the previous step:  define (   [    \n    laxar_patterns  ],   function (   patterns   )   { \n    patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n   ); \n    ...  }   Any updates to the i18n-locale received over the event bus will now be saved under  $scope.i18n , along with their tags.\nMore locales may be registered for other features (if a single widget wants to use more than one language at the same time), resulting ins something like:  $scope.i 18 n   =   {       \n    locale:   default , \n    tags:   { \n       default :   en_US , \n       customer :   de_DE , \n       support :   en_GB \n    }  }   In the HTML template we can now use the angular filter  axLocalize  to convert an i18nHtmlText to a string:  p   data-ng-bind-html = model.i18nHtmlText | axLocalize:i18n / p   The filter expects an object for internationalization or a string if the value is not internationalized.\nIt uses  $scope.i18n.locale  (passed as an argument to the filter) to select the correct language tag.\nEvery property of the object should have a language tag as key and the translated text or html as value.  i18nHtmlText :   { \n     en_US :   Upload file  em now /em , \n     de_DE :   Datei  em jetzt /em  hochladen  }", 
            "title": "Writing an i18n-capable Widget"
        }, 
        {
            "location": "/manuals/i18n/#localizing-values-in-the-controller", 
            "text": "In some cases it is more appropriate to create the localized string inside the controller of the widget.\nThis is the case if the localization has to be retrieved from the server first.  p   data-ng-bind-html = model.htmlVeryLongDocument / p   To achieve this, we obtain a  localize  function when we subscribe the widget to the didChangeLocale event.\nLike the  axLocalize -directive, this function automatically uses the current language tag:  var   localize   =   patterns . i18n . handlerFor (   $scope   ). scopeLocaleFromFeature (   i18n ,   { \n     onChange :   updateLocalization  }   ). localizer ();   Then we can transform any object with language tag properties to a string using the  localize  function:  function   updateLocalization ()   { \n    var   documentUrl   =   localize (   $scope . features . i18nDocumentUrl   ); \n    $http . get (   documentUrl   ). then (   function (   response   )   { \n       $scope . model . htmlVeryLongDocument   =   response . data ; \n    }   );  }", 
            "title": "Localizing values in the controller"
        }, 
        {
            "location": "/manuals/writing_pages/", 
            "text": "return to the manuals\n\n\nPreliminary readings:\n\n\n\n\nCreating Layouts\n\n\nWidgets and Activities\n\n\n\n\nWriting Pages\n\n\nPages are written in a declarative fashion using the JSON format. Starting point is a simple object and some specific properties that will be explained in this document.\n\n\nLayouts and Areas\n\n\nFirst of all a page should specify the layout which defines the available widget areas and how they are arranged visually when rendered by the web browser. If a page is intended to be used as a base page for inheritance (see chapter \nInheritance\n for more information), the layout property should be omitted as for the time being only one page in an extension chain may define a layout.\n\n\nConfiguring the layout is done via the \nlayout\n property of the page object. Its value is the name of the layout which is in turn a relative path to where the specific layout's assets are located (see \nCreating Layouts\n for further information). If for example the desired layout is located at \npopups/layout_one\n, the according page (without any widgets yet) would look like this:\n\n\n{\n   \nlayout\n: \npopups/layout_one\n\n}\n\n\n\n\n\nNow let's assume the html file of \npopups/layout_one\n looks like this:\n\n\ndiv\n\n   \ndiv ax-widget-area=\nheader\n/div\n\n   \ndiv ax-widget-area=\ncontent\n/div\n\n   \ndiv ax-widget-area=\nfooter\n/div\n\n\n/div\n\n\n\n\n\n\nHence there are three areas available, that can be occupied by widgets on the page. To do so, we add another top-level key \nareas\n parallel to\nlayout\n. Its value is a map, where each key is the name of a widget area defined in the layout and the values are arrays, that will later receive the widgets. The order of the areas in the map doesn't matter, as the layout decides where each area will later be displayed. Nevertheless it is advised to keep the order, as it simplifies matters. We thus get the following page file:\n\n\n{\n   \nlayout\n: \npopups/layout_one\n,\n   \nareas\n: {\n      \nheader\n: [],\n      \ncontent\n: [],\n      \nfooter\n: []\n   }\n}\n\n\n\n\n\nThe arrays can now be filled with the widgets to render within each area. In contrast to the area map order is important here, as this is the order in which the widgets will be rendered in the DOM.\n\n\nEach entry in the array is an object that can either reference a widget or a \ncomposition\n. It thus needs to specify either \nwidget\n or \ncomposition\n as key. Additionally a page wide unique (even over inheritance) \nid\n property can be provided. This can be useful for debugging and is mandatory in case a widget provides one or more embedded areas (like e.g. the popover widget). The latter case is explained in detail later in \nTODO\n. Finally it is possible to provide configuration for a widget or a composition under the key \nfeatures\n.\n\n\nOur example with some simple exemplary content:\n\n\n{\n   \nlayout\n: \npopups/layout_one\n,\n   \nareas\n: {\n      \nheader\n: [\n         {\n            \nwidget\n: \nportal/headline_widget\n,\n            \nfeatures\n: {\n               \nheadline\n: {\n                  \nhtmlText\n: \nWelcome!\n,\n                  \nlevel\n: 3\n               }\n            }\n         }\n      ],\n      \ncontent\n: [\n         {\n            \nwidget\n: \nportal/command_bar_widget\n,\n            \nfeatures\n: {\n               \nnext\n: {\n                  \nenabled\n: true\n               }\n            }\n         },\n         {\n            \ncomposition\n: \npopup_composition\n,\n            \nfeatures\n: {\n               \nopenPopup\n: {\n                  \nonActions\n: [ \nnext\n ]\n               }\n            }\n         }\n      ],\n      \nfooter\n: [\n         {\n            \nwidget\n: \nportal/html_display_widget\n,\n            \nfeatures\n: {\n               \ncontent\n: {\n                  \nresource\n: \nfooterTextResource\n\n               }\n            }\n         }\n      ]\n   }\n}\n\n\n\n\n\nInheritance\n\n\nThe most simple way to reuse parts of a page specification is by inheritance. Due to the intentional lack of complex additional inheritance features it is also the most limited way of specification reuse. Nevertheless it has its valid use cases as in every user interface there are some elements that never change across pages. These should be extracted into a base page which defines no layout and than reused by all other pages defining the layout necessary to display their contents.\n\n\nValid candidate widgets for base pages are application headlines, informational notes in a footer area or activities providing common tasks for all pages. Let's apply this to our example from above and extract the HeadlineWidget into a base page called \nbase_page.json\n.\n\n\n{\n   \nareas\n: {\n      \nheader\n: [\n         {\n            \nwidget\n: \nportal/headline_widget\n,\n            \nfeatures\n: {\n               \nheadline\n: {\n                  \nhtmlText\n: \nWelcome!\n,\n                  \nlevel\n: 3\n               }\n            }\n         }\n      ]\n   }\n}\n\n\n\n\n\nWe now can modify our original page using the keyword \nextends\n that references the base page. The parts already provided by the base page can then be deleted:\n\n\n{\n   \nlayout\n: \npopups/layout_one\n,\n   \nextends\n: \nbase_page\n,\n   \nareas\n: {\n      \ncontent\n: [\n         {\n            \nwidget\n: \nportal/command_bar_widget\n,\n            \nfeatures\n: {\n               \nnext\n: {\n                  \nenabled\n: true\n               }\n            }\n         },\n         {\n            \ncomposition\n: \npopup_composition\n,\n            \nfeatures\n: {\n               \nopenPopup\n: {\n                  \nonActions\n: [ \nnext\n ]\n               }\n            }\n         }\n      ],\n      \nfooter\n: [\n         {\n            \nwidget\n: \nportal/html_display_widget\n,\n            \nfeatures\n: {\n               \ncontent\n: {\n                  \nresource\n: \nfooterTextResource\n\n               }\n            }\n         }\n      ]\n   }\n}\n\n\n\n\n\nIt is also possible to add widgets to an area, that is already filled with one or more widgets in the base page. Those widgets in the extending page will be appended to the according area and thus appear after the base widgets in the DOM. If a widget should explicitly be added before another widget, this can be achieved using the keyword \ninsertBeforeId\n. Note that for this to work it's necessary to provide an \nid\n property at the according widget in the base page.\n\n\nLet's assume we wanted to add another additional headline in one extending page. We therefore change the base page first and add an id to the existing headline:\n\n\n{\n   \nareas\n: {\n      \nheader\n: [\n         {\n            \nwidget\n: \nportal/headline_widget\n,\n            \nid\n: \nmainHeadline\n,\n            \nfeatures\n: {\n               \nheadline\n: {\n                  \nhtmlText\n: \nWelcome!\n,\n                  \nlevel\n: 3\n               }\n            }\n         }\n      ]\n   }\n}\n\n\n\n\n\nThe page that has the need to add content thus looks something like this:\n\n\n{\n   \nlayout\n: \npopups/layout_one\n,\n   \nextends\n: \nbase_page\n,\n   \nareas\n: {\n      \nheader\n: [\n         {\n            \nwidget\n: \nportal/headline_widget\n,\n            \ninsertBeforeId\n: \nmainHeadline\n,\n            \nfeatures\n: {\n                \nheadline\n: {\n                   \nhtmlText\n: \nYou just won one billion dollar!\n\n                }\n            }\n         }\n      ],\n      \ncontent\n: [ \n ... some widgets ... \n ],\n      \nfooter\n: [ \n ... some widgets ... \n ]\n   }\n}\n\n\n\n\n\nThat is all inheritance can do for you. Compositions are the way to got for sophisticated reuse of partial specifications. So read on!\n\n\nCompositions\n\n\nIn short compositions are a mixture of page and widget definition: They fill areas with widgets, specify which features are configurable and are used within another page (or composition) like a normal widget.", 
            "title": "Writing Pages"
        }, 
        {
            "location": "/manuals/writing_pages/#writing-pages", 
            "text": "Pages are written in a declarative fashion using the JSON format. Starting point is a simple object and some specific properties that will be explained in this document.", 
            "title": "Writing Pages"
        }, 
        {
            "location": "/manuals/writing_pages/#layouts-and-areas", 
            "text": "First of all a page should specify the layout which defines the available widget areas and how they are arranged visually when rendered by the web browser. If a page is intended to be used as a base page for inheritance (see chapter  Inheritance  for more information), the layout property should be omitted as for the time being only one page in an extension chain may define a layout.  Configuring the layout is done via the  layout  property of the page object. Its value is the name of the layout which is in turn a relative path to where the specific layout's assets are located (see  Creating Layouts  for further information). If for example the desired layout is located at  popups/layout_one , the according page (without any widgets yet) would look like this:  {\n    layout :  popups/layout_one \n}  Now let's assume the html file of  popups/layout_one  looks like this:  div \n    div ax-widget-area= header /div \n    div ax-widget-area= content /div \n    div ax-widget-area= footer /div  /div   Hence there are three areas available, that can be occupied by widgets on the page. To do so, we add another top-level key  areas  parallel to layout . Its value is a map, where each key is the name of a widget area defined in the layout and the values are arrays, that will later receive the widgets. The order of the areas in the map doesn't matter, as the layout decides where each area will later be displayed. Nevertheless it is advised to keep the order, as it simplifies matters. We thus get the following page file:  {\n    layout :  popups/layout_one ,\n    areas : {\n       header : [],\n       content : [],\n       footer : []\n   }\n}  The arrays can now be filled with the widgets to render within each area. In contrast to the area map order is important here, as this is the order in which the widgets will be rendered in the DOM.  Each entry in the array is an object that can either reference a widget or a  composition . It thus needs to specify either  widget  or  composition  as key. Additionally a page wide unique (even over inheritance)  id  property can be provided. This can be useful for debugging and is mandatory in case a widget provides one or more embedded areas (like e.g. the popover widget). The latter case is explained in detail later in  TODO . Finally it is possible to provide configuration for a widget or a composition under the key  features .  Our example with some simple exemplary content:  {\n    layout :  popups/layout_one ,\n    areas : {\n       header : [\n         {\n             widget :  portal/headline_widget ,\n             features : {\n                headline : {\n                   htmlText :  Welcome! ,\n                   level : 3\n               }\n            }\n         }\n      ],\n       content : [\n         {\n             widget :  portal/command_bar_widget ,\n             features : {\n                next : {\n                   enabled : true\n               }\n            }\n         },\n         {\n             composition :  popup_composition ,\n             features : {\n                openPopup : {\n                   onActions : [  next  ]\n               }\n            }\n         }\n      ],\n       footer : [\n         {\n             widget :  portal/html_display_widget ,\n             features : {\n                content : {\n                   resource :  footerTextResource \n               }\n            }\n         }\n      ]\n   }\n}", 
            "title": "Layouts and Areas"
        }
    ]
}