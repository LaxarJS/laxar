{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS Patterns\n\n\nTo allow for widgets to cooperate without tight coupling, it is very useful to share a basic event vocabulary.\nThe LaxarJS Runtime already defines the semantics of \ncore event patterns\n.\nFor application-level events, \nLaxarJS Patterns\n provides an additional vocabulary, which may be grouped into a handful of _pattern families__.\nBefore starting with the patterns, make sure that you are familiar with the \nLaxarJS Core Concepts\n and the \nLaxarJS events manual\n.\n\n\nFamilies of LaxarJS Patterns\n\n\nMost application-level events have to do with \nresources\n, \nactions\n and \nflags\n.\nThere is a common theme to how these patterns are used:\nWidgets define \nwhat events\n generally concern them, but the page configuration is used to constrain \nwhere\n or \nwhen\n they are interested in these events:\n\n\n* an email viewer is interested in _resource-events_, but only for the _currently selected email_ resource, not for the _mailbox_ resource\n* a navigation activity may be interested in _action-events_, but only in those generated by the _next_ and _previous_ buttons, not in those generated by the _save_ button\n* a widget presenting real-time stock market information is interested in _flag-events_, but only those that tell wether its container popover widget is currently open, so that it may pause updates otherwise\n\n\n\n\n\nResources\n\n\nPossibly the most important family of patterns, \nresource events\n deals with sharing, validating and persisting application \nresources\n.\nHere, \nresource\n usually refers to a \nJSON\n representation of a \nREST\n resource, for example in \nHAL\n format.\nHowever, LaxarJS and the patterns described here do not actually make assumptions about the origin or the internal structure of resources, except that they are directly representable as JSON objects.\nThis means that it is perfectly acceptable to obtain resources through a different mechanism than HTTP (such as \nWebSockets\n or \nlocalStorage\n).\n\n\nThe resource patterns cover events starting with the following topics:\n\n\n* `didReplace` and `didUpdate`\n* `validateRequest`, `willValidate` and `didValidate`\n* `saveRequest`, `willSave` and `didSave`\n\n\n\n\n\nmore on resources \u00bb\n\n\nActions\n\n\nWidgets may publish \nrequests for action\n to indicate that the user has triggered some functionality outside of their own scope.\nDepending on the page configuration, other widgets will respond to these actions in whatever way is appropriate or configured for them.\nWidgets may respond using the \nwill/did\n-mechanism\n, for long running actions.\n\n\nThe actions pattern covers events starting with the following topics:\n\n\n* `takeActionRequest`, `willTakeAction` and `didTakeAction`\n\n\n\n\n\nmore on actions \u00bb\n\n\nFlags\n\n\nFlags\n allow widgets to communicate boolean state.\nFor example, one activity could track validation events from all widgets on a page and publish a flag describing the overall validation state.\nA navigation widget could then enable or disable its \"save\" button according to that state.\n\n\nThe flag pattern covers events starting with the following topics:\n\n\n* `didChangeFlag`\n\n\n\n\n\nmore on flags \u00bb\n\n\nErrors\n\n\nSometimes widgets and especially activities have to indicate an error situation that is not recoverable (such as a network problem).\nThe \nerror events\n can be used to broadcast these problems, and have another component handle them, through means such as logging, displaying a problem message to the user or navigating to an error page.\n\n\nThe error pattern covers events starting with the following topics:\n\n\n* `didEncounterError`\n\n\n\n\n\nmore on errors \u00bb", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs-patterns", 
            "text": "To allow for widgets to cooperate without tight coupling, it is very useful to share a basic event vocabulary.\nThe LaxarJS Runtime already defines the semantics of  core event patterns .\nFor application-level events,  LaxarJS Patterns  provides an additional vocabulary, which may be grouped into a handful of _pattern families__.\nBefore starting with the patterns, make sure that you are familiar with the  LaxarJS Core Concepts  and the  LaxarJS events manual .", 
            "title": "LaxarJS Patterns"
        }, 
        {
            "location": "/#families-of-laxarjs-patterns", 
            "text": "Most application-level events have to do with  resources ,  actions  and  flags .\nThere is a common theme to how these patterns are used:\nWidgets define  what events  generally concern them, but the page configuration is used to constrain  where  or  when  they are interested in these events:  * an email viewer is interested in _resource-events_, but only for the _currently selected email_ resource, not for the _mailbox_ resource\n* a navigation activity may be interested in _action-events_, but only in those generated by the _next_ and _previous_ buttons, not in those generated by the _save_ button\n* a widget presenting real-time stock market information is interested in _flag-events_, but only those that tell wether its container popover widget is currently open, so that it may pause updates otherwise", 
            "title": "Families of LaxarJS Patterns"
        }, 
        {
            "location": "/#resources", 
            "text": "Possibly the most important family of patterns,  resource events  deals with sharing, validating and persisting application  resources .\nHere,  resource  usually refers to a  JSON  representation of a  REST  resource, for example in  HAL  format.\nHowever, LaxarJS and the patterns described here do not actually make assumptions about the origin or the internal structure of resources, except that they are directly representable as JSON objects.\nThis means that it is perfectly acceptable to obtain resources through a different mechanism than HTTP (such as  WebSockets  or  localStorage ).  The resource patterns cover events starting with the following topics:  * `didReplace` and `didUpdate`\n* `validateRequest`, `willValidate` and `didValidate`\n* `saveRequest`, `willSave` and `didSave`  more on resources \u00bb", 
            "title": "Resources"
        }, 
        {
            "location": "/#actions", 
            "text": "Widgets may publish  requests for action  to indicate that the user has triggered some functionality outside of their own scope.\nDepending on the page configuration, other widgets will respond to these actions in whatever way is appropriate or configured for them.\nWidgets may respond using the  will/did -mechanism , for long running actions.  The actions pattern covers events starting with the following topics:  * `takeActionRequest`, `willTakeAction` and `didTakeAction`  more on actions \u00bb", 
            "title": "Actions"
        }, 
        {
            "location": "/#flags", 
            "text": "Flags  allow widgets to communicate boolean state.\nFor example, one activity could track validation events from all widgets on a page and publish a flag describing the overall validation state.\nA navigation widget could then enable or disable its \"save\" button according to that state.  The flag pattern covers events starting with the following topics:  * `didChangeFlag`  more on flags \u00bb", 
            "title": "Flags"
        }, 
        {
            "location": "/#errors", 
            "text": "Sometimes widgets and especially activities have to indicate an error situation that is not recoverable (such as a network problem).\nThe  error events  can be used to broadcast these problems, and have another component handle them, through means such as logging, displaying a problem message to the user or navigating to an error page.  The error pattern covers events starting with the following topics:  * `didEncounterError`  more on errors \u00bb", 
            "title": "Errors"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv0.18.0\n\n\n\n\n#26\n: documentation: overview, resource/action/flag/error patterns\n\n\n#24\n: refactoring: use \nlaxar.string\n rather than \nlaxar.text\n\n\n\n\nv0.17.0\n\n\n\n\n#23\n: actions: added promise support for asynchronous handlers.\n\n\n\n\nv0.16.0\n\n\n\n\n#22\n: actions: implemented action handler and publisher convenience.\n  NEW FEATURE: see ticket for details\n\n\n\n\nv0.15.0\n\n\n\n\n#21\n: resources: added deliverToSender option to event publishers.\n\n\n#20\n: fixed wrongly global assert in jshintrc.\n\n\n\n\nv0.14.0\n\n\n\n\n#19\n: tests: make sure PhantomJS is installed properly, before running spec tests.\n\n\n#18\n: added support for visibility events\n  NEW FEATURE: see ticket for details\n\n\n\n\nv0.13.0\n\n\n\n\n#17\n: replace and update publishers now return a promise.\n\n\n#16\n: don't try to load \nwidget.json\n in laxar_patterns specs.\n\n\n#15\n: json: added helpers to work with json pointer (rfc-6901) and json patch (rfc-6902)\n\n\n#14\n: temporarily switched to the LaxarJS fork of json patch.\n\n\n\n\nv0.12.0\n\n\n\n\n\n\n#12\n: added support for JSON patch in didUpdate events.\n  NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#13\n: Remove some obsolete NPM \ndevDependencies\n.\n\n\n\n\n#11\n: added missing require path mapping for jjv and jjve.\n\n\n\n\nv0.11.0\n\n\n\n\n\n\n#8\n: resources: added method \nwereAllReplaced\n to find out if all registered resources have been replaced\n  NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#10\n: errors: implemented publisher for the didEncounterError event\n  NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#7\n: resources: fixed null-pointer when handling \nisOptional\n\n\n\n\n#6\n: i18n: fixed localize to not use fallback for non-i18n values.\n\n\n#9\n: jshintrc: disabled enforcement of dot notation for object property access.\n\n\n#5\n: Fixed jshint violation\n\n\n\n\nv0.10.0\n\n\n\n\n#4\n: Allowed to keep receiving updates from \nwhenAllWereReplaced\n after initial replacement (set watch option to true).\n\n\n#2\n: Gracefully handle optional resources, fixed resource spec tests.\n\n\n#3\n: \npatches.create\n: exclude properties starting with \n$$\n.\n\n\n#1\n: Update Bower from ~1.2.8 to ~1.3.3.", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v0180", 
            "text": "#26 : documentation: overview, resource/action/flag/error patterns  #24 : refactoring: use  laxar.string  rather than  laxar.text", 
            "title": "v0.18.0"
        }, 
        {
            "location": "/CHANGELOG/#v0170", 
            "text": "#23 : actions: added promise support for asynchronous handlers.", 
            "title": "v0.17.0"
        }, 
        {
            "location": "/CHANGELOG/#v0160", 
            "text": "#22 : actions: implemented action handler and publisher convenience.\n  NEW FEATURE: see ticket for details", 
            "title": "v0.16.0"
        }, 
        {
            "location": "/CHANGELOG/#v0150", 
            "text": "#21 : resources: added deliverToSender option to event publishers.  #20 : fixed wrongly global assert in jshintrc.", 
            "title": "v0.15.0"
        }, 
        {
            "location": "/CHANGELOG/#v0140", 
            "text": "#19 : tests: make sure PhantomJS is installed properly, before running spec tests.  #18 : added support for visibility events\n  NEW FEATURE: see ticket for details", 
            "title": "v0.14.0"
        }, 
        {
            "location": "/CHANGELOG/#v0130", 
            "text": "#17 : replace and update publishers now return a promise.  #16 : don't try to load  widget.json  in laxar_patterns specs.  #15 : json: added helpers to work with json pointer (rfc-6901) and json patch (rfc-6902)  #14 : temporarily switched to the LaxarJS fork of json patch.", 
            "title": "v0.13.0"
        }, 
        {
            "location": "/CHANGELOG/#v0120", 
            "text": "#12 : added support for JSON patch in didUpdate events.\n  NEW FEATURE: see ticket for details    #13 : Remove some obsolete NPM  devDependencies .   #11 : added missing require path mapping for jjv and jjve.", 
            "title": "v0.12.0"
        }, 
        {
            "location": "/CHANGELOG/#v0110", 
            "text": "#8 : resources: added method  wereAllReplaced  to find out if all registered resources have been replaced\n  NEW FEATURE: see ticket for details    #10 : errors: implemented publisher for the didEncounterError event\n  NEW FEATURE: see ticket for details    #7 : resources: fixed null-pointer when handling  isOptional   #6 : i18n: fixed localize to not use fallback for non-i18n values.  #9 : jshintrc: disabled enforcement of dot notation for object property access.  #5 : Fixed jshint violation", 
            "title": "v0.11.0"
        }, 
        {
            "location": "/CHANGELOG/#v0100", 
            "text": "#4 : Allowed to keep receiving updates from  whenAllWereReplaced  after initial replacement (set watch option to true).  #2 : Gracefully handle optional resources, fixed resource spec tests.  #3 :  patches.create : exclude properties starting with  $$ .  #1 : Update Bower from ~1.2.8 to ~1.3.3.", 
            "title": "v0.10.0"
        }, 
        {
            "location": "/patterns/actions/", 
            "text": "\u00ab return to the patterns overview\n\n\nAction Patterns\n\n\nIn LaxarJS applications, \nactions\n allow widgets and activities to give their collaborators the opportunity to \nreact\n to \"something that happened\".\nUsually, \"something\" is a user-interaction: A confirmation button was clicked, a selection was changed or a service call was completed on behalf of the user.\n\n\nOther widgets may respond to arbitrary action requests by listening to their configured topics, and taking an action \nappropriate for them:\n\nThey might open a popup, start navigation, perform a REST call, ask to validate or save some resources, clear their own resources and so on.\nWhen widgets respond to an action request, they can do so \nasynchronously\n using the [will/did]-mechanism.\nThis means that actions can have a \nduration\n, which is useful for longer running tasks such as performing a search.\nThe duration can in turn be used by yet other widgets, for example to show a progress indicator every time that an action on the page runs for more than, say, 200 milliseconds.\n\n\nIf you are familiar with \nQt's signal/slot\n mechanism, you may think of an action as the named, asynchronous counterpart to an \nn:m\n signal/slot connection.\n\n\nAction Requests and Will/Did-Responses\n\n\nAs with \nresources\n, the \npage configuration\n determines which widgets share action topics:\nIf a widget offers to publish an action, but no topic was configured for that action, it should not publish an event.\nSimilarly, if a widget offers to respond to some action, but no topic was configured, it should not subscribe to action requests.\n\n\nThe \ntakeActionRequest, willTakeAction\n and \ndidTakeAction\n Events\n\n\nA widget (the \naction initiator\n) may request for action to be taken by publishing a \ntakeActionRequest\n.\nCollaborators (\naction handlers\n) capable and configured to perform a corresponding action respond by publishing a \nwillTakeAction\n event.\nAfter they have completed performing their action, possibly asynchronously, the collaborators publish a \ndidTakeAction\n event.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntakeActionRequest.{action}\n\n\n\n\n\n\npublished by any widget to request for some action being taken\n\n\n\n\n\n\n\n\naction\n\n\nstring\n\n\nthe topic through which respondents are connected (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\n\n\nanchorDomElement\n\n\nstring\n\n\nIf applicable: the ID of a DOM element where the action originated\n\n\n\n\n\n\nwillTakeAction.{action}\n\n\n\n\n\n\npublished by a widget that is about to perform some action\n\n\n\n\n\n\n\n\naction\n\n\nstring\n\n\nsee above\n\n\n\n\n\n\ndidTakeAction.{action}.{outcome}\n\n\n\n\n\n\npublished by a widget that has completed its action\n\n\n\n\n\n\n\n\naction\n\n\nstring\n\n\nsee above\n\n\n\n\n\n\n\n\noutcome\n\n\nstring\n\n\nERROR\n or \nSUCCESS\n\n\n\n\n\n\n\n\nThe \nanchorDomElement\n that can be sent along with the \ntakeActionRequest\n is useful to display popover hints right next to the UI element that was activated by the user.\nThis information exposes implementation details of the sender, so respondents should take care not to modify the sender DOM and not to rely on a specific structure.\n\n\nThe \noutcome\n that is sent with the \ndidTakeAction\n response indicated if the (assumed) user intent could be satisfied, because of an error condition that could not be handled (such as a network problem).\nIf the outcome is \nERROR\n, the initiator should signal this to the user if appropriate, and the handler should publish a \ndidEncounterError\n event with details on the problem.", 
            "title": "Action Patterns"
        }, 
        {
            "location": "/patterns/actions/#action-patterns", 
            "text": "In LaxarJS applications,  actions  allow widgets and activities to give their collaborators the opportunity to  react  to \"something that happened\".\nUsually, \"something\" is a user-interaction: A confirmation button was clicked, a selection was changed or a service call was completed on behalf of the user.  Other widgets may respond to arbitrary action requests by listening to their configured topics, and taking an action  appropriate for them: \nThey might open a popup, start navigation, perform a REST call, ask to validate or save some resources, clear their own resources and so on.\nWhen widgets respond to an action request, they can do so  asynchronously  using the [will/did]-mechanism.\nThis means that actions can have a  duration , which is useful for longer running tasks such as performing a search.\nThe duration can in turn be used by yet other widgets, for example to show a progress indicator every time that an action on the page runs for more than, say, 200 milliseconds.  If you are familiar with  Qt's signal/slot  mechanism, you may think of an action as the named, asynchronous counterpart to an  n:m  signal/slot connection.", 
            "title": "Action Patterns"
        }, 
        {
            "location": "/patterns/actions/#action-requests-and-willdid-responses", 
            "text": "As with  resources , the  page configuration  determines which widgets share action topics:\nIf a widget offers to publish an action, but no topic was configured for that action, it should not publish an event.\nSimilarly, if a widget offers to respond to some action, but no topic was configured, it should not subscribe to action requests.", 
            "title": "Action Requests and Will/Did-Responses"
        }, 
        {
            "location": "/patterns/actions/#the-takeactionrequest-willtakeaction-and-didtakeaction-events", 
            "text": "A widget (the  action initiator ) may request for action to be taken by publishing a  takeActionRequest .\nCollaborators ( action handlers ) capable and configured to perform a corresponding action respond by publishing a  willTakeAction  event.\nAfter they have completed performing their action, possibly asynchronously, the collaborators publish a  didTakeAction  event.     Event name  Payload Attribute  Type  Description      takeActionRequest.{action}    published by any widget to request for some action being taken     action  string  the topic through which respondents are connected (used in the payload  as well as  in the event name)     anchorDomElement  string  If applicable: the ID of a DOM element where the action originated    willTakeAction.{action}    published by a widget that is about to perform some action     action  string  see above    didTakeAction.{action}.{outcome}    published by a widget that has completed its action     action  string  see above     outcome  string  ERROR  or  SUCCESS     The  anchorDomElement  that can be sent along with the  takeActionRequest  is useful to display popover hints right next to the UI element that was activated by the user.\nThis information exposes implementation details of the sender, so respondents should take care not to modify the sender DOM and not to rely on a specific structure.  The  outcome  that is sent with the  didTakeAction  response indicated if the (assumed) user intent could be satisfied, because of an error condition that could not be handled (such as a network problem).\nIf the outcome is  ERROR , the initiator should signal this to the user if appropriate, and the handler should publish a  didEncounterError  event with details on the problem.", 
            "title": "The takeActionRequest, willTakeAction and didTakeAction Events"
        }, 
        {
            "location": "/patterns/errors/", 
            "text": "\u00ab return to the patterns overview\n\n\nError Handling Patterns\n\n\nAny LaxarJS widget or activity that communicates with the outside world can experience an error condition.\nThis can be a an HTTP server that is not reachable anymore, failing to open a WebSocket connection, or an unexpected privilege restriction imposed by the web browser.\n\n\nThe \ndidEncounterError\n Event\n\n\nWidgets may use the \ndidEncounterError\n event to inform about problems from which they cannot recover.\nThis allows for some other dedicated widget or activity to take an appropriate measure, for example by displaying a message to the user or by informing a REST service dedicated to monitoring or logging.\nNo topic configuration is needed for this event, as it is assumed that only a small number of activities or widgets are responsible for handling all types of errors.\n\n\nThe \ndidEncounterError\n event is \nnot\n intended to handle programming errors, such as null-pointer errors, which should be eliminated during testing.\nAlso, it is not intended to inform about invalid user input: \nHave a look at \nresource validation events\n instead.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndidEncounterError.{code}\n\n\n\n\n\n\npublished by any widget to indicate an unrecoverable error\n\n\n\n\n\n\n\n\ncode\n\n\nstring\n\n\nHTTP_GET\n or \nHTTP_PUT\n (if applicable)\n\n\n\n\n\n\n\n\nmessage\n\n\nstring\n\n\na more precise description of the problem\n\n\n\n\n\n\n\n\ndata\n\n\nobject\n\n\nadditional details, specific to the problem\n\n\n\n\n\n\n\n\nThe \ncode\n values stand representative for any \nread\n and \nwrite\n, or \n(I/O)\n problems.\nIf necessary, a sub-topic can be added, for example \nHTTP_PUT-WEB_SOCKET\n.\n\n\nThe \nmessage\n and \ndata\n attributes should contain additional information.", 
            "title": "Error Handling Patterns"
        }, 
        {
            "location": "/patterns/errors/#error-handling-patterns", 
            "text": "Any LaxarJS widget or activity that communicates with the outside world can experience an error condition.\nThis can be a an HTTP server that is not reachable anymore, failing to open a WebSocket connection, or an unexpected privilege restriction imposed by the web browser.", 
            "title": "Error Handling Patterns"
        }, 
        {
            "location": "/patterns/errors/#the-didencountererror-event", 
            "text": "Widgets may use the  didEncounterError  event to inform about problems from which they cannot recover.\nThis allows for some other dedicated widget or activity to take an appropriate measure, for example by displaying a message to the user or by informing a REST service dedicated to monitoring or logging.\nNo topic configuration is needed for this event, as it is assumed that only a small number of activities or widgets are responsible for handling all types of errors.  The  didEncounterError  event is  not  intended to handle programming errors, such as null-pointer errors, which should be eliminated during testing.\nAlso, it is not intended to inform about invalid user input: \nHave a look at  resource validation events  instead.     Event name  Payload Attribute  Type  Description      didEncounterError.{code}    published by any widget to indicate an unrecoverable error     code  string  HTTP_GET  or  HTTP_PUT  (if applicable)     message  string  a more precise description of the problem     data  object  additional details, specific to the problem     The  code  values stand representative for any  read  and  write , or  (I/O)  problems.\nIf necessary, a sub-topic can be added, for example  HTTP_PUT-WEB_SOCKET .  The  message  and  data  attributes should contain additional information.", 
            "title": "The didEncounterError Event"
        }, 
        {
            "location": "/patterns/flags/", 
            "text": "\u00ab return to the patterns overview\n\n\nFlag Patterns\n\n\nLaxarJS widgets use \nflags\n to communicate boolean application state \n(true/false)\n, usually to control parts of the user interface.\nFor example, a flag might be used by an activity to indicate that some resource is currently in a \ndirty\n state, or that a \npopup\n layer is currently open.\nConsumers of flags respond to the state changes: a \"save\" button should be active \nwhile\n a resource is in the dirty state, and an animation on the main page should be paused \nwhile\n a popup is open.\n\n\nAs with resources and actions, flags are defined by the page configuration.\n\n\nThe \ndidChangeFlag\n Event\n\n\nWidgets that publish boolean state may do so by publishing a \ndidChangeFlag\n event.\nTo avoid race conditions, only one widget should be configured to publish state for a given flag on any single page.\n\n\nConsumers of the \ndidChangeFlag\n event react simply by adapting to the modified state.\nUsually, flag consumers take an arbitrary number of flag topics (configurable as an array in their features).\nConsumers should consider the overall flag state to be true if any of their subscribed flags is \ntrue\n.\nIf no state as been received yet for a single flag, consumers should consider it to be \nfalse\n.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndidChangeFlag.{flag}.{state}\n\n\n\n\n\n\npublished by any widget to communicate a boolean state\n\n\n\n\n\n\n\n\naction\n\n\nstring\n\n\nthe topic through which flag consumer and producers are connected (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\n\n\nstate\n\n\nboolean\n\n\nthe new state for the flag\n\n\n\n\n\n\n\n\nBecause the flag \nstate\n is encoded in the event name as \n\"true\"\n or \n\"false\"\n, subscribers can use pattern matching to create two different subscriptions.", 
            "title": "Flag Patterns"
        }, 
        {
            "location": "/patterns/flags/#flag-patterns", 
            "text": "LaxarJS widgets use  flags  to communicate boolean application state  (true/false) , usually to control parts of the user interface.\nFor example, a flag might be used by an activity to indicate that some resource is currently in a  dirty  state, or that a  popup  layer is currently open.\nConsumers of flags respond to the state changes: a \"save\" button should be active  while  a resource is in the dirty state, and an animation on the main page should be paused  while  a popup is open.  As with resources and actions, flags are defined by the page configuration.", 
            "title": "Flag Patterns"
        }, 
        {
            "location": "/patterns/flags/#the-didchangeflag-event", 
            "text": "Widgets that publish boolean state may do so by publishing a  didChangeFlag  event.\nTo avoid race conditions, only one widget should be configured to publish state for a given flag on any single page.  Consumers of the  didChangeFlag  event react simply by adapting to the modified state.\nUsually, flag consumers take an arbitrary number of flag topics (configurable as an array in their features).\nConsumers should consider the overall flag state to be true if any of their subscribed flags is  true .\nIf no state as been received yet for a single flag, consumers should consider it to be  false .     Event name  Payload Attribute  Type  Description      didChangeFlag.{flag}.{state}    published by any widget to communicate a boolean state     action  string  the topic through which flag consumer and producers are connected (used in the payload  as well as  in the event name)     state  boolean  the new state for the flag     Because the flag  state  is encoded in the event name as  \"true\"  or  \"false\" , subscribers can use pattern matching to create two different subscriptions.", 
            "title": "The didChangeFlag Event"
        }, 
        {
            "location": "/patterns/resources/", 
            "text": "\u00ab return to the patterns overview\n\n\nResource Patterns\n\n\nResource events are essential to any non-trivial LaxarJS application, as they allow to share application resources and to collaborate on them.\nBecause events are always delivered \nby copy\n, there is no danger of widgets and activities performing conflicting operations on shared mutable state.\n\n\nThe Master/Slave Pattern\n\n\nWhen using the LaxarJS resource pattern, for a given resource there is usually a single widget (or activity) responsible for \nproviding\n it, in order for others to collaborate.\nIf applicable, that widget (the \nresource master\n) is also capable of persisting modifications to the resource.\nThe other collaborators are \nslaves\n with respect to the shared resource.\n\n\nOnly the resource master may change the \nidentity\n of a shared resource, while the slaves may only publish \nmodifications to the state\n of the resource.\n\n\nExample: Shopping Cart\n\n\nAs an example, consider a shopping cart widget that displays a list of \npositions\n (articles and quantities) in a web shop application.\nThe user may select any of the positions, and a second widget will then show details on the \nselected-position\n resource, such as a photo of the corresponding article.\nThe shopping cart widget is the resource master here, because it alone determines which article is currently selected.\nThe details widget is a slave, it can only act with respect to the currently selected article.\n\n\nThe details widget might even allow to modify the quantity of a given article within the cart, causing the shopping cart to remove a position when its quantity reaches zero.\nHowever, the slave can never change \nwhich\n position is currently the \nselected-position\n .\n\n\nThe \ndidReplace\n and \ndidUpdate\n Events\n\n\nThe identity and initial state of a resource is published through the \ndidReplace\n event by the resource master.\nModifications to a resource may be published through the \ndidUpdate\n event, by master or slaves.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndidReplace.{resource}\n\n\n\n\n\n\npublished by a resource master to define state and identity of a shared resource\n\n\n\n\n\n\n\n\n`resource\n\n\nstring\n\n\nthe topic through which the resource is shared (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\n\n\ndata\n\n\nobject\n\n\nthe (initial or new) state of the resource\n\n\n\n\n\n\ndidUpdate.{resource}\n\n\n\n\n\n\npublished by a resource master or by its slaves to publish modifications to the state of a shared resource\n\n\n\n\n\n\n\n\nresource\n\n\nstring\n\n\nsee above\n\n\n\n\n\n\n\n\npatches\n\n\narray\n\n\nA \nJSON-Patch\n document (an array representing a sequence of incremental modifications)\n\n\n\n\n\n\n\n\nBecause modifications \n(didUpdate)\n are transmitted incrementally, the resource master may use the \npatches\n attribute of the event payload to persist modifications using an \nHTTP PATCH\n request.\nTo create and apply patches, you require \nlaxar_patterns\n into your widget controller and use \ncreatePatch\n and \napplyPatch\n from the \nlaxar_patterns.json\n API.\n\n\nWhen sharing resources, keep in mind that resource events (like all LaxarJS events) are cloned for each receiver.\nThis makes it easy to write robust applications, but can lead to inefficiencies if very large resources are published.\nIn some cases, it might be worthwhile to factor out sub-resources relevant to the consumers.\n\n\nAsynchronous Resource Validation\n\n\nOften the individual widgets sharing a resource know best how to validate their specific user input.\nHowever, in the context of persistence or navigation the validity state of the overall resource or of the entire page is of interest.\n\n\nWidgets and activities concerned with navigation and persistence should not be exposed to the details of resource validation [1].\nTo separate these concerns, widgets may issue \nrequests to validate a resource\n which other widgets may respond to.\nRespondents may choose to validate immediately or asynchronously.\n\n\nThe \nvalidateRequest, willValidate\n and \ndidValidate\n Events\n\n\nA widget may request validation of a resource using a \nvalidateRequest\n event.\nCollaborators capable of performing validation on this resource respond by publishing a \nwillValidate\n event.\nAfter they have performed validation, possibly asynchronously, collaborators publish a \ndidValidate\n event.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalidateRequest.{resource}\n\n\n\n\n\n\npublished by any widget that requires validation of the given resource\n\n\n\n\n\n\n\n\nresource\n\n\nstring\n\n\nthe topic through which the resource is shared (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\nwillValidate.{resource}\n\n\n\n\n\n\npublished by a widget that is about to perform validation of the given resource\n\n\n\n\n\n\n\n\nresource\n\n\nstring\n\n\nsee above\n\n\n\n\n\n\ndidValidate.{resource}\n\n\n\n\n\n\npublished by a widget that has performed validation of the given resource\n\n\n\n\n\n\n\n\nresource\n\n\nstring\n\n\nsee above\n\n\n\n\n\n\n\n\noutcome\n\n\nstring\n\n\nOne of \nERROR\n, \nWARNING\n, \nINFO\n and \nSUCCESS\n\n\n\n\n\n\n\n\ndata\n\n\narray\n\n\nA list of \nvalidation messages\n for the application user (see below)\n\n\n\n\n\n\n\n\nValidation Outcome and Validation Messages\n\n\nThe \ndidValidate\n event contains information on the results of a validation:\n\n\n* The _outcome_ determines if validation was successful:\n\n        + `ERROR`: The resource is in an invalid state. If the receiver would normally persist the resource, it will probably not do so.\n        + `WARNING`: The resource _probably_ contains problems. If the receiver would normally persist the resource, it should probably obtain user confirmation before doing so.\n        + `INFO`: The resource _might_ contain problems or require user intervention. If the receiver would normally persist the resource, it might obtain confirmation or otherwise inform the user.\n        + `SUCCESS`: No problems were found _by the sender_ of the event. If the receiver would normally persist the resource, it should proceed as far as the sender is concerned.\n\n* The _validation messages_ (`data` array) contains additional details for the user. Each message is an object with at least these attributes:\n\n        + `htmlMessage`: A validation message for the user (a _string_), to be interpreted as HTML markup\n        + `level`: The severity of this particular vaidation message (a _string_), using the outcomes specified above\n        + `sortKey`: The message priority (a _string_) that should be used for sorting messages lexicographically.\n\n\n\n\n\n[1]: As an exception to this rule, a resource master may perform a (semantic) \noverall\n validation after the individual editor widgets had their say.\n\n\nSaving Resources\n\n\nUsually the resource master is responsible for saving user input where appropriate.\nThis can be achieved by performing a REST call for example, or by putting state into a container resource (as a slave) and requesting for the container to be persisted.\n\n\nThe \nsaveRequest, willSave\n and \ndidSave\n Events\n\n\nTo request saving a resource, widgets may publish a \nsaveRequest\n event.\nWidgets capable of and configured for persisting the resource respond by publishing a \nwillSave\n event.\nAfter they have ensured persistence, usually asynchronously, collaborators publish a \ndidSave\n event.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsaveRequest.{resource}\n\n\n\n\n\n\npublished by any widget that requires persisting the given resource\n\n\n\n\n\n\n\n\nresource\n\n\nstring\n\n\nthe topic through which the resource is shared (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\nwillSave.{resource}\n\n\n\n\n\n\npublished by a widget that is about to persist the given resource\n\n\n\n\n\n\n\n\nresource\n\n\nstring\n\n\nsee above\n\n\n\n\n\n\ndidSave.{resource}\n\n\n\n\n\n\npublished by a widget after saving the given resource\n\n\n\n\n\n\n\n\nresource\n\n\nstring\n\n\nsee above\n\n\n\n\n\n\n\n\noutcome\n\n\nstring\n\n\nERROR\n or \nSUCCESS\n\n\n\n\n\n\n\n\nThe \ndidSave\n event contains information on the \noutcome\n:\n\n\n* `ERROR`: The resource could not be saved. The sender should also publish a `didEncounterError` event in this case.\n* `SUCCESS`: The resource was saved successfully.\n\n\n\n\n\nDepending on the use case, widgets might persist resources automatically every time they have been modified.\nIn this case, it is recommended for them to still respond to save requests, for best interoperability.", 
            "title": "Resource Patterns"
        }, 
        {
            "location": "/patterns/resources/#resource-patterns", 
            "text": "Resource events are essential to any non-trivial LaxarJS application, as they allow to share application resources and to collaborate on them.\nBecause events are always delivered  by copy , there is no danger of widgets and activities performing conflicting operations on shared mutable state.", 
            "title": "Resource Patterns"
        }, 
        {
            "location": "/patterns/resources/#the-masterslave-pattern", 
            "text": "When using the LaxarJS resource pattern, for a given resource there is usually a single widget (or activity) responsible for  providing  it, in order for others to collaborate.\nIf applicable, that widget (the  resource master ) is also capable of persisting modifications to the resource.\nThe other collaborators are  slaves  with respect to the shared resource.  Only the resource master may change the  identity  of a shared resource, while the slaves may only publish  modifications to the state  of the resource.", 
            "title": "The Master/Slave Pattern"
        }, 
        {
            "location": "/patterns/resources/#example-shopping-cart", 
            "text": "As an example, consider a shopping cart widget that displays a list of  positions  (articles and quantities) in a web shop application.\nThe user may select any of the positions, and a second widget will then show details on the  selected-position  resource, such as a photo of the corresponding article.\nThe shopping cart widget is the resource master here, because it alone determines which article is currently selected.\nThe details widget is a slave, it can only act with respect to the currently selected article.  The details widget might even allow to modify the quantity of a given article within the cart, causing the shopping cart to remove a position when its quantity reaches zero.\nHowever, the slave can never change  which  position is currently the  selected-position  .", 
            "title": "Example: Shopping Cart"
        }, 
        {
            "location": "/patterns/resources/#the-didreplace-and-didupdate-events", 
            "text": "The identity and initial state of a resource is published through the  didReplace  event by the resource master.\nModifications to a resource may be published through the  didUpdate  event, by master or slaves.     Event name  Payload Attribute  Type  Description      didReplace.{resource}    published by a resource master to define state and identity of a shared resource     `resource  string  the topic through which the resource is shared (used in the payload  as well as  in the event name)     data  object  the (initial or new) state of the resource    didUpdate.{resource}    published by a resource master or by its slaves to publish modifications to the state of a shared resource     resource  string  see above     patches  array  A  JSON-Patch  document (an array representing a sequence of incremental modifications)     Because modifications  (didUpdate)  are transmitted incrementally, the resource master may use the  patches  attribute of the event payload to persist modifications using an  HTTP PATCH  request.\nTo create and apply patches, you require  laxar_patterns  into your widget controller and use  createPatch  and  applyPatch  from the  laxar_patterns.json  API.  When sharing resources, keep in mind that resource events (like all LaxarJS events) are cloned for each receiver.\nThis makes it easy to write robust applications, but can lead to inefficiencies if very large resources are published.\nIn some cases, it might be worthwhile to factor out sub-resources relevant to the consumers.", 
            "title": "The didReplace and didUpdate Events"
        }, 
        {
            "location": "/patterns/resources/#asynchronous-resource-validation", 
            "text": "Often the individual widgets sharing a resource know best how to validate their specific user input.\nHowever, in the context of persistence or navigation the validity state of the overall resource or of the entire page is of interest.  Widgets and activities concerned with navigation and persistence should not be exposed to the details of resource validation [1].\nTo separate these concerns, widgets may issue  requests to validate a resource  which other widgets may respond to.\nRespondents may choose to validate immediately or asynchronously.", 
            "title": "Asynchronous Resource Validation"
        }, 
        {
            "location": "/patterns/resources/#the-validaterequest-willvalidate-and-didvalidate-events", 
            "text": "A widget may request validation of a resource using a  validateRequest  event.\nCollaborators capable of performing validation on this resource respond by publishing a  willValidate  event.\nAfter they have performed validation, possibly asynchronously, collaborators publish a  didValidate  event.     Event name  Payload Attribute  Type  Description      validateRequest.{resource}    published by any widget that requires validation of the given resource     resource  string  the topic through which the resource is shared (used in the payload  as well as  in the event name)    willValidate.{resource}    published by a widget that is about to perform validation of the given resource     resource  string  see above    didValidate.{resource}    published by a widget that has performed validation of the given resource     resource  string  see above     outcome  string  One of  ERROR ,  WARNING ,  INFO  and  SUCCESS     data  array  A list of  validation messages  for the application user (see below)", 
            "title": "The validateRequest, willValidate and didValidate Events"
        }, 
        {
            "location": "/patterns/resources/#validation-outcome-and-validation-messages", 
            "text": "The  didValidate  event contains information on the results of a validation:  * The _outcome_ determines if validation was successful:\n\n        + `ERROR`: The resource is in an invalid state. If the receiver would normally persist the resource, it will probably not do so.\n        + `WARNING`: The resource _probably_ contains problems. If the receiver would normally persist the resource, it should probably obtain user confirmation before doing so.\n        + `INFO`: The resource _might_ contain problems or require user intervention. If the receiver would normally persist the resource, it might obtain confirmation or otherwise inform the user.\n        + `SUCCESS`: No problems were found _by the sender_ of the event. If the receiver would normally persist the resource, it should proceed as far as the sender is concerned.\n\n* The _validation messages_ (`data` array) contains additional details for the user. Each message is an object with at least these attributes:\n\n        + `htmlMessage`: A validation message for the user (a _string_), to be interpreted as HTML markup\n        + `level`: The severity of this particular vaidation message (a _string_), using the outcomes specified above\n        + `sortKey`: The message priority (a _string_) that should be used for sorting messages lexicographically.  [1]: As an exception to this rule, a resource master may perform a (semantic)  overall  validation after the individual editor widgets had their say.", 
            "title": "Validation Outcome and Validation Messages"
        }, 
        {
            "location": "/patterns/resources/#saving-resources", 
            "text": "Usually the resource master is responsible for saving user input where appropriate.\nThis can be achieved by performing a REST call for example, or by putting state into a container resource (as a slave) and requesting for the container to be persisted.", 
            "title": "Saving Resources"
        }, 
        {
            "location": "/patterns/resources/#the-saverequest-willsave-and-didsave-events", 
            "text": "To request saving a resource, widgets may publish a  saveRequest  event.\nWidgets capable of and configured for persisting the resource respond by publishing a  willSave  event.\nAfter they have ensured persistence, usually asynchronously, collaborators publish a  didSave  event.     Event name  Payload Attribute  Type  Description      saveRequest.{resource}    published by any widget that requires persisting the given resource     resource  string  the topic through which the resource is shared (used in the payload  as well as  in the event name)    willSave.{resource}    published by a widget that is about to persist the given resource     resource  string  see above    didSave.{resource}    published by a widget after saving the given resource     resource  string  see above     outcome  string  ERROR  or  SUCCESS     The  didSave  event contains information on the  outcome :  * `ERROR`: The resource could not be saved. The sender should also publish a `didEncounterError` event in this case.\n* `SUCCESS`: The resource was saved successfully.  Depending on the use case, widgets might persist resources automatically every time they have been modified.\nIn this case, it is recommended for them to still respond to save requests, for best interoperability.", 
            "title": "The saveRequest, willSave and didSave Events"
        }
    ]
}