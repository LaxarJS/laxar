{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS Testing\n\n\n\n\nThe companion testing framework for LaxarJS widgets.\n\n\n\n\nUse it on top of Jasmine to setup and load a widget just like in a real app.\nThe available APIs then support you in instrumenting and inspecting the widget under test.\n\n\nFor an introduction to \nLaxarJS Testing\n have a look at the \nmanuals\n.\nAdditionally the \nAPI docs\n provide detailed information on the configuration, instrumentation and inspection possibilities.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs-testing", 
            "text": "The companion testing framework for LaxarJS widgets.   Use it on top of Jasmine to setup and load a widget just like in a real app.\nThe available APIs then support you in instrumenting and inspecting the widget under test.  For an introduction to  LaxarJS Testing  have a look at the  manuals .\nAdditionally the  API docs  provide detailed information on the configuration, instrumentation and inspection possibilities.", 
            "title": "LaxarJS Testing"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv0.1.0", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v010", 
            "text": "", 
            "title": "v0.1.0"
        }, 
        {
            "location": "/api/laxar-testing.js/", 
            "text": "laxar-testing\n\n\nA testing framework for LaxarJS widgets.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreateSetupForWidget\n\n\ntearDown\n\n\ntriggerStartupEvents\n\n\n\n\nTypes\n\n\n\n\nWidget\n\n\nWidget#configure\n\n\nWidget#load\n\n\nWidget#render\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreateSetupForWidget( widgetDescriptor, optionalOptions )\n\n\nCreates the setup function for a widget test. The returned function is asynchronous and should simply be\npassed to \nbeforeEach\n. By doing so, the handling of the Jasmine \ndone\n callback happens under the hood.\nTo receive the widget descriptor (i.e. the contents of the \nwidget.json\n file) the use of the RequireJS\n\n\njson\n plugin is advised.\n\n\nExample:\n\n\ndefine\n(\n \n[\n\n   \njson!../widget.json\n,\n\n   \nlaxar-testing\n\n\n],\n \nfunction\n(\n \ndescriptor\n,\n \ntesting\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \ndescribe\n(\n \nAn ExampleWidget\n,\n \nfunction\n()\n \n{\n\n\n      \nbeforeEach\n(\n \ntesting\n.\ncreateSetupForWidget\n(\n \ndescriptor\n \n)\n \n);\n\n\n      \n// ... widget configuration, loading and your tests\n\n\n      \nafterEach\n(\n \ntesting\n.\ntearDown\n \n);\n\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwidgetDescriptor\n\n\nObject\n\n\nthe widget descriptor (taken from \nwidget.json\n)\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\noptional map of options\n\n\n\n\n\n\noptionalOptions.knownMissingResources\n\n\nArray\n\n\nlist of file name parts as strings or regular expressions, that are known to be absent and as such won't be found by the file resource provider and thus result in the logging of a 404 HTTP error. So whenever such an error is logged and the absence of the file is fine, an appropriate entry can be added to this configuration. Mostly CSS files are affected by this\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function to directly pass to \nbeforeEach\n, accepting a Jasmine \ndone\n callback\n\n\n\n\n\n\n\n\ntearDown()\n\n\nRemoves any DOM fragments of the widget and calls the appropriate destructors. It is advised to call\nthis once in an \nafterEach\n call. Passing this function directly to \nafterEach\n works as well.\n\n\nExample.\n\n\nafterEach\n(\n \ntesting\n.\ntearDown\n \n);\n\n\n\n\n\n\ntriggerStartupEvents( optionalEvents )\n\n\nTriggers all events normally published by the runtime after instantiation of the controller. This\nincludes the following events, listed with their according payloads in the order they are published:\n\n\n1. didChangeLocale.default:\n\n\n{\n\n   \nlocale\n:\n \ndefault\n,\n\n   \nlanguageTag\n:\n \nen\n\n\n}\n\n\n\n\n\n\n2. didChangeTheme.default:\n\n\n{\n\n   \ntheme\n:\n \ndefault\n\n\n}\n\n\n\n\n\n\n3. beginLifecycleRequest.default:\n\n\n{\n\n   \nlifecycleId\n:\n \ndefault\n\n\n}\n\n\n\n\n\n\n4. didChangeAreaVisibility.content.true:\n\n\n{\n\n   \narea\n:\n \ncontent\n,\n\n   \nvisible\n:\n \ntrue\n\n\n}\n\n\n\n\n\n\n5. didNavigate.testing:\n\n\n{\n\n   \nplace\n:\n \ntesting\n,\n\n   \ntarget\n:\n \n_self\n,\n\n   \ndata\n:\n \n{}\n\n\n}\n\n\n\n\n\n\nVia the \noptionalEvents\n argument it is possible to add events with different trailing topics, to\noverwrite events defined above, or to completely prevent from triggering one of the events. To do so\nsimply pass a map, where the primary topics are the keys and the value is a map from trailing topic to\npayload. If the value is \nnull\n, the specific event is not published.\n\n\nExample:\n\n\ntesting\n.\ntriggerStartupEvents\n(\n \n{\n\n   \ndidChangeLocale\n:\n \n{\n\n      \nalternative\n:\n \n{\n\n         \nlocale\n:\n \nalternative\n,\n\n         \nlanguageTag\n:\n \nde\n\n      \n}\n\n   \n},\n\n   \ndidChangeTheme\n:\n \n{\n\n      \ndefault\n:\n \nnull\n\n   \n},\n\n   \ndidNavigate\n:\n \n{\n\n      \ntesting\n:\n \n{\n\n         \nplace\n:\n \ntesting\n,\n\n         \ntarget\n:\n \n_self\n,\n\n         \ndata\n:\n \n{\n\n            \nuser\n:\n \nPeter\n,\n\n            \narticleId\n:\n \n1234\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n \n);\n\n\n\n\n\n\nThe effect of this call is the following:\n\n\n\n\n\n\nThere will be two \ndidChangeLocale\n events: \ndidChangeLocale.default\n, carrying the language tag \nen\n\n   in its payload, and \ndidChangeLocale.alternative\n, carrying the language tag \nde\n in its payload.\n\n\n\n\n\n\nThere will be no \ndidChangeTheme\n event, since the only pre-configured one is set to \nnull\n.\n\n\n\n\nThe parameters of the \ndidNavigate.testing\n event are changed to be\n   \n{ user: 'Peter', articleId: '1234' }\n.\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalEvents\n\n\nObject\n\n\noptional map of user defined events\n\n\n\n\n\n\n\n\nTypes\n\n\nWidget\n\n\nThe API to instrument and inspect the widget under test. In addition to the listed methods it has all\ninjections for the specific widget technology set as properties. E.g. for every widget technology there\nwill be \naxEventBus\n and \naxContext\n properties, but for AngularJS widgets there will be an additional\n\n$scope\n property. Note that these are only available after \nload()\n has been called and the widget\ncontroller is loaded.\n\n\nThe methods of the event bus instance available as \naxEventBus\n are already provided with\n\nJasmine spies\n.\n\n\nWidget#configure( keyOrConfiguration, optionalValue )\n\n\nConfigures the widget features before loading with the given configuration object or key/value\nentries. In fact this is what you'd normally configure under the \nfeatures\n key in a page descriptor.\n\n\nShorthands may be used:\n\n\nThis\n\n\nbeforeEach\n(\n \nfunction\n()\n \n{\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \n{\n\n      \nsearch\n:\n \n{\n\n         \nresource\n:\n \nsearch\n\n      \n}\n\n   \n}\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nis equivalent to the following shorter version\n\n\nbeforeEach\n(\n \nfunction\n()\n \n{\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \nsearch.resource\n,\n \nsearch\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkeyOrConfiguration\n\n\nString\n, \nObject\n\n\neither an object for the full features configuration or the path to the property to configure\n\n\n\n\n\n\noptionalValue\n\n\n*\n\n\nif \nkeyOrConfiguration\n is a string, this is the value to set the feature configuration to\n\n\n\n\n\n\n\n\nWidget#load( done )\n\n\nLoads the given widget and instantiates its controller. As this function is asynchronous, it receives\na Jasmine \ndone\n callback, that is called when the widget is ready.\n\n\nThe simplest way to call this function is by passing it to its own \nbeforeEach\n call:\n\n\nbeforeEach\n(\n \ntesting\n.\nwidget\n.\nload\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndone\n\n\nFunction\n\n\ncallback to notify Jasmine, that the asynchronous widget loading has finished\n\n\n\n\n\n\n\n\nWidget#render()\n\n\nRenders the widget's template by calling the appropriate widget adapter and appends it within a\ncontainer div to the test's DOM. The widget DOM fragement will be returned in order to simulate\nuser interaction on it. Calling \ntesting.tearDown()\n will remove it again.\n\n\nNote that calling this method for an activity has no effect and hence is unnessecary.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nNode\n\n\nthe widget DOM fragment", 
            "title": "laxar-testing"
        }, 
        {
            "location": "/api/laxar-testing.js/#laxar-testing", 
            "text": "A testing framework for LaxarJS widgets.", 
            "title": "laxar-testing"
        }, 
        {
            "location": "/api/laxar-testing.js/#contents", 
            "text": "Module Members   createSetupForWidget  tearDown  triggerStartupEvents   Types   Widget  Widget#configure  Widget#load  Widget#render", 
            "title": "Contents"
        }, 
        {
            "location": "/api/laxar-testing.js/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/laxar-testing.js/#parameters", 
            "text": "Property  Type  Description      widgetDescriptor  Object  the widget descriptor (taken from  widget.json )    optionalOptions  Object  optional map of options    optionalOptions.knownMissingResources  Array  list of file name parts as strings or regular expressions, that are known to be absent and as such won't be found by the file resource provider and thus result in the logging of a 404 HTTP error. So whenever such an error is logged and the absence of the file is fine, an appropriate entry can be added to this configuration. Mostly CSS files are affected by this", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-testing.js/#returns", 
            "text": "Type  Description      Function  a function to directly pass to  beforeEach , accepting a Jasmine  done  callback", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar-testing.js/#parameters_1", 
            "text": "Property  Type  Description      optionalEvents  Object  optional map of user defined events", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-testing.js/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/laxar-testing.js/#parameters_2", 
            "text": "Property  Type  Description      keyOrConfiguration  String ,  Object  either an object for the full features configuration or the path to the property to configure    optionalValue  *  if  keyOrConfiguration  is a string, this is the value to set the feature configuration to", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-testing.js/#parameters_3", 
            "text": "Property  Type  Description      done  Function  callback to notify Jasmine, that the asynchronous widget loading has finished", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar-testing.js/#returns_1", 
            "text": "Type  Description      Node  the widget DOM fragment", 
            "title": "Returns"
        }, 
        {
            "location": "/manuals/", 
            "text": "Manuals\n\n\n\n\nIntroduction LaxarJS Testing", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Introduction LaxarJS Testing", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/introduction/", 
            "text": "return to the manuals\n\n\nIntroduction to LaxarJS Testing\n\n\nLaxarJS Testing\n aids you in writing tests for \nLaxarJS\n widgets.\nAlthough widgets themselves only have little direct dependency on \nLaxarJS\n (apart from the event bus) and should mostly follow the best practices for the underlying technology (e.g. \nAngularJS\n), they depend on a fixed setup process provided by the LaxarJS runtime.\nThis includes loading of relevant assets (such as templates and stylesheets), creation of the controller and rendering at the right time, as well as sending all initially relevant events.\n\n\nLaxarJS Testing\n provides a simple, programmatic interface to control this process and load a widget within a test.\nWe'll introduce the testing framework by showing an example and use this to describe the individual steps usually found in a widget test.\n\n\nThis is a simple test for an \nAngularJS\n-Widget (read \nthis\n to know where to place this file):\n\n\n// 1. Module Definition\n\n\ndefine\n(\n \n[\n\n   \njson!../widget.json\n,\n\n   \nlaxar-testing\n,\n\n   \nangular-mocks\n\n\n],\n \nfunction\n(\n \ndescriptor\n,\n \ntesting\n,\n \nngMocks\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \ndescribe\n(\n \nAn ExampleWidget\n,\n \nfunction\n()\n \n{\n\n\n      \nvar\n \n$httpBackend\n;\n\n      \nvar\n \nwidgetDom\n;\n\n\n      \n// 2. Test Setup\n\n      \nbeforeEach\n(\n \ntesting\n.\ncreateSetupForWidget\n(\n \ndescriptor\n,\n \n{\n\n         \nknownMissingResources\n:\n \n[\n \nax-i18n-control.css\n \n]\n\n      \n}\n \n)\n \n);\n\n\n      \n// 3. Widget Configuration\n\n      \nbeforeEach\n(\n \nfunction\n()\n \n{\n\n         \ntesting\n.\nwidget\n.\nconfigure\n(\n \n{\n\n            \nexample\n:\n \n{\n\n               \nresource\n:\n \nexampleResource\n,\n\n               \naction\n:\n \nexampleAction\n\n            \n}\n\n         \n}\n \n);\n\n      \n}\n \n);\n\n\n      \n// 4. Loading the Widget\n\n      \nbeforeEach\n(\n \ntesting\n.\nwidget\n.\nload\n \n);\n\n\n      \nbeforeEach\n(\n \nfunction\n()\n \n{\n\n         \n// 5. Optional: Rendering the Widget DOM\n\n         \nwidgetDom\n \n=\n \ntesting\n.\nwidget\n.\nrender\n();\n\n\n         \n// 6. Optional: Mocking an AngularJS Injection\n\n         \nngMocks\n.\ninject\n(\n \nfunction\n(\n \n$injector\n \n)\n \n{\n\n            \n$httpBackend\n \n=\n \n$injector\n.\nget\n(\n \n$httpBackend\n \n);\n\n         \n}\n \n);\n\n\n         \n// 7.  Optional: Simulating Startup Events\n\n         \ntesting\n.\ntriggerStartupEvents\n();\n\n      \n}\n \n);\n\n\n      \n// 8. Tests\n\n      \nit\n(\n \nsubscribes to didReplace events for the search resource\n,\n \nfunction\n()\n \n{\n\n         \nexpect\n(\n \ntesting\n.\nwidget\n.\naxEventBus\n.\nsubscribe\n \n)\n\n            \n.\ntoHaveBeenCalledWith\n(\n \ndidReplace.exampleResource\n,\n \njasmine\n.\nany\n(\n \nFunction\n \n)\n \n);\n\n      \n}\n \n);\n\n\n      \n// 9. Test Tear-Down\n\n      \nafterEach\n(\n \ntesting\n.\ntearDown\n \n);\n\n\n   \n}\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\n1. Module Definition\n\n\nIn the AMD module definition for a widget test the first thing to depend on should usually be the widget descriptor (the contents of the \nwidget.json\n file).\nThis is the only information LaxarJS Testing needs to determine the relevant widget and according assets to load.\nWe recommend using the \njson\n plugin for \nRequireJS\n to load the file hassle-free just as done in this example.\n\n\nAdditionally \nLaxarJS Testing\n needs to be loaded, to gain access to the API for widget loading, instrumentation and inspection.\nWhen using the default \nRequireJS\n configuration for that package, it should be available as \nlaxar-testing\n.\nThe import of \nangular-mocks\n should only take place, if it is really needed during testing.\nIn this example we want to use the mocked \n$httpBackend\n provided by \nAngularJS Mocks\n and thus need to import \nangular-mocks\n.\n\n\n2. Test Setup\n\n\nDue to a bunch of HTTP requests that need to take place, setting up a widget test is an asynchronous task.\nTo spare the user the handling of asynchronous tasks in the \nJasmine\n environment, \ntesting.createSetupForWidget( descriptor )\n returns an asynchronous function suitable for use with \nbeforeEach\n.\nBesides the widget descriptor, it can optionally receive a map of configuration options.\n\n\nAvailable Options\n\n\nknownMissingResources\n\n\nA list of file name parts that are known to be absent.\nIf left unspecified, the runtime's file resource provider would try to fetch these assets for widgets and controls through HTTP, resulting in 404 errors being logged.\nSo whenever you see such an error in the log and decide that the absence of the corresponding file is fine, an appropriate entry can be added to this configuration.\nThe list entries can be strings or regular expressions.\nRegular expressions are tested against requested file names, while strings will match any file name that contains them anywhere.\n\n\nIn this example the widget uses the \ni18n\n control.\nWe already know that there is no theme, and hence no CSS file for this control, as it only provides some APIs and has no visual representation.\nWhen loading the widget from a running application, the generated file listing would yield that the file is absent and it wouldn't be loaded.\nDuring testing we have to give that hint manually, as seen in this example.\n\n\nFurther information can be found in the \napi docs\n.\n\n\n3. Widget Configuration\n\n\nIn the next step we configure the features of the widget, just as it normally happens in a page definition.\nThe object you'd put under the key \nfeatures\n can simply be passed to the method \ntesting.widget.configure\n.\nFor convenience it's also possible to use an object attribute path and a single value as arguments.\nThis is e.g. useful if the widget gets pre-configured in an outer \ndescribe\n block and is adjusted deeper in a nested structure.\n\n\nSo here we could have also written this:\n\n\nbeforeEach\n(\n \nfunction\n()\n \n{\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \nexample.resource\n,\n \nexampleResource\n \n);\n\n   \ntesting\n.\nwidget\n.\nconfigure\n(\n \nexample.action\n,\n \nexampleAction\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\n4. Loading the Widget\n\n\nHere we tell the widget loader to actually load the widget controller.\nSince the API of the widget loader is asynchronous, the \nload\n method is asynchronous as well and thus expects a \nJasmine\n \ndone\n callback.\nAgain, to keep it as simple as possible for the user, the \nload\n method doesn't need to be called directly, but can simply be passed on to \nbeforeEach\n\nMake sure to load the widget only when all configuration has been applied, because afterwards calls to \ntesting.widget.configure\n have no effect.\n\n\n5. Optional: Rendering the Widget DOM\n\n\nNaturally this step does not apply to activities, since they do not influence the DOM and in particular have no visual representation.\nCalling the \ntesting.widget.render()\n for activities isn't harmful, but simply has no effect at all.\nIn case of a widget, the template is compiled by the underlying technology adapter, wrapped in a \ndiv\n element and the resulting DOM node returned.\nThis is not different from the rendering process in a regular application.\nInstead of appending the DOM to a widget area, it is appended to the body element of the test.\nIt is removed again before the next test run would render its DOM or when calling \ntesting.tearDown\n.\n\n\n6. Optional: Mocking an AngularJS Injection\n\n\nFor this example, we assume that we're testing an \nAngularJS\n widget, which performs some backend communication, using the \n$http\n service provided by \nAngularJS\n.\n\nAngularJS Mocks\n aids us in this case, by providing the instrumentation API \n$httpBackend\n.\nTo prevent from going too much into detail, the \nAngularJS Mocks API\n should be your source of information in that regard.\n\n\n7.  Optional: Simulating Startup Events\n\n\nWhen a page within a \nLaxarJS\n application loads, the runtime publishes several initial events.\nMany widgets don't actually care for these events and only subscribe to custom events such as \ndidReplace\n or \ntakeActionRequest\n.\nOther widgets may depend on \ncore events\n like \ndidChangeLocale\n or \ndidNavigate\n with certain parameters.\n\n\nIn order to be able to test a widgets response to core events without duplicating too much of this task within every test, the method \ntesting.triggerStartupEvents\n publishes all events the runtime would publish in the correct order.\nThe method allows to configure parts of these events or skip some of them completely.\nFor further information on event configuration have a look at the extensive \nAPI docs\n.\n\n\n8. Tests\n\n\nNow you're set up to write your actual tests.\nAt this point the widget controller is instantiated, the (optional) DOM fragment has been rendered and all relevant runtime events were published.\n\n\nProbably you want to group your tests into functional use cases via \nJasmine\n \ndescribe\n functions.\nIn this case it is sometimes a good thing to postpone the calls to \ntesting.widget.load\n, \ntesting.widget.render\n and \ntesting.triggerStartupEvents\n.\nIt is then possible to structure the test in isolated \ndescribe\n blocks, to adjust the configuration for each block as needed and only afterwards call the other methods to actually fire up your tests.\n\n\n9. Test Tear-Down\n\n\nEvery widget test should call \ntesting.tearDown\n in a \nJasmine\n \nafterEach\n block or simply pass it to \nafterEach\n.\nThis ensures, that after one test is run, the DOM is cleaned up and the widget with all its dependencies is destroyed.\nIf this is omitted, it cannot be guaranteed that remainders of the previous test run do not influence the current test run.\n\n\nDirectory Layout\n\n\nIf you generated your widget or activity with the latest \ngrunt-init\n template, everything should be set up correctly.\nWhen creating the widget artifacts manually, we recommend the following directory layout for the tests within the widget directory:\n\n\nexample-widget\n\n+-- example-widget.js\n+-- widget.json\n+-- spec\n    +-- example-widget.spec.js\n    +-- spec_runner.html\n    +-- spec_runner.js\n\n\n\n\n\nWhen follwing this structure, the AMD module definition from the top of this introduction should work for you.\nYou just have to ensure that paths like \nlaxar-testing\n and \nangular-mocks\n are configured correctly.\n\n\nWhen running the widget test in your browser, this is achieved by using the correct paths in the file \nspec_runner.html\n.\nBy default it is assumed that any widget directory can be found at the directory \nincludes/widget/\nyour category\n/\n under the application root.\nThe \nrequire_config.js\n of the application will then be loaded by stepping up to the parent directory five times (see \nhere\n for an example).\nFor tests to run, at least the paths \nrequirejs\n, \njasmine\n, \nlaxar-testing\n and the RequireJS \njson\n plugin have to be defined in that file.\nWhen testing \nAngularJS\n widgets, the path to \nangular-mocks\n must be defined as well.\n\n\nThe next file that is loaded is \nspec_runner.js\n (an example can be found \nhere\n).\nThis file merely defines which actual test files to load and run.\nThese files are searched relative to  \nspec_runner.js\n.\nOptionally you can overwrite \nRequireJS\n configuration from the application's \nrequire_config.js\n file, by setting the appropriate entries under the property \nrequireConfig\n.\nFor example, it may sometimes be a good idea to mock a large external library with a simpler stub for testing.\n\n\nFinally, the module \nexample-widget.spec.js\n defines the actual testing code.\nIf you're following these guidelines, the widget descriptor (\nwidget.json\n) can also be loaded as explained in the example, so that the widget under test can be instantiated without problems.", 
            "title": "Introduction to LaxarJS Testing"
        }, 
        {
            "location": "/manuals/introduction/#introduction-to-laxarjs-testing", 
            "text": "LaxarJS Testing  aids you in writing tests for  LaxarJS  widgets.\nAlthough widgets themselves only have little direct dependency on  LaxarJS  (apart from the event bus) and should mostly follow the best practices for the underlying technology (e.g.  AngularJS ), they depend on a fixed setup process provided by the LaxarJS runtime.\nThis includes loading of relevant assets (such as templates and stylesheets), creation of the controller and rendering at the right time, as well as sending all initially relevant events.  LaxarJS Testing  provides a simple, programmatic interface to control this process and load a widget within a test.\nWe'll introduce the testing framework by showing an example and use this to describe the individual steps usually found in a widget test.  This is a simple test for an  AngularJS -Widget (read  this  to know where to place this file):  // 1. Module Definition  define (   [ \n    json!../widget.json , \n    laxar-testing , \n    angular-mocks  ],   function (   descriptor ,   testing ,   ngMocks   )   { \n    use strict ; \n\n    describe (   An ExampleWidget ,   function ()   { \n\n       var   $httpBackend ; \n       var   widgetDom ; \n\n       // 2. Test Setup \n       beforeEach (   testing . createSetupForWidget (   descriptor ,   { \n          knownMissingResources :   [   ax-i18n-control.css   ] \n       }   )   ); \n\n       // 3. Widget Configuration \n       beforeEach (   function ()   { \n          testing . widget . configure (   { \n             example :   { \n                resource :   exampleResource , \n                action :   exampleAction \n             } \n          }   ); \n       }   ); \n\n       // 4. Loading the Widget \n       beforeEach (   testing . widget . load   ); \n\n       beforeEach (   function ()   { \n          // 5. Optional: Rendering the Widget DOM \n          widgetDom   =   testing . widget . render (); \n\n          // 6. Optional: Mocking an AngularJS Injection \n          ngMocks . inject (   function (   $injector   )   { \n             $httpBackend   =   $injector . get (   $httpBackend   ); \n          }   ); \n\n          // 7.  Optional: Simulating Startup Events \n          testing . triggerStartupEvents (); \n       }   ); \n\n       // 8. Tests \n       it (   subscribes to didReplace events for the search resource ,   function ()   { \n          expect (   testing . widget . axEventBus . subscribe   ) \n             . toHaveBeenCalledWith (   didReplace.exampleResource ,   jasmine . any (   Function   )   ); \n       }   ); \n\n       // 9. Test Tear-Down \n       afterEach (   testing . tearDown   ); \n\n    }   );  }   );", 
            "title": "Introduction to LaxarJS Testing"
        }, 
        {
            "location": "/manuals/introduction/#1-module-definition", 
            "text": "In the AMD module definition for a widget test the first thing to depend on should usually be the widget descriptor (the contents of the  widget.json  file).\nThis is the only information LaxarJS Testing needs to determine the relevant widget and according assets to load.\nWe recommend using the  json  plugin for  RequireJS  to load the file hassle-free just as done in this example.  Additionally  LaxarJS Testing  needs to be loaded, to gain access to the API for widget loading, instrumentation and inspection.\nWhen using the default  RequireJS  configuration for that package, it should be available as  laxar-testing .\nThe import of  angular-mocks  should only take place, if it is really needed during testing.\nIn this example we want to use the mocked  $httpBackend  provided by  AngularJS Mocks  and thus need to import  angular-mocks .", 
            "title": "1. Module Definition"
        }, 
        {
            "location": "/manuals/introduction/#2-test-setup", 
            "text": "Due to a bunch of HTTP requests that need to take place, setting up a widget test is an asynchronous task.\nTo spare the user the handling of asynchronous tasks in the  Jasmine  environment,  testing.createSetupForWidget( descriptor )  returns an asynchronous function suitable for use with  beforeEach .\nBesides the widget descriptor, it can optionally receive a map of configuration options.", 
            "title": "2. Test Setup"
        }, 
        {
            "location": "/manuals/introduction/#available-options", 
            "text": "", 
            "title": "Available Options"
        }, 
        {
            "location": "/manuals/introduction/#knownmissingresources", 
            "text": "A list of file name parts that are known to be absent.\nIf left unspecified, the runtime's file resource provider would try to fetch these assets for widgets and controls through HTTP, resulting in 404 errors being logged.\nSo whenever you see such an error in the log and decide that the absence of the corresponding file is fine, an appropriate entry can be added to this configuration.\nThe list entries can be strings or regular expressions.\nRegular expressions are tested against requested file names, while strings will match any file name that contains them anywhere.  In this example the widget uses the  i18n  control.\nWe already know that there is no theme, and hence no CSS file for this control, as it only provides some APIs and has no visual representation.\nWhen loading the widget from a running application, the generated file listing would yield that the file is absent and it wouldn't be loaded.\nDuring testing we have to give that hint manually, as seen in this example.  Further information can be found in the  api docs .", 
            "title": "knownMissingResources"
        }, 
        {
            "location": "/manuals/introduction/#3-widget-configuration", 
            "text": "In the next step we configure the features of the widget, just as it normally happens in a page definition.\nThe object you'd put under the key  features  can simply be passed to the method  testing.widget.configure .\nFor convenience it's also possible to use an object attribute path and a single value as arguments.\nThis is e.g. useful if the widget gets pre-configured in an outer  describe  block and is adjusted deeper in a nested structure.  So here we could have also written this:  beforeEach (   function ()   { \n    testing . widget . configure (   example.resource ,   exampleResource   ); \n    testing . widget . configure (   example.action ,   exampleAction   );  }   );", 
            "title": "3. Widget Configuration"
        }, 
        {
            "location": "/manuals/introduction/#4-loading-the-widget", 
            "text": "Here we tell the widget loader to actually load the widget controller.\nSince the API of the widget loader is asynchronous, the  load  method is asynchronous as well and thus expects a  Jasmine   done  callback.\nAgain, to keep it as simple as possible for the user, the  load  method doesn't need to be called directly, but can simply be passed on to  beforeEach \nMake sure to load the widget only when all configuration has been applied, because afterwards calls to  testing.widget.configure  have no effect.", 
            "title": "4. Loading the Widget"
        }, 
        {
            "location": "/manuals/introduction/#5-optional-rendering-the-widget-dom", 
            "text": "Naturally this step does not apply to activities, since they do not influence the DOM and in particular have no visual representation.\nCalling the  testing.widget.render()  for activities isn't harmful, but simply has no effect at all.\nIn case of a widget, the template is compiled by the underlying technology adapter, wrapped in a  div  element and the resulting DOM node returned.\nThis is not different from the rendering process in a regular application.\nInstead of appending the DOM to a widget area, it is appended to the body element of the test.\nIt is removed again before the next test run would render its DOM or when calling  testing.tearDown .", 
            "title": "5. Optional: Rendering the Widget DOM"
        }, 
        {
            "location": "/manuals/introduction/#6-optional-mocking-an-angularjs-injection", 
            "text": "For this example, we assume that we're testing an  AngularJS  widget, which performs some backend communication, using the  $http  service provided by  AngularJS . AngularJS Mocks  aids us in this case, by providing the instrumentation API  $httpBackend .\nTo prevent from going too much into detail, the  AngularJS Mocks API  should be your source of information in that regard.", 
            "title": "6. Optional: Mocking an AngularJS Injection"
        }, 
        {
            "location": "/manuals/introduction/#7-optional-simulating-startup-events", 
            "text": "When a page within a  LaxarJS  application loads, the runtime publishes several initial events.\nMany widgets don't actually care for these events and only subscribe to custom events such as  didReplace  or  takeActionRequest .\nOther widgets may depend on  core events  like  didChangeLocale  or  didNavigate  with certain parameters.  In order to be able to test a widgets response to core events without duplicating too much of this task within every test, the method  testing.triggerStartupEvents  publishes all events the runtime would publish in the correct order.\nThe method allows to configure parts of these events or skip some of them completely.\nFor further information on event configuration have a look at the extensive  API docs .", 
            "title": "7.  Optional: Simulating Startup Events"
        }, 
        {
            "location": "/manuals/introduction/#8-tests", 
            "text": "Now you're set up to write your actual tests.\nAt this point the widget controller is instantiated, the (optional) DOM fragment has been rendered and all relevant runtime events were published.  Probably you want to group your tests into functional use cases via  Jasmine   describe  functions.\nIn this case it is sometimes a good thing to postpone the calls to  testing.widget.load ,  testing.widget.render  and  testing.triggerStartupEvents .\nIt is then possible to structure the test in isolated  describe  blocks, to adjust the configuration for each block as needed and only afterwards call the other methods to actually fire up your tests.", 
            "title": "8. Tests"
        }, 
        {
            "location": "/manuals/introduction/#9-test-tear-down", 
            "text": "Every widget test should call  testing.tearDown  in a  Jasmine   afterEach  block or simply pass it to  afterEach .\nThis ensures, that after one test is run, the DOM is cleaned up and the widget with all its dependencies is destroyed.\nIf this is omitted, it cannot be guaranteed that remainders of the previous test run do not influence the current test run.", 
            "title": "9. Test Tear-Down"
        }, 
        {
            "location": "/manuals/introduction/#directory-layout", 
            "text": "If you generated your widget or activity with the latest  grunt-init  template, everything should be set up correctly.\nWhen creating the widget artifacts manually, we recommend the following directory layout for the tests within the widget directory:  example-widget\n\n+-- example-widget.js\n+-- widget.json\n+-- spec\n    +-- example-widget.spec.js\n    +-- spec_runner.html\n    +-- spec_runner.js  When follwing this structure, the AMD module definition from the top of this introduction should work for you.\nYou just have to ensure that paths like  laxar-testing  and  angular-mocks  are configured correctly.  When running the widget test in your browser, this is achieved by using the correct paths in the file  spec_runner.html .\nBy default it is assumed that any widget directory can be found at the directory  includes/widget/ your category /  under the application root.\nThe  require_config.js  of the application will then be loaded by stepping up to the parent directory five times (see  here  for an example).\nFor tests to run, at least the paths  requirejs ,  jasmine ,  laxar-testing  and the RequireJS  json  plugin have to be defined in that file.\nWhen testing  AngularJS  widgets, the path to  angular-mocks  must be defined as well.  The next file that is loaded is  spec_runner.js  (an example can be found  here ).\nThis file merely defines which actual test files to load and run.\nThese files are searched relative to   spec_runner.js .\nOptionally you can overwrite  RequireJS  configuration from the application's  require_config.js  file, by setting the appropriate entries under the property  requireConfig .\nFor example, it may sometimes be a good idea to mock a large external library with a simpler stub for testing.  Finally, the module  example-widget.spec.js  defines the actual testing code.\nIf you're following these guidelines, the widget descriptor ( widget.json ) can also be loaded as explained in the example, so that the widget under test can be instantiated without problems.", 
            "title": "Directory Layout"
        }
    ]
}