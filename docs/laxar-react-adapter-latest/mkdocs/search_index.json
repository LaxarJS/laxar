{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS React Adapter \n\n\n\n\nCreate LaxarJS widgets and controls using React\n\n\n\n\n\n   Take a look at the \ndocumentation site\n to browse documentation for all releases of this artifact.\n\n\n\nInstallation\n\n\nnpm install --save laxar-react-adapter babel-plugin-transform-react-jsx babel-plugin-transform-class-properties\n\n\n\n\n\n\nThis will automatically add React if not already installed.\nThese instructions assume that Babel is already configured with \nES2015\n support, e.g. by using the \nLaxarJS Yeoman generator\n.\n\n\nLoad the React adapter module (\nlaxar-react-adapter\n) into your project and pass it to LaxarJS \ncreate\n:\n\n\nimport\n \n{\n \ncreate\n \n}\n \nfrom\n \nlaxar\n;\n\n\nimport\n \n*\n \nas\n \nreactAdapter\n \nfrom\n \nlaxar-react-adapter\n;\n\n\nimport\n \nartifacts\n \nfrom\n \nlaxar-loader/artifacts?flow=main\ntheme=cube\n;\n\n\nconst\n \nconfiguration\n \n=\n \n{\n \n/* ... */\n \n};\n\n\ncreate\n(\n \n[\n \nreactAdapter\n \n/* , ... */\n \n],\n \nartifacts\n,\n \nconfiguration\n \n)\n\n   \n.\nflow\n(\n \n/* ... name, element ... */\n \n)\n\n   \n.\nbootstrap\n();\n\n\n\n\n\n\nwebpack Configuration\n\n\nIf you did not use the Yeoman generator to pre-configure webpack for React, your loader configuration will probably need to be adjusted.\nFor webpack to resolve JSX files and to process them using Babel, the configuration (usually \nwebpack.config.js\n) needs to be adjusted:\n\n\n   \nresolve\n:\n \n{\n \nextensions\n:\n \n[\n \n.js\n,\n \n.jsx\n \n]\n \n},\n\n   \nmodule\n:\n \n{\n\n      \nrules\n:\n \n[\n\n         \n// ...,\n\n         \n{\n\n            \ntest\n:\n \n/\\.jsx?$/\n,\n\n            \nexclude\n:\n \npath\n.\nresolve\n(\n \n__dirname\n,\n \n./node_modules\n \n);\n\n            \nuse\n:\n \nbabel-loader\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n\n\n\n\nFinally include support for JSX in your \n.babelrc\n:\n\n\n{\n\n   \n// ...\n\n   \nplugins\n:\n \n[\n\n      \n// ...,\n\n      \ntransform-class-properties\n,\n\n      \ntransform-react-jsx\n\n   \n]\n\n\n}\n\n\n\n\n\n\nFor \nESLint\n support, check out the \neslint-plugin-react\n module.\nThat's it.\n\n\nUsage\n\n\nWith the adapter in place, you can now write widgets and controls using React.\nThe \nLaxarJS Yeoman generator\n can create implementation stubs for you, if you specify the integration technology \n\"react\"\n.\nWhen creating widgets \nmanually\n, make sure to set the \n\"integration.technology\"\n to \n\"react\"\n in the \nwidget.json\n.\n\n\nCreating a React Widget\n\n\nWidgets can be created from a JSX file containing a basic widget component.\n\n\nFor example \nmy-new-widget.jsx\n:\n\n\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\nimport\n \n{\n \ninjections\n \n}\n \nfrom\n \nlaxar-react-adapter\n;\n\n\n\nexport\n \ndefault\n \nclass\n \nMyNewWidget\n \nextends\n \nReact\n.\nComponent\n \n{\n\n   \nstatic\n \n[\n \ninjections\n \n]\n \n=\n \n[\n \naxFeatures\n \n];\n\n   \nrender\n()\n \n{\n\n      \nconst\n \n[\n \nfeatures\n \n]\n \n=\n \nthis\n.\nprops\n.\ninjections\n;\n\n      \nreturn\n \ndiv\nHello\n,\n \nworld\n!\n \n{\n \nfeatures\n.\nsome\n.\nconfig\n \n}\n/div\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe component in this example is \ninjected\n the \naxFeatures\n object.\nThis object can be used to access the widget instance configuration.\nIf a widget does not require any \ninjections\n, the static property may be omitted.\n\n\nAnother injection called \naxReactRender\n is provided only when using \n\"react\"\n as the integration technology, and it can be used to update the widget DOM after a data change. When using component classes, this is not necessary, as \nthis.forceUpdate()\n can be used instead. The following example uses the \naxReactRender\n injection in a functional component:\n\n\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\nimport\n \n{\n \ninjections\n \n}\n \nfrom\n \nlaxar-react-adapter\n;\n\n\n\nMyNewWidget\n[\n \ninjections\n \n]\n \n=\n \n[\n \naxReactRender\n \n];\n\n\nexport\n \ndefault\n \nfunction\n \nMyNewWidget\n(\n \nprops\n \n)\n \n{\n\n   \nconst\n \n[\n \nreactRender\n \n]\n \n=\n \nprops\n.\ninjections\n;\n\n\n   \nlet\n \ncount\n \n=\n \n0\n;\n\n   \nreturn\n \ndiv\n \nonClick\n=\n{\n \nincrement\n \n}\nClicks\n:\n \n{\n \ncount\n \n}\n/div\n;\n\n\n   \nfunction\n \nincrement\n()\n \n{\n\n      \n++\ncount\n;\n\n      \nreactRender\n();\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe render function is a no-op as long as the widget has not been attached to the DOM (e.g. while in a background-tab, or within a closed popup).\nAs soon as the widget has been attached to the page DOM, \naxReactRender\n calls the \nforceUpdate()\n method of the component.\n\n\nRead the LaxarJS documentation for more about \ncreating widgets and activities\n and the \navailable injections\n.\n\n\nProviding a Widget Area to embed other Widgets\n\n\nLaxarJS widgets can provide widget areas in their own HTML template.\nThese areas can then be referenced from within page definitions in order to add widgets to them.\nTo create such a widget with React, the component \nAxWidgetArea\n is provided by the adapter.\n\n\nAn AxWidgetArea instance accepts the following React props:\n\n\n\n\n\n\nname\n (\nString\n): the local name of the widget area \n(required)\n.\n  This is the part after the \n.\n in the page definition. Must be constant\n\n\n\n\n\n\naxAreaHelper\n (\nObject\n): the widget injection \naxAreaHelper\n \n(required)\n\n\n\n\n\n\naxVisibility\n (\nObject\n): the widget injection \naxVisibility\n.\n  This is required for the area visibility to ever be \nfalse\n\n\n\n\n\n\nclassName\n (\nString\n, \nObject\n): forwarded to the \nclassName\n of the generated container DIV\n\n\n\n\n\n\nvisible\n (\nBoolean\n): \nfalse\n if the widget area should be hidden (default: \ntrue\n).\n  The area will be hidden using CSS \ndisplay: none\n, and will be kept in the DOM\n\n\n\n\n\n\nHere is an example of a \n\"react\"\n widget providing a widget area \"myContent\" (accessible in the page as \nwidget-id\n.myContent\n):\n\n\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\nimport\n \n{\n \nAxWidgetArea\n,\n \ninjections\n \n}\n \nfrom\n \nlaxar-react-adapter\n;\n\n\n\nexport\n \ndefault\n \nclass\n \nMyNewWidget\n \nextends\n \nReact\n.\nComponent\n \n{\n\n   \nstatic\n \n[\n \ninjections\n \n]\n \n=\n \n[\n \naxAreaHelper\n \n];\n\n\n   \nrender\n()\n \n{\n\n      \nconst\n \n[\n \nareaHelper\n \n]\n \n=\n \nthis\n.\nprops\n.\ninjections\n;\n\n      \nreturn\n \nAxWidgetArea\n \nname\n=\nmyContent\n \naxAreaHelper\n=\n{\n \nareaHelper\n \n}\n \n/\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nIn this example the widget area is always visible.\nFor the visibility to change at runtime, the additional injection \naxVisibility\n is required.\nWe're using React's \nsetState\n to trigger change detection and automatic re-rending of the component.\n\n\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\nimport\n \n{\n \nAxWidgetArea\n,\n \ninjections\n \n}\n \nfrom\n \nlaxar-react-adapter\n;\n\n\n\n\nexport\n \ndefault\n \nclass\n \nMyNewWidget\n \nextends\n \nReact\n.\nComponent\n \n{\n\n   \nstatic\n \n[\n \ninjections\n \n]\n \n=\n \n[\n \naxAreaHelper\n,\n \naxVisibility\n \n];\n\n   \nconstructor\n(\n \nprops\n \n)\n \n{\n\n      \nsuper\n(\n \nprops\n \n);\n\n      \nthis\n.\nstate\n \n=\n \n{\n\n         \nshowing\n:\n \ntrue\n\n      \n}\n\n   \n}\n\n   \nrender\n()\n \n{\n\n      \nconst\n \n[\n \nareaHelper\n,\n \nvisibility\n \n]\n \n=\n \nthis\n.\nprops\n.\ninjections\n;\n\n      \nconst\n \ntoggleShowing\n \n=\n \n()\n \n=\n \n{\n\n         \nthis\n.\nsetState\n(\nprev\n \n=\n \n({\n \nshowing\n:\n \n!\nprev\n.\nshowing\n \n}));\n\n      \n};\n\n      \nreturn\n \n(\n\n         \ndiv\n \nonClick\n=\n{\n \ntoggleShowing\n \n}\n\n            \nAxWidgetArea\n\n               \nname\n=\nmyContent\n\n               \nvisible\n=\n{\n \nthis\n.\nstate\n.\nshowing\n \n}\n\n               \naxAreaHelper\n=\n{\n \nareaHelper\n \n}\n\n               \naxVisibility\n=\n{\n \nvisibility\n \n}\n \n/\n\n         \n/div\n\n      \n);\n\n   \n}\n\n\n}\n\n\n\n\n\n\nCreating a React Control\n\n\nA \nLaxarJS control\n allows you to encapsulates one or more React components with associated CSS styles that can be overwritten by \nLaxarJS themes.\n\n\nReact controls are implemented as regular JavaScript modules, just like \nplain\n LaxarJS controls:\n\n\n// my-new-control.jsx\n\n\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\n\nexport\n \ndefault\n \nclass\n \nMyNewControl\n \nextends\n \nReact\n.\nComponent\n \n{\n\n   \nrender\n()\n \n{\n\n      \nreturn\n \ndiv\n \nclassName\n=\nmy-new-control\n/div\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nSelect \n\"react\"\n as the integration technology when you generate the control with the LaxarJS Yeoman generator, or set it as the \n\"integration.technology\"\n of the \ncontrol.json\n descriptor when creating a control manually:\n\n\n// control.json\n\n\n{\n\n   \nname\n:\n \nmy-new-control\n,\n\n   \nintegration\n:\n \n{\n\n      \ntechnology\n:\n \nreact\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWidgets can access the control by loading its module, or by requesting it through the \naxControls\n injection.\nThe latter is \nrecommended\n as it does not depend as much on the project-specific loader configuration:\n\n\n// my-new-widget.jsx\n\n\nimport\n \nReact\n \nfrom\n \nreact\n;\n\n\nimport\n \n{\n \ninjections\n \n}\n \nfrom\n \nlaxar-react-adapter\n;\n\n\n\nexport\n \nclass\n \nMyNewWidget\n \nextends\n \nReact\n.\nComponent\n \n{\n\n   \nstatic\n \n[\n \ninjections\n \n]\n \n=\n \n[\n \naxControls\n \n];\n\n   \nrender\n()\n \n{\n\n      \nconst\n \n[\n \ncontrols\n \n]\n \n=\n \nthis\n.\nprops\n.\ninjections\n;\n\n      \nconst\n \n{\n \nMyReactControl\n \n}\n \n=\n \ncontrols\n.\nprovide\n(\n \nmy-new-control\n \n);\n\n      \nreturn\n \ndiv\nHello\n,\n \nworld\n!\n \nMyReactControl\n \n/\n/div\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\nFor this to work the widget needs to list their controls in the \n\"controls\"\n section of the descriptor, which also ensures that CSS theming works:\n\n\n// widget.json\n\n\n{\n\n   \nname\n:\n \nmy-new-widget\n,\n\n   \nintegration\n:\n \n{\n\n      \ntechnology\n:\n \nreact\n,\n\n      \ntype\n:\n \nwidget\n\n   \n},\n\n   \ncontrols\n:\n \n[\n \nmy-new-control\n \n],\n\n   \nfeatures\n:\n \n{\n \n/* ... */\n \n}\n\n\n}\n\n\n\n\n\n\nRead the LaxarJS documentation for general information on \nproviding controls\n.\n\n\nTesting with LaxarJS Mocks\n\n\nStarting with \nlaxar-mocks\n v2.0.0, you can easily create tests with the \nsetupForWidget\n function.\nSimply write your specs like this:\n\n\nimport\n \n*\n \nas\n \naxMocks\n \nfrom\n \nlaxar-mocks\n;\n\n\n\ndescribe\n(\n \nThe my-counter-widget\n,\n \n()\n \n=\n \n{\n\n\n   \nbeforeEach\n(\n \naxMocks\n.\nsetupForWidget\n()\n \n);\n\n   \nbeforeEach\n(\n \n()\n \n=\n \n{\n\n      \naxMocks\n.\nwidget\n.\nconfigure\n(\n \n{\n \nsomeFeature\n:\n \nsomeConfigValue\n \n}\n \n);\n\n   \n}\n \n);\n\n\n   \nbeforeEach\n(\n \naxMocks\n.\nwidget\n.\nload\n \n);\n\n\n   \nlet\n \nwidgetDom\n;\n\n   \nbeforeEach\n(\n \n()\n \n=\n \n{\n \nwidgetDom\n \n=\n \naxMocks\n.\nwidget\n.\nrender\n();\n \n}\n \n);\n\n\n   \n// ... tests ...\n\n\n   \nafterEach\n(\n \naxMocks\n.\ntearDown\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nBuilding the Adapter from Source\n\n\nInstead of using a pre-compiled library within a project, you can also clone this repository:\n\n\ngit clone https://github.com/LaxarJS/laxar-react-adapter.git\n\ncd\n laxar-react-adapter\nnpm install\n\n\n\n\n\nTo see changes in your application, either configure your project to work with the sources (e.g. by using webpack), or rebuild the webpack bundles by running \nnpm run dist\n.\n\n\nTo run the automated karma tests:\n\n\nnpm \ntest\n\n\n\n\n\n\nTo generate HTML spec runners for opening in your web browser, so that you can e.g. use the browser's developer tools:\n\n\nnpm  start\n\n\n\n\n\nNow you can select a spec-runner by browsing to http://localhost:8080/dist/spec/.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs-react-adapter", 
            "text": "Create LaxarJS widgets and controls using React   \n   Take a look at the  documentation site  to browse documentation for all releases of this artifact.", 
            "title": "LaxarJS React Adapter"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install --save laxar-react-adapter babel-plugin-transform-react-jsx babel-plugin-transform-class-properties   This will automatically add React if not already installed.\nThese instructions assume that Babel is already configured with  ES2015  support, e.g. by using the  LaxarJS Yeoman generator .  Load the React adapter module ( laxar-react-adapter ) into your project and pass it to LaxarJS  create :  import   {   create   }   from   laxar ;  import   *   as   reactAdapter   from   laxar-react-adapter ;  import   artifacts   from   laxar-loader/artifacts?flow=main theme=cube ;  const   configuration   =   {   /* ... */   };  create (   [   reactAdapter   /* , ... */   ],   artifacts ,   configuration   ) \n    . flow (   /* ... name, element ... */   ) \n    . bootstrap ();", 
            "title": "Installation"
        }, 
        {
            "location": "/#webpack-configuration", 
            "text": "If you did not use the Yeoman generator to pre-configure webpack for React, your loader configuration will probably need to be adjusted.\nFor webpack to resolve JSX files and to process them using Babel, the configuration (usually  webpack.config.js ) needs to be adjusted:      resolve :   {   extensions :   [   .js ,   .jsx   ]   }, \n    module :   { \n       rules :   [ \n          // ..., \n          { \n             test :   /\\.jsx?$/ , \n             exclude :   path . resolve (   __dirname ,   ./node_modules   ); \n             use :   babel-loader \n          } \n       ] \n    }   Finally include support for JSX in your  .babelrc :  { \n    // ... \n    plugins :   [ \n       // ..., \n       transform-class-properties , \n       transform-react-jsx \n    ]  }   For  ESLint  support, check out the  eslint-plugin-react  module.\nThat's it.", 
            "title": "webpack Configuration"
        }, 
        {
            "location": "/#usage", 
            "text": "With the adapter in place, you can now write widgets and controls using React.\nThe  LaxarJS Yeoman generator  can create implementation stubs for you, if you specify the integration technology  \"react\" .\nWhen creating widgets  manually , make sure to set the  \"integration.technology\"  to  \"react\"  in the  widget.json .", 
            "title": "Usage"
        }, 
        {
            "location": "/#creating-a-react-widget", 
            "text": "Widgets can be created from a JSX file containing a basic widget component.  For example  my-new-widget.jsx :  import   React   from   react ;  import   {   injections   }   from   laxar-react-adapter ;  export   default   class   MyNewWidget   extends   React . Component   { \n    static   [   injections   ]   =   [   axFeatures   ]; \n    render ()   { \n       const   [   features   ]   =   this . props . injections ; \n       return   div Hello ,   world !   {   features . some . config   } /div ; \n    }  }   The component in this example is  injected  the  axFeatures  object.\nThis object can be used to access the widget instance configuration.\nIf a widget does not require any  injections , the static property may be omitted.  Another injection called  axReactRender  is provided only when using  \"react\"  as the integration technology, and it can be used to update the widget DOM after a data change. When using component classes, this is not necessary, as  this.forceUpdate()  can be used instead. The following example uses the  axReactRender  injection in a functional component:  import   React   from   react ;  import   {   injections   }   from   laxar-react-adapter ;  MyNewWidget [   injections   ]   =   [   axReactRender   ];  export   default   function   MyNewWidget (   props   )   { \n    const   [   reactRender   ]   =   props . injections ; \n\n    let   count   =   0 ; \n    return   div   onClick = {   increment   } Clicks :   {   count   } /div ; \n\n    function   increment ()   { \n       ++ count ; \n       reactRender (); \n    }  }   The render function is a no-op as long as the widget has not been attached to the DOM (e.g. while in a background-tab, or within a closed popup).\nAs soon as the widget has been attached to the page DOM,  axReactRender  calls the  forceUpdate()  method of the component.  Read the LaxarJS documentation for more about  creating widgets and activities  and the  available injections .", 
            "title": "Creating a React Widget"
        }, 
        {
            "location": "/#providing-a-widget-area-to-embed-other-widgets", 
            "text": "LaxarJS widgets can provide widget areas in their own HTML template.\nThese areas can then be referenced from within page definitions in order to add widgets to them.\nTo create such a widget with React, the component  AxWidgetArea  is provided by the adapter.  An AxWidgetArea instance accepts the following React props:    name  ( String ): the local name of the widget area  (required) .\n  This is the part after the  .  in the page definition. Must be constant    axAreaHelper  ( Object ): the widget injection  axAreaHelper   (required)    axVisibility  ( Object ): the widget injection  axVisibility .\n  This is required for the area visibility to ever be  false    className  ( String ,  Object ): forwarded to the  className  of the generated container DIV    visible  ( Boolean ):  false  if the widget area should be hidden (default:  true ).\n  The area will be hidden using CSS  display: none , and will be kept in the DOM    Here is an example of a  \"react\"  widget providing a widget area \"myContent\" (accessible in the page as  widget-id .myContent ):  import   React   from   react ;  import   {   AxWidgetArea ,   injections   }   from   laxar-react-adapter ;  export   default   class   MyNewWidget   extends   React . Component   { \n    static   [   injections   ]   =   [   axAreaHelper   ]; \n\n    render ()   { \n       const   [   areaHelper   ]   =   this . props . injections ; \n       return   AxWidgetArea   name = myContent   axAreaHelper = {   areaHelper   }   / ; \n    }  }   In this example the widget area is always visible.\nFor the visibility to change at runtime, the additional injection  axVisibility  is required.\nWe're using React's  setState  to trigger change detection and automatic re-rending of the component.  import   React   from   react ;  import   {   AxWidgetArea ,   injections   }   from   laxar-react-adapter ;  export   default   class   MyNewWidget   extends   React . Component   { \n    static   [   injections   ]   =   [   axAreaHelper ,   axVisibility   ]; \n    constructor (   props   )   { \n       super (   props   ); \n       this . state   =   { \n          showing :   true \n       } \n    } \n    render ()   { \n       const   [   areaHelper ,   visibility   ]   =   this . props . injections ; \n       const   toggleShowing   =   ()   =   { \n          this . setState ( prev   =   ({   showing :   ! prev . showing   })); \n       }; \n       return   ( \n          div   onClick = {   toggleShowing   } \n             AxWidgetArea \n                name = myContent \n                visible = {   this . state . showing   } \n                axAreaHelper = {   areaHelper   } \n                axVisibility = {   visibility   }   / \n          /div \n       ); \n    }  }", 
            "title": "Providing a Widget Area to embed other Widgets"
        }, 
        {
            "location": "/#creating-a-react-control", 
            "text": "A  LaxarJS control  allows you to encapsulates one or more React components with associated CSS styles that can be overwritten by  LaxarJS themes.  React controls are implemented as regular JavaScript modules, just like  plain  LaxarJS controls:  // my-new-control.jsx  import   React   from   react ;  export   default   class   MyNewControl   extends   React . Component   { \n    render ()   { \n       return   div   className = my-new-control /div ; \n    }  }   Select  \"react\"  as the integration technology when you generate the control with the LaxarJS Yeoman generator, or set it as the  \"integration.technology\"  of the  control.json  descriptor when creating a control manually:  // control.json  { \n    name :   my-new-control , \n    integration :   { \n       technology :   react \n    }  }   Widgets can access the control by loading its module, or by requesting it through the  axControls  injection.\nThe latter is  recommended  as it does not depend as much on the project-specific loader configuration:  // my-new-widget.jsx  import   React   from   react ;  import   {   injections   }   from   laxar-react-adapter ;  export   class   MyNewWidget   extends   React . Component   { \n    static   [   injections   ]   =   [   axControls   ]; \n    render ()   { \n       const   [   controls   ]   =   this . props . injections ; \n       const   {   MyReactControl   }   =   controls . provide (   my-new-control   ); \n       return   div Hello ,   world !   MyReactControl   / /div ; \n    }  }   For this to work the widget needs to list their controls in the  \"controls\"  section of the descriptor, which also ensures that CSS theming works:  // widget.json  { \n    name :   my-new-widget , \n    integration :   { \n       technology :   react , \n       type :   widget \n    }, \n    controls :   [   my-new-control   ], \n    features :   {   /* ... */   }  }   Read the LaxarJS documentation for general information on  providing controls .", 
            "title": "Creating a React Control"
        }, 
        {
            "location": "/#testing-with-laxarjs-mocks", 
            "text": "Starting with  laxar-mocks  v2.0.0, you can easily create tests with the  setupForWidget  function.\nSimply write your specs like this:  import   *   as   axMocks   from   laxar-mocks ;  describe (   The my-counter-widget ,   ()   =   { \n\n    beforeEach (   axMocks . setupForWidget ()   ); \n    beforeEach (   ()   =   { \n       axMocks . widget . configure (   {   someFeature :   someConfigValue   }   ); \n    }   ); \n\n    beforeEach (   axMocks . widget . load   ); \n\n    let   widgetDom ; \n    beforeEach (   ()   =   {   widgetDom   =   axMocks . widget . render ();   }   ); \n\n    // ... tests ... \n\n    afterEach (   axMocks . tearDown   );  }   );", 
            "title": "Testing with LaxarJS Mocks"
        }, 
        {
            "location": "/#building-the-adapter-from-source", 
            "text": "Instead of using a pre-compiled library within a project, you can also clone this repository:  git clone https://github.com/LaxarJS/laxar-react-adapter.git cd  laxar-react-adapter\nnpm install  To see changes in your application, either configure your project to work with the sources (e.g. by using webpack), or rebuild the webpack bundles by running  npm run dist .  To run the automated karma tests:  npm  test   To generate HTML spec runners for opening in your web browser, so that you can e.g. use the browser's developer tools:  npm  start  Now you can select a spec-runner by browsing to http://localhost:8080/dist/spec/.", 
            "title": "Building the Adapter from Source"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv2.0.1\n\n\n\n\n#29\n: documentation: fixed example use of \naxControls\n\n\n\n\nv2.0.0\n\n\n\n\n#27\n: widgets can now export \nReact.Component\n classes instead of create functions\n\n\n#28\n: fixed changelog\n\n\n\n\nv2.0.0-rc.1\n\n\n\n\n#26\n: fixed dependencies in package.json\n\n\n\n\nv2.0.0-rc.0\n\n\n\n\n#25\n: polish\n\n\n\n\nv2.0.0-beta.1\n\n\n\n\n#24\n: turned \neslint-plugin-react\n into a dev dependency\n\n\n\n\nv2.0.0-beta.0\n\n\n\n\n\n\n#21\n: simplified integration and AxWidgetArea, improved README\n\n\n\n\nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n\n\n#22\n: fixed missing devDependencies in package.json\n\n\n\n\n\n\nv2.0.0-alpha.1\n\n\n\n\n#19\n: added widget area component\n\n\n#20\n: adapted to laxar API change (LaxarJS/laxar#413)\n\n\n#18\n: project: updated dev-dependencies, upgraded to webpack 2\n\n\n\n\nv2.0.0-alpha.0\n\n\n\n\n#17\n: adapted to latest laxar changes (laxar#396, laxar#397)\n\n\n#16\n: fixed bad copy/paste (package.json)\n\n\n#15\n: adjusted to adapter API changes (laxar#358)\n\n\n#14\n: fixed passing of services to \nonBeforeControllerCreation\n callback\n\n\n#13\n: fixed bower.json \nmain\n entry\n\n\n#12\n: removed applyViewChanges\n\n\n#11\n: environment: adapted to reduced environment\n\n\n#10\n: project: turned framework dependencies into peer-dependencies\n\n\n\n\n#5\n: services: adopted to new widget services\n\n\n\n\nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n\n\n#9\n: eslint: use shared configuration\n\n\n\n\n#8\n: applied restricted eslint rules\n\n\n#7\n: added dist-target for UMD-library\n\n\n#6\n: made react adapter module stateless (LaxarJS v2)\n\n\nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n\n\nv0.4.0\n\n\n\n\n#4\n: documentation: using \"react\" as integration technology with the LaxarJS generator\n\n\n#3\n: documentation: fixed path for require.js\n\n\n\n\nv0.3.0\n\n\n\n\n#2\n: upgraded to React v0.14.x\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv0.2.0\n\n\n\n\n#1\n: added testing documentation\n\n\n\n\nv0.1.0", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v201", 
            "text": "#29 : documentation: fixed example use of  axControls", 
            "title": "v2.0.1"
        }, 
        {
            "location": "/CHANGELOG/#v200", 
            "text": "#27 : widgets can now export  React.Component  classes instead of create functions  #28 : fixed changelog", 
            "title": "v2.0.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc1", 
            "text": "#26 : fixed dependencies in package.json", 
            "title": "v2.0.0-rc.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc0", 
            "text": "#25 : polish", 
            "title": "v2.0.0-rc.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta1", 
            "text": "#24 : turned  eslint-plugin-react  into a dev dependency", 
            "title": "v2.0.0-beta.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta0", 
            "text": "#21 : simplified integration and AxWidgetArea, improved README   BREAKING CHANGE:  see ticket for details     #22 : fixed missing devDependencies in package.json", 
            "title": "v2.0.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha1", 
            "text": "#19 : added widget area component  #20 : adapted to laxar API change (LaxarJS/laxar#413)  #18 : project: updated dev-dependencies, upgraded to webpack 2", 
            "title": "v2.0.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha0", 
            "text": "#17 : adapted to latest laxar changes (laxar#396, laxar#397)  #16 : fixed bad copy/paste (package.json)  #15 : adjusted to adapter API changes (laxar#358)  #14 : fixed passing of services to  onBeforeControllerCreation  callback  #13 : fixed bower.json  main  entry  #12 : removed applyViewChanges  #11 : environment: adapted to reduced environment  #10 : project: turned framework dependencies into peer-dependencies   #5 : services: adopted to new widget services   BREAKING CHANGE:  see ticket for details     #9 : eslint: use shared configuration   #8 : applied restricted eslint rules  #7 : added dist-target for UMD-library  #6 : made react adapter module stateless (LaxarJS v2)  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v040", 
            "text": "#4 : documentation: using \"react\" as integration technology with the LaxarJS generator  #3 : documentation: fixed path for require.js", 
            "title": "v0.4.0"
        }, 
        {
            "location": "/CHANGELOG/#v030", 
            "text": "#2 : upgraded to React v0.14.x\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v0.3.0"
        }, 
        {
            "location": "/CHANGELOG/#v020", 
            "text": "#1 : added testing documentation", 
            "title": "v0.2.0"
        }, 
        {
            "location": "/CHANGELOG/#v010", 
            "text": "", 
            "title": "v0.1.0"
        }
    ]
}