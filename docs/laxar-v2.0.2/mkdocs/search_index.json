{
    "docs": [
        {
            "location": "/", 
            "text": "LaxarJS \n\n\n\n\nMiddleware for your web client:\n Create maintainable applications from small, isolated parts.\n\n\n\n\n\n   Take a look at the \ndocumentation site\n to browse documentation for all releases of this artifact.\n\n\n\nWhy LaxarJS?\n\n\nFind out \nwhy\n you would use LaxarJS and if it's the right tool for you.\nThen, explore the \ncore concepts\n and browse the \nmanuals\n in the \ndocumentation\n.\nAlso, there is a \nglossary\n where you can lookup individual concepts, and a \ntroubleshooting guide\n there for you if you need it.\n\n\nHave a look at the \nLaxarJS website\n for demos and more information.\n\n\n   Take a look at the \ndocumentation site\n to browse documentation for all releases.\n\n\n\nGetting Started\n\n\nHere are the basic instructions to get started.\n\n\nRequirements\n\n\nOn your \ndevelopment machine\n, make sure that you have Node.js v6 or above (v4 might work, but there is no support).\n\n\nUsers of your application will need to have the following \nbrowser capabilities:\n\n\n\n\nnative ES5 support (no polyfills: MSIE \n 9 is \nnot\n supported)\n\n\n\n\nSupport for the following ES6 features (native or polyfilled):\n\n\n\n\nPromise, Fetch\n\n\nArray.from, Array.prototype.includes\n\n\nObject.assign\n\n\n\n\n\n\n\n\nModern browsers have support for all of these, but polyfills for the listed ES6 features can be obtained by simply loading the LaxarJS polyfills bundle (\ndist/polyfills.js\n) using a script tag, before loading anything else.\nWhen using the generator (next step), your project will be setup for use with polyfills automatically.\n\n\nUsing the Generator\n\n\nUse the  \ngenerator-laxarjs2\n for the \nYeoman\n scaffolding tool to get started:\n\n\nnpm install -g yo generator-laxarjs2\n\n\nmkdir my-app\n\n\ncd my-app\n\n\nyo laxarjs2\n\n\n\n\n\n\nThis will guide you through a couple of prompts in order to create your first application.\nThere is a \nstep-by-step tutorial\n containing a more detailed example.\n\n\nManual Setup\n\n\nUsing the generator is the recommended way of creating a LaxarJS application.\nHowever, knowledge about the \nmanual\n project setup process is useful for a better understanding of LaxarJS and may help in some advanced use cases, such as \nmigrating\n a project from a previous major version.\n\n\nThere are detailed \ninstructions to create a project from scratch\n.\n\n\nHacking LaxarJS itself\n\n\nInstead of using the compiled library within a project, you can also clone this repository:\n\n\ngit clone https://github.com/LaxarJS/laxar.git\n\n\ncd laxar\n\n\nnpm install\n\n\n\n\n\n\nTo see changes in your application, either configure your project to work with the sources (e.g. by configuring a webpack alias), or \nrebuild the bundles\n:\n\n\nnpm run dist\n\n\n\n\n\n\nTo run the \nautomated tests\n:\n\n\nnpm test\n\n\n\n\n\n\nTo generate HTML test runners for opening in your web browser, so that you can e.g. use the browser's developer tools for diagnostics:\n\n\nnpm start\n\n\n\n\n\n\nNow you can select a spec-runner by browsing to http://localhost:8080/dist/lib/.", 
            "title": "README"
        }, 
        {
            "location": "/#laxarjs", 
            "text": "Middleware for your web client:  Create maintainable applications from small, isolated parts.   \n   Take a look at the  documentation site  to browse documentation for all releases of this artifact.", 
            "title": "LaxarJS"
        }, 
        {
            "location": "/#why-laxarjs", 
            "text": "Find out  why  you would use LaxarJS and if it's the right tool for you.\nThen, explore the  core concepts  and browse the  manuals  in the  documentation .\nAlso, there is a  glossary  where you can lookup individual concepts, and a  troubleshooting guide  there for you if you need it.  Have a look at the  LaxarJS website  for demos and more information. \n   Take a look at the  documentation site  to browse documentation for all releases.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Here are the basic instructions to get started.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#requirements", 
            "text": "On your  development machine , make sure that you have Node.js v6 or above (v4 might work, but there is no support).  Users of your application will need to have the following  browser capabilities:   native ES5 support (no polyfills: MSIE   9 is  not  supported)   Support for the following ES6 features (native or polyfilled):   Promise, Fetch  Array.from, Array.prototype.includes  Object.assign     Modern browsers have support for all of these, but polyfills for the listed ES6 features can be obtained by simply loading the LaxarJS polyfills bundle ( dist/polyfills.js ) using a script tag, before loading anything else.\nWhen using the generator (next step), your project will be setup for use with polyfills automatically.", 
            "title": "Requirements"
        }, 
        {
            "location": "/#using-the-generator", 
            "text": "Use the   generator-laxarjs2  for the  Yeoman  scaffolding tool to get started:  npm install -g yo generator-laxarjs2  mkdir my-app  cd my-app  yo laxarjs2   This will guide you through a couple of prompts in order to create your first application.\nThere is a  step-by-step tutorial  containing a more detailed example.", 
            "title": "Using the Generator"
        }, 
        {
            "location": "/#manual-setup", 
            "text": "Using the generator is the recommended way of creating a LaxarJS application.\nHowever, knowledge about the  manual  project setup process is useful for a better understanding of LaxarJS and may help in some advanced use cases, such as  migrating  a project from a previous major version.  There are detailed  instructions to create a project from scratch .", 
            "title": "Manual Setup"
        }, 
        {
            "location": "/#hacking-laxarjs-itself", 
            "text": "Instead of using the compiled library within a project, you can also clone this repository:  git clone https://github.com/LaxarJS/laxar.git  cd laxar  npm install   To see changes in your application, either configure your project to work with the sources (e.g. by configuring a webpack alias), or  rebuild the bundles :  npm run dist   To run the  automated tests :  npm test   To generate HTML test runners for opening in your web browser, so that you can e.g. use the browser's developer tools for diagnostics:  npm start   Now you can select a spec-runner by browsing to http://localhost:8080/dist/lib/.", 
            "title": "Hacking LaxarJS itself"
        }, 
        {
            "location": "/CHANGELOG/", 
            "text": "Changelog\n\n\nLast Changes\n\n\nv2.0.2\n\n\n\n\n#469\n: flow: fixed \nconstructAbsoluteUrl\n to not lose active place parameters\n\n\n\n\nv2.0.1\n\n\n\n\n#472\n: bootstrapping: fixed a race condition that sometimes caused initialization to get stuck indefinitely\n\n\n#471\n: documentation: fixed outdated things in widgets and activities manual\n\n\n\n\nv2.0.0\n\n\nv2.0.0-rc.4\n\n\n\n\n#467\n: documentation: mention ngSanitize removal in upgrade guide\n\n\n#466\n: documentation: fixed list formatting, added more links to angular adapter manual\n\n\n#468\n: flow: fixed querystring in empty hash based url not working\n\n\n\n\n#461\n: runtime: added \nax\n prefix to auto-generated areas: \naxActivities\n, \naxPopovers\n, \naxPopups\n\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#464\n: flow: support fragments for routing and for navigation events\n\n\n\n\n\n\nv2.0.0-rc.3\n\n\n\n\n#465\n: fixed dependencies in package.json\n\n\n#460\n: documentation: fixed broken link\n\n\n\n\nv2.0.0-rc.2\n\n\n\n\n#459\n: documentation: fixed broken links\n\n\n#458\n: documentation: fixed broken link\n\n\n\n\nv2.0.0-rc.1\n\n\n\n\n\n\n#457\n: dropped minified targets, using laxar-infrastructure\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#456\n: tooling: gracefully handle missing debugInfo when providing \naxTooling\n injection\n\n\n\n\n\n\nv2.0.0-rc.0\n\n\n\n\n#455\n: documentation: improved getting-started docs, added project-from-scratch instructions\n\n\n\n\nv2.0.0-beta.0\n\n\n\n\n#454\n: documentation: fixed markdown list problems\n\n\n#453\n: documentation: explain that descriptors are mandatory for all themable artifacts\n\n\n#451\n: documentation: fixed broken link\n\n\n\n\nv2.0.0-alpha.24\n\n\n\n\n#452\n: fix configuration \nname\n not being treated as optional\n\n\n#449\n: documentation fixes\n\n\n\n\nv2.0.0-alpha.23\n\n\n\n\n#450\n: removed configuration option \ntooling.enabled\n\n\n#445\n: log: the \nconsole\n log channel now uses standard console formatting specifiers\n\n\n\n\n#403\n: tooling: added external API originally added in LaxarJS 1.3 (#303)\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#404\n: documentation: the \naxTooling\n API is now documented\n\n\n\n\n\n\nv2.0.0-alpha.22\n\n\n\n\n\n\n#447\n: testing: made createAxI18nMock friendly to standalone usage\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#443\n: testing: initialize eventBusMock with noisy error log\n\n\n\n\n#448\n: documentation: fixed markdown indent in API index\n\n\n\n\nv2.0.0-alpha.21\n\n\n\n\n#446\n: documentation: transformed code examples to ES2015\n\n\n#418\n: documentation: various API doc fixes, added index.md\n\n\n#438\n: log: improved visibility of \nlog.fatal\n\n\n#444\n: navigo router: fixed use of fallbackHandler (404)\n\n\n\n\nv2.0.0-alpha.20\n\n\n\n\n#440\n: navigo router: fixed creation of absolute URLs with hash\n\n\n\n\nv2.0.0-alpha.19\n\n\n\n\n\n\n#437\n: bootstrapping: new \ncreate().flow().bootstrap()\n workflow\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#436\n: testing: auto-spy unsubscribe-callback of \neventBus.subscribe\n\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#435\n: navigo: updated to current version with configurable hash string\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#348\n: documentation: added manual on the \nplain\n adapter\n\n\n\n\n#420\n: documentation: added upgrade guide\n\n\n#434\n: areaHelper: keep \ndata-ax-widget-area\n attribute\n\n\n#433\n: documentation: updated manuals for LaxarJS v2\n\n\n\n\n#432\n: router: replaced page.js with Navigo\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#385\n: removed CSS loader\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\nv2.0.0-alpha.18\n\n\n\n\n#419\n: updated contributor information\n\n\n#431\n: testing: added \neventBusMock.drainAsync()\n\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv2.0.0-alpha.17\n\n\n\n\n\n\n#429\n: i18n: allow instantiating widget service without i18n feature config\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#408\n: area helper: improved error logging when calling domAttachTo\n\n\n\n\n\n\n#417\n: flow: added redirects to paths with parameter values included\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#430\n: page.js: fixed hashbang navigation for bases being prefix of a path\n\n\n\n\n#428\n: widget service mocks: provide context to area helper in axVisibilityMock\n\n\n#427\n: project: revert #425\n\n\n\n\nv2.0.0-alpha.16\n\n\n\n\n#423\n: project: fix building LaxarJS when somewhere inside a \nnode_modules\n directory\n\n\n#425\n: project: add browser mappings for other entry points to \npackage.json\n\n\n#426\n: project: don't use library name \nlaxar\n for polyfills and widget service mocks entry points\n\n\n\n\nv2.0.0-alpha.15\n\n\n\n\n\n\n#422\n: runtime: improved widget services testability\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#416\n: fixed log levels reference in compatibility main file\n\n\n\n\n\n\nv2.0.0-alpha.14\n\n\n\n\n\n\n#413\n: adapters: renamed \nonBeforeControllerCreation\n hook\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#415\n: project: updated dev-dependencies, upgraded to webpack 2\n\n\n\n\n#414\n: areaHelperMock: added missing spies to localName and fullName methods\n\n\n\n\nv2.0.0-alpha.13\n\n\n\n\n\n\n#411\n: simplified visibility checking\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#412\n: temporarily re-added widget loader to services\n\n\n\n\n\n\nv2.0.0-alpha.12\n\n\n\n\n\n\n#398\n: removed page service from widget adapter services\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#397\n: moved adapter errors from widgetLoader to new \nadapterUtilities\n service\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#394\n: fixed broken \naxI18n.track()\n, improved docs and spec coverage\n\n\n\n\n\n\nv2.0.0-alpha.11\n\n\n\n\n\n\n#380\n: removed JSON schema processing from runtime\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#405\n: JSON schemas have been converted back to JSON and updated to include all artifacts\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#410\n: adapters: adapters now get access to the flow-service during bootstrapping\n\n\n\n\n#407\n: polyfills: converted to ES2015 and fixed fetch-polyfill path\n\n\n#406\n: fixed typo in comments\n\n\n#396\n: adapters: adapter instances no longer need to have a \ntechnology\n property\n\n\n#276\n: added and fixed API docs\n\n\n\n\n#381\n: flow: clearly distinguish places from their targets and patterns\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#402\n: project: polyfill \nObject.assign\n\n\n\n\n\n\n#395\n: cleanup: removed \nobject.extend\n and \nobject.deepFreeze\n\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#349\n: removed support for MSIE 9\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#392\n: flow: removed \nentryPoint\n / \nexitPoint\n feature\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#390\n: adapter API: make \nartifactProvider\n available to adapters and allow \ncreate()\n to be async\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\nv2.0.0-alpha.10\n\n\n\n\n\n\n#389\n: flow: normalize generated URLs (no trailing \n/_\n)\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#388\n: flow: fixed handling of parameter-only places\n\n\n\n\n#386\n: flow: double-encode slashes in path segments\n\n\n\n\n#387\n: flow: reverted name-change (keep \nconstructAbsoluteUrl\n)\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#384\n: flow: simplified handling of invalid empty places\n\n\n\n\n\n\n#375\n: flow: added support for query parameters\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#376\n: flow: fixed \nconstructAbsoluteUrl\n (was not absolute)\n\n\n\n\n#371\n: flow: fixed URL encoding of place parameter values\n\n\n\n\n#366\n: axFlowService: removed \nconstructAnchor\n and \nconstructPath\n\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#369\n: documentation: improved docs and specs for object.path/setPath\n\n\n\n\n#323\n: documentation: fixed link\n\n\n#365\n: jasmine: set fixed minor version\n\n\n\n\n#364\n: axFlowService: widgets can now longer access the flow controller\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#362\n: loaders: support new \nstyleSource\n and \ntemplateSource\n in artifact descriptors\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#317\n: utilities: removed \npath\n, added \nbrowser.resolve\n\n\n\n\n#357\n: runtime: consolidated modules into \nlib/runtime\n\n\n#361\n: widget services: re-added \naxControls\n injection\n\n\n\n\nv2.0.0-alpha.9\n\n\n\n\n#358\n: adapter API: simplified further\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv2.0.0-alpha.8\n\n\n\n\n\n\n#360\n: routing: use \nflow.router.base\n instead of \nbaseHref\n config\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#351\n: testing: provided full set of widget service mocks\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\nv2.0.0-alpha.7\n\n\nv2.0.0-alpha.6\n\n\n\n\n#356\n: event bus: can be created with a custom error handler\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv2.0.0-alpha.5\n\n\n\n\n#355\n: json validator: moved to utilities\n\n\n\n\n#354\n: event bus: removed unsubscribe methods\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#353\n: log: changed level to levels\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#332\n: widget services: added axI18n service\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#344\n: widget services: added axAssets service\n\n\n\n\n#345\n: added \naxConfiguration.ensure\n, collected configuration defaults in \nservices\n\n\n#347\n: timer: removed resumedOrStarted and added missing tests\n\n\n\n\n#300\n: plain widget adapter: added axWithDom service and renamed DOM ready hook\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#309\n: runtime: slightly simplified area helper\n\n\n\n\n\n\n#333\n: added \naxVisibility\n injection to replace the visibility helper of patterns\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#346\n: testing: added spec-tests for the various mocks\n\n\n\n\n\n\n#304\n: loaders: replaced dynamic artifact resolution with prebuilt artifacts listing\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#270\n: json validator: simplified return value\n\n\n\n\n\n\n#307\n: flow: improved page.js integration\n        + NEW FEATURE: see ticket for details\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#337\n: widget adapters: removed applyViewChanges from widget adapter api\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#340\n: heartbeat: call listeners asynchronously so that event bus promises have already been processed\n\n\n\n\n#339\n: event bus: return unsubscribe function on subscription\n\n\n\n\n#338\n: event bus: automatically remove inspectors on widget destruction\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#308\n: event bus: removed setMediator and setErrorHandler\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\nv2.0.0-alpha.4\n\n\n\n\n\n\n#335\n: widget services: build lazily, allow to decorate\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#334\n: added LaxarJS v1.x compatibility helpers\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#331\n: widget services: added axAreaHelper service\n\n\n\n\n#306\n: log: added as property to widget context object\n\n\n#326\n: documentation: added manual for injectable widget services\n\n\n\n\n#321\n: simplified file listings API and file resource provider\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#328\n: allow to configure if and how the instanceId is generated\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#327\n: EventBus: simplified internal API\n\n\n\n\n\n\n#329\n: made any access to laxarInstances go through a laxar API\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#273\n: removed asset-loading compatibility code for pre-1.0 widgets\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#310\n: services: adjusted set of services available to application artifacts\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#325\n: project: improved browser-spec reporting\n\n\n\n\n#324\n: project: es2015 object-rest/spread, array.includes\n\n\n\n\n#318\n: logging: improved source location reporting\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#316\n: fn: removed\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#319\n: storage: simplified prefix generation\n\n\n\n\n\n\n#305\n: widget-areas: no longer generate first/last classes\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#320\n: use shared eslint configuration\n\n\n\n\n#315\n: added and applied some more complex eslint rules\n\n\n#302\n: added and applied comprehensive eslint rules\n\n\n\n\nv2.0.0-alpha.3\n\n\n\n\n#314\n: re-enabled junit reporting and firefox/chrome tests\n\n\n#313\n: added i18n mock\n\n\n\n\nv2.0.0-alpha.2\n\n\n\n\n#311\n: moved webpack-jasmine-html-runner-plugin to its own project\n\n\n#312\n: provide required polyfills as bundle\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv2.0.0-alpha.1\n\n\n\n\n\n\n#303\n: modules: eliminated all global state\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#298\n: modules: load using webpack\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#299\n: plain widget adapter: fixed injectable service names\n\n\n\n\n#291\n: page loader: merged namespaces for widget- and composition-ids\n\n\n#286\n: flow: fixed flow-validation error message format\n\n\n#277\n: loaders: Fix problem with insertBeforeId in compositions\n\n\n#274\n: loaders: Fix handling of compositions without '.' area\n\n\n#296\n: documentation: fixed string API doc module name\n\n\n#269\n: EventBus: fixed handling of single \ndid\n response after multiple requests with individual \nwill\n responses\n\n\n#293\n: loaders: mention composition name and ID when composition features fail validation\n\n\n\n\n#281\n: bootstrapping: improved state encapsulation for adapters and modules\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#284\n: documentation: fixed broken link\n\n\n\n\n#295\n: documentation: fixed order of preliminary readings\n\n\n\n\n#279\n: bootstrapping: a custom node for the page can now be used\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#264\n: configuration: paths are now configurable via application configuration\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\nv2.0.0-alpha.0\n\n\n\n\n\n\n#272\n: AngularJS: Removed all dependencies and usages in core\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#271\n: page: implemented without AngularJS (not yet in use)\n\n\n\n\n\n\n#267\n: flow: implemented without AngularJS (not yet in use)\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#262\n: services: extracted stateful services\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#265\n: visibility service: moved from core to angular adapter\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#263\n: modules: made all modules stateless\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#261\n: profiling: moved from core to angular adapter\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#258\n: directives: moved from core to angular adapter\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#259\n: AngularJS: implemented widget area collector without angular\n\n\n\n\n\n\n#257\n: AngularJS: moved widget adapter to its own repository\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#256\n: using locally installed jspm\n\n\n\n\n#254\n: documentation: improved and updated manuals\n\n\n#250\n: testing: updated spec runners to Jasmine 2.4\n\n\n#246\n: transformed AMD modules to es2015 modules\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv1.2.0\n\n\n\n\n#249\n: project: updated copyright year in file header\n\n\n\n\n#248\n: tooling: added compositions to page inspection API\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#247\n: tooling: added page inspection API\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#244\n: documentation: added extensive documentation on visibility events\n\n\n\n\n\n\nv1.2.0-alpha.1\n\n\n\n\n#243\n: fn: fixed invalid setTimeout application\n\n\n\n\nv1.2.0-alpha.0\n\n\n\n\n\n\n#242\n: tooling: added \nprovideQ\n factory\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#241\n: fn: allow to cancel debounced functions\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#240\n: documentation: fixed prerequisites (yeoman, not grunt-init)\n\n\n\n\n\n\nv1.1.0\n\n\nv1.1.0-beta.1\n\n\n\n\n#238\n: testing: fixed initialization of \naxControls\n mock\n\n\n\n\nv1.1.0-beta.0\n\n\n\n\n#210\n: runtime: added \naxControls\n service so that controls can be instantiated in any integration technology\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.1.0-alpha.9\n\n\n\n\n#237\n: runtime: defer page-controller injections until controller instantiation\n\n\n\n\nv1.1.0-alpha.8\n\n\n\n\n#236\n: loaders: fixed typo which prevented default theme from loading (debug mode)\n\n\n\n\nv1.1.0-alpha.7\n\n\n\n\n#235\n: loaders: to find CSS in theme, first try the descriptor name\n\n\n\n\nv1.1.0-alpha.6\n\n\n\n\n#234\n: testing: do not query widget CSS/HTML assets\n\n\n\n\nv1.1.0-alpha.5\n\n\n\n\n#233\n: loaders: fixed widget theme lookup\n\n\n#232\n: documentation: explain Bower-based widget installation\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.1.0-alpha.4\n\n\n\n\n\n\n#195\n: documentation: added manual on the FileResourceProvider\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#230\n: documentation: fixed example in \nWidgets and Activities\n manual\n\n\n\n\n#223\n: documentation: explain tooling with the new grunt tasks\n\n\n#228\n: documentation: documented writing widget controller for specific technologies\n\n\n#229\n: adapters: added axFeatures as injection for angular widgets\n\n\n#221\n: adapters: made all relevant services available to plain widgets\n\n\n\n\nv1.1.0-alpha.3\n\n\n\n\n#227\n: testing: fixed widget descriptor lookup so that it is independent of the widget location\n\n\n#225\n: loaders: prefer widget specification name over directory name if possible\n\n\n#226\n: angular: normalized widget module lookup so that widget.json can use dash-separated-names\n\n\n\n\n#129\n: integration: implemented using widgets installed via bower as amd module\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#222\n: require_config: added documentation for widget / control specific configuration\n\n\n\n\n#215\n: testing: updated documentation regarding widget tests\n\n\n#220\n: fixed off-by-one bug in HTML spec-runners\n\n\n#78\n: tests: allow to execute spec-tests using a project RequireJS configuration\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.1.0-alpha.2\n\n\n\n\n\n\n#219\n: added Travis-CI build integration\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#213\n: documentation: fixed widget installation manual\n\n\n\n\n#214\n: axHeartBeat: using applyViewChanges via page controller\n\n\n\n\nv1.1.0-alpha.1\n\n\n\n\n#193\n: loaders: implemented nesting of layouts within areas directly in a page\n\n\n\n\nv1.1.0-alpha.0\n\n\n\n\n#127\n: testing: made necessary changes for new, distinct testing framework\n\n\n\n\n#211\n: project: state compatibility with AngularJS 1.4.x\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#212\n: documentation: added basic manual on installing controls\n\n\n\n\n#150\n: documentation: added contributor guide\n\n\n#209\n: api-doc: update generated api doc\n\n\n#208\n: configuration: applied default for \ni18n.locales\n when setting \n$rootScope.i18n.tags\n\n\n\n\nv1.0.0\n\n\n\n\n#205\n: documentation: updated README.md according to latest template version\n\n\n\n\nv1.0.0-beta.1\n\n\n\n\n#207\n: documentation: adapted to changed naming\n\n\n#206\n: runtime: fixed problem with possible duplicate flow-controller\n\n\n#203\n: documentation: updated manual on controls to cover the new descriptor\n\n\n\n\nv1.0.0-beta.0\n\n\n\n\n#132\n: documentation: provided updated API doc for relevant modules\n\n\n\n\nv1.0.0-alpha.15\n\n\n\n\n#202\n: themes: made path to the default theme configurable\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv1.0.0-alpha.14\n\n\n\n\n#201\n: testing: fix loading of old-style controls\n\n\n\n\nv1.0.0-alpha.13\n\n\n\n\n#200\n: loaders, testing: fix loading of controls that are configured as commonjs packages in RequireJS\n\n\n\n\nv1.0.0-alpha.12\n\n\n\n\n#199\n: project: removed unnecessary dependencies, simplified Bower references\n\n\n#197\n: loaders: read control name from control.json descriptor if present\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.0.0-alpha.11\n\n\n\n\n#198\n: project: prepared \nlaxar\n npm package\n\n\n\n\nv1.0.0-alpha.10\n\n\n\n\n#196\n: runtime: fixed default theme loading\n\n\n\n\nv1.0.0-alpha.9\n\n\n\n\n\n\n#183\n: runtime, file_resource_provider: allow to load file listings directly from configuration\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#186\n: loaders: allow to load layouts from theme\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#192\n: loaders: removed duplicate code for defaults application\n\n\n\n\n\n\nv1.0.0-alpha.8\n\n\n\n\n#189\n: loaders: fixed inferring top-level widget configuration defaults for JSON schema v4\n\n\n#188\n: configuration: moved configuration module to utilities\n\n\n\n\n#187\n: storage: use per-app unique storage prefixes\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#184\n: documentation: fixed logging configuration documentation\n\n\n\n\n#185\n: logging: configuration value not applied correctly\n\n\n\n\n#128\n: logging, utilities: simplified and removed some APIs\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#159\n: flow: removed support for triggerBrowserReload.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#182\n: runtime: removed live theme switching\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#180\n: directives: removed \naxPageFade\n directive\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\nv1.0.0-alpha.7\n\n\n\n\n#179\n: loaders: fixed loading of CSS for controls\n\n\n#154\n: widget_adapters: added deprecation warning for old-style widget modules\n\n\n\n\n#177\n: runtime: renamed configuration options\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#171\n: documentation: added manual on widget adapters\n\n\n\n\n#178\n: runtime: renamed AngularJS modules to match AMD modules\n\n\n#176\n: documentation: replaced the widget category \nportal\n with \nlaxarjs\n\n\n\n\n#175\n: loaders: changed generated DOM- and topic-IDs to be more compact\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#174\n: widget_adapters: simplified widget adapter API\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\nv1.0.0-alpha.6\n\n\n\n\n#173\n: testing: fixed a bug when configuring the widget under test.\n\n\n\n\n#167\n: widget_adapters: added injectable axContext as alternative to AngularJS scopes.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#170\n: loaders: refactored widget loader and widget adapters.\n\n\n\n\n#168\n: documentation: added basic documentation on coding style\n\n\n#136\n: storage: removed \nwindow.name\n-shim for session-storage\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv1.0.0-alpha.5\n\n\n\n\n#130\n: portal: refactored portal artifacts to runtime and loaders.\n\n\n\n\nv1.0.0-alpha.4\n\n\n\n\n#164\n: updated bower dependencies jjv and jjve to latest versions.\n\n\n#71\n: angular_adapter: widget and activity scopes are now created on demand.\n\n\n\n\nv1.0.0-alpha.3\n\n\n\n\n\n\n#165\n: i18n: changed localizer.format signature to match string.format\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#161\n: portal: removed memory leak fix for msie8\n\n\n\n\n\n\nv1.0.0-alpha.2\n\n\n\n\n\n\n#158\n: changed AngularJS support to version 1.3.15.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#147\n: footprint: made jquery from a dependency into a dev-dependency\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#162\n: documentation: fixed theme manual after shop-demo update\n\n\n\n\n\n\nv1.0.0-alpha.1\n\n\n\n\n\n\n#160\n: refactoring: normalized AngularJS artifact names\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#149\n: testing: always use \nwidget.json\n for widget spec tests\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#139\n: loader: removed widget compatibility warning for now\n\n\n\n\n#124\n: implemented an adapter for plain JavaScript widgets.\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv1.0.0-alpha.0\n\n\n\n\n\n\n#103\n: portal: removed json patch compatibility layer.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#117\n: portal: implemented a flow service that provides place urls usable as hyperlinks.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#35\n: Upgraded internal JSON schemas to draft v4.\n\n\n\n\n\n\n#116\n: performance: the flow is now loaded through the file resource provider\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#99\n: exit points are now configured as \nexitPoint\n in flow.json.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#72\n: configuration: removed deprecated configuration paths.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#88\n: footprint: removed \nunderscore\n dependency\n\n\n\n\n\n\n#70\n: footprint: removed \nlaxar.text\n API (use \nlaxar.string.format\n instead)\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#92\n: removed obsolete mixins in favor of compositions.\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\n\n\n#181\n: runtime: added missing default for the configuration key \ni18n.locales\n\n\n\n\n\n\nv0.26.0\n\n\n\n\n#169\n: widget_adapters: fixed plain-adapter to use new-style widget module names\n\n\n#172\n: documentation: fixed dead link\n\n\n#166\n: cleanup: removed distribution-related configuration and files\n\n\n#163\n: EventBus: fixed request topic matching\n\n\n\n\nv0.25.0\n\n\n\n\n#156\n: i18n: by default, use relaxed matching for language tags\n\n\n\n\nv0.24.0\n\n\n\n\n#157\n: portal: angular-adapter: fixed error reporting\n\n\n#145\n: testing: added missing cancel-method to mock-$timeout\n\n\n#155\n: visibility: page controller now unsubscribes on tear-down\n\n\n#152\n: documentation: added widget installation manual\n        + NEW FEATURE: see ticket for details\n\n\n\n\nv0.23.0\n\n\n\n\n\n\n#153\n: portal: angular-adapter: simplified widget and controller naming\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#151\n: EventBus: fixed cycle count for zero subscribers\n\n\n\n\n#148\n: documentation: more detailed information on the event bus, link to api doc\n\n\n\n\nv0.22.0\n\n\n\n\n#146\n: documentation: improved the prerequisites in the \nREADME.md\n and writing style\n\n\n#143\n: documentation: fixed testing configuration example (\nandCallFake\n, not \nandCallThrough\n)\n\n\n#142\n: documentation: fixed task alias for development server (\nstart\n, not \ndevelop\n)\n\n\n#144\n: EventBus: reject publishAndGatherReplies-promise after timeout\n        + \nBREAKING CHANGE:\n see ticket for details\n\n\n\n\nv0.21.0\n\n\n\n\n#137\n: flow: warn on empty place\n\n\n#140\n: EventBus: make timeout configurable\n\n\n#126\n: testing: \naxEventBus\n injection available to widget controllers during testing\n\n\n\n\nv0.20.0\n\n\n\n\n\n\n#138\n: logging: the instance id is now generated by the log context and transmitted using an $http interceptor\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#134\n: storage: fixed storage in iOS Safari private browsing\n\n\n\n\n\n\nv0.19.0\n\n\n\n\n\n\n#125\n: axLayout: emit AngularJS event when loaded\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#113\n: documentation: manual on tools\n\n\n\n\n\n\n#122\n: testing: allow to inject dependencies\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#123\n: portal: preload widget assets on page load\n\n\n\n\n#117\n: portal: implemented a flow service that provides place urls usable as hyperlinks.\n\n\n#121\n: documentation: have README.md next steps point to manuals\n\n\n#118\n: performance: removed $timeout from axPageFade\n\n\n#120\n: portal: fixed flaky timestamp test\n\n\n#119\n: portal: fixed race condition in page loader\n\n\n\n\nv0.18.0\n\n\n\n\n#97\n: documentation: manual on themes\n\n\n#112\n: documentation: removed colloquial style\n\n\n\n\nv0.17.0\n\n\n\n\n#108\n: documentation: unify code-snippet format, and some polish\n\n\n#109\n: documentation: added manual on providing controls\n\n\n#107\n: angular widget adapter: added widget specific event bus service.\n\n\n#106\n: documentation: fixed manuals, improved introduction in README.md\n\n\n#93\n: refactoring: extracted page related services into own files.\n\n\n#98\n: documentation: added manual on events and pub/sub\n\n\n#100\n: widget loader: added angular widget as default integration.\n\n\n#105\n: moved resumable timer handling from flow to timer.\n\n\n#104\n: configuration: deprecated configuration keys are no handled at one place.\n\n\n#101\n: documentation: use \"\u00ab\" rather than \"\n\" for backwards navigation links\n\n\n#76\n: documentation: widgets and activities\n\n\n#75\n: documentation: flow and places.\n\n\n#96\n: documentation: restructured existing documents and added stubs for missing ones.\n\n\n#95\n: documentation: wrote a motivational article for LaxarJS.\n\n\n#94\n: footprint: removed the outdated app stub in favor of grunt-init (see README.md)\n\n\n#38\n: documentation: pages and compositions.\n\n\n#91\n: portal: make sure that widget DOM is attached when linking\n\n\n\n\n#90\n: documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#89\n: documentation: primary concepts of LaxarJS\n\n\n\n\n#84\n: storage: storing \nundefined\n now causes the entry to be removed\n\n\n\n\nv0.16.0\n\n\n\n\n#87\n: portal: Ensure anonymization of logged events.\n\n\n#86\n: logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.\n\n\n\n\n#85\n: utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#83\n: portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#81\n: added check for duplicate area definitions in layouts\n\n\n\n\n\n\nv0.15.0\n\n\n\n\n\n\n#82\n: implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#80\n: storage: Improved detection of WebStorage API for Internet Explorer\n\n\n\n\n#79\n: assert: details given as object are now serialized\n\n\n#77\n: flow: the log tag \nPLCE\n with the current place name is set after navigation\n\n\n\n\nv0.14.0\n\n\n\n\n#73\n: portal: fixed lookup of merged CSS file\n\n\n#69\n: portal: moved setting widget root element IDs to widget loader\n\n\n#68\n: fixed wrongly global assert in jshintrc.\n\n\n#67\n: re-added missing widget root element IDs.\n\n\n#65\n: fixed navigation being broken when parameter values were missing.\n\n\n#66\n: prevented endless navigation ping pong in flow controller\n\n\n#63\n: axVisibilityService: use scope.$id to identify handlers, not scope.id\n\n\n#62\n: fixed endless recursion on navigation when place and target have the same name.\n\n\n\n\nv0.13.0\n\n\n\n\n\n\n#61\n: added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#60\n: tests: make sure PhantomJS is installed properly, before running spec tests.\n\n\n\n\n\n\n#52\n: portal, testing: added visibility events and the \naxVisibilityService\n\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#59\n: portal: fixed dangling comma in timer imports\n\n\n\n\n#58\n: portal, json: fixed copyright headers\n\n\n#57\n: portal: fixed double-navigation problem which can lead to skipping places\n\n\n#56\n: object: removed all direct calls of hasOwnProperty.\n\n\n#55\n: run_spec: disable loading the \nwidget.json\n if the \nspec_runner.js\n contains \nwidgetJson: false\n\n\n#54\n: testing: fixed broken testBed injection of $q and $timeout\n\n\n#50\n: performance: decoupled instantiation of widget controllers from their DOM\n\n\n\n\nv0.12.0\n\n\n\n\n\n\n#49\n: added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#48\n: Promises generated by the event bus are now scheduled by the event bus, not by AngularJS \n$apply\n.\n\n\n\n\n#51\n: Remove some obsolete NPM \ndevDependencies\n.\n\n\n#47\n: Do not schedule another full event-bus tick while one is already being processed.\n\n\n#46\n: fixed misinterpretation of falsy required attribute in json schema converter.\n\n\n#45\n: i18n: adjusted localizer.format specs to changes from \n#43\n.\n\n\n\n\n#43\n: string: added new function \nstring.format\n as simpler replacement for \ntext\n library.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#42\n: portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#40\n: portal: fixed 'flag-topic' pattern.\n\n\n\n\n\n\nv0.11.0\n\n\n\n\n\n\n#39\n: portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#37\n: improved browsing of existing api doc and fixed some syntactical errors.\n\n\n\n\n#36\n: jshintrc: disabled enforcement of dot notation for object property access.\n\n\n\n\n#34\n: Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#33\n: EventBus: added event object to the information sent to inspectors on deliver actions.\n\n\n\n\n\n\n#31\n: Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#32\n: Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#30\n: PageLoader: added missing check for duplicate composition ids.\n\n\n\n\n\n\nv0.10.0\n\n\n\n\n#27\n: Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick\n\n\n#28\n: Fixed null values in widget features within compositions being turned into empty objects.\n\n\n#29\n: PageLoader: composition features that are not configured do not result in undefined values for widget features.\n\n\n#25\n: Only the page relevant for the current place is loaded now.\n\n\n\n\n#17\n: Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#26\n: Testing: Fixed the responseTransform option for http-mock\n\n\n\n\n\n\n#22\n: FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#15\n: FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings\n\n\n\n\n\n\n#24\n: Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details\n\n\n\n\n\n\n#23\n: FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.\n\n\n\n\n#21\n: The file resource provider now normalizes its root path.\n\n\n#20\n: Fixed event bus inspectors not being notified on unsubscription.\n\n\n#14\n: Fixed navigation being broken after successive navigation to the current location.\n\n\n#13\n: The current place is now send as part of the didNavigate event.\n\n\n#12\n: Testing: Get the LaxarJS tests running in Karma again.\n\n\n#11\n: Testing: Handle \nspec_runner.js\n that are not in a subdirectory of the RequireJS' \nbaseUrl\n.\n\n\n#10\n: Testing: Loading controls during tests now works in Karma.\n\n\n#9\n: Update Bower from ~1.2.8 to ~1.3.3.\n\n\n#8\n: Fixed the cleanup mechanism for generated widget areas.\n\n\n#6\n: The Portal now initializes an i18n object on the application's \n$rootScope\n\n\n#5\n: Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json\n\n\n#4\n: PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys\n\n\n#3\n: Added url formatting for links in Readme.md\n\n\n#2\n: Fixed grunt-init step in Getting-Started docs\n\n\n#1\n: Added initial Getting-Started documentation", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/CHANGELOG/#last-changes", 
            "text": "", 
            "title": "Last Changes"
        }, 
        {
            "location": "/CHANGELOG/#v202", 
            "text": "#469 : flow: fixed  constructAbsoluteUrl  to not lose active place parameters", 
            "title": "v2.0.2"
        }, 
        {
            "location": "/CHANGELOG/#v201", 
            "text": "#472 : bootstrapping: fixed a race condition that sometimes caused initialization to get stuck indefinitely  #471 : documentation: fixed outdated things in widgets and activities manual", 
            "title": "v2.0.1"
        }, 
        {
            "location": "/CHANGELOG/#v200", 
            "text": "", 
            "title": "v2.0.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc4", 
            "text": "#467 : documentation: mention ngSanitize removal in upgrade guide  #466 : documentation: fixed list formatting, added more links to angular adapter manual  #468 : flow: fixed querystring in empty hash based url not working   #461 : runtime: added  ax  prefix to auto-generated areas:  axActivities ,  axPopovers ,  axPopups \n        +  BREAKING CHANGE:  see ticket for details    #464 : flow: support fragments for routing and for navigation events", 
            "title": "v2.0.0-rc.4"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc3", 
            "text": "#465 : fixed dependencies in package.json  #460 : documentation: fixed broken link", 
            "title": "v2.0.0-rc.3"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc2", 
            "text": "#459 : documentation: fixed broken links  #458 : documentation: fixed broken link", 
            "title": "v2.0.0-rc.2"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc1", 
            "text": "#457 : dropped minified targets, using laxar-infrastructure\n        +  BREAKING CHANGE:  see ticket for details    #456 : tooling: gracefully handle missing debugInfo when providing  axTooling  injection", 
            "title": "v2.0.0-rc.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-rc0", 
            "text": "#455 : documentation: improved getting-started docs, added project-from-scratch instructions", 
            "title": "v2.0.0-rc.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-beta0", 
            "text": "#454 : documentation: fixed markdown list problems  #453 : documentation: explain that descriptors are mandatory for all themable artifacts  #451 : documentation: fixed broken link", 
            "title": "v2.0.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha24", 
            "text": "#452 : fix configuration  name  not being treated as optional  #449 : documentation fixes", 
            "title": "v2.0.0-alpha.24"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha23", 
            "text": "#450 : removed configuration option  tooling.enabled  #445 : log: the  console  log channel now uses standard console formatting specifiers   #403 : tooling: added external API originally added in LaxarJS 1.3 (#303)\n        +  BREAKING CHANGE:  see ticket for details    #404 : documentation: the  axTooling  API is now documented", 
            "title": "v2.0.0-alpha.23"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha22", 
            "text": "#447 : testing: made createAxI18nMock friendly to standalone usage\n        +  BREAKING CHANGE:  see ticket for details    #443 : testing: initialize eventBusMock with noisy error log   #448 : documentation: fixed markdown indent in API index", 
            "title": "v2.0.0-alpha.22"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha21", 
            "text": "#446 : documentation: transformed code examples to ES2015  #418 : documentation: various API doc fixes, added index.md  #438 : log: improved visibility of  log.fatal  #444 : navigo router: fixed use of fallbackHandler (404)", 
            "title": "v2.0.0-alpha.21"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha20", 
            "text": "#440 : navigo router: fixed creation of absolute URLs with hash", 
            "title": "v2.0.0-alpha.20"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha19", 
            "text": "#437 : bootstrapping: new  create().flow().bootstrap()  workflow\n        +  BREAKING CHANGE:  see ticket for details    #436 : testing: auto-spy unsubscribe-callback of  eventBus.subscribe \n        + NEW FEATURE: see ticket for details    #435 : navigo: updated to current version with configurable hash string\n        + NEW FEATURE: see ticket for details    #348 : documentation: added manual on the  plain  adapter   #420 : documentation: added upgrade guide  #434 : areaHelper: keep  data-ax-widget-area  attribute  #433 : documentation: updated manuals for LaxarJS v2   #432 : router: replaced page.js with Navigo\n        +  BREAKING CHANGE:  see ticket for details    #385 : removed CSS loader\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.19"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha18", 
            "text": "#419 : updated contributor information  #431 : testing: added  eventBusMock.drainAsync() \n        + NEW FEATURE: see ticket for details", 
            "title": "v2.0.0-alpha.18"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha17", 
            "text": "#429 : i18n: allow instantiating widget service without i18n feature config\n        + NEW FEATURE: see ticket for details    #408 : area helper: improved error logging when calling domAttachTo    #417 : flow: added redirects to paths with parameter values included\n        + NEW FEATURE: see ticket for details    #430 : page.js: fixed hashbang navigation for bases being prefix of a path   #428 : widget service mocks: provide context to area helper in axVisibilityMock  #427 : project: revert #425", 
            "title": "v2.0.0-alpha.17"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha16", 
            "text": "#423 : project: fix building LaxarJS when somewhere inside a  node_modules  directory  #425 : project: add browser mappings for other entry points to  package.json  #426 : project: don't use library name  laxar  for polyfills and widget service mocks entry points", 
            "title": "v2.0.0-alpha.16"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha15", 
            "text": "#422 : runtime: improved widget services testability\n        + NEW FEATURE: see ticket for details    #416 : fixed log levels reference in compatibility main file", 
            "title": "v2.0.0-alpha.15"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha14", 
            "text": "#413 : adapters: renamed  onBeforeControllerCreation  hook\n        +  BREAKING CHANGE:  see ticket for details    #415 : project: updated dev-dependencies, upgraded to webpack 2   #414 : areaHelperMock: added missing spies to localName and fullName methods", 
            "title": "v2.0.0-alpha.14"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha13", 
            "text": "#411 : simplified visibility checking\n        +  BREAKING CHANGE:  see ticket for details    #412 : temporarily re-added widget loader to services", 
            "title": "v2.0.0-alpha.13"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha12", 
            "text": "#398 : removed page service from widget adapter services\n        +  BREAKING CHANGE:  see ticket for details    #397 : moved adapter errors from widgetLoader to new  adapterUtilities  service\n        +  BREAKING CHANGE:  see ticket for details    #394 : fixed broken  axI18n.track() , improved docs and spec coverage", 
            "title": "v2.0.0-alpha.12"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha11", 
            "text": "#380 : removed JSON schema processing from runtime\n        +  BREAKING CHANGE:  see ticket for details    #405 : JSON schemas have been converted back to JSON and updated to include all artifacts\n        +  BREAKING CHANGE:  see ticket for details    #410 : adapters: adapters now get access to the flow-service during bootstrapping   #407 : polyfills: converted to ES2015 and fixed fetch-polyfill path  #406 : fixed typo in comments  #396 : adapters: adapter instances no longer need to have a  technology  property  #276 : added and fixed API docs   #381 : flow: clearly distinguish places from their targets and patterns\n        +  BREAKING CHANGE:  see ticket for details    #402 : project: polyfill  Object.assign    #395 : cleanup: removed  object.extend  and  object.deepFreeze \n        +  BREAKING CHANGE:  see ticket for details    #349 : removed support for MSIE 9\n        +  BREAKING CHANGE:  see ticket for details    #392 : flow: removed  entryPoint  /  exitPoint  feature\n        +  BREAKING CHANGE:  see ticket for details    #390 : adapter API: make  artifactProvider  available to adapters and allow  create()  to be async\n        + NEW FEATURE: see ticket for details", 
            "title": "v2.0.0-alpha.11"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha10", 
            "text": "#389 : flow: normalize generated URLs (no trailing  /_ )\n        +  BREAKING CHANGE:  see ticket for details    #388 : flow: fixed handling of parameter-only places   #386 : flow: double-encode slashes in path segments   #387 : flow: reverted name-change (keep  constructAbsoluteUrl )\n        + NEW FEATURE: see ticket for details    #384 : flow: simplified handling of invalid empty places    #375 : flow: added support for query parameters\n        + NEW FEATURE: see ticket for details    #376 : flow: fixed  constructAbsoluteUrl  (was not absolute)   #371 : flow: fixed URL encoding of place parameter values   #366 : axFlowService: removed  constructAnchor  and  constructPath \n        +  BREAKING CHANGE:  see ticket for details    #369 : documentation: improved docs and specs for object.path/setPath   #323 : documentation: fixed link  #365 : jasmine: set fixed minor version   #364 : axFlowService: widgets can now longer access the flow controller\n        +  BREAKING CHANGE:  see ticket for details    #362 : loaders: support new  styleSource  and  templateSource  in artifact descriptors\n        + NEW FEATURE: see ticket for details    #317 : utilities: removed  path , added  browser.resolve   #357 : runtime: consolidated modules into  lib/runtime  #361 : widget services: re-added  axControls  injection", 
            "title": "v2.0.0-alpha.10"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha9", 
            "text": "#358 : adapter API: simplified further\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.9"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha8", 
            "text": "#360 : routing: use  flow.router.base  instead of  baseHref  config\n        +  BREAKING CHANGE:  see ticket for details    #351 : testing: provided full set of widget service mocks\n        + NEW FEATURE: see ticket for details", 
            "title": "v2.0.0-alpha.8"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha7", 
            "text": "", 
            "title": "v2.0.0-alpha.7"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha6", 
            "text": "#356 : event bus: can be created with a custom error handler\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.6"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha5", 
            "text": "#355 : json validator: moved to utilities   #354 : event bus: removed unsubscribe methods\n        +  BREAKING CHANGE:  see ticket for details    #353 : log: changed level to levels\n        +  BREAKING CHANGE:  see ticket for details    #332 : widget services: added axI18n service\n        + NEW FEATURE: see ticket for details    #344 : widget services: added axAssets service   #345 : added  axConfiguration.ensure , collected configuration defaults in  services  #347 : timer: removed resumedOrStarted and added missing tests   #300 : plain widget adapter: added axWithDom service and renamed DOM ready hook\n        +  BREAKING CHANGE:  see ticket for details    #309 : runtime: slightly simplified area helper    #333 : added  axVisibility  injection to replace the visibility helper of patterns\n        + NEW FEATURE: see ticket for details    #346 : testing: added spec-tests for the various mocks    #304 : loaders: replaced dynamic artifact resolution with prebuilt artifacts listing\n        +  BREAKING CHANGE:  see ticket for details    #270 : json validator: simplified return value    #307 : flow: improved page.js integration\n        + NEW FEATURE: see ticket for details\n        +  BREAKING CHANGE:  see ticket for details    #337 : widget adapters: removed applyViewChanges from widget adapter api\n        +  BREAKING CHANGE:  see ticket for details    #340 : heartbeat: call listeners asynchronously so that event bus promises have already been processed   #339 : event bus: return unsubscribe function on subscription   #338 : event bus: automatically remove inspectors on widget destruction\n        +  BREAKING CHANGE:  see ticket for details    #308 : event bus: removed setMediator and setErrorHandler\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.5"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha4", 
            "text": "#335 : widget services: build lazily, allow to decorate\n        + NEW FEATURE: see ticket for details    #334 : added LaxarJS v1.x compatibility helpers\n        + NEW FEATURE: see ticket for details    #331 : widget services: added axAreaHelper service   #306 : log: added as property to widget context object  #326 : documentation: added manual for injectable widget services   #321 : simplified file listings API and file resource provider\n        +  BREAKING CHANGE:  see ticket for details    #328 : allow to configure if and how the instanceId is generated\n        + NEW FEATURE: see ticket for details    #327 : EventBus: simplified internal API    #329 : made any access to laxarInstances go through a laxar API\n        + NEW FEATURE: see ticket for details    #273 : removed asset-loading compatibility code for pre-1.0 widgets\n        +  BREAKING CHANGE:  see ticket for details    #310 : services: adjusted set of services available to application artifacts\n        +  BREAKING CHANGE:  see ticket for details    #325 : project: improved browser-spec reporting   #324 : project: es2015 object-rest/spread, array.includes   #318 : logging: improved source location reporting\n        + NEW FEATURE: see ticket for details    #316 : fn: removed\n        +  BREAKING CHANGE:  see ticket for details    #319 : storage: simplified prefix generation    #305 : widget-areas: no longer generate first/last classes\n        +  BREAKING CHANGE:  see ticket for details    #320 : use shared eslint configuration   #315 : added and applied some more complex eslint rules  #302 : added and applied comprehensive eslint rules", 
            "title": "v2.0.0-alpha.4"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha3", 
            "text": "#314 : re-enabled junit reporting and firefox/chrome tests  #313 : added i18n mock", 
            "title": "v2.0.0-alpha.3"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha2", 
            "text": "#311 : moved webpack-jasmine-html-runner-plugin to its own project  #312 : provide required polyfills as bundle\n        + NEW FEATURE: see ticket for details", 
            "title": "v2.0.0-alpha.2"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha1", 
            "text": "#303 : modules: eliminated all global state\n        +  BREAKING CHANGE:  see ticket for details    #298 : modules: load using webpack\n        +  BREAKING CHANGE:  see ticket for details    #299 : plain widget adapter: fixed injectable service names   #291 : page loader: merged namespaces for widget- and composition-ids  #286 : flow: fixed flow-validation error message format  #277 : loaders: Fix problem with insertBeforeId in compositions  #274 : loaders: Fix handling of compositions without '.' area  #296 : documentation: fixed string API doc module name  #269 : EventBus: fixed handling of single  did  response after multiple requests with individual  will  responses  #293 : loaders: mention composition name and ID when composition features fail validation   #281 : bootstrapping: improved state encapsulation for adapters and modules\n        +  BREAKING CHANGE:  see ticket for details    #284 : documentation: fixed broken link   #295 : documentation: fixed order of preliminary readings   #279 : bootstrapping: a custom node for the page can now be used\n        +  BREAKING CHANGE:  see ticket for details    #264 : configuration: paths are now configurable via application configuration\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v200-alpha0", 
            "text": "#272 : AngularJS: Removed all dependencies and usages in core\n        +  BREAKING CHANGE:  see ticket for details    #271 : page: implemented without AngularJS (not yet in use)    #267 : flow: implemented without AngularJS (not yet in use)\n        +  BREAKING CHANGE:  see ticket for details    #262 : services: extracted stateful services\n        +  BREAKING CHANGE:  see ticket for details    #265 : visibility service: moved from core to angular adapter\n        +  BREAKING CHANGE:  see ticket for details    #263 : modules: made all modules stateless\n        +  BREAKING CHANGE:  see ticket for details    #261 : profiling: moved from core to angular adapter\n        +  BREAKING CHANGE:  see ticket for details    #258 : directives: moved from core to angular adapter\n        +  BREAKING CHANGE:  see ticket for details    #259 : AngularJS: implemented widget area collector without angular    #257 : AngularJS: moved widget adapter to its own repository\n        +  BREAKING CHANGE:  see ticket for details    #256 : using locally installed jspm   #254 : documentation: improved and updated manuals  #250 : testing: updated spec runners to Jasmine 2.4  #246 : transformed AMD modules to es2015 modules\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v2.0.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v120", 
            "text": "#249 : project: updated copyright year in file header   #248 : tooling: added compositions to page inspection API\n        + NEW FEATURE: see ticket for details    #247 : tooling: added page inspection API\n        + NEW FEATURE: see ticket for details    #244 : documentation: added extensive documentation on visibility events", 
            "title": "v1.2.0"
        }, 
        {
            "location": "/CHANGELOG/#v120-alpha1", 
            "text": "#243 : fn: fixed invalid setTimeout application", 
            "title": "v1.2.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v120-alpha0", 
            "text": "#242 : tooling: added  provideQ  factory\n        + NEW FEATURE: see ticket for details    #241 : fn: allow to cancel debounced functions\n        + NEW FEATURE: see ticket for details    #240 : documentation: fixed prerequisites (yeoman, not grunt-init)", 
            "title": "v1.2.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v110", 
            "text": "", 
            "title": "v1.1.0"
        }, 
        {
            "location": "/CHANGELOG/#v110-beta1", 
            "text": "#238 : testing: fixed initialization of  axControls  mock", 
            "title": "v1.1.0-beta.1"
        }, 
        {
            "location": "/CHANGELOG/#v110-beta0", 
            "text": "#210 : runtime: added  axControls  service so that controls can be instantiated in any integration technology\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.1.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha9", 
            "text": "#237 : runtime: defer page-controller injections until controller instantiation", 
            "title": "v1.1.0-alpha.9"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha8", 
            "text": "#236 : loaders: fixed typo which prevented default theme from loading (debug mode)", 
            "title": "v1.1.0-alpha.8"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha7", 
            "text": "#235 : loaders: to find CSS in theme, first try the descriptor name", 
            "title": "v1.1.0-alpha.7"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha6", 
            "text": "#234 : testing: do not query widget CSS/HTML assets", 
            "title": "v1.1.0-alpha.6"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha5", 
            "text": "#233 : loaders: fixed widget theme lookup  #232 : documentation: explain Bower-based widget installation\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.1.0-alpha.5"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha4", 
            "text": "#195 : documentation: added manual on the FileResourceProvider\n        + NEW FEATURE: see ticket for details    #230 : documentation: fixed example in  Widgets and Activities  manual   #223 : documentation: explain tooling with the new grunt tasks  #228 : documentation: documented writing widget controller for specific technologies  #229 : adapters: added axFeatures as injection for angular widgets  #221 : adapters: made all relevant services available to plain widgets", 
            "title": "v1.1.0-alpha.4"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha3", 
            "text": "#227 : testing: fixed widget descriptor lookup so that it is independent of the widget location  #225 : loaders: prefer widget specification name over directory name if possible  #226 : angular: normalized widget module lookup so that widget.json can use dash-separated-names   #129 : integration: implemented using widgets installed via bower as amd module\n        + NEW FEATURE: see ticket for details    #222 : require_config: added documentation for widget / control specific configuration   #215 : testing: updated documentation regarding widget tests  #220 : fixed off-by-one bug in HTML spec-runners  #78 : tests: allow to execute spec-tests using a project RequireJS configuration\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.1.0-alpha.3"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha2", 
            "text": "#219 : added Travis-CI build integration\n        + NEW FEATURE: see ticket for details    #213 : documentation: fixed widget installation manual   #214 : axHeartBeat: using applyViewChanges via page controller", 
            "title": "v1.1.0-alpha.2"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha1", 
            "text": "#193 : loaders: implemented nesting of layouts within areas directly in a page", 
            "title": "v1.1.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v110-alpha0", 
            "text": "#127 : testing: made necessary changes for new, distinct testing framework   #211 : project: state compatibility with AngularJS 1.4.x\n        + NEW FEATURE: see ticket for details    #212 : documentation: added basic manual on installing controls   #150 : documentation: added contributor guide  #209 : api-doc: update generated api doc  #208 : configuration: applied default for  i18n.locales  when setting  $rootScope.i18n.tags", 
            "title": "v1.1.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v100", 
            "text": "#205 : documentation: updated README.md according to latest template version", 
            "title": "v1.0.0"
        }, 
        {
            "location": "/CHANGELOG/#v100-beta1", 
            "text": "#207 : documentation: adapted to changed naming  #206 : runtime: fixed problem with possible duplicate flow-controller  #203 : documentation: updated manual on controls to cover the new descriptor", 
            "title": "v1.0.0-beta.1"
        }, 
        {
            "location": "/CHANGELOG/#v100-beta0", 
            "text": "#132 : documentation: provided updated API doc for relevant modules", 
            "title": "v1.0.0-beta.0"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha15", 
            "text": "#202 : themes: made path to the default theme configurable\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v1.0.0-alpha.15"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha14", 
            "text": "#201 : testing: fix loading of old-style controls", 
            "title": "v1.0.0-alpha.14"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha13", 
            "text": "#200 : loaders, testing: fix loading of controls that are configured as commonjs packages in RequireJS", 
            "title": "v1.0.0-alpha.13"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha12", 
            "text": "#199 : project: removed unnecessary dependencies, simplified Bower references  #197 : loaders: read control name from control.json descriptor if present\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.0.0-alpha.12"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha11", 
            "text": "#198 : project: prepared  laxar  npm package", 
            "title": "v1.0.0-alpha.11"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha10", 
            "text": "#196 : runtime: fixed default theme loading", 
            "title": "v1.0.0-alpha.10"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha9", 
            "text": "#183 : runtime, file_resource_provider: allow to load file listings directly from configuration\n        + NEW FEATURE: see ticket for details    #186 : loaders: allow to load layouts from theme\n        + NEW FEATURE: see ticket for details    #192 : loaders: removed duplicate code for defaults application", 
            "title": "v1.0.0-alpha.9"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha8", 
            "text": "#189 : loaders: fixed inferring top-level widget configuration defaults for JSON schema v4  #188 : configuration: moved configuration module to utilities   #187 : storage: use per-app unique storage prefixes\n        + NEW FEATURE: see ticket for details    #184 : documentation: fixed logging configuration documentation   #185 : logging: configuration value not applied correctly   #128 : logging, utilities: simplified and removed some APIs\n        +  BREAKING CHANGE:  see ticket for details    #159 : flow: removed support for triggerBrowserReload.\n        +  BREAKING CHANGE:  see ticket for details    #182 : runtime: removed live theme switching\n        +  BREAKING CHANGE:  see ticket for details    #180 : directives: removed  axPageFade  directive\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v1.0.0-alpha.8"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha7", 
            "text": "#179 : loaders: fixed loading of CSS for controls  #154 : widget_adapters: added deprecation warning for old-style widget modules   #177 : runtime: renamed configuration options\n        + NEW FEATURE: see ticket for details    #171 : documentation: added manual on widget adapters   #178 : runtime: renamed AngularJS modules to match AMD modules  #176 : documentation: replaced the widget category  portal  with  laxarjs   #175 : loaders: changed generated DOM- and topic-IDs to be more compact\n        +  BREAKING CHANGE:  see ticket for details    #174 : widget_adapters: simplified widget adapter API\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.0.0-alpha.7"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha6", 
            "text": "#173 : testing: fixed a bug when configuring the widget under test.   #167 : widget_adapters: added injectable axContext as alternative to AngularJS scopes.\n        + NEW FEATURE: see ticket for details    #170 : loaders: refactored widget loader and widget adapters.   #168 : documentation: added basic documentation on coding style  #136 : storage: removed  window.name -shim for session-storage\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v1.0.0-alpha.6"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha5", 
            "text": "#130 : portal: refactored portal artifacts to runtime and loaders.", 
            "title": "v1.0.0-alpha.5"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha4", 
            "text": "#164 : updated bower dependencies jjv and jjve to latest versions.  #71 : angular_adapter: widget and activity scopes are now created on demand.", 
            "title": "v1.0.0-alpha.4"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha3", 
            "text": "#165 : i18n: changed localizer.format signature to match string.format\n        +  BREAKING CHANGE:  see ticket for details    #161 : portal: removed memory leak fix for msie8", 
            "title": "v1.0.0-alpha.3"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha2", 
            "text": "#158 : changed AngularJS support to version 1.3.15.\n        +  BREAKING CHANGE:  see ticket for details    #147 : footprint: made jquery from a dependency into a dev-dependency\n        + NEW FEATURE: see ticket for details    #162 : documentation: fixed theme manual after shop-demo update", 
            "title": "v1.0.0-alpha.2"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha1", 
            "text": "#160 : refactoring: normalized AngularJS artifact names\n        +  BREAKING CHANGE:  see ticket for details    #149 : testing: always use  widget.json  for widget spec tests\n        +  BREAKING CHANGE:  see ticket for details    #139 : loader: removed widget compatibility warning for now   #124 : implemented an adapter for plain JavaScript widgets.\n        + NEW FEATURE: see ticket for details", 
            "title": "v1.0.0-alpha.1"
        }, 
        {
            "location": "/CHANGELOG/#v100-alpha0", 
            "text": "#103 : portal: removed json patch compatibility layer.\n        +  BREAKING CHANGE:  see ticket for details    #117 : portal: implemented a flow service that provides place urls usable as hyperlinks.\n        +  BREAKING CHANGE:  see ticket for details    #35 : Upgraded internal JSON schemas to draft v4.    #116 : performance: the flow is now loaded through the file resource provider\n        +  BREAKING CHANGE:  see ticket for details    #99 : exit points are now configured as  exitPoint  in flow.json.\n        +  BREAKING CHANGE:  see ticket for details    #72 : configuration: removed deprecated configuration paths.\n        +  BREAKING CHANGE:  see ticket for details    #88 : footprint: removed  underscore  dependency    #70 : footprint: removed  laxar.text  API (use  laxar.string.format  instead)\n        +  BREAKING CHANGE:  see ticket for details    #92 : removed obsolete mixins in favor of compositions.\n        +  BREAKING CHANGE:  see ticket for details    #181 : runtime: added missing default for the configuration key  i18n.locales", 
            "title": "v1.0.0-alpha.0"
        }, 
        {
            "location": "/CHANGELOG/#v0260", 
            "text": "#169 : widget_adapters: fixed plain-adapter to use new-style widget module names  #172 : documentation: fixed dead link  #166 : cleanup: removed distribution-related configuration and files  #163 : EventBus: fixed request topic matching", 
            "title": "v0.26.0"
        }, 
        {
            "location": "/CHANGELOG/#v0250", 
            "text": "#156 : i18n: by default, use relaxed matching for language tags", 
            "title": "v0.25.0"
        }, 
        {
            "location": "/CHANGELOG/#v0240", 
            "text": "#157 : portal: angular-adapter: fixed error reporting  #145 : testing: added missing cancel-method to mock-$timeout  #155 : visibility: page controller now unsubscribes on tear-down  #152 : documentation: added widget installation manual\n        + NEW FEATURE: see ticket for details", 
            "title": "v0.24.0"
        }, 
        {
            "location": "/CHANGELOG/#v0230", 
            "text": "#153 : portal: angular-adapter: simplified widget and controller naming\n        + NEW FEATURE: see ticket for details    #151 : EventBus: fixed cycle count for zero subscribers   #148 : documentation: more detailed information on the event bus, link to api doc", 
            "title": "v0.23.0"
        }, 
        {
            "location": "/CHANGELOG/#v0220", 
            "text": "#146 : documentation: improved the prerequisites in the  README.md  and writing style  #143 : documentation: fixed testing configuration example ( andCallFake , not  andCallThrough )  #142 : documentation: fixed task alias for development server ( start , not  develop )  #144 : EventBus: reject publishAndGatherReplies-promise after timeout\n        +  BREAKING CHANGE:  see ticket for details", 
            "title": "v0.22.0"
        }, 
        {
            "location": "/CHANGELOG/#v0210", 
            "text": "#137 : flow: warn on empty place  #140 : EventBus: make timeout configurable  #126 : testing:  axEventBus  injection available to widget controllers during testing", 
            "title": "v0.21.0"
        }, 
        {
            "location": "/CHANGELOG/#v0200", 
            "text": "#138 : logging: the instance id is now generated by the log context and transmitted using an $http interceptor\n        + NEW FEATURE: see ticket for details    #134 : storage: fixed storage in iOS Safari private browsing", 
            "title": "v0.20.0"
        }, 
        {
            "location": "/CHANGELOG/#v0190", 
            "text": "#125 : axLayout: emit AngularJS event when loaded\n        + NEW FEATURE: see ticket for details    #113 : documentation: manual on tools    #122 : testing: allow to inject dependencies\n        + NEW FEATURE: see ticket for details    #123 : portal: preload widget assets on page load   #117 : portal: implemented a flow service that provides place urls usable as hyperlinks.  #121 : documentation: have README.md next steps point to manuals  #118 : performance: removed $timeout from axPageFade  #120 : portal: fixed flaky timestamp test  #119 : portal: fixed race condition in page loader", 
            "title": "v0.19.0"
        }, 
        {
            "location": "/CHANGELOG/#v0180", 
            "text": "#97 : documentation: manual on themes  #112 : documentation: removed colloquial style", 
            "title": "v0.18.0"
        }, 
        {
            "location": "/CHANGELOG/#v0170", 
            "text": "#108 : documentation: unify code-snippet format, and some polish  #109 : documentation: added manual on providing controls  #107 : angular widget adapter: added widget specific event bus service.  #106 : documentation: fixed manuals, improved introduction in README.md  #93 : refactoring: extracted page related services into own files.  #98 : documentation: added manual on events and pub/sub  #100 : widget loader: added angular widget as default integration.  #105 : moved resumable timer handling from flow to timer.  #104 : configuration: deprecated configuration keys are no handled at one place.  #101 : documentation: use \"\u00ab\" rather than \" \" for backwards navigation links  #76 : documentation: widgets and activities  #75 : documentation: flow and places.  #96 : documentation: restructured existing documents and added stubs for missing ones.  #95 : documentation: wrote a motivational article for LaxarJS.  #94 : footprint: removed the outdated app stub in favor of grunt-init (see README.md)  #38 : documentation: pages and compositions.  #91 : portal: make sure that widget DOM is attached when linking   #90 : documentation: secondary parts of any LaxarJS application\n        + NEW FEATURE: see ticket for details    #89 : documentation: primary concepts of LaxarJS   #84 : storage: storing  undefined  now causes the entry to be removed", 
            "title": "v0.17.0"
        }, 
        {
            "location": "/CHANGELOG/#v0160", 
            "text": "#87 : portal: Ensure anonymization of logged events.  #86 : logging: Added tests to ensure that string format compatible format strings using indexed placeholders are supported.   #85 : utilities: Implemented support for value mapping functions in string.format.\n        + NEW FEATURE: see ticket for details    #83 : portal: provided a timestamp service with a mock that works with jasmine\n        + NEW FEATURE: see ticket for details    #81 : added check for duplicate area definitions in layouts", 
            "title": "v0.16.0"
        }, 
        {
            "location": "/CHANGELOG/#v0150", 
            "text": "#82 : implemented directives axId and axFor\n        + NEW FEATURE: see ticket for details    #80 : storage: Improved detection of WebStorage API for Internet Explorer   #79 : assert: details given as object are now serialized  #77 : flow: the log tag  PLCE  with the current place name is set after navigation", 
            "title": "v0.15.0"
        }, 
        {
            "location": "/CHANGELOG/#v0140", 
            "text": "#73 : portal: fixed lookup of merged CSS file  #69 : portal: moved setting widget root element IDs to widget loader  #68 : fixed wrongly global assert in jshintrc.  #67 : re-added missing widget root element IDs.  #65 : fixed navigation being broken when parameter values were missing.  #66 : prevented endless navigation ping pong in flow controller  #63 : axVisibilityService: use scope.$id to identify handlers, not scope.id  #62 : fixed endless recursion on navigation when place and target have the same name.", 
            "title": "v0.14.0"
        }, 
        {
            "location": "/CHANGELOG/#v0130", 
            "text": "#61 : added first profiling tools for scope property watchers.\n        + NEW FEATURE: see ticket for details    #60 : tests: make sure PhantomJS is installed properly, before running spec tests.    #52 : portal, testing: added visibility events and the  axVisibilityService \n        + NEW FEATURE: see ticket for details    #59 : portal: fixed dangling comma in timer imports   #58 : portal, json: fixed copyright headers  #57 : portal: fixed double-navigation problem which can lead to skipping places  #56 : object: removed all direct calls of hasOwnProperty.  #55 : run_spec: disable loading the  widget.json  if the  spec_runner.js  contains  widgetJson: false  #54 : testing: fixed broken testBed injection of $q and $timeout  #50 : performance: decoupled instantiation of widget controllers from their DOM", 
            "title": "v0.13.0"
        }, 
        {
            "location": "/CHANGELOG/#v0120", 
            "text": "#49 : added compatibility layer for JSON patch.\n        + NEW FEATURE: see ticket for details    #48 : Promises generated by the event bus are now scheduled by the event bus, not by AngularJS  $apply .   #51 : Remove some obsolete NPM  devDependencies .  #47 : Do not schedule another full event-bus tick while one is already being processed.  #46 : fixed misinterpretation of falsy required attribute in json schema converter.  #45 : i18n: adjusted localizer.format specs to changes from  #43 .   #43 : string: added new function  string.format  as simpler replacement for  text  library.\n        + NEW FEATURE: see ticket for details    #42 : portal: added 'language-tag', 'topic-map' and 'localization' formats.\n        + NEW FEATURE: see ticket for details    #40 : portal: fixed 'flag-topic' pattern.", 
            "title": "v0.12.0"
        }, 
        {
            "location": "/CHANGELOG/#v0110", 
            "text": "#39 : portal: added JSON-schema formats 'topic', 'sub-topic' and 'flag-topic' to widget loader.\n        + NEW FEATURE: see ticket for details    #37 : improved browsing of existing api doc and fixed some syntactical errors.   #36 : jshintrc: disabled enforcement of dot notation for object property access.   #34 : Enabled specification of widget features using JSON schema draft v4 notation.\n        + NEW FEATURE: see ticket for details    #33 : EventBus: added event object to the information sent to inspectors on deliver actions.    #31 : Refactored JSON validator for better error messages and schema v4 support.\n        + NEW FEATURE: see ticket for details    #32 : Configuration: Consolidated and documented configuration options under docs/manuals/configuration.md\n        + NEW FEATURE: see ticket for details    #30 : PageLoader: added missing check for duplicate composition ids.", 
            "title": "v0.11.0"
        }, 
        {
            "location": "/CHANGELOG/#v0100", 
            "text": "#27 : Portal: Enhanced the portal event bus performance by not requiring a digest/render-cycle on each tick  #28 : Fixed null values in widget features within compositions being turned into empty objects.  #29 : PageLoader: composition features that are not configured do not result in undefined values for widget features.  #25 : Only the page relevant for the current place is loaded now.   #17 : Testing: The testBed.setup method can now simulate default-events\n        + NEW FEATURE: see ticket for details    #26 : Testing: Fixed the responseTransform option for http-mock    #22 : FileResourceProvider: allow to embed files into listings\n        + NEW FEATURE: see ticket for details    #15 : FileResourceProvider, PageLoader: Prevented duplicate (simultaneous) requests to file listings    #24 : Widgets and compositions can now be disabled in pages.\n        + NEW FEATURE: see ticket for details    #23 : FileResourceProvider: Slashes are now correctly handled when checking a file for existence in a listing.   #21 : The file resource provider now normalizes its root path.  #20 : Fixed event bus inspectors not being notified on unsubscription.  #14 : Fixed navigation being broken after successive navigation to the current location.  #13 : The current place is now send as part of the didNavigate event.  #12 : Testing: Get the LaxarJS tests running in Karma again.  #11 : Testing: Handle  spec_runner.js  that are not in a subdirectory of the RequireJS'  baseUrl .  #10 : Testing: Loading controls during tests now works in Karma.  #9 : Update Bower from ~1.2.8 to ~1.3.3.  #8 : Fixed the cleanup mechanism for generated widget areas.  #6 : The Portal now initializes an i18n object on the application's  $rootScope  #5 : Testing: The run_spec-script (used to set up the spec tests) now loads controls declared in the widget.json  #4 : PageLoader: Added missing optional negation of generated topics and replacement of expressions in feature keys  #3 : Added url formatting for links in Readme.md  #2 : Fixed grunt-init step in Getting-Started docs  #1 : Added initial Getting-Started documentation", 
            "title": "v0.10.0"
        }, 
        {
            "location": "/concepts/", 
            "text": "LaxarJS Concepts\n\n\nIn order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.\n\n\nA LaxarJS Application\n\n\nTo the visitor running a web browser, an \napplication\n is a set of URLs and associated pages which are loaded by the browser to provide some information or functionality.\nAn application may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.\n\n\nFrom a developer point of view, an application primarily consists of:\n\n\n\n\na set of LaxarJS \nwidgets\n and \nactivities\n providing the functionality\n\n\nthe \npages\n and \nlayouts\n assembling these widgets and activities\n\n\na \nflow\n that connects the individual pages\n\n\none or more \nthemes\n to define the look and feel of the application.\n\n\n\n\nIn order to run the application, there are additional secondary resources:\n\n\n\n\nthe \nLaxarJS runtime\n loads flow and pages, sets up the widgets and connects them through an \nevent bus\n\n\ncontrols\n which are used by the widgets to provide advanced user interface functionality, such as those provided by \nLaxarJS UiKit\n\n\nlibraries\n used by widgets and activities, such as \nmoment.js\n, \njQuery\n, and \nLaxarJS Patterns\n.\n\n\n\n\nThe following two sections first explain the primary application components, and then the underlying secondary components.\n\n\nPrimary Application Parts\n\n\nWidgets\n\n\nA \nLaxarJS widget\n is a rectangular part of the browser viewport which \nallows the user to perform some task\n.\nIt usually consists of several HTML elements, but could in some cases use only a single element, for example a \ncanvas\n to provide a painting surface.\n\n\nThe important distinction between a LaxarJS widget and a plain HTML control (such as a \nselect\n box or an \ninput\n field) is that a widget is written with a specific \nuser-goal\n in mind, whereas a control is general-purpose and its role in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a name, or a password), a widget could combine several input controls to a dialogue allowing the same user to \nlog in\n to the application, and another widget might allow the user to \nregister\n a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.\n\n\nTo illustrate this with further examples, possible widgets \nwith their specific goals\n include:\n\n\n\n\na to-do list, \nto check and plan what is to do\n\n\na shopping cart, \nto review and edit purchase items\n\n\na route planner displayed as a map, \nto plan a journey\n\n\na calendar displaying various events, \nto schedule and check appointments\n\n\nthe details editor for a specific event, \nto reschedule or cancel an appointment\n\n\na social buttons bar, \nto share content\n.\n\n\n\n\nIn contrast, these are controls:\n\n\n\n\nan input field, \nto display/edit any text\n\n\na date picker, \nto display/edit any date\n\n\na select box, \nto choose from any list of options\n\n\nan accordion control or a tab control, \nto navigate any set of contents\n.\n\n\n\n\nAnother way to think of it is that \nwidgets are made of controls\n, and  \ncontrols are HTML elements\n \u2014 which \nmay\n be user-defined, for example by using HTML web components or AngularJS directives.\nThe program logic of an individual widget is implemented in JavaScript, while the presentation is defined by using an HTML template, optionally accompanied by CSS styling information.\n\n\nAn important property of widgets is that they always can be \nloaded and tested in isolation\n:\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) may already be there.\nTo simplify the creation of widgets, LaxarJS directly supports several modern UI technologies, including Angular, React and Vue.\n\n\nActivities\n\n\nA \nLaxarJS activity\n is a widget without a visual representation, performing a task for the user \nbehind the scenes\n.\nTo build upon the previous example, a \nlogin widget\n might talk to an authentication service itself, but it might also delegate this task to an \nauthentication activity\n using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS authentication to OAuth) only the activity needs to be exchanged, while the widget remains untouched.\nIn contrast to regular libraries, activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe.\n\n\nAnother possible example would be a \nweb search widget\n offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just \nsubscribes\n to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching the widget or any of the search engine implementations.\n\n\nWidgets vs. Activities\n\n\nWidgets assume that they are displayed in the browser, while activities can run in any JavaScript environment\n.\nIn contrast to the visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.\n\n\nPages\n\n\nA \nLaxarJS page\n is a piece of configuration data that combines and configures widgets and activities that are used together at the same place in the application.\nFor visual arrangement, the page anchors them within an HTML skeleton called \nlayout\n.\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions.\n\n\nAn individual widget is still somewhat generic in that it allows to perform a specific task \nin any context\n:\nFor example, a social buttons bar allows to share \nany content\n, and the specific list of social sites to share on might be \nconfigurable\n.\nThe page establishes this context, for example \nby placing\n the social buttons below a news article (rendered from markdown by another widget), and \nby configuring\n that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nStill, reuse is supported for those widgets where it makes sense.\n\n\nCollaboration Patterns and Compositions\n\n\nWhile widgets and activities are implemented in JavaScript and HTML, pages are written using \nJSON\n in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.\nOf course, often the widgets on a page are supposed to be collaborating, by sharing resources or by accessing each other's functionality in some way.\nPages enable this by connecting widgets through shared event bus topics.\nThe widgets in turn participate in standard \nevent patterns\n for collaboration.\n\n\nUsually, each page occupies its own \"screen\" in your application, but there is a \ncomposition\n mechanism to divide pages into reusable fragments and re-assemble them in various contexts.\n\n\nLayouts\n\n\nLaxarJS layouts\n are skeleton HTML documents, which contain placeholders (called \nwidget areas\n) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nYou can use one or several layouts for all of the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.\n\n\nBy default, LaxarJS applications use \nBootstrap CSS\n to implement a grid layout in CSS, and to ensure that widgets are compatible with respect to their CSS, however you are free to deviate from this in your application.\nFor each \nwidget area\n, the layout can define a width in Bootstrap grid columns, and widgets within these areas may not exceed their available number of columns.\nLike widgets, layouts may be accompanied by their own CSS styles, for example to define a background color.\n\n\nYou may think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.\n\n\nThe Flow\n\n\nThe flow defines \nURL patterns\n that may be used to navigate to the pages of an application, and \nrelations between pages\n.\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, the flow defines semantic relations between pages, such as what is considered the \nnext\n page from a given page in the application.\n\n\nThemes\n\n\nWidgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.\n\n\nThe LaxarJS UiKit is based on SCSS to simplify the generation of user-defined themes. However, any way to generate Bootstrap-like CSS styles is a valid way to create a standard LaxarJS theme.\n\n\nSecondary Application Parts \u2013 Under the Hood\n\n\nThe LaxarJS Runtime\n\n\nThe \nruntime\n handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.\nOnce everything is set up, the runtime gets out of the way: it lets the widgets perform their tasks and communicate through the event bus as needed.\n\n\nThe LaxarJS Event Bus\n\n\nThe \nevent bus\n allows widgets to talk about common topics, without knowing \nanything\n about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or await resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.\n\n\nControls\n\n\nControls\n are (user-defined) HTML elements and attributes.\nThey can be implemented using standard web technologies, or by relying on an MVC framework such as Angular or React, effectively restricting their use to widgets created in the same technology.\nControls are available to widgets as reusable UI components, and are usually styled using \nBootstrap 3\n for interoperability and theme support.\n\n\nSometimes, multiple widgets use the same or very similar UI of significant size and/or complexity.\nIn some cases, the common UI actually represents a standalone use case and should be extracted into a widget.\nMore often however, the UI part should be reused as a \"dumb\" control, with widgets providing the application data from the outside.\n\n\nLibraries\n\n\nWidgets may use \nlibraries\n such as \njQuery\n or \nmoment.js\n just like in any JavaScript web application.\n\n\nSince version 2, LaxarJS, provides a development workflow based on \nnpm\n and \nwebpack\n in order to install and load widgets with their asset and library dependencies, but as there are no runtime dependencies to these tools, adapting a different tool chain for use with LaxarJS should not be too hard.\n\n\nTo establish a useful common base vocabulary for use with the event bus, the \nLaxarJS Patterns\n library is provided.\nIt contains helpers that make it easy for widgets to talk about user actions, common (REST) resources and Boolean flags.\n\n\nLaxarJS and UI Frameworks\n\n\nAlthough intended for web applications, LaxarJS is not a UI (User-Interface) framework.\nFor non-trivial applications, it should be used together with a dedicated UI framework:\nIn the past, LaxarJS was integrated with AngularJS v1, making it the framework of choice for the view layer of LaxarJS applications.\n\n\nStarting with LaxarJS v2, several \nadapters\n allow to integrate with various UI technologies.\nBesides AngularJS v1, there are adapters for Angular v2, React and Vue.\nCurrently, we particularly like Vue for its simplicity (like React) combined with the ability to use plain old HTML templates (like AngularJS).\n\n\nNext Steps\n\n\nAfter this quick tour through the building blocks of a LaxarJS application, have a look at the \nmanuals\n for in-depth information on individual topics.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#laxarjs-concepts", 
            "text": "In order to get productive with LaxarJS, a basic understanding of a few core concepts is helpful.", 
            "title": "LaxarJS Concepts"
        }, 
        {
            "location": "/concepts/#a-laxarjs-application", 
            "text": "To the visitor running a web browser, an  application  is a set of URLs and associated pages which are loaded by the browser to provide some information or functionality.\nAn application may access web services or connect to database programs, which are not considered part of the LaxarJS application itself.  From a developer point of view, an application primarily consists of:   a set of LaxarJS  widgets  and  activities  providing the functionality  the  pages  and  layouts  assembling these widgets and activities  a  flow  that connects the individual pages  one or more  themes  to define the look and feel of the application.   In order to run the application, there are additional secondary resources:   the  LaxarJS runtime  loads flow and pages, sets up the widgets and connects them through an  event bus  controls  which are used by the widgets to provide advanced user interface functionality, such as those provided by  LaxarJS UiKit  libraries  used by widgets and activities, such as  moment.js ,  jQuery , and  LaxarJS Patterns .   The following two sections first explain the primary application components, and then the underlying secondary components.", 
            "title": "A LaxarJS Application"
        }, 
        {
            "location": "/concepts/#primary-application-parts", 
            "text": "", 
            "title": "Primary Application Parts"
        }, 
        {
            "location": "/concepts/#widgets", 
            "text": "A  LaxarJS widget  is a rectangular part of the browser viewport which  allows the user to perform some task .\nIt usually consists of several HTML elements, but could in some cases use only a single element, for example a  canvas  to provide a painting surface.  The important distinction between a LaxarJS widget and a plain HTML control (such as a  select  box or an  input  field) is that a widget is written with a specific  user-goal  in mind, whereas a control is general-purpose and its role in the application is up to the developer.\nFor example, while a control might allow a user to input some text (such as a name, or a password), a widget could combine several input controls to a dialogue allowing the same user to  log in  to the application, and another widget might allow the user to  register  a new account.\nSo, both widgets and controls are parts of the user interface, but on different levels of abstraction.  To illustrate this with further examples, possible widgets  with their specific goals  include:   a to-do list,  to check and plan what is to do  a shopping cart,  to review and edit purchase items  a route planner displayed as a map,  to plan a journey  a calendar displaying various events,  to schedule and check appointments  the details editor for a specific event,  to reschedule or cancel an appointment  a social buttons bar,  to share content .   In contrast, these are controls:   an input field,  to display/edit any text  a date picker,  to display/edit any date  a select box,  to choose from any list of options  an accordion control or a tab control,  to navigate any set of contents .   Another way to think of it is that  widgets are made of controls , and   controls are HTML elements  \u2014 which  may  be user-defined, for example by using HTML web components or AngularJS directives.\nThe program logic of an individual widget is implemented in JavaScript, while the presentation is defined by using an HTML template, optionally accompanied by CSS styling information.  An important property of widgets is that they always can be  loaded and tested in isolation :\nA widget instance may be put onto any page, regardless of what other widgets (even of the same type) may already be there.\nTo simplify the creation of widgets, LaxarJS directly supports several modern UI technologies, including Angular, React and Vue.", 
            "title": "Widgets"
        }, 
        {
            "location": "/concepts/#activities", 
            "text": "A  LaxarJS activity  is a widget without a visual representation, performing a task for the user  behind the scenes .\nTo build upon the previous example, a  login widget  might talk to an authentication service itself, but it might also delegate this task to an  authentication activity  using the event bus.\nWhen the authentication mechanism changes (e.g. from a plain HTTPS authentication to OAuth) only the activity needs to be exchanged, while the widget remains untouched.\nIn contrast to regular libraries, activities participate in the lifecycle of the page and are attached to the event bus, which allows them to communicate with other widgets using publish/subscribe.  Another possible example would be a  web search widget  offering a search box with a list of web search results.\nInstead of hard-wiring the widget to a specific search engine, one could implement multiple engine-specific activities and choose depending on user preference.\nBecause the search widget does not know any of the activities (it just  subscribes  to the search results) one could even define a \"proxy\" activity to combine results from multiple searches without touching the widget or any of the search engine implementations.", 
            "title": "Activities"
        }, 
        {
            "location": "/concepts/#widgets-vs-activities", 
            "text": "Widgets assume that they are displayed in the browser, while activities can run in any JavaScript environment .\nIn contrast to the visual widgets, activities do not have HTML templates nor CSS styles.\nTo sum it up, widgets support direct user-interaction, while activities perform tasks behind the scenes, such as talking to (REST) services or coordinating different widgets.", 
            "title": "Widgets vs. Activities"
        }, 
        {
            "location": "/concepts/#pages", 
            "text": "A  LaxarJS page  is a piece of configuration data that combines and configures widgets and activities that are used together at the same place in the application.\nFor visual arrangement, the page anchors them within an HTML skeleton called  layout .\nWhen navigated to, the runtime loads the page and puts the widgets referenced by the page into the associated layout to display them.\nThe page also defines the publish/subscribe topics that the widget instance use to communicate resource state and user actions.  An individual widget is still somewhat generic in that it allows to perform a specific task  in any context :\nFor example, a social buttons bar allows to share  any content , and the specific list of social sites to share on might be  configurable .\nThe page establishes this context, for example  by placing  the social buttons below a news article (rendered from markdown by another widget), and  by configuring  that twitter and tumblr should be offered, but not LinkedIn.\nThis does not mean that all widgets must be broadly reusable: a widget to manage the inventory in a video game would probably not be useful anywhere else.\nStill, reuse is supported for those widgets where it makes sense.", 
            "title": "Pages"
        }, 
        {
            "location": "/concepts/#collaboration-patterns-and-compositions", 
            "text": "While widgets and activities are implemented in JavaScript and HTML, pages are written using  JSON  in a declarative fashion.\nThis reflects on the fact that pages do not contain application logic, but merely assemble and configure a set of widgets.\nOf course, often the widgets on a page are supposed to be collaborating, by sharing resources or by accessing each other's functionality in some way.\nPages enable this by connecting widgets through shared event bus topics.\nThe widgets in turn participate in standard  event patterns  for collaboration.  Usually, each page occupies its own \"screen\" in your application, but there is a  composition  mechanism to divide pages into reusable fragments and re-assemble them in various contexts.", 
            "title": "Collaboration Patterns and Compositions"
        }, 
        {
            "location": "/concepts/#layouts", 
            "text": "LaxarJS layouts  are skeleton HTML documents, which contain placeholders (called  widget areas ) within which widget instances can be placed.\nEach page specifies a layout that the LaxarJS runtime should use for it.\nYou can use one or several layouts for all of the scaffolding markup of your application (such as copyright footers and navigation), but you may also choose to implement these areas as widgets to allow for re-use and configuration.  By default, LaxarJS applications use  Bootstrap CSS  to implement a grid layout in CSS, and to ensure that widgets are compatible with respect to their CSS, however you are free to deviate from this in your application.\nFor each  widget area , the layout can define a width in Bootstrap grid columns, and widgets within these areas may not exceed their available number of columns.\nLike widgets, layouts may be accompanied by their own CSS styles, for example to define a background color.  You may think of layouts as the opposite of activities: While activities are just widgets without a user interface, layouts are similar to widgets without the logic part \u2013 just HTML templates and CSS.", 
            "title": "Layouts"
        }, 
        {
            "location": "/concepts/#the-flow", 
            "text": "The flow defines  URL patterns  that may be used to navigate to the pages of an application, and  relations between pages .\nIt is comparable to the routing mechanisms found in many MVC web frameworks.\nAlso, the flow defines semantic relations between pages, such as what is considered the  next  page from a given page in the application.", 
            "title": "The Flow"
        }, 
        {
            "location": "/concepts/#themes", 
            "text": "Widgets and their controls may be styled using CSS.\nFor widgets with a broad applicability (such as a calendar, or a route planner) it can be very useful to adapt the visual appearance to various circumstances.\nThis is achieved by overriding parts of the vanilla bootstrap CSS classes (shipping with LaxarJS UiKit) with user defined CSS styles.\nA theme may specify styles for any control and for any widget that it wants to modify.\nWhere nothing else is specified, plain bootstrap is used.  The LaxarJS UiKit is based on SCSS to simplify the generation of user-defined themes. However, any way to generate Bootstrap-like CSS styles is a valid way to create a standard LaxarJS theme.", 
            "title": "Themes"
        }, 
        {
            "location": "/concepts/#secondary-application-parts-under-the-hood", 
            "text": "", 
            "title": "Secondary Application Parts \u2013 Under the Hood"
        }, 
        {
            "location": "/concepts/#the-laxarjs-runtime", 
            "text": "The  runtime  handles URL routing and loads the template associated with the current page definition.\nIt instantiates all required widgets and activities, and tells them when everyone else is ready to receive their publish/subscribe-events.\nIt also loads the corresponding templates and CSS files, or provides these assets from an optimized bundle in production.\nOnce everything is set up, the runtime gets out of the way: it lets the widgets perform their tasks and communicate through the event bus as needed.", 
            "title": "The LaxarJS Runtime"
        }, 
        {
            "location": "/concepts/#the-laxarjs-event-bus", 
            "text": "The  event bus  allows widgets to talk about common topics, without knowing  anything  about each other (not even a service name, interface or super-class).\nWidgets may request actions (such as a navigation or saving the page state), and other widgets might be there to respond to these actions.\nLikewise, widgets might provide resources (JSON structures), or await resources to be provided for them.\nBecause each widget uses its own isolated copy of the relevant resources which is synchronized over the event bus at well defined instances, race conditions are effectively avoided.", 
            "title": "The LaxarJS Event Bus"
        }, 
        {
            "location": "/concepts/#controls", 
            "text": "Controls  are (user-defined) HTML elements and attributes.\nThey can be implemented using standard web technologies, or by relying on an MVC framework such as Angular or React, effectively restricting their use to widgets created in the same technology.\nControls are available to widgets as reusable UI components, and are usually styled using  Bootstrap 3  for interoperability and theme support.  Sometimes, multiple widgets use the same or very similar UI of significant size and/or complexity.\nIn some cases, the common UI actually represents a standalone use case and should be extracted into a widget.\nMore often however, the UI part should be reused as a \"dumb\" control, with widgets providing the application data from the outside.", 
            "title": "Controls"
        }, 
        {
            "location": "/concepts/#libraries", 
            "text": "Widgets may use  libraries  such as  jQuery  or  moment.js  just like in any JavaScript web application.  Since version 2, LaxarJS, provides a development workflow based on  npm  and  webpack  in order to install and load widgets with their asset and library dependencies, but as there are no runtime dependencies to these tools, adapting a different tool chain for use with LaxarJS should not be too hard.  To establish a useful common base vocabulary for use with the event bus, the  LaxarJS Patterns  library is provided.\nIt contains helpers that make it easy for widgets to talk about user actions, common (REST) resources and Boolean flags.", 
            "title": "Libraries"
        }, 
        {
            "location": "/concepts/#laxarjs-and-ui-frameworks", 
            "text": "Although intended for web applications, LaxarJS is not a UI (User-Interface) framework.\nFor non-trivial applications, it should be used together with a dedicated UI framework:\nIn the past, LaxarJS was integrated with AngularJS v1, making it the framework of choice for the view layer of LaxarJS applications.  Starting with LaxarJS v2, several  adapters  allow to integrate with various UI technologies.\nBesides AngularJS v1, there are adapters for Angular v2, React and Vue.\nCurrently, we particularly like Vue for its simplicity (like React) combined with the ability to use plain old HTML templates (like AngularJS).", 
            "title": "LaxarJS and UI Frameworks"
        }, 
        {
            "location": "/concepts/#next-steps", 
            "text": "After this quick tour through the building blocks of a LaxarJS application, have a look at the  manuals  for in-depth information on individual topics.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/glossary/", 
            "text": "LaxarJS Glossary\n\n\nWhile reading LaxarJS manuals and API documentation you will from time to time stumble over terms, that have a certain meaning within the context of LaxarJS.\nTo prevent from defining these terms over and over again, this document is a collection of all terms and our definition.\nIf you deem something important is missing here, feel free to \ncontact us\n.\n\n\nAction\n\n\nIn the context of \nLaxarJS Patterns\n, an event expressing user intent.\n\n\nMore Information:\n\n\n\n\nLaxarJS Patterns: Actions\n\n\n\n\nActivity\n\n\nAn artifact in a LaxarJS application, implementing business logic or providing supporting service functionality.\nSimilar to a widget, but without any user interface.\n\n\nMore Information:\n\n\n\n\nLaxarJS Core Concepts\n\n\nManual: Widgets and Activities\n\n\n\n\nArtifact\n\n\nLaxarJS distinguishes the following application artifacts:\n\n\n\n\nwidgets\n\n\nactivities\n\n\ncontrols\n\n\nlayouts\n\n\nflows\n\n\npages\n\n\nthemes\n\n\n\n\nMore Information:\n\n\n\n\nLaxarJS Core Concepts\n\n\nManual: Widgets and Activities\n\n\nManual: Providing Controls\n\n\nManual: Writing Pages\n\n\nManual: Flow and Places\n\n\n\n\nAssets\n\n\nSecondary resources (HTML, CSS, images) that may belong to certain application artifacts (widgets, controls, layouts).\n\n\nMore Information:\n\n\n\n\nManual: Asset Lookup\n\n\n\n\nAttribute Path\n\n\nAn attribute path is a JavaScript string that references a property in an object or array, possibly deeply nested.\nIt consists of a list of keys denoting the path to follow within the object hierarchy.\nThe keys are written as a string, where each key is separated by a dot from each other.\n\n\nExample\n\n\nConsider the following object:\n\n\n{\n\n   \nitems\n:\n \n[\n\n      \n{\n \nuser\n:\n \n{\n \nname\n:\n \nTom\n \n}\n \n},\n\n      \n{\n \nuser\n:\n \n{\n \nname\n:\n \nPete\n \n}\n \n}\n\n   \n]\n\n\n}\n\n\n\n\n\n\nWhen evaluated against this object, the attribute path \n\"items.1.user.name\"\n would yield the string \n\"Pete\"\n.\n\n\nMore Information:\n\n\n\n\nAPI: \nlaxar.object.path\n\n\n\n\nBootstrap CSS\n\n\nThe CSS framework used by default for LaxarJS applications, widgets and controls.\nNot to be confused with the \n.bootstrap()\n-method used to initialize a LaxarJS Bootstrapping Instance.\n\n\nMore Information:\n\n\n\n\ngetbootstrap.com\n\n\n\n\nBootstrapping Instance\n\n\nA runtime context within which LaxarJS instantiates and configures a flow, pages and widgets.\nMultiple bootstrapping instances may run within the same browser window at the same time in complete isolation from each other.\nEach instance may use a flow that displays one page at a time.\nNot to be confused Bootstrap CSS.\n\n\nMore Information:\n\n\n\n\nAPI: \nlaxar.create\n\n\n\n\nControl\n\n\nGenerally, a basic UI building block to be used within widgets.\nMore specifically, a LaxarJS artifact consisting of a JavaScript module (possibly loading an HTML template) and an optional CSS stylesheet, which may be \nthemed\n.\n\n\nMore Information:\n\n\n\n\nLaxarJS Core Concepts\n\n\nManual: Providing Controls\n\n\n\n\nComposition\n\n\nAdvanced concept:\nA partial page definition that can be instantiated from within other pages.\nSupports feature configuration, similar to widgets.\n\n\nMore Information:\n\n\n\n\nManual: Writing Compositions\n\n\n\n\nConfiguration\n\n\nApart from the page and flow definitions, LaxarJS supports application-level configuration which is passed directly to each bootstrapping instance.\nUse this for deployment-dependent configuration, such as service URLs.\n\n\nMore Information:\n\n\n\n\nManual: Configuration\n\n\nAPI: \naxConfiguration\n\n\nAPI: \nlaxar.bootstrap\n\n\n\n\nDescriptor\n\n\nJSON file containing meta information about a LaxarJS artifact, most importantly its canonical \nname\n.\nA descriptor is \nrequired\n for the following artifact types:\n\n\n\n\nWidgets/Activities: \nwidget.json\n, see also: \nWidget Descriptor\n\n\nLayouts: \nlayout.json\n\n\nThemes: \ntheme.json\n\n\nControls: \ncontrol.json\n\n\n\n\nThe \nname\n field is used to resolve the implementation module (only for widgets and controls), and to determine the default location for CSS and HTML assets.\nThe \nstyleSource\n and \ntemplateSource\n attributes of the descriptor can be used to specify non-default stylesheet (such as SCSS) or template (e.g. pug) assets.\n\n\nEvent Bus\n\n\nCentral event broker within each LaxarJS application.\nConnects widgets and activities through publish/subscribe events.\n\n\nMore Information:\n\n\n\n\nManual: Events\n\n\nAPI: \naxEventBus\n\n\n\n\nFeature Path\n\n\nMost commonly used as function argument called \nfeaturePath\n\n\nThis is an \nattribute path\n for a widget feature.\nIf not said otherwise, the path starts after the \nfeatures\n key.\nYou'll find this being used very frequently when working with the \nLaxarJS Patterns library\n.\n\n\nFlag\n\n\nIn the context of \nLaxarJS Patterns\n, a publish/subscribe event announcing a Boolean state to collaborators.\nOften used to toggle visibility of context-dependent UI items, or to enable/disable form elements.\n\n\nMore Information:\n\n\n\n\nLaxarJS Patterns: Flags\n\n\n\n\nFlow\n\n\nRouting configuration for a LaxarJS application.\nAssociates URL patterns with pages, and defines their parameters.\n\n\nMore Information:\n\n\n\n\nManual: Flow and Places\n\n\nAPI: \naxFlowService\n\n\n\n\nI18n\n\n\nInternationalization:\n LaxarJS allows to broadcast changes to application locales and offers a small set of helpers for selecting the correct localization from internationalized values.\n\n\nMore Information:\n\n\n\n\nManual: i18n\n\n\n\n\nI18n Object\n\n\nFor internationalization purposes, many LaxarJS libraries, widgets and controls support so-called \ni18n objects\n instead of primitive values, in order to support multiple localizations.\nAn i18n object is a map from language tag (\nen-US\n, \nde\n, etc.) to plain text or HTML markup.\nDepending on the selected locale and resulting language tag, the correct message localization is used.\n\n\nMore Information:\n\n\n\n\nManual: i18n\n\n\n\n\nIntegration Technology\n\n\nA string that identifies which UI technology a widget or control is built upon.\nLaxarJS comes with support for a single integration technology, \n\"plain\"\n, meaning that an artifact is built using vanilla HTML5/CSS/JavaScript.\nFor any other technology, an appropriate \ntechnology adapter\n must be passed to LaxarJS when bootstrapping the application.\nThe LaxarJS project provides adapters for the following integration technologies: \n\"angular\"\n (for \nAngularJS v1\n), \n\"angular2\"\n (for \nAngular 2\n and beyond), \n\"react\"\n (for \nReact\n) and \n\"vue\"\n (for \nVue.js v2\n).\n\n\nMore Information:\n\n\n\n\nManual: Widgets and Activities\n\n\nManual: Creating an Adapter for a new Widget Technology\n\n\n\n\nIntegration Technology Adapter\n\n\nA JavaScript module that allows LaxarJS to load widgets and controls written in a specific \nintegration technology.\n\nMust be passed to LaxarJS when bootstrapping an application.\n\n\nMore Information:\n\n\n\n\nManual: Creating an Adapter for a new Widget Technology\n\n\nlaxar-angular-adapter\n\n\nlaxar-angular2-adapter\n\n\nlaxar-react-adapter\n\n\nlaxar-vue-adapter\n\n\n\n\nIntegration Type\n\n\nA string used in the widget descriptor to distinguish widgets (integration type \n\"widget\"\n) from activities (integration type \n\"activity\"\n).\n\n\nMore Information:\n\n\n\n\nManual: Widgets and Activities\n\n\n\n\nLayout\n\n\nA piece of plain old HTML used to render scaffolding HTML, or to arrange widgets contained in page by including one or more \nwidget areas\n.\n\n\nMore Information:\n\n\n\n\nManual: Writing Pages\n\n\n\n\nLaxarJS Patterns\n\n\nA library helping to support several standard event patterns for widget collaboration, most importantly \nactions, resources,\n and \nflags.\n\n\nMore Information:\n\n\n\n\nLaxarJS Patterns\n\n\n\n\nLaxarJS Mocks\n\n\nA library that helps to write specification tests \n(spec tests)\n for widgets and activities.\n\n\nMore Information:\n\n\n\n\nLaxarJS Mocks\n\n\n\n\nLaxarJS UiKit\n\n\nA library containing the LaxarJS default theme (a slightly extended Bootstrap 3, plus Font Awesome) as well as JavaScript helper functions for locale-aware parsing and formatting of numbers and dates.\n\n\nMore Information:\n\n\n\n\nLaxarJS UiKit\n\n\n\n\nLifecycle\n\n\nStandard event sequence that is published by the LaxarJS runtime from the instant a page is entered...\n\n\n\n\nbeginLifecycleRequest\n\n\ndidNavigate\n\n\n\n\n...until it is replaced by the next page:\n\n\n\n\nnavigateRequest\n\n\nendLifecycleRequest\n.\n\n\n\n\nMore Information:\n\n\n\n\nManual: Events\n\n\n\n\nTopic\n\n\nFragment of an event name when split by \n.\n (dot).\nMore specifically, the \"middle\" part of pattern event names (actions, resources, flags) that is used within page definitions in order to connect collaborating widgets.\nAlso called topic ID in this context.\n\n\nPage\n\n\nConfiguration for a set of LaxarJS widgets, activities and possibly nested compositions that are run at the same time.\nAlso contains a reference to a main layout, and possibly to additional nested layouts, in order to visually arrange the widgets.\n\n\nPlace\n\n\nAn entry in a flow definition.\nBinds one or more URL patterns to either a page, or to a redirect.\n\n\nPublish/Subscribe\n\n\nArchitectural pattern used for communication of components within LaxarJS applications.\n\n\nResource\n\n\nIn the context of \nLaxarJS Patterns\n, a publish/subscribe event broadcasting application state to collaborators.\n\n\nMore Information:\n\n\n\n\nLaxarJS Patterns: Resources\n\n\n\n\nTheme\n\n\nA named collection of CSS styles that define the look and feel of a LaxarJS application.\nBy default, LaxarJS applications use the \ndefault.theme\n which is just Bootstrap 3 plus Font Awesome.\nCustom themes can modify the Bootstrap styling or completely replace it, e.g. by using \nMaterial Design\n.\nWidgets should always define styles for the \ndefault.theme\n.\n\n\nMore Information:\n\n\n\n\nCreating Themes\n\n\n\n\nWidget\n\n\nMain building block within a LaxarJS application.\nProvides and-user functionality within its area of the screen.\n\n\nMore Information:\n\n\n\n\nLaxarJS Core Concepts\n\n\nManual: Widgets and Activities\n\n\n\n\nWidget Adapter\n\n\nSee \nIntegration Technology Adapter\n.\n\n\nWidget Area\n\n\nAn anchor for nested widgets that is provided by layouts and sometimes by widgets.\nEach widget area is attached to a DOM node and its contents are determined by the page configuration.\nWidget areas even allow nesting widgets that were created in different \nintegration technologies\n.\n\n\nMore Information:\n\n\n\n\nManual: Writing Pages\n\n\nAPI: \naxAreaHelper\n\n\n\n\nWidget Descriptor\n\n\nThe contents of a JSON file (called \nwidget.json\n) containing meta information about a widget.\nThe descriptor defines the \nname\n, \nintegration type and technology\n, and the \nwidget features\n that may be configured.\nIt may also specify a \nstyleSource\n and/or \ntemplateSource\n if the widget deviates from the defaults, e.g. when using SCSS.\n\n\nMore Information:\n\n\n\n\nManual: Widgets and Activities\n\n\n\n\nWidget Directory\n\n\nFile system directory containing a widget with its descriptor, implementation module, and assets.\n\n\nMore Information:\n\n\n\n\nManual: Widgets and Activities\n\n\n\n\nWidget Features\n\n\nWhen a widget is \ninstantiated\n within a page, runtime configuration is passed to the widget controller through the \naxFeatures\n injection.\nThe \nwidget descriptor\n may specify and document what feature configuration is allowed by providing a JSON schema under its \nfeatures\n property.\n\n\nMore Information:\n\n\n\n\nManual: Widgets and Activities\n\n\nManual: Writing Pages\n\n\nAPI: \naxFeatures\n\n\n\n\nWidget Instance\n\n\nEach widget is a \nblueprint\n that can be instantiated on any number of pages, or even multiple times within a single page.\nEach of those instances has its own configuration, its own ID, and its own container node in the browser DOM.\n\n\nWidget Services, Widget Injections\n\n\nTo use service APIs provided by LaxarJS, most importantly the event bus, widgets and activities request them to be injected into their controller.\nThe specific syntax for this depends on the integration technology.\nLaxarJS does not use a fancy dependency injection (DI) framework for this, just a simple registry of known services.\nHowever, technology adapters may hook into the DI of their respective framework to enrich it with the LaxarJS services.\n\n\nMore Information:\n\n\n\n\nManual: Widget Services\n\n\nAPI: Widget Services\n\n\n\n\nYeoman, Yeoman Generator\n\n\nYeoman\n is a general purpose \nscaffolding tool\n that allows to create new software artifacts based on a template, and interactive dialogues to fill in the blanks.\nThe \nYeoman Generator for LaxarJS\n is a plugin for Yeoman that helps to create LaxarJS applications, widgets, activities and controls.", 
            "title": "LaxarJS Glossary"
        }, 
        {
            "location": "/glossary/#laxarjs-glossary", 
            "text": "While reading LaxarJS manuals and API documentation you will from time to time stumble over terms, that have a certain meaning within the context of LaxarJS.\nTo prevent from defining these terms over and over again, this document is a collection of all terms and our definition.\nIf you deem something important is missing here, feel free to  contact us .", 
            "title": "LaxarJS Glossary"
        }, 
        {
            "location": "/glossary/#action", 
            "text": "In the context of  LaxarJS Patterns , an event expressing user intent.  More Information:   LaxarJS Patterns: Actions", 
            "title": "Action"
        }, 
        {
            "location": "/glossary/#activity", 
            "text": "An artifact in a LaxarJS application, implementing business logic or providing supporting service functionality.\nSimilar to a widget, but without any user interface.  More Information:   LaxarJS Core Concepts  Manual: Widgets and Activities", 
            "title": "Activity"
        }, 
        {
            "location": "/glossary/#artifact", 
            "text": "LaxarJS distinguishes the following application artifacts:   widgets  activities  controls  layouts  flows  pages  themes   More Information:   LaxarJS Core Concepts  Manual: Widgets and Activities  Manual: Providing Controls  Manual: Writing Pages  Manual: Flow and Places", 
            "title": "Artifact"
        }, 
        {
            "location": "/glossary/#assets", 
            "text": "Secondary resources (HTML, CSS, images) that may belong to certain application artifacts (widgets, controls, layouts).  More Information:   Manual: Asset Lookup", 
            "title": "Assets"
        }, 
        {
            "location": "/glossary/#attribute-path", 
            "text": "An attribute path is a JavaScript string that references a property in an object or array, possibly deeply nested.\nIt consists of a list of keys denoting the path to follow within the object hierarchy.\nThe keys are written as a string, where each key is separated by a dot from each other.", 
            "title": "Attribute Path"
        }, 
        {
            "location": "/glossary/#example", 
            "text": "Consider the following object:  { \n    items :   [ \n       {   user :   {   name :   Tom   }   }, \n       {   user :   {   name :   Pete   }   } \n    ]  }   When evaluated against this object, the attribute path  \"items.1.user.name\"  would yield the string  \"Pete\" .  More Information:   API:  laxar.object.path", 
            "title": "Example"
        }, 
        {
            "location": "/glossary/#bootstrap-css", 
            "text": "The CSS framework used by default for LaxarJS applications, widgets and controls.\nNot to be confused with the  .bootstrap() -method used to initialize a LaxarJS Bootstrapping Instance.  More Information:   getbootstrap.com", 
            "title": "Bootstrap CSS"
        }, 
        {
            "location": "/glossary/#bootstrapping-instance", 
            "text": "A runtime context within which LaxarJS instantiates and configures a flow, pages and widgets.\nMultiple bootstrapping instances may run within the same browser window at the same time in complete isolation from each other.\nEach instance may use a flow that displays one page at a time.\nNot to be confused Bootstrap CSS.  More Information:   API:  laxar.create", 
            "title": "Bootstrapping Instance"
        }, 
        {
            "location": "/glossary/#control", 
            "text": "Generally, a basic UI building block to be used within widgets.\nMore specifically, a LaxarJS artifact consisting of a JavaScript module (possibly loading an HTML template) and an optional CSS stylesheet, which may be  themed .  More Information:   LaxarJS Core Concepts  Manual: Providing Controls", 
            "title": "Control"
        }, 
        {
            "location": "/glossary/#composition", 
            "text": "Advanced concept:\nA partial page definition that can be instantiated from within other pages.\nSupports feature configuration, similar to widgets.  More Information:   Manual: Writing Compositions", 
            "title": "Composition"
        }, 
        {
            "location": "/glossary/#configuration", 
            "text": "Apart from the page and flow definitions, LaxarJS supports application-level configuration which is passed directly to each bootstrapping instance.\nUse this for deployment-dependent configuration, such as service URLs.  More Information:   Manual: Configuration  API:  axConfiguration  API:  laxar.bootstrap", 
            "title": "Configuration"
        }, 
        {
            "location": "/glossary/#descriptor", 
            "text": "JSON file containing meta information about a LaxarJS artifact, most importantly its canonical  name .\nA descriptor is  required  for the following artifact types:   Widgets/Activities:  widget.json , see also:  Widget Descriptor  Layouts:  layout.json  Themes:  theme.json  Controls:  control.json   The  name  field is used to resolve the implementation module (only for widgets and controls), and to determine the default location for CSS and HTML assets.\nThe  styleSource  and  templateSource  attributes of the descriptor can be used to specify non-default stylesheet (such as SCSS) or template (e.g. pug) assets.", 
            "title": "Descriptor"
        }, 
        {
            "location": "/glossary/#event-bus", 
            "text": "Central event broker within each LaxarJS application.\nConnects widgets and activities through publish/subscribe events.  More Information:   Manual: Events  API:  axEventBus", 
            "title": "Event Bus"
        }, 
        {
            "location": "/glossary/#feature-path", 
            "text": "Most commonly used as function argument called  featurePath  This is an  attribute path  for a widget feature.\nIf not said otherwise, the path starts after the  features  key.\nYou'll find this being used very frequently when working with the  LaxarJS Patterns library .", 
            "title": "Feature Path"
        }, 
        {
            "location": "/glossary/#flag", 
            "text": "In the context of  LaxarJS Patterns , a publish/subscribe event announcing a Boolean state to collaborators.\nOften used to toggle visibility of context-dependent UI items, or to enable/disable form elements.  More Information:   LaxarJS Patterns: Flags", 
            "title": "Flag"
        }, 
        {
            "location": "/glossary/#flow", 
            "text": "Routing configuration for a LaxarJS application.\nAssociates URL patterns with pages, and defines their parameters.  More Information:   Manual: Flow and Places  API:  axFlowService", 
            "title": "Flow"
        }, 
        {
            "location": "/glossary/#i18n", 
            "text": "Internationalization:  LaxarJS allows to broadcast changes to application locales and offers a small set of helpers for selecting the correct localization from internationalized values.  More Information:   Manual: i18n", 
            "title": "I18n"
        }, 
        {
            "location": "/glossary/#i18n-object", 
            "text": "For internationalization purposes, many LaxarJS libraries, widgets and controls support so-called  i18n objects  instead of primitive values, in order to support multiple localizations.\nAn i18n object is a map from language tag ( en-US ,  de , etc.) to plain text or HTML markup.\nDepending on the selected locale and resulting language tag, the correct message localization is used.  More Information:   Manual: i18n", 
            "title": "I18n Object"
        }, 
        {
            "location": "/glossary/#integration-technology", 
            "text": "A string that identifies which UI technology a widget or control is built upon.\nLaxarJS comes with support for a single integration technology,  \"plain\" , meaning that an artifact is built using vanilla HTML5/CSS/JavaScript.\nFor any other technology, an appropriate  technology adapter  must be passed to LaxarJS when bootstrapping the application.\nThe LaxarJS project provides adapters for the following integration technologies:  \"angular\"  (for  AngularJS v1 ),  \"angular2\"  (for  Angular 2  and beyond),  \"react\"  (for  React ) and  \"vue\"  (for  Vue.js v2 ).  More Information:   Manual: Widgets and Activities  Manual: Creating an Adapter for a new Widget Technology", 
            "title": "Integration Technology"
        }, 
        {
            "location": "/glossary/#integration-technology-adapter", 
            "text": "A JavaScript module that allows LaxarJS to load widgets and controls written in a specific  integration technology. \nMust be passed to LaxarJS when bootstrapping an application.  More Information:   Manual: Creating an Adapter for a new Widget Technology  laxar-angular-adapter  laxar-angular2-adapter  laxar-react-adapter  laxar-vue-adapter", 
            "title": "Integration Technology Adapter"
        }, 
        {
            "location": "/glossary/#integration-type", 
            "text": "A string used in the widget descriptor to distinguish widgets (integration type  \"widget\" ) from activities (integration type  \"activity\" ).  More Information:   Manual: Widgets and Activities", 
            "title": "Integration Type"
        }, 
        {
            "location": "/glossary/#layout", 
            "text": "A piece of plain old HTML used to render scaffolding HTML, or to arrange widgets contained in page by including one or more  widget areas .  More Information:   Manual: Writing Pages", 
            "title": "Layout"
        }, 
        {
            "location": "/glossary/#laxarjs-patterns", 
            "text": "A library helping to support several standard event patterns for widget collaboration, most importantly  actions, resources,  and  flags.  More Information:   LaxarJS Patterns", 
            "title": "LaxarJS Patterns"
        }, 
        {
            "location": "/glossary/#laxarjs-mocks", 
            "text": "A library that helps to write specification tests  (spec tests)  for widgets and activities.  More Information:   LaxarJS Mocks", 
            "title": "LaxarJS Mocks"
        }, 
        {
            "location": "/glossary/#laxarjs-uikit", 
            "text": "A library containing the LaxarJS default theme (a slightly extended Bootstrap 3, plus Font Awesome) as well as JavaScript helper functions for locale-aware parsing and formatting of numbers and dates.  More Information:   LaxarJS UiKit", 
            "title": "LaxarJS UiKit"
        }, 
        {
            "location": "/glossary/#lifecycle", 
            "text": "Standard event sequence that is published by the LaxarJS runtime from the instant a page is entered...   beginLifecycleRequest  didNavigate   ...until it is replaced by the next page:   navigateRequest  endLifecycleRequest .   More Information:   Manual: Events", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/glossary/#topic", 
            "text": "Fragment of an event name when split by  .  (dot).\nMore specifically, the \"middle\" part of pattern event names (actions, resources, flags) that is used within page definitions in order to connect collaborating widgets.\nAlso called topic ID in this context.", 
            "title": "Topic"
        }, 
        {
            "location": "/glossary/#page", 
            "text": "Configuration for a set of LaxarJS widgets, activities and possibly nested compositions that are run at the same time.\nAlso contains a reference to a main layout, and possibly to additional nested layouts, in order to visually arrange the widgets.", 
            "title": "Page"
        }, 
        {
            "location": "/glossary/#place", 
            "text": "An entry in a flow definition.\nBinds one or more URL patterns to either a page, or to a redirect.", 
            "title": "Place"
        }, 
        {
            "location": "/glossary/#publishsubscribe", 
            "text": "Architectural pattern used for communication of components within LaxarJS applications.", 
            "title": "Publish/Subscribe"
        }, 
        {
            "location": "/glossary/#resource", 
            "text": "In the context of  LaxarJS Patterns , a publish/subscribe event broadcasting application state to collaborators.  More Information:   LaxarJS Patterns: Resources", 
            "title": "Resource"
        }, 
        {
            "location": "/glossary/#theme", 
            "text": "A named collection of CSS styles that define the look and feel of a LaxarJS application.\nBy default, LaxarJS applications use the  default.theme  which is just Bootstrap 3 plus Font Awesome.\nCustom themes can modify the Bootstrap styling or completely replace it, e.g. by using  Material Design .\nWidgets should always define styles for the  default.theme .  More Information:   Creating Themes", 
            "title": "Theme"
        }, 
        {
            "location": "/glossary/#widget", 
            "text": "Main building block within a LaxarJS application.\nProvides and-user functionality within its area of the screen.  More Information:   LaxarJS Core Concepts  Manual: Widgets and Activities", 
            "title": "Widget"
        }, 
        {
            "location": "/glossary/#widget-adapter", 
            "text": "See  Integration Technology Adapter .", 
            "title": "Widget Adapter"
        }, 
        {
            "location": "/glossary/#widget-area", 
            "text": "An anchor for nested widgets that is provided by layouts and sometimes by widgets.\nEach widget area is attached to a DOM node and its contents are determined by the page configuration.\nWidget areas even allow nesting widgets that were created in different  integration technologies .  More Information:   Manual: Writing Pages  API:  axAreaHelper", 
            "title": "Widget Area"
        }, 
        {
            "location": "/glossary/#widget-descriptor", 
            "text": "The contents of a JSON file (called  widget.json ) containing meta information about a widget.\nThe descriptor defines the  name ,  integration type and technology , and the  widget features  that may be configured.\nIt may also specify a  styleSource  and/or  templateSource  if the widget deviates from the defaults, e.g. when using SCSS.  More Information:   Manual: Widgets and Activities", 
            "title": "Widget Descriptor"
        }, 
        {
            "location": "/glossary/#widget-directory", 
            "text": "File system directory containing a widget with its descriptor, implementation module, and assets.  More Information:   Manual: Widgets and Activities", 
            "title": "Widget Directory"
        }, 
        {
            "location": "/glossary/#widget-features", 
            "text": "When a widget is  instantiated  within a page, runtime configuration is passed to the widget controller through the  axFeatures  injection.\nThe  widget descriptor  may specify and document what feature configuration is allowed by providing a JSON schema under its  features  property.  More Information:   Manual: Widgets and Activities  Manual: Writing Pages  API:  axFeatures", 
            "title": "Widget Features"
        }, 
        {
            "location": "/glossary/#widget-instance", 
            "text": "Each widget is a  blueprint  that can be instantiated on any number of pages, or even multiple times within a single page.\nEach of those instances has its own configuration, its own ID, and its own container node in the browser DOM.", 
            "title": "Widget Instance"
        }, 
        {
            "location": "/glossary/#widget-services-widget-injections", 
            "text": "To use service APIs provided by LaxarJS, most importantly the event bus, widgets and activities request them to be injected into their controller.\nThe specific syntax for this depends on the integration technology.\nLaxarJS does not use a fancy dependency injection (DI) framework for this, just a simple registry of known services.\nHowever, technology adapters may hook into the DI of their respective framework to enrich it with the LaxarJS services.  More Information:   Manual: Widget Services  API: Widget Services", 
            "title": "Widget Services, Widget Injections"
        }, 
        {
            "location": "/glossary/#yeoman-yeoman-generator", 
            "text": "Yeoman  is a general purpose  scaffolding tool  that allows to create new software artifacts based on a template, and interactive dialogues to fill in the blanks.\nThe  Yeoman Generator for LaxarJS  is a plugin for Yeoman that helps to create LaxarJS applications, widgets, activities and controls.", 
            "title": "Yeoman, Yeoman Generator"
        }, 
        {
            "location": "/troubleshooting/", 
            "text": "LaxarJS Troubleshooting\n\n\nBy its nature, LaxarJS tries to be forgiving and not impose a lot of restrictions on application developers.\nThe publish/subscribe model ensures loose coupling and prevents failure of individual components from propagating throughout an application.\n\n\nHowever, precisely because LaxarJS applications are loosely coupled and forgiving, in some cases problems are not noticed right away.\nAnd in some circumstances, misconfigurations may be hard to detect.\nThis guide serves as a quick checklist to avoid known \"gotchas\".\n\n\nGeneral Development Tips\n\n\nFirst, here are a couple of development tips that hopefully help you avoid having to ever use the troubleshooting section below.\n\n\nYeoman Generators\n\n\nUsing the \nLaxarJS Yeoman Generators\n is a simple way to get started with a working application.\nMaking incremental changes from there will help you to pinpoint any problems to their cause.\nIn fact, it is a good practice to create a commit in Git (or a VCS of choice) right after finishing the application generator, to establish a working baseline.\n\n\nLog Level\n\n\nDuring development of your application, set the LaxarJS logging level to \"DEBUG\" or \"TRACE\".\nThe default level is \"INFO\", which is appropriate for production.\nLaxarJS itself logs its lifecycle messages in \"TRACE\", so make sure to enable it if you have problems with the overall setup of your application.\nTo enable \"TRACE\" logging, set \nlogging: { level: 'TRACE' }\n in the configuration option that you pass to \nlaxar.create\n, usually in your \ninit.js\n.\n\n\nUse the Developer Tools Extension\n\n\nFor Google Chrome, there is a \ndeveloper tools extension\n that helps to inspect the setup of your pages and to verify that your widgets are connected correctly.\nIt also allows to inspect event bus events with their payload.\n\n\nWrite JSON Schemas for Widget Features\n\n\nWith LaxarJS v2 it is optional to add a JSON schema to your widget feature configuration.\nHowever, once you are confident that your widget configuration interface is somewhat stable, take a moment to create a JSON schema, both as documentation and for improved reliability.\n\n\nTroubleshooting\n\n\nSometimes you follow all the best practices and still run into problems.\nHere are a few pointers to follow if things are going wrong:\n\n\nThere are no errors, just a blank Page\n\n\nThis is most commonly a problem with the routing setup.\nEnsure that the router actually matches against the browser location.\nFor example, if you are using hash-based-URLs for routing, set \nrouter: { navigo: { useHash: true } }\n.", 
            "title": "LaxarJS Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/#laxarjs-troubleshooting", 
            "text": "By its nature, LaxarJS tries to be forgiving and not impose a lot of restrictions on application developers.\nThe publish/subscribe model ensures loose coupling and prevents failure of individual components from propagating throughout an application.  However, precisely because LaxarJS applications are loosely coupled and forgiving, in some cases problems are not noticed right away.\nAnd in some circumstances, misconfigurations may be hard to detect.\nThis guide serves as a quick checklist to avoid known \"gotchas\".", 
            "title": "LaxarJS Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/#general-development-tips", 
            "text": "First, here are a couple of development tips that hopefully help you avoid having to ever use the troubleshooting section below.", 
            "title": "General Development Tips"
        }, 
        {
            "location": "/troubleshooting/#yeoman-generators", 
            "text": "Using the  LaxarJS Yeoman Generators  is a simple way to get started with a working application.\nMaking incremental changes from there will help you to pinpoint any problems to their cause.\nIn fact, it is a good practice to create a commit in Git (or a VCS of choice) right after finishing the application generator, to establish a working baseline.", 
            "title": "Yeoman Generators"
        }, 
        {
            "location": "/troubleshooting/#log-level", 
            "text": "During development of your application, set the LaxarJS logging level to \"DEBUG\" or \"TRACE\".\nThe default level is \"INFO\", which is appropriate for production.\nLaxarJS itself logs its lifecycle messages in \"TRACE\", so make sure to enable it if you have problems with the overall setup of your application.\nTo enable \"TRACE\" logging, set  logging: { level: 'TRACE' }  in the configuration option that you pass to  laxar.create , usually in your  init.js .", 
            "title": "Log Level"
        }, 
        {
            "location": "/troubleshooting/#use-the-developer-tools-extension", 
            "text": "For Google Chrome, there is a  developer tools extension  that helps to inspect the setup of your pages and to verify that your widgets are connected correctly.\nIt also allows to inspect event bus events with their payload.", 
            "title": "Use the Developer Tools Extension"
        }, 
        {
            "location": "/troubleshooting/#write-json-schemas-for-widget-features", 
            "text": "With LaxarJS v2 it is optional to add a JSON schema to your widget feature configuration.\nHowever, once you are confident that your widget configuration interface is somewhat stable, take a moment to create a JSON schema, both as documentation and for improved reliability.", 
            "title": "Write JSON Schemas for Widget Features"
        }, 
        {
            "location": "/troubleshooting/#troubleshooting", 
            "text": "Sometimes you follow all the best practices and still run into problems.\nHere are a few pointers to follow if things are going wrong:", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/troubleshooting/#there-are-no-errors-just-a-blank-page", 
            "text": "This is most commonly a problem with the routing setup.\nEnsure that the router actually matches against the browser location.\nFor example, if you are using hash-based-URLs for routing, set  router: { navigo: { useHash: true } } .", 
            "title": "There are no errors, just a blank Page"
        }, 
        {
            "location": "/why_laxar/", 
            "text": "Why LaxarJS?\n\n\nLaxarJS started out to address problems when trying to create \nhuge applications\n in AngularJS, spanning teams or organizations.\nWhile the situation was somewhat improved with Angular v2 and with components for AngularJS v1, we found that it actually makes a lot of sense to decouple your application components independent from the UI technology that you may be using today.\n\n\nUsing the event bus together with small adapter plugins allows to \nbridge into various view technologies\n such as Angular, React or Vue. LaxarJS helps you split your application into isolated, manageable components that may be reused in different contexts.\nBecause LaxarJS allows components to collaborate without prior knowledge of each other by using publish/subscribe, you may think of it as the missing \nmiddleware for the web client\n.\n\n\nHow LaxarJS Addresses the Complexity Issue\n\n\nAt its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an \nevent bus\n that allows components (called \nwidgets\n) to communicate without knowing each other.\n\n\nThe Event Bus Decouples Widgets\n\n\nWidgets may \npublish\n application resources and \nsubscribe\n to changes of those resources without knowing about their mutual state.\nFor example, in a web shop one widget might represent the shopping cart while another widget resembling the catalog would add articles to the shopping cart by publishing the respective events.\nEach of the two widgets has its own view of the \nsame\n shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.\n\n\nAfter a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a \ncheck out\n button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would then \nreact\n to the event and later publish its own event to indicate that the action was performed successfully.\n\n\nThere is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation, \nrelaxing\n the tight constraints and dependencies imposed by traditional programmatic APIs.\n\n\nThe Runtime Composes Widgets\n\n\nIn the application, widgets are connected to each other in a declarative fashion using JSON \npage definitions\n.\nThe \nLaxarJS runtime\n is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets such as HTML and CSS.\n\n\nIndividual pages are interrelated through a \nflow definition\n which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.\n\n\nLaxarJS and Unidirectional Flow\n\n\nTo address the complexity problem from the perspective of view frameworks, people came up with state management patterns such as \nflux\n and \nredux\n.\nThese patterns are modeled around the concept of a unidirectional flow: \nstate\n (application data) flows \"down\" from business components (stores) to UI components, forming the only source of truth for rendering.\nActions triggered by the user on the other hand flow \"up\" from the view to the stores where they trigger state modifications, ultimately leading to another render cycle.\n\n\nThis architecture actually works really well for LaxarJS applications, where activities serve as natural state containers while widgets assume the role of the view components.\nThe event bus is then used to transport resources (state) from activities to widgets, and actions in the other direction, using standard LaxarJS event patterns.\n\n\nHowever, since widgets and activities form isolated silos within your application, you don't have to adopt a flux-style data flow everywhere at once.\nMost of the time, these application slices are small enough that any straightforward approach to render a user interface using a modern view framework will work well.\n\n\nThe Best of Many Worlds\n\n\nBuilding upon the thriving ecosystem of web standards and view technologies, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.\n\n\nIf this draws your interest, learn more about the LaxarJS \nkey concepts\n or jump in at the deep end by writing your first \nLaxarJS\n application.", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#why-laxarjs", 
            "text": "LaxarJS started out to address problems when trying to create  huge applications  in AngularJS, spanning teams or organizations.\nWhile the situation was somewhat improved with Angular v2 and with components for AngularJS v1, we found that it actually makes a lot of sense to decouple your application components independent from the UI technology that you may be using today.  Using the event bus together with small adapter plugins allows to  bridge into various view technologies  such as Angular, React or Vue. LaxarJS helps you split your application into isolated, manageable components that may be reused in different contexts.\nBecause LaxarJS allows components to collaborate without prior knowledge of each other by using publish/subscribe, you may think of it as the missing  middleware for the web client .", 
            "title": "Why LaxarJS?"
        }, 
        {
            "location": "/why_laxar/#how-laxarjs-addresses-the-complexity-issue", 
            "text": "At its core, LaxarJS is built around the publish/subscribe-pattern:\nIt provides an  event bus  that allows components (called  widgets ) to communicate without knowing each other.", 
            "title": "How LaxarJS Addresses the Complexity Issue"
        }, 
        {
            "location": "/why_laxar/#the-event-bus-decouples-widgets", 
            "text": "Widgets may  publish  application resources and  subscribe  to changes of those resources without knowing about their mutual state.\nFor example, in a web shop one widget might represent the shopping cart while another widget resembling the catalog would add articles to the shopping cart by publishing the respective events.\nEach of the two widgets has its own view of the  same  shopping cart resource synchronizing state by way of events.\nBoth widgets would still be able to perform their respective function without the other being on the same page.  After a user interaction, widgets may publish the need for some other widget to take an action, if that is outside of their own responsibility.\nApplied to the previous example, a shopping cart widget would provide a  check out  button.\nOn click of that button, the widget would simply publish a request for action as an event, because it is not responsible for the actual ordering process, which might involve navigation, calling a (RESTful) web service and so on.\nA separate component would then  react  to the event and later publish its own event to indicate that the action was performed successfully.  There is no need to decide upfront which widgets talk about the same resources and actions.\nWidgets may be developed and tested completely in isolation,  relaxing  the tight constraints and dependencies imposed by traditional programmatic APIs.", 
            "title": "The Event Bus Decouples Widgets"
        }, 
        {
            "location": "/why_laxar/#the-runtime-composes-widgets", 
            "text": "In the application, widgets are connected to each other in a declarative fashion using JSON  page definitions .\nThe  LaxarJS runtime  is responsible for loading and instantiating all widgets configured on the current page and to orchestrate them throughout the page lifecycle.\nAdditionally, it performs the task of loading static assets such as HTML and CSS.  Individual pages are interrelated through a  flow definition  which tells the runtime how to handle URLs and how to navigate between pages.\nLike pages, flows are written in a simple JSON format.", 
            "title": "The Runtime Composes Widgets"
        }, 
        {
            "location": "/why_laxar/#laxarjs-and-unidirectional-flow", 
            "text": "To address the complexity problem from the perspective of view frameworks, people came up with state management patterns such as  flux  and  redux .\nThese patterns are modeled around the concept of a unidirectional flow:  state  (application data) flows \"down\" from business components (stores) to UI components, forming the only source of truth for rendering.\nActions triggered by the user on the other hand flow \"up\" from the view to the stores where they trigger state modifications, ultimately leading to another render cycle.  This architecture actually works really well for LaxarJS applications, where activities serve as natural state containers while widgets assume the role of the view components.\nThe event bus is then used to transport resources (state) from activities to widgets, and actions in the other direction, using standard LaxarJS event patterns.  However, since widgets and activities form isolated silos within your application, you don't have to adopt a flux-style data flow everywhere at once.\nMost of the time, these application slices are small enough that any straightforward approach to render a user interface using a modern view framework will work well.", 
            "title": "LaxarJS and Unidirectional Flow"
        }, 
        {
            "location": "/why_laxar/#the-best-of-many-worlds", 
            "text": "Building upon the thriving ecosystem of web standards and view technologies, LaxarJS tries to simplify organizing, re-using and even sharing the larger building blocks of your applications.  If this draws your interest, learn more about the LaxarJS  key concepts  or jump in at the deep end by writing your first  LaxarJS  application.", 
            "title": "The Best of Many Worlds"
        }, 
        {
            "location": "/api/", 
            "text": "API Documentation\n\n\nThis API documentation serves as a reference to the public APIs exposed by LaxarJS.\nIf you are new to LaxarJS, you might wish to check out the \nmanuals\n first.\n\n\nHere are the most important starting points for LaxarJS API documentation:\n\n\n\n\n\n\nThe \nlaxar\n module API\n - The small portion of LaxarJS that is actually exposed through module exports, including \ncreate()\n.\n\n\n\n\n\n\nThe \nWidget Services\n - Named injections available to widgets: \naxEventBus\n, \naxFeatures\n, \u2026\n\n\n\n\n\n\nThe \nWidget Service Mocks\n - Factory functions to create configurable mocks for widget services.\n  In tests, use these rather than the actual widget services.\n  Automatically used when testing widgets with \nLaxarJS Mocks\n.", 
            "title": "Overview"
        }, 
        {
            "location": "/api/#api-documentation", 
            "text": "This API documentation serves as a reference to the public APIs exposed by LaxarJS.\nIf you are new to LaxarJS, you might wish to check out the  manuals  first.  Here are the most important starting points for LaxarJS API documentation:    The  laxar  module API  - The small portion of LaxarJS that is actually exposed through module exports, including  create() .    The  Widget Services  - Named injections available to widgets:  axEventBus ,  axFeatures , \u2026    The  Widget Service Mocks  - Factory functions to create configurable mocks for widget services.\n  In tests, use these rather than the actual widget services.\n  Automatically used when testing widgets with  LaxarJS Mocks .", 
            "title": "API Documentation"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/", 
            "text": "adapter_utilities\n\n\nSeveral factory methods for creating error objects that are useful for almost any adapter.\n\n\nContents\n\n\nModule Members\n\n\n\n\nactivityAccessingDom()\n\n\nunknownInjection()\n\n\nunknownWidget()\n\n\n\n\nTypes\n\n\n\n\nAdapterUtilities\n\n\n\n\nModule Members\n\n\nactivityAccessingDom( details )\n\n\nCreates (but does not throw) an error indicating that an activity tried accessing the DOM.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetails\n\n\nObject\n\n\ndetails for the error\n\n\n\n\n\n\ndetails.technology\n\n\nString\n\n\nthe complaining adapter's technology\n\n\n\n\n\n\ndetails.widgetName\n\n\nString\n\n\nthe canonical name of the activity causing the problem\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nError\n\n\nthe error, ready to throw\n\n\n\n\n\n\n\n\nunknownInjection( details )\n\n\nCreates (but does not throw) an error indicating that a widget requested an injection that cannot be\nprovided by the adapter.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetails\n\n\nObject\n\n\ndetails for the error\n\n\n\n\n\n\ndetails.technology\n\n\nString\n\n\nthe complaining adapter's technology\n\n\n\n\n\n\ndetails.injection\n\n\nString\n\n\nthe failing injection\n\n\n\n\n\n\ndetails.widgetName\n\n\nString\n\n\nthe canonical name of the widget causing the problem\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nError\n\n\nthe error, ready to throw\n\n\n\n\n\n\n\n\nunknownWidget( details )\n\n\nCreates (but does not throw) an error indicating that a widget was not registered with the current\nadapter.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndetails\n\n\nObject\n\n\ndetails for the error\n\n\n\n\n\n\ndetails.technology\n\n\nString\n\n\nthe complaining adapter's technology\n\n\n\n\n\n\ndetails.widgetName\n\n\nString\n\n\nthe canonical name of the missing widget\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nError\n\n\nthe error, ready to throw\n\n\n\n\n\n\n\n\nTypes\n\n\nAdapterUtilities\n\n\nProvides access to the configuration that was passed during application bootstrapping.\n\n\nA \nConfiguration\n instance provides convenient readonly access to the underlying LaxarJS\napplication bootstrapping configuration. The configuration values are passed to\n\nlaxar#create()\n on startup (before LaxarJS v2.x, these configuration values were read from\n\nwindow.laxar\n). When using the LaxarJS application template, the configuration values are set in the\nfile \ninit.js\n under your project's root directory.", 
            "title": "adapter_utilities"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#contents", 
            "text": "Module Members   activityAccessingDom()  unknownInjection()  unknownWidget()   Types   AdapterUtilities", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#parameters", 
            "text": "Property  Type  Description      details  Object  details for the error    details.technology  String  the complaining adapter's technology    details.widgetName  String  the canonical name of the activity causing the problem", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#returns", 
            "text": "Type  Description      Error  the error, ready to throw", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#parameters_1", 
            "text": "Property  Type  Description      details  Object  details for the error    details.technology  String  the complaining adapter's technology    details.injection  String  the failing injection    details.widgetName  String  the canonical name of the widget causing the problem", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#returns_1", 
            "text": "Type  Description      Error  the error, ready to throw", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#parameters_2", 
            "text": "Property  Type  Description      details  Object  details for the error    details.technology  String  the complaining adapter's technology    details.widgetName  String  the canonical name of the missing widget", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#returns_2", 
            "text": "Type  Description      Error  the error, ready to throw", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.adapter_utilities/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/utilities.assert/", 
            "text": "assert\n\n\nThe \nassert\n module provides some simple assertion methods for type checks, truthyness tests and guards\ninvalid code paths.\nWhen importing the module as \ndefault\n module, it is the \nassert\n function itself.\n\n\nIt can be imported as \nassert\n from 'laxar';\n\n\nContents\n\n\nModule Members\n\n\n\n\nassert()\n\n\n\n\nTypes\n\n\n\n\n\n\nAssertion\n\n\n\n\nAssertion.isNotNull()\n\n\nAssertion.hasType()\n\n\nAssertion.hasProperty()\n\n\n\n\n\n\n\n\nassert\n\n\n\n\nassert.codeIsUnreachable()\n\n\nassert.state()\n\n\n\n\n\n\n\n\nModule Members\n\n\nassert( subject, optionalDetails )\n\n\nCreates and returns a new \nAssertion\n instance for the given \nsubject\n.\n\n\nNote\n: this function is no member of the module, but the module itself. Thus when using \nassert\n via\nlaxar, \nassert\n is will be no simple object, but this function having the other functions as\nproperties.\n\n\nExample:\n\n\nimport\n \n{\n \nassert\n \n}\n \nfrom\n \nlaxar\n;\n\n\nassert\n(\n \nassert\n \n).\nhasType\n(\n \nFunction\n \n);\n\n\nassert\n.\nstate\n(\n \ntypeof\n \nassert\n.\ncodeIsUnreachable\n \n===\n \nfunction\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsubject\n\n\n*\n\n\nthe object assertions are made for\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails that should be printed in case no specific details are given when calling an assertion method\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthe assertion instance\n\n\n\n\n\n\n\n\nTypes\n\n\nAssertion\n\n\nAssertion.isNotNull( optionalDetails )\n\n\nThrows an error if the subject is \nnull\n or \nundefined\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthis instance\n\n\n\n\n\n\n\n\nAssertion.hasType( type, optionalDetails )\n\n\nThrows an error if the subject is not of the given type. No error is thrown for \nnull\n or \nundefined\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntype\n\n\nFunction\n\n\nthe expected type of the subject\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthis instance\n\n\n\n\n\n\n\n\nAssertion.hasProperty( property, optionalDetails )\n\n\nThrows an error if the subject is no object or the given property is not defined on it.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nproperty\n\n\nString\n\n\nthe property that is expected for the subject\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAssertion\n\n\nthis instance\n\n\n\n\n\n\n\n\nassert\n\n\nassert.codeIsUnreachable( optionalDetails )\n\n\nMarks a code path as erroneous by throwing an error when reached.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message\n\n\n\n\n\n\n\n\nassert.state( expression, optionalDetails )\n\n\nThrows an error if the given expression is falsy.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexpression\n\n\n*\n\n\nthe expression to test for truthyness\n\n\n\n\n\n\noptionalDetails\n\n\nString\n\n\ndetails to append to the error message", 
            "title": "assert"
        }, 
        {
            "location": "/api/utilities.assert/#contents", 
            "text": "Module Members   assert()   Types    Assertion   Assertion.isNotNull()  Assertion.hasType()  Assertion.hasProperty()     assert   assert.codeIsUnreachable()  assert.state()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/utilities.assert/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/utilities.assert/#parameters", 
            "text": "Property  Type  Description      subject  *  the object assertions are made for    optionalDetails  String  details that should be printed in case no specific details are given when calling an assertion method", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.assert/#returns", 
            "text": "Type  Description      Assertion  the assertion instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.assert/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/utilities.assert/#parameters_1", 
            "text": "Property  Type  Description      optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.assert/#returns_1", 
            "text": "Type  Description      Assertion  this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.assert/#parameters_2", 
            "text": "Property  Type  Description      type  Function  the expected type of the subject    optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.assert/#returns_2", 
            "text": "Type  Description      Assertion  this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.assert/#parameters_3", 
            "text": "Property  Type  Description      property  String  the property that is expected for the subject    optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.assert/#returns_3", 
            "text": "Type  Description      Assertion  this instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.assert/#parameters_4", 
            "text": "Property  Type  Description      optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.assert/#parameters_5", 
            "text": "Property  Type  Description      expression  *  the expression to test for truthyness    optionalDetails  String  details to append to the error message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.browser/", 
            "text": "browser\n\n\nModule providing the Browser factory.\n\n\nProvides abstractions for browser APIs used internally by LaxarJS, which might need a different\nimplementation in a server-side environment, or for testing.\nThis service is internal to LaxarJS and not available to widgets and activities.\n\n\nContents\n\n\nTypes\n\n\n\n\nBrowser\n\n\nBrowser.resolve()\n\n\nBrowser.location()\n\n\nBrowser.fetch()\n\n\nBrowser.console()\n\n\n\n\n\n\n\n\nTypes\n\n\nBrowser\n\n\nA brower mostly abstracts over the location-related DOM window APIs, and provides a console wrapper.\nSince it is internal to LaxarJS, only relevant APIs are included.\n\n\nBrowser.resolve( url, baseUrl )\n\n\nCalculates an absolute URL from a (relative) URL, and an optional base URL.\n\n\nIf no base URL is given, the \ndocument.baseURI\n is used instead. The given base URL may also be\nrelative, in which case it is resolved against the \ndocument.baseURI\n before resolving the first URL.\n\n\nFor browser environments that do not support the \nnew URL( url, baseUrl )\n constructor for resolving\nURLs or that do not support \ndocument.baseURI\n, fallback mechanisms are used.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nurl\n\n\nString\n\n\nthe URL to resolve\n\n\n\n\n\n\nbaseUrl\n\n\nString\n\n\nthe base to resolve from\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nan absolute URL based on the given URL\n\n\n\n\n\n\n\n\nBrowser.location()\n\n\nProvides easily mocked access to \nwindow.location\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLocation\n\n\nthe current (window's) DOM location\n\n\n\n\n\n\n\n\nBrowser.fetch( input, init )\n\n\nProvides easily mocked access to \nwindow.fetch\n or a suitable polyfill:\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninput\n\n\nString\n, \nRequest\n\n\nthe URL to fetch or the request to perform\n\n\n\n\n\n\ninit\n\n\nObject\n\n\nadditional options, described here in more detail: https://developer.mozilla.org/en-US/docs/Web/API/Globalfetch/fetch#Parameters\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise.\nResponse\n\n\nthe resulting promise\n\n\n\n\n\n\n\n\nBrowser.console()\n\n\nProvides easily mocked access to \nwindow.console\n:\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nConsole\n\n\nthe browser console promise", 
            "title": "browser"
        }, 
        {
            "location": "/api/runtime.browser/#contents", 
            "text": "Types   Browser  Browser.resolve()  Browser.location()  Browser.fetch()  Browser.console()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.browser/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.browser/#parameters", 
            "text": "Property  Type  Description      url  String  the URL to resolve    baseUrl  String  the base to resolve from", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.browser/#returns", 
            "text": "Type  Description      String  an absolute URL based on the given URL", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.browser/#returns_1", 
            "text": "Type  Description      Location  the current (window's) DOM location", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.browser/#parameters_1", 
            "text": "Property  Type  Description      input  String ,  Request  the URL to fetch or the request to perform    init  Object  additional options, described here in more detail: https://developer.mozilla.org/en-US/docs/Web/API/Globalfetch/fetch#Parameters", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.browser/#returns_2", 
            "text": "Type  Description      Promise. Response  the resulting promise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.browser/#returns_3", 
            "text": "Type  Description      Console  the browser console promise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.configuration/", 
            "text": "configuration\n\n\nModule providing the Configuration factory.\n\n\nTo use the Configuration in a widget, request the \naxConfiguration\n\ninjection. In compatibility mode with LaxarJS v1.x, it is also available under \nlaxar.configuration\n.\n\n\nContents\n\n\nTypes\n\n\n\n\nConfiguration\n\n\nConfiguration.get()\n\n\nConfiguration.ensure()\n\n\n\n\n\n\n\n\nTypes\n\n\nConfiguration\n\n\nProvides access to the configuration that was passed during application bootstrapping.\n\n\nA \nConfiguration\n instance provides convenient readonly access to the underlying LaxarJS\napplication bootstrapping configuration. The configuration values are passed to\n\nlaxar#create()\n on startup (before LaxarJS v2.x, these configuration values were read from\n\nwindow.laxar\n). When using the LaxarJS application template, the configuration values are set in the\nfile \ninit.js\n under your project's root directory.\n\n\nConfiguration.get( key, optionalDefault )\n\n\nReturns the configured value for the specified attribute path or \nundefined\n in case it wasn't\nconfigured. If a default value was passed as second argument this is returned instead of \nundefined\n.\n\n\nServices should use this to get configuration values for which there are universal fallback behaviors.\n\n\nExamples:\n\n\n// ... inject `axConfiguration` as `config` ...\n\n\nconfig\n.\nget\n(\n \nlogging.threshold\n \n);\n \n// -\n \nINFO\n\n\nconfig\n.\nget\n(\n \niDontExist\n \n);\n \n// -\n undefined\n\n\nconfig\n.\nget\n(\n \niDontExist\n,\n \n42\n \n);\n \n// -\n 42\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\na path (using \n.\n as separator) to the property in the configuration object\n\n\n\n\n\n\noptionalDefault\n\n\n*\n\n\nthe value to return if no value was set for \nkey\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\neither the configured value, \nundefined\n or \noptionalDefault\n\n\n\n\n\n\n\n\nConfiguration.ensure( key )\n\n\nRetrieves a configuration value by key, failing if it is \nundefined\n or \nnull\n.\n\n\nServices should use this to get configuration values for which no universal default or fallback exists.\n\n\nExamples:\n\n\n// ... inject `axConfiguration` as `config` ...\n\n\nconfig\n.\nensure\n(\n \nlogging.threshold\n \n);\n \n// -\n \nINFO\n\n\nconfig\n.\nensure\n(\n \niDontExist\n \n);\n \n// -\n throws\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\na path (using \n.\n as separator) to the property in the configuration object\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe configured value (if \nundefined\n or \nnull\n, an exception is thrown instead)", 
            "title": "configuration"
        }, 
        {
            "location": "/api/runtime.configuration/#contents", 
            "text": "Types   Configuration  Configuration.get()  Configuration.ensure()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.configuration/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.configuration/#parameters", 
            "text": "Property  Type  Description      key  String  a path (using  .  as separator) to the property in the configuration object    optionalDefault  *  the value to return if no value was set for  key", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.configuration/#returns", 
            "text": "Type  Description      *  either the configured value,  undefined  or  optionalDefault", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.configuration/#parameters_1", 
            "text": "Property  Type  Description      key  String  a path (using  .  as separator) to the property in the configuration object", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.configuration/#returns_1", 
            "text": "Type  Description      *  the configured value (if  undefined  or  null , an exception is thrown instead)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.configuration_mock/", 
            "text": "configuration_mock\n\n\nAllows to create mock implementations of \nConfiguration\n, compatible to the \"axConfiguration\"\ninjection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nModule Members\n\n\ncreate( configByPath )\n\n\nCreates a mock \nConfiguration\n, compatible to the \"axConfiguration\" injection of a widget.\n\n\nThe accessor methods \nget\n and \nensure\n are spied.\n\n\nThe mock behaves just like the actual configuration, except that configuration values may be initialized\nfrom paths, not just regular nested JSON objects. This simplifies mocking of nested configuration such as\n\nlogging.threshold\n. Usage of this feature is optional, nested objects work just as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconfigByPath\n\n\nObject\n\n\npath-to-value mappings for the mock\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nConfiguration\n\n\na fresh mock instance", 
            "title": "configuration_mock"
        }, 
        {
            "location": "/api/testing.configuration_mock/#contents", 
            "text": "Module Members   create()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.configuration_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.configuration_mock/#parameters", 
            "text": "Property  Type  Description      configByPath  Object  path-to-value mappings for the mock", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.configuration_mock/#returns", 
            "text": "Type  Description      Configuration  a fresh mock instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/loaders.control_loader/", 
            "text": "control_loader\n\n\nThe control loader helps to load control assets and implementations.\n\n\nContents\n\n\nTypes\n\n\n\n\nControlLoader\n\n\nControlLoader.provide()\n\n\nControlLoader.load()\n\n\n\n\n\n\n\n\nTypes\n\n\nControlLoader\n\n\nControlLoader.provide( controlRef )\n\n\nProvides the implementation module of the given control, for manual instantiation by a widget.\n\n\nBecause the method must return synchronously, it may only be called for controls that have been\nloaded before (using \n#load()\n)!\nFor controls that are correctly listed in the \ncontrols\n section of the \nwidget.json\n, this is ensured\nby the widget loader.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontrolRef\n\n\nString\n\n\na valid control reference as used in the \nwidget.json\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe module for the requested control reference\n\n\n\n\n\n\n\n\nControlLoader.load( controlRef )\n\n\nFetches the descriptor for a given control reference, and saves it as a side-effect.\nThis is part of the internal API used by the widget loader.\n\n\nThis process must be completed before the descriptor or the module for a control can be provided.\nFor this reason, \nload\n is called by the widget-loader, using information from the \nwidget.json\n file.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontrolRef\n\n\nString\n\n\na valid control reference as used in the \nwidget.json\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\na promise for the (fetched or synthesized) control descriptor", 
            "title": "control_loader"
        }, 
        {
            "location": "/api/loaders.control_loader/#contents", 
            "text": "Types   ControlLoader  ControlLoader.provide()  ControlLoader.load()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/loaders.control_loader/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/loaders.control_loader/#parameters", 
            "text": "Property  Type  Description      controlRef  String  a valid control reference as used in the  widget.json", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/loaders.control_loader/#returns", 
            "text": "Type  Description      *  the module for the requested control reference", 
            "title": "Returns"
        }, 
        {
            "location": "/api/loaders.control_loader/#parameters_1", 
            "text": "Property  Type  Description      controlRef  String  a valid control reference as used in the  widget.json", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/loaders.control_loader/#returns_1", 
            "text": "Type  Description      Promise  a promise for the (fetched or synthesized) control descriptor", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.event_bus/", 
            "text": "event_bus\n\n\nModule providing the EventBus factory.\n\n\nTo use the EventBus in a widget, request the \naxEventBus\n injection, or\nuse the \neventBus\n property on the \naxContext\n injection.\nIn some cases, it may be useful to inject the global EventBus instance backing all widget instances of the\nsame bootstrapping context, by requesting the \naxGlobalEventBus\n\ninjection.\n\n\nContents\n\n\nTypes\n\n\n\n\nEventBus\n\n\nEventBus.addInspector()\n\n\nEventBus.subscribe()\n\n\nEventBus.publish()\n\n\nEventBus.publishAndGatherReplies()\n\n\n\n\n\n\n\n\nTypes\n\n\nEventBus\n\n\nEventBus.addInspector( inspector )\n\n\nAdds an inspector, that gets notified when certain actions within the event bus take place. Currently\nthese actions may occur:\n\n\n\n\nsubscribe\n: a new subscriber registered for an event\n\n\npublish\n: an event is published but not yet delivered\n\n\ndeliver\n: an event is actually delivered to a subscriber\n\n\n\n\nAn inspector receives a map with the following properties:\n\n\n\n\naction\n: one of the actions from above\n\n\nsource\n: the origin of the \naction\n\n\ntarget\n: the name of the event subscriber (\ndeliver\n action only)\n\n\nevent\n: the full name of the event or the subscribed event (\nsubscribe\n action only)\n\n\neventObject\n: the published event item (\npublish\n action only)\n\n\nsubscribedTo\n: the event, possibly with omissions, the subscriber subscribed to (\ndeliver\n action only)\n\n\ncycleId\n: the id of the event cycle\n\n\n\n\nThe function returned by this method can be called to remove the inspector again and prevent it from\nbeing called for future event bus actions.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninspector\n\n\nFunction\n\n\nthe inspector function to add\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function to remove the inspector\n\n\n\n\n\n\n\n\nEventBus.subscribe( eventName, subscriber, optionalOptions )\n\n\nSubscribes to an event by name. An event name consists of so called \ntopics\n, where each topic is\nseparated from another by dots (\n.\n). If a topic is omitted, this is treated as a wildcard. Note that\ntwo dots in the middle or one dot at the beginning of an event name must remain, whereas a dot at the\nend may be omitted. As such every event name has an intrinsic wildcard at its end. For example these are\nall valid event names:\n\n\n\n\nsome.event\n: matches \nsome.event\n, \nsome.event.again\n\n\n.event\n: matches \nsome.event\n, \nany.event\n, \nany.event.again\n\n\nsome..event\n: matches \nsome.fancy.event\n, \nsome.special.event\n\n\n\n\nAdditionally \nsubtopics\n are supported. Subtopics are fragments of a topic, separated from another by\nsimple dashes (\n-\n). Here only suffixes of subtopics may be omitted when subscribing. Thus subscribing\nto \nsome.event\n would match an event published with name \nsome.event-again\n or even\n\nsome.event-another.again\n.\n\n\nThe subscriber function\n\n\nWhen an event is delivered, the subscriber function receives two arguments:\nThe first one is the event object as it was published. If \noptionalOptions.clone\n yields \ntrue\n this is a\nsimple deep copy of the object (note that only properties passing a JSON-(de)serialization remain). If\n\nfalse\n the object is frozen using \nObject.freeze\n recursively.\n\n\nThe second one is a meta object with these properties:\n\n\n\n\nname\n: The name of the event as it actually was published (i.e. without wildcards).\n\n\ncycleId\n: The id of the cycle the event was published (and delivered) in\n\n\nsender\n: The id of the event sender, may be \nnull\n.\n\n\ninitiator\n: The id of the initiator of the cycle. Currently not implemented, thus always \nnull\n.\n\n\noptions\n: The options that were passed to \npublish\n or \npublishAndGatherReplies\n respectively.\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neventName\n\n\nString\n\n\nthe name of the event to subscribe to\n\n\n\n\n\n\nsubscriber\n\n\nFunction\n\n\na function to call whenever an event matching \neventName\n is published\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nadditional options for the subscribe action\n\n\n\n\n\n\noptionalOptions.subscriber=null\n\n\nString\n\n\nthe id of the subscriber. Default is \nnull\n\n\n\n\n\n\noptionalOptions.clone=true\n\n\nBoolean\n\n\nif \nfalse\n the event will be send frozen to the subscriber, otherwise it will receive a deep copy. Default is \ntrue\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function that when called unsubscribes from this subscription again\n\n\n\n\n\n\n\n\nEventBus.publish( eventName, optionalEvent, optionalOptions )\n\n\nAsynchronously publishes an event on the event bus. The returned promise will be enqueued as soon as this\nevent is delivered and, if during delivery a new event was enqueued, resolved after that new event was\ndelivered. If no new event is published during delivery of this event, the promise is instantly resolved.\nTo make this a bit clearer, lets assume we publish and thus enqueue an event at time \nt\n. It then will\nbe delivered at time \nt+1\n. At that precise moment the promise is enqueued to be resolved soon. We then\ndistinguish between two cases:\n\n\n\n\nAt time \nt+1\n no subscriber publishes (i.e. enqueues) an event: Thus there is no event in the same\n  cycle and the promise is also resolved at time \nt+1\n.\n\n\nAt least one subscriber publishes an event at time \nt+1\n: The promise is then scheduled to be resolved\n  as soon as this event is delivered at time \nt+2\n.\n\n\n\n\nThe implication of this is the following:\n\n\nWe have two collaborators, A and B. A listens to event b and B listens to event a.\nWhenever A publishes a and B than instantly (i.e. in the same event cycle of the JavaScript runtime\nwhere its subscriber function was called) \nresponds\n by publishing b, b arrives at the subscriber\nfunction of A, before the promise of A's publish action is resolved.\nIt is hence possible to observe possible effects of an event sent by oneself, under the conditions\nmentioned above. Practically this is used internally for the implementation of\n\n#EventBus.publishAndGatherReplies()\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neventName\n\n\nString\n\n\nthe name of the event to publish\n\n\n\n\n\n\noptionalEvent\n\n\nObject\n\n\nthe event to publish\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nadditional options for the publish action\n\n\n\n\n\n\noptionalOptions.sender=null\n\n\nString\n\n\nthe id of the event sender. Default is \nnull\n\n\n\n\n\n\noptionalOptions.deliverToSender=true\n\n\nBoolean\n\n\nif \nfalse\n the event will not be send to subscribers whose subscriber name matches \noptionalOptions.sender\n, else all subscribers will receive the event. Default is \ntrue\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\nthe delivery promise\n\n\n\n\n\n\n\n\nEventBus.publishAndGatherReplies( eventName, optionalEvent, optionalOptions )\n\n\nPublishes an event that follows the \nrequest-will-did pattern\n and awaits all replies. This pattern has\nevolved over time and is of great use when handling the asynchronous nature of event bus events.\n\n\nCertain rules need to be fulfilled: First the initiator needs to call this method with an event whose\nname has the suffix \nRequest\n, e.g. \ntakeActionRequest\n. All collaborators that want to react to this\nevent then either do so in the same event cycle by sending a \ndidTakeAction\n event or announce that they\nwill do something asynchronously by publishing a \nwillTakeAction\n event. In the latter case they need to\nbroadcast the fulfillment of their action some time later by sending a \ndidTakeAction\n event. Note that for\nboth events the same sender name needs to be given. Otherwise they cannot be mapped and the event bus\ndoesn't know if all asynchronous replies were already received.\n\n\nAdditionally a timer is started using either the globally configured \npendingDidTimeout\n ms value or the\nvalue provided as option to this method. If that timer expires before all \ndid*\n events to all given\n\nwill*\n events were received, the error handler is called to handle the incident and the promise is\nrejected with all responses received up to now.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\neventName\n\n\nString\n\n\nthe name of the event to publish\n\n\n\n\n\n\noptionalEvent\n\n\nObject\n\n\nthe event to publish\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nadditional options for the publish action\n\n\n\n\n\n\noptionalOptions.sender=null\n\n\nString\n\n\nthe id of the event sender. Default is \nnull\n\n\n\n\n\n\noptionalOptions.pendingDidTimeout\n\n\nNumber\n\n\nthe timeout in milliseconds for pending did* events. Default is the timeout option used when the event bus instance was created\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\nthe delivery promise. It receives a list of all collected \ndid*\n events and according meta information", 
            "title": "event_bus"
        }, 
        {
            "location": "/api/runtime.event_bus/#contents", 
            "text": "Types   EventBus  EventBus.addInspector()  EventBus.subscribe()  EventBus.publish()  EventBus.publishAndGatherReplies()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.event_bus/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.event_bus/#parameters", 
            "text": "Property  Type  Description      inspector  Function  the inspector function to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.event_bus/#returns", 
            "text": "Type  Description      Function  a function to remove the inspector", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.event_bus/#parameters_1", 
            "text": "Property  Type  Description      eventName  String  the name of the event to subscribe to    subscriber  Function  a function to call whenever an event matching  eventName  is published    optionalOptions  Object  additional options for the subscribe action    optionalOptions.subscriber=null  String  the id of the subscriber. Default is  null    optionalOptions.clone=true  Boolean  if  false  the event will be send frozen to the subscriber, otherwise it will receive a deep copy. Default is  true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.event_bus/#returns_1", 
            "text": "Type  Description      Function  a function that when called unsubscribes from this subscription again", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.event_bus/#parameters_2", 
            "text": "Property  Type  Description      eventName  String  the name of the event to publish    optionalEvent  Object  the event to publish    optionalOptions  Object  additional options for the publish action    optionalOptions.sender=null  String  the id of the event sender. Default is  null    optionalOptions.deliverToSender=true  Boolean  if  false  the event will not be send to subscribers whose subscriber name matches  optionalOptions.sender , else all subscribers will receive the event. Default is  true", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.event_bus/#returns_2", 
            "text": "Type  Description      Promise  the delivery promise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.event_bus/#parameters_3", 
            "text": "Property  Type  Description      eventName  String  the name of the event to publish    optionalEvent  Object  the event to publish    optionalOptions  Object  additional options for the publish action    optionalOptions.sender=null  String  the id of the event sender. Default is  null    optionalOptions.pendingDidTimeout  Number  the timeout in milliseconds for pending did* events. Default is the timeout option used when the event bus instance was created", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.event_bus/#returns_3", 
            "text": "Type  Description      Promise  the delivery promise. It receives a list of all collected  did*  events and according meta information", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.event_bus_mock/", 
            "text": "event_bus_mock\n\n\nAllows to create mock implementations of \nEventBus\n, compatible to the \"axEventBus\" and\n\"axGlobalEventBus\" injections.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nEventBusMock\n\n\nEventBusMock.flush\n\n\nEventBusMock.drainAsync()\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( options )\n\n\nCreates a mock \nEventBus\n, compatible to the \"axEventBus\" injection of a widget.\n\n\nIf no custom tick-scheduler function is passed through the options, the returned event bus has a method\n\nflush\n, to synchronously deliver all pending as well as synchronously added events. It also has a method\ndrainAsync` to asynchronously run event handlers to completion, including additional asynchronously\npublished events.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nObject\n\n\nadditional options\n\n\n\n\n\n\noptions.nextTick\n\n\nObject\n\n\nan alternative callback for scheduling the next event bus cycle (such as window.setTimeout)\n\n\n\n\n\n\noptions.errorHandler\n\n\nObject\n\n\nan alternative error handler, e.g. to inspect error conditions during test. By default, exceptions thrown by subscribers to the mock will be reported using \nwindow.console.error\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nEventBusMock\n\n\na fresh mock instance\n\n\n\n\n\n\n\n\nTypes\n\n\nEventBusMock\n\n\n\n\nextends \nEventBus\n\n\n\n\nA mock version of \nEventBus\n.\n\n\nOffers spied-upon version of the usual axEventBus methods, including a spy on the unsubscribe-callback\nreturned by \nsubscribe\n. Also has as a \nflush\n method for synchronous scheduling of events, and a\n\ndrainAsync\n to asynchronously run event handlers to completion.\n\n\nEventBusMock.flush \nundefined\n\n\nFlushes all pending events and runs their subscriber callbacks.\nIf new events are published synchronously from subscriber callbacks, these will also be processed.\n\n\nThis operation happens synchronously, so asynchronously triggered events (e.g. those published from a\nthen handler) may not be processed.\n\n\nEventBusMock.drainAsync()\n\n\nAsynchronously flushes pending events and runs their subscriber callbacks.\nIf new events are published synchronously from subscriber callbacks, these will also be processed.\nAdditionally, if new events are published asynchronously but immediately (i.e. right after a call to\nPromise.resolve), they will be processed as well.\n\n\nThis operation happens \nasynchronously\n, so callers need to wait on the returned promise in order to\nobserve the effects.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\na promise that is resolved when all events have been processed, and no more have been scheduled", 
            "title": "event_bus_mock"
        }, 
        {
            "location": "/api/testing.event_bus_mock/#contents", 
            "text": "Module Members   create()   Types   EventBusMock  EventBusMock.flush  EventBusMock.drainAsync()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.event_bus_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.event_bus_mock/#parameters", 
            "text": "Property  Type  Description      options  Object  additional options    options.nextTick  Object  an alternative callback for scheduling the next event bus cycle (such as window.setTimeout)    options.errorHandler  Object  an alternative error handler, e.g. to inspect error conditions during test. By default, exceptions thrown by subscribers to the mock will be reported using  window.console.error", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.event_bus_mock/#returns", 
            "text": "Type  Description      EventBusMock  a fresh mock instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.event_bus_mock/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/testing.event_bus_mock/#returns_1", 
            "text": "Type  Description      Promise  a promise that is resolved when all events have been processed, and no more have been scheduled", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.flow_service/", 
            "text": "flow_service\n\n\nModule providing the FlowService factory.\n\n\nTo access the FlowService in a widget, request the \naxFlowService\n\ninjection.\n\n\nContents\n\n\nTypes\n\n\n\n\nFlowService\n\n\nFlowService.constructAbsoluteUrl()\n\n\n\n\n\n\n\n\nTypes\n\n\nFlowService\n\n\nAllows widgets to create valid URLs without knowledge about the current place, its routing patterns, or\nabout the actual routing implementation.\n\n\nFlowService.constructAbsoluteUrl( targetOrPlace, optionalParameters )\n\n\nConstructs an absolute URL to the given target or place using the given parameters. If a target is\ngiven as first argument, it is resolved using the currently active place.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntargetOrPlace\n\n\nString\n\n\nthe target or place ID to construct a URL for\n\n\n\n\n\n\noptionalParameters\n\n\nObject\n\n\noptional map of place parameters. Missing parameters are filled base on the parameters that were passed to the currently active place\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe generated absolute URL", 
            "title": "flow_service"
        }, 
        {
            "location": "/api/runtime.flow_service/#contents", 
            "text": "Types   FlowService  FlowService.constructAbsoluteUrl()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.flow_service/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.flow_service/#parameters", 
            "text": "Property  Type  Description      targetOrPlace  String  the target or place ID to construct a URL for    optionalParameters  Object  optional map of place parameters. Missing parameters are filled base on the parameters that were passed to the currently active place", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.flow_service/#returns", 
            "text": "Type  Description      String  the generated absolute URL", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.flow_service_mock/", 
            "text": "flow_service_mock\n\n\nAllows to create mock implementations of \nFlowService\n, compatible to the \"axFlowService\" injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nAxFlowServiceMock\n\n\n\n\nModule Members\n\n\ncreate( dependencies={} )\n\n\nCreates a mock for the \naxFlowService\n injection of a widget.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndependencies={}\n\n\nObject\n\n\noptional service dependencies to be used by the mock flow service\n\n\n\n\n\n\ndependencies.browser\n\n\nAxBrowser\n\n\na (mock) browser to resolve the location when creating absolute mock URLs\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxFlowServiceMock\n\n\na mock of \naxFlowService\n that can be spied and/or mocked with additional items\n\n\n\n\n\n\n\n\nTypes\n\n\nAxFlowServiceMock\n\n\n\n\nextends \nAxFlowService\n\n\n\n\nA mock version of the \nFlowService\n that does not rely on an actual flow definition.\n\n\nBy default, the mock will simply return '/mockPath' for any call to \nconstructPath\n, and the remaining\nmethods behave accordingly. All methods are spies, so their arguments may be inspected and their return\nvalue may be modified using \nand.callFake\n.", 
            "title": "flow_service_mock"
        }, 
        {
            "location": "/api/testing.flow_service_mock/#contents", 
            "text": "Module Members   create()   Types   AxFlowServiceMock", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.flow_service_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.flow_service_mock/#parameters", 
            "text": "Property  Type  Description      dependencies={}  Object  optional service dependencies to be used by the mock flow service    dependencies.browser  AxBrowser  a (mock) browser to resolve the location when creating absolute mock URLs", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.flow_service_mock/#returns", 
            "text": "Type  Description      AxFlowServiceMock  a mock of  axFlowService  that can be spied and/or mocked with additional items", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.flow_service_mock/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.heartbeat/", 
            "text": "heartbeat\n\n\nModule providing the Heartbeat factory.\n\n\nTo use the Heartbeat service in a widget, request the \naxHeartbeat\n\ninjection.\n\n\nContents\n\n\nTypes\n\n\n\n\nHeartbeat\n\n\nHeartbeat.registerHeartbeatListener()\n\n\nHeartbeat.onNext()\n\n\nHeartbeat.onBeforeNext()\n\n\nHeartbeat.onAfterNext()\n\n\n\n\n\n\n\n\nTypes\n\n\nHeartbeat\n\n\nScheduler for tasks that possibly synchronously trigger creation of new tasks, that need some common\nwork to be done before or after all of these tasks (and all tasks scheduled in the meantime) are\nfinished.\n\n\nAn example would be model-manipulating operations in an application using AngularJS, that need to run\n\n$rootScope.$apply\n after all operations are done, but only \nonce\n.\n\n\nHeartbeat.registerHeartbeatListener( listener )\n\n\nRegisters a listener, that is called whenever a heartbeat occurs.\nIt is called after the before and next queues were processed, but before working off the after queue has\nstarted.\nIn contrast to the \non*\n methods, listeners are not removed after a tick, but will be called again each\ntime a heartbeat occurs.\nInstead this method returns a function to manually remove the listener again.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlistener\n\n\nFunction\n\n\nthe listener to register\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function to remove the listener again\n\n\n\n\n\n\n\n\nHeartbeat.onNext( func )\n\n\nSchedules a function for the next heartbeat.\nIf no heartbeat was triggered yet, it will be requested now.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nFunction\n\n\na function to schedule for the next tick\n\n\n\n\n\n\n\n\nHeartbeat.onBeforeNext( func )\n\n\nSchedules a function to be called before the next heartbeat occurs.\nNote that \nfunc\n may never be called, if there is no next heartbeat since calling this function won't\ntrigger a new heartbeat.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nFunction\n\n\na function to call before the next heartbeat\n\n\n\n\n\n\n\n\nHeartbeat.onAfterNext( func )\n\n\nSchedules a function to be called after the next heartbeat occured.\nNote that \nfunc\n may never be called, if there is no next heartbeat since calling this function won't\ntrigger a new heartbeat.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfunc\n\n\nFunction\n\n\na function to call after the next heartbeat", 
            "title": "heartbeat"
        }, 
        {
            "location": "/api/runtime.heartbeat/#contents", 
            "text": "Types   Heartbeat  Heartbeat.registerHeartbeatListener()  Heartbeat.onNext()  Heartbeat.onBeforeNext()  Heartbeat.onAfterNext()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.heartbeat/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.heartbeat/#parameters", 
            "text": "Property  Type  Description      listener  Function  the listener to register", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.heartbeat/#returns", 
            "text": "Type  Description      Function  a function to remove the listener again", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.heartbeat/#parameters_1", 
            "text": "Property  Type  Description      func  Function  a function to schedule for the next tick", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.heartbeat/#parameters_2", 
            "text": "Property  Type  Description      func  Function  a function to call before the next heartbeat", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.heartbeat/#parameters_3", 
            "text": "Property  Type  Description      func  Function  a function to call after the next heartbeat", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.heartbeat_mock/", 
            "text": "heartbeat_mock\n\n\nAllows to create mock implementations of \nHeartbeat\n, compatible to the \"axHeartbeat\" injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nHeartbeatMock\n\n\nHeartbeatMock.reset()\n\n\nHeartbeatMock.flush()\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate()\n\n\nCreates a mock for the \"axHeartbeat\" injection of a widget.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nHeartbeatMock\n\n\na fresh mock instance\n\n\n\n\n\n\n\n\nTypes\n\n\nHeartbeatMock\n\n\n\n\nextends \nHeartbeat\n\n\n\n\nA mock version of \nHeartbeat\n, with additional methods.\n\n\nOffers spied-upon version of the usual axHeartbeat methods, as well as a \nflush\n method for synchronous\nscheduling of heartbeat events, and a \nreset\n methods to clear all listeners.\n\n\nHeartbeatMock.reset()\n\n\nReset the internal state of the mock, clearing all \nonBeforeNext\n, \nonNext\n and \nonAfterNext\n\ncallbacks.\n\n\nHeartbeatMock.flush()\n\n\nIf any \nonNext\n callbacks have been schedules, synchronously runs all scheduled \nonBeforeNext\n,\n\nonNext\n and \nonAfterNext\n callbacks, clearing the corresponding queues in the process.", 
            "title": "heartbeat_mock"
        }, 
        {
            "location": "/api/testing.heartbeat_mock/#contents", 
            "text": "Module Members   create()   Types   HeartbeatMock  HeartbeatMock.reset()  HeartbeatMock.flush()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.heartbeat_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.heartbeat_mock/#returns", 
            "text": "Type  Description      HeartbeatMock  a fresh mock instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.heartbeat_mock/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/testing.widget_services_i18n_mock/", 
            "text": "i18n_mock\n\n\nAllows to instantiate a mock implementation of \nAxI18n\n, compatible to \"axI18n\" injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nModule Members\n\n\ncreate( tagsByLocale, context, configuration )\n\n\nCreates a mock for the \"axI18n\" injection of a widget.\n\n\nCustom language tags for locales may be passed on creation, or changed using \nmockUpdateLocale\n.\nAlternatively, pass an AxContext instance to control the feature configuration and/or control the\nlocale state using events. This is for use by widget test-beds (e.g. LaxarJS Mocks) to connect the i18n\nmock to the same event bus and feature configuration as the rest of the test.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntagsByLocale\n\n\nObject\n\n\nstarting locales with language tag(s) for which to simulate \ndidChangeLocale\n. Use this to test controls (where using the event bus is out-of-scope)\n\n\n\n\n\n\ncontext\n\n\nAxContext\n\n\na context with features and/or eventBus to use. By default (or when set to an empty object), a mock eventBus will be used, and a widget with ID \"test-widget\" will be assumed, with its feature configuration \n\"i18n.locale\"\n set to \n\"default\"\n\n\n\n\n\n\nconfiguration\n\n\nAxConfiguration\n\n\npass a (mock) configuration to control the fallback language tag (\"en\" by default), using the configuration key \ni18n.locales.default\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxI18n\n\n\na mock of \naxI18n\n with preconfigured jasmine spies, plus the \nmockUpdateLocale\n method", 
            "title": "i18n_mock"
        }, 
        {
            "location": "/api/testing.widget_services_i18n_mock/#contents", 
            "text": "Module Members   create()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.widget_services_i18n_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.widget_services_i18n_mock/#parameters", 
            "text": "Property  Type  Description      tagsByLocale  Object  starting locales with language tag(s) for which to simulate  didChangeLocale . Use this to test controls (where using the event bus is out-of-scope)    context  AxContext  a context with features and/or eventBus to use. By default (or when set to an empty object), a mock eventBus will be used, and a widget with ID \"test-widget\" will be assumed, with its feature configuration  \"i18n.locale\"  set to  \"default\"    configuration  AxConfiguration  pass a (mock) configuration to control the fallback language tag (\"en\" by default), using the configuration key  i18n.locales.default", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_i18n_mock/#returns", 
            "text": "Type  Description      AxI18n  a mock of  axI18n  with preconfigured jasmine spies, plus the  mockUpdateLocale  method", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar/", 
            "text": "laxar\n\n\nThe API entry point for boostrapping LaxarJS applications.\nAlso, provides a couple of utilities to deal with assertions, objects and strings.\n\n\nContents\n\n\nTypes\n\n\n\n\n\n\nlaxar\n\n\n\n\nlaxar.create()\n\n\nlaxar.instances()\n\n\n\n\n\n\n\n\nBootstrappingInstance\n\n\n\n\nBootstrappingInstance.flow()\n\n\nBootstrappingInstance.page()\n\n\nBootstrappingInstance.tooling()\n\n\nBootstrappingInstance.testing()\n\n\nBootstrappingInstance.bootstrap()\n\n\n\n\n\n\n\n\nItemMeta\n\n\n\n\nItemMeta.instance\n\n\nItemMeta.item\n\n\nItemMeta.type\n\n\nItemMeta.${type}\n\n\n\n\n\n\n\n\nTypes\n\n\nlaxar\n\n\nlaxar.create( adapters, artifacts, configuration )\n\n\nPrepares a LaxarJS application instance from a list of adapters, a bundle of artifacts, and application\nconfiguration. The instance then allows to configure which DOM node should receive an application flow.\nRunning this has no effect until \n.bootstrap()\n is called on the returned instance API.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nadapters\n\n\nArray\n\n\nwidget adapters to use in this bootstrapping instance\n\n\n\n\n\n\nartifacts\n\n\nObject\n\n\nan artifact listing for the application, generated by the utilized built tool (e.g. webpack)\n\n\n\n\n\n\nconfiguration\n\n\nObject\n\n\napplication-wide LaxarJS configuration. See http://laxarjs.org/docs/laxar-latest/manuals/configuration/ for further information on available properties\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBootstrappingInstance\n\n\na handle on the bootstrapping instance, to load and bootstrap a flow\n\n\n\n\n\n\n\n\nlaxar.instances( optionalName )\n\n\nProvide tooling access to LaxarJS services.\n\n\nEach laxar#bootstrap call creates a new set of services such as a logger, global event bus etc. For tools\nlike the laxar-developer-tools-widget, it may be necessary to access these services for a given instance,\nor for all instances.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptionalName\n\n\nString\n\n\nthe configuration name of a LaxarJS instance to inspect (may be omitted to access all application instances by name)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe tooling services for a specified instance, or for all instances that have tooling enabled\n\n\n\n\n\n\n\n\nBootstrappingInstance\n\n\nHandle on a LaxarJS bootstrapping instance.\n\n\nBootstrappingInstance.flow( name, anchorElement )\n\n\nRegisters a flow to control routing for this application.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nthe name of the flow to load\n\n\n\n\n\n\nanchorElement\n\n\nHTMLElement\n\n\ncontainer element to determine where to put the flow\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBootstrappingInstance\n\n\nthe current bootstrapping instance (self), for chaining\n\n\n\n\n\n\n\n\nBootstrappingInstance.page( name, anchorElement, parameters )\n\n\nRegisters a page to display without navigation control.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nthe name of the page to load\n\n\n\n\n\n\nanchorElement\n\n\nHTMLElement\n\n\ncontainer element to determine where to put the page\n\n\n\n\n\n\nparameters\n\n\nObject\n\n\npage parameters to publish with didNavigate\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBootstrappingInstance\n\n\nthe current bootstrapping instance (self), for chaining\n\n\n\n\n\n\n\n\nBootstrappingInstance.tooling( debugInfo )\n\n\nRegisters a debug bundle for this application.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndebugInfo\n\n\nFunction\n, \nObject\n\n\nthe debug-info bundle for the application, generated by the utilized built tool (e.g. webpack)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBootstrappingInstance\n\n\nthe current bootstrapping instance (self), for chaining\n\n\n\n\n\n\n\n\nBootstrappingInstance.testing()\n\n\nDeclare that this instance is used for testing.\nThis will cause .bootstrap not to fail if no flow was configured.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBootstrappingInstance\n\n\nthe current bootstrapping instance (self), for chaining\n\n\n\n\n\n\n\n\nBootstrappingInstance.bootstrap()\n\n\nPerforms the actual application bootstrapping.\nThis includes bootstrapping the application adapters and starting the router.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\na promise resolving when all items have been bootstrapped\n\n\n\n\n\n\n\n\nItemMeta\n\n\nAn object of strings which together identify a bootstrapping item.\n\n\nItemMeta.instance \nString\n\n\nThe (topic-formatted) name of the LaxarJS instance.\n\n\nItemMeta.item \nString\n\n\nThe (topic-formatted, ID-suffixed) name of the bootstrapping item.\n\n\nItemMeta.type \nString\n\n\nThe type of the bootstrapping item.\n\n\nItemMeta.${type} \nString\n\n\nThe artifact reference used for creating the bootstrapping item.", 
            "title": "laxar"
        }, 
        {
            "location": "/api/laxar/#contents", 
            "text": "Types    laxar   laxar.create()  laxar.instances()     BootstrappingInstance   BootstrappingInstance.flow()  BootstrappingInstance.page()  BootstrappingInstance.tooling()  BootstrappingInstance.testing()  BootstrappingInstance.bootstrap()     ItemMeta   ItemMeta.instance  ItemMeta.item  ItemMeta.type  ItemMeta.${type}", 
            "title": "Contents"
        }, 
        {
            "location": "/api/laxar/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/laxar/#parameters", 
            "text": "Property  Type  Description      adapters  Array  widget adapters to use in this bootstrapping instance    artifacts  Object  an artifact listing for the application, generated by the utilized built tool (e.g. webpack)    configuration  Object  application-wide LaxarJS configuration. See http://laxarjs.org/docs/laxar-latest/manuals/configuration/ for further information on available properties", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar/#returns", 
            "text": "Type  Description      BootstrappingInstance  a handle on the bootstrapping instance, to load and bootstrap a flow", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar/#parameters_1", 
            "text": "Property  Type  Description      optionalName  String  the configuration name of a LaxarJS instance to inspect (may be omitted to access all application instances by name)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar/#returns_1", 
            "text": "Type  Description      Object  the tooling services for a specified instance, or for all instances that have tooling enabled", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar/#parameters_2", 
            "text": "Property  Type  Description      name  String  the name of the flow to load    anchorElement  HTMLElement  container element to determine where to put the flow", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar/#returns_2", 
            "text": "Type  Description      BootstrappingInstance  the current bootstrapping instance (self), for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar/#parameters_3", 
            "text": "Property  Type  Description      name  String  the name of the page to load    anchorElement  HTMLElement  container element to determine where to put the page    parameters  Object  page parameters to publish with didNavigate", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar/#returns_3", 
            "text": "Type  Description      BootstrappingInstance  the current bootstrapping instance (self), for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar/#parameters_4", 
            "text": "Property  Type  Description      debugInfo  Function ,  Object  the debug-info bundle for the application, generated by the utilized built tool (e.g. webpack)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/laxar/#returns_4", 
            "text": "Type  Description      BootstrappingInstance  the current bootstrapping instance (self), for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar/#returns_5", 
            "text": "Type  Description      BootstrappingInstance  the current bootstrapping instance (self), for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar/#returns_6", 
            "text": "Type  Description      Promise  a promise resolving when all items have been bootstrapped", 
            "title": "Returns"
        }, 
        {
            "location": "/api/laxar-widget-service-mocks/", 
            "text": "laxar-widget-service-mocks\n\n\nMock factories that help to tests widgets.\nThese mocks are automatically provided in place of the regular LaxarJS widget services when using\nlaxar-mocks for widget testing.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreateAxAssetsMocks()\n\n\ncreateAxAreaHelperMock()\n\n\ncreateAxConfigurationMock()\n\n\ncreateAxEventBusMock()\n\n\ncreateAxFlowServiceMock()\n\n\ncreateAxGlobalStorageMock()\n\n\ncreateAxHeartbeatMock()\n\n\ncreateAxI18nMock()\n\n\ncreateAxLogMock()\n\n\ncreateAxStorageMock()\n\n\ncreateAxVisibilityMock()\n\n\n\n\nModule Members\n\n\ncreateAxAssetsMocks()\n\n\nReturns a mock of the \naxAssets\n injection for tests, to avoid making actual \nfetch\n calls.\n\n\nFor details, see \nwidget_services_assets_mock\n.\n\n\ncreateAxAreaHelperMock()\n\n\nReturns a mock of the \naxAreaHelper\n injection for tests.\n\n\nFor details, see \nwidget_services_area_helper_mock\n.\n\n\ncreateAxConfigurationMock()\n\n\nReturns a mock of the \naxConfiguration\n injection for tests.\n\n\nFor details, see \nconfiguration_mock\n.\n\n\ncreateAxEventBusMock()\n\n\nReturns a mock of the \naxEventBus\n injection for tests.\n\n\nFor details, see \nevent_bus_mock\n.\n\n\ncreateAxFlowServiceMock()\n\n\nReturns a mock of the \naxFlowService\n injection for tests.\n\n\nFor details, see \nflow_service_mock\n.\n\n\ncreateAxGlobalStorageMock()\n\n\nReturns a mock of the \naxGlobalStorage\n injection for tests.\n\n\nFor details, see \nstorage_mock\n.\n\n\ncreateAxHeartbeatMock()\n\n\nReturns a mock of the \naxHeartbeat\n injection for tests.\n\n\nFor details, see \nheartbeat_mock\n.\n\n\ncreateAxI18nMock()\n\n\nReturns a mock of the \naxI18n\n injection for tests.\n\n\nFor details, see \ni18n_mock\n.\n\n\ncreateAxLogMock()\n\n\nReturns a mock of the \naxLog\n injection for tests.\n\n\nFor details, see \nlog_mock\n.\n\n\ncreateAxStorageMock()\n\n\nReturns a mock of the \naxStorage\n injection for tests.\n\n\nFor details, see \nwidget_services_storage_mock\n.\n\n\ncreateAxVisibilityMock()\n\n\nReturns a mock of the \naxVisibility\n injection for tests.\n\n\nFor details, see \nwidget_services_visibility_mock\n.", 
            "title": "laxar-widget-service-mocks"
        }, 
        {
            "location": "/api/laxar-widget-service-mocks/#contents", 
            "text": "Module Members   createAxAssetsMocks()  createAxAreaHelperMock()  createAxConfigurationMock()  createAxEventBusMock()  createAxFlowServiceMock()  createAxGlobalStorageMock()  createAxHeartbeatMock()  createAxI18nMock()  createAxLogMock()  createAxStorageMock()  createAxVisibilityMock()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/laxar-widget-service-mocks/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/runtime.log/", 
            "text": "log\n\n\nModule providing the Logger factory.\n\n\nTo use the Log service in a widget, request the \naxLog\n injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\nlevels\n\n\nBLACKBOX\n\n\n\n\nTypes\n\n\n\n\nLogger\n\n\nLogger.log()\n\n\nLogger.trace()\n\n\nLogger.debug()\n\n\nLogger.info()\n\n\nLogger.warn()\n\n\nLogger.error()\n\n\nLogger.fatal()\n\n\nLogger.addLogChannel()\n\n\nLogger.removeLogChannel()\n\n\nLogger.addTag()\n\n\nLogger.setTag()\n\n\nLogger.removeTag()\n\n\nLogger.gatherTags()\n\n\nLogger.setLogThreshold()\n\n\n\n\n\n\n\n\nModule Members\n\n\nlevels \nObject\n\n\nLog levels that are available by default, sorted by increasing severity:\n\n\n\n\nTRACE (level 100)\n\n\nDEBUG (level 200)\n\n\nINFO (level 300)\n\n\nWARN (level 400)\n\n\nERROR (level 500)\n\n\nFATAL (level 600)\n\n\n\n\nBLACKBOX \nObject\n\n\nPass this as an additional replacement parameter to a log-method, in order to blackbox your logging call.\nBlackboxed callers are ignored when logging the source information (file, line).\n\n\nTypes\n\n\nLogger\n\n\nLogger.log( level, message, replacements )\n\n\nLogs a message. A message may contain placeholders in the form \n[#]\n where \n#\n resembles the index\nwithin the list of \nreplacements\n. \nreplacements\n are incrementally counted starting at \n0\n. If the\nlog level is below the configured log threshold, the message is simply discarded.\n\n\nIt is recommended not to use this method directly, but instead one of the short cut methods for the\naccording log level.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlevel\n\n\nNumber\n\n\nthe level for this message\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger.trace( message, replacements )\n\n\nLogs a message in log level \nTRACE\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger.debug( message, replacements )\n\n\nLogs a message in log level \nDEBUG\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger.info( message, replacements )\n\n\nLogs a message in log level \nINFO\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger.warn( message, replacements )\n\n\nLogs a message in log level \nWARN\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger.error( message, replacements )\n\n\nLogs a message in log level \nERROR\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger.fatal( message, replacements )\n\n\nLogs a message in log level \nFATAL\n. See \nLogger#log\n for further information.\n\n\nImportant note\n: This method is only available, if no custom log levels were defined via\nconfiguration or custom log levels include this method as well.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmessage\n\n\nString\n\n\nthe message to log\n\n\n\n\n\n\nreplacements...\n\n\n*\n\n\nobjects that should replace placeholders within the message\n\n\n\n\n\n\n\n\nLogger.addLogChannel( channel )\n\n\nAdds a new channel to forward log messages to. A channel is called synchronously for every log message\nand can do whatever necessary to handle the message according to its task. Note that blocking or\nperformance critical actions within a channel should always take place asynchronously to prevent from\nblocking the application. Ideally a web worker is used for heavier background tasks.\n\n\nEach message is an object having the following properties:\n\n\n\n\nid\n: the unique, ascending id of the log message\n\n\nlevel\n: the log level of the message in string representation\n\n\ntext\n: the actual message that was logged\n\n\nreplacements\n: the raw list of replacements passed along the message\n\n\ntime\n: JavaScript Date instance when the message was logged\n\n\ntags\n: A map of all log tags currently set for the logger\n\n\nsourceInfo\n: if supported, a map containing \nfile\n, \nline\n and \nchar\n where the logging took place\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nchannel\n\n\nFunction\n\n\nthe log channel to add\n\n\n\n\n\n\n\n\nLogger.removeLogChannel( channel )\n\n\nRemoves a log channel and thus stops sending further messages to it.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nchannel\n\n\nFunction\n\n\nthe log channel to remove\n\n\n\n\n\n\n\n\nLogger.addTag( tag, value )\n\n\nAdds a value for a log tag. If a tag is already known, the value is appended to the existing one using a\n\n;\n as separator. Note that no formatting of the value takes place and a non-string value will just have\nits appropriate \ntoString\n method called.\n\n\nLog tags can be used to mark a set of log messages with a value giving further information on the\ncurrent logging context. For example laxar sets a tag \n'INST'\n with a unique-like identifier for the\ncurrent browser client. If then for example log messages are persisted on a server, messages belonging\nto the same client can be accumulated.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntag\n\n\nString\n\n\nthe id of the tag to add a value for\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nthe value to add\n\n\n\n\n\n\n\n\nLogger.setTag( tag, value )\n\n\nSets a value for a log tag. If a tag is already known, the value is overwritten by the given one. Note\nthat no formatting of the value takes place and a non-string value will just have its appropriate\n\ntoString\n method called. For further information on log tags, see \nLogger#addTag\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntag\n\n\nString\n\n\nthe id of the tag to set a value for\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nthe value to set\n\n\n\n\n\n\n\n\nLogger.removeTag( tag )\n\n\nRemoves a log tag. For further information on log tags, see \nLogger#addTag\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntag\n\n\nString\n\n\nthe id of the tag to set a value for\n\n\n\n\n\n\n\n\nLogger.gatherTags()\n\n\nReturns a map of all tags. If there are multiple values for the same tag, their values are concatenated\nusing a \n;\n as separator. For further information on log tags, see \nLogger#addTag\n.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\na mapping from tag to its value(s)\n\n\n\n\n\n\n\n\nLogger.setLogThreshold( threshold )\n\n\nSets the threshold for log messages. Log messages with a lower level will be discarded upon logging.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nthreshold\n\n\nString\n, \nNumber\n\n\nthe numeric or the string value of the log level to use as threshold", 
            "title": "log"
        }, 
        {
            "location": "/api/runtime.log/#contents", 
            "text": "Module Members   levels  BLACKBOX   Types   Logger  Logger.log()  Logger.trace()  Logger.debug()  Logger.info()  Logger.warn()  Logger.error()  Logger.fatal()  Logger.addLogChannel()  Logger.removeLogChannel()  Logger.addTag()  Logger.setTag()  Logger.removeTag()  Logger.gatherTags()  Logger.setLogThreshold()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.log/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/runtime.log/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.log/#parameters", 
            "text": "Property  Type  Description      level  Number  the level for this message    message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_1", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_2", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_3", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_4", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_5", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_6", 
            "text": "Property  Type  Description      message  String  the message to log    replacements...  *  objects that should replace placeholders within the message", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_7", 
            "text": "Property  Type  Description      channel  Function  the log channel to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_8", 
            "text": "Property  Type  Description      channel  Function  the log channel to remove", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_9", 
            "text": "Property  Type  Description      tag  String  the id of the tag to add a value for    value  String  the value to add", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_10", 
            "text": "Property  Type  Description      tag  String  the id of the tag to set a value for    value  String  the value to set", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#parameters_11", 
            "text": "Property  Type  Description      tag  String  the id of the tag to set a value for", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.log/#returns", 
            "text": "Type  Description      Object  a mapping from tag to its value(s)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.log/#parameters_12", 
            "text": "Property  Type  Description      threshold  String ,  Number  the numeric or the string value of the log level to use as threshold", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.log_mock/", 
            "text": "log_mock\n\n\nAllows to create mock implementations of \nLog\n, compatible to the \"axLog\" and \"axGlobalLog\"\ninjections.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nModule Members\n\n\ncreate()\n\n\nCreates a log mock that does not actually log anywhere, but can be spied upon.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxLog\n\n\na fresh mock instance", 
            "title": "log_mock"
        }, 
        {
            "location": "/api/testing.log_mock/#contents", 
            "text": "Module Members   create()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.log_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.log_mock/#returns", 
            "text": "Type  Description      AxLog  a fresh mock instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.navigo_router/", 
            "text": "navigo_router\n\n\nModule providing the Navigo router factory.\n\n\nContents\n\n\nTypes\n\n\n\n\nNavigoRouter\n\n\nNavigoRouter.registerRoutes()\n\n\nNavigoRouter.navigateTo()\n\n\nNavigoRouter.navigateToPath()\n\n\nNavigoRouter.constructAbsoluteUrl()\n\n\n\n\n\n\n\n\nTypes\n\n\nNavigoRouter\n\n\nRouter implementation based on \nNavigo\n.\n\n\nThis router allows to register flow patterns in Navigo syntax so that their handler is activated when\nthe corresponding URL is entered in the browser. While that alone does not add much to the\nfunctionality built into Navigo, this router also allows to construct URLs based on a pattern and\ncorresponding substitution parameters. Finally, users can trigger navigation directly.\n\n\nNote that the router supports various configuration options:\n\n\n\n\nrouter.navigo\n: configuration object that is directly passed to Navigo (such as \nuseHash\n). The\n   application is responsible for specifying the required options, as LaxarJS does not touch the Navigo\n   defaults otherwise. Consult the Navigo documentation for more information\n\n\nrouter.query.enabled\n: if \ntrue\n, query parameters are automatically transformed into additional\n   place parameters and vice versa. The default is \nfalse\n\n\nrouter.base\n: The base path under which to perform routing. If omitted, the document base href is\n   used\n\n\n\n\nNote that this router encodes/decodes certain parameters in a way that is different from Navigo:\n\n\n\n\nwhen the value \nnull\n is encoded into a URL path segment, it is encoded as \n_\n\n\nthe value \n/\n is double-encoded\n\n\n\n\nNavigoRouter.registerRoutes( routeMap, fallbackHandler )\n\n\nRegisters all routes defined in the given route map, as well as a fallback route that should be used\nwhen none of the other routes match. Also causes the initial route to be triggered.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nrouteMap\n\n\nObject.\nString, Function\n\n\na map of routing patterns in Navigo syntax to the corresponding handler functions. When invoked, the handler functions will receive the decoded parameter values for their pattern and (if configured) from the query string, as a map from string parameter name to string value\n\n\n\n\n\n\nfallbackHandler\n\n\nFunction\n\n\na handler that is invoked when none of the configured routes match. It receives the failed location href as a string argument\n\n\n\n\n\n\n\n\nNavigoRouter.navigateTo( patterns, parameters, options )\n\n\nChange the browser location to a different routable URL, from pattern and parameters. This is also\ncalled reverse-routing.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npatterns\n\n\nArray.\nString\n\n\na list of patterns to choose from. This allows the router to pick the \"best\" pattern, such as the pattern containing the largest number of given parameters. This router always picks the first pattern for now\n\n\n\n\n\n\nparameters\n\n\nObject\n\n\nparameter values to substitute into the pattern to generate a URL\n\n\n\n\n\n\noptions\n\n\nObject\n\n\nadditional options to influence navigation\n\n\n\n\n\n\noptions.replaceHistory=false\n\n\nBoolean\n\n\nif \ntrue\n, the current history entry is replaced with the new one, otherwise a new entry is pushed. Useful to express redirects\n\n\n\n\n\n\noptions.fragment=null\n\n\nString\n\n\nif set, the given fragment is appended to the URL (after a \n#\n). Useful with pushState based routing\n\n\n\n\n\n\n\n\nNavigoRouter.navigateToPath( path, options )\n\n\nChange the browser location to a different routable URL, from a complete path. This is also\ncalled reverse-routing.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nString\n\n\nthe complete path to navigate to. This includes values for all relevant parameters\n\n\n\n\n\n\noptions\n\n\nObject\n\n\nadditional options to influence navigation\n\n\n\n\n\n\noptions.replaceHistory=false\n\n\nBoolean\n\n\nif \ntrue\n, the current history entry is replaced with the new one, otherwise a new entry is pushed. Useful to express redirects\n\n\n\n\n\n\n\n\nNavigoRouter.constructAbsoluteUrl( patterns, parameters, fragment )\n\n\nCreate a routable URL, from pattern and parameters. This allows to create link-hrefs without repeating\nURL patterns throughout the code base.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npatterns\n\n\nArray.\nString\n\n\na list of patterns to choose from. This allows the router to pick the \"best\" pattern, such as the pattern containing the largest number of given parameters. This router always picks the first pattern for now\n\n\n\n\n\n\nparameters\n\n\nObject\n\n\nparameter values to substitute into the pattern to generate a URL\n\n\n\n\n\n\nfragment\n\n\nString\n\n\noptional String fragment to append to the generated URL\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe resulting URL, including schema and host", 
            "title": "navigo_router"
        }, 
        {
            "location": "/api/runtime.navigo_router/#contents", 
            "text": "Types   NavigoRouter  NavigoRouter.registerRoutes()  NavigoRouter.navigateTo()  NavigoRouter.navigateToPath()  NavigoRouter.constructAbsoluteUrl()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.navigo_router/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.navigo_router/#parameters", 
            "text": "Property  Type  Description      routeMap  Object. String, Function  a map of routing patterns in Navigo syntax to the corresponding handler functions. When invoked, the handler functions will receive the decoded parameter values for their pattern and (if configured) from the query string, as a map from string parameter name to string value    fallbackHandler  Function  a handler that is invoked when none of the configured routes match. It receives the failed location href as a string argument", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.navigo_router/#parameters_1", 
            "text": "Property  Type  Description      patterns  Array. String  a list of patterns to choose from. This allows the router to pick the \"best\" pattern, such as the pattern containing the largest number of given parameters. This router always picks the first pattern for now    parameters  Object  parameter values to substitute into the pattern to generate a URL    options  Object  additional options to influence navigation    options.replaceHistory=false  Boolean  if  true , the current history entry is replaced with the new one, otherwise a new entry is pushed. Useful to express redirects    options.fragment=null  String  if set, the given fragment is appended to the URL (after a  # ). Useful with pushState based routing", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.navigo_router/#parameters_2", 
            "text": "Property  Type  Description      path  String  the complete path to navigate to. This includes values for all relevant parameters    options  Object  additional options to influence navigation    options.replaceHistory=false  Boolean  if  true , the current history entry is replaced with the new one, otherwise a new entry is pushed. Useful to express redirects", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.navigo_router/#parameters_3", 
            "text": "Property  Type  Description      patterns  Array. String  a list of patterns to choose from. This allows the router to pick the \"best\" pattern, such as the pattern containing the largest number of given parameters. This router always picks the first pattern for now    parameters  Object  parameter values to substitute into the pattern to generate a URL    fragment  String  optional String fragment to append to the generated URL", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.navigo_router/#returns", 
            "text": "Type  Description      String  the resulting URL, including schema and host", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.object/", 
            "text": "object\n\n\nUtilities for dealing with objects.\n\n\nIt can be imported as \nobject\n from 'laxar';\n\n\nContents\n\n\nModule Members\n\n\n\n\noptions()\n\n\nforEach()\n\n\npath()\n\n\nsetPath()\n\n\ndeepClone()\n\n\ntabulate()\n\n\n\n\nModule Members\n\n\noptions( obj, defaults )\n\n\nReturns all properties from \nobj\n with missing properties completed from \ndefaults\n. If \nobj\n is \nnull\n\nor \nundefined\n, an empty object is automatically created. \nobj\n and \ndefaults\n are not modified by this\nfunction. This is very useful for optional map arguments, resembling some kind of configuration.\n\n\nExample:\n\n\nimport\n \n{\n \nobject\n \n}\n \nfrom\n \nlaxar\n;\n\n\nobject\n.\noptions\n(\n \n{\n \nvalidate\n:\n \ntrue\n \n},\n \n{\n\n   \nvalidate\n:\n \nfalse\n,\n\n   \nhighlight\n:\n \ntrue\n\n\n}\n \n);\n\n\n// =\n\n\n// {\n\n\n//    validate: true,\n\n\n//    highlight: true\n\n\n// }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj\n\n\nObject\n\n\nthe options object to use as source, may be \nnull\n or \nundefined\n\n\n\n\n\n\ndefaults\n\n\nObject\n\n\nthe defaults to take missing properties from\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe completed options object\n\n\n\n\n\n\n\n\nforEach( object, iteratorFunction )\n\n\nIterates over the keys of an object and calls the given iterator function for each entry.\nOn each iteration the iterator function is passed the \nvalue\n, the \nkey\n and the complete \nobject\n as\narguments.\nIf \nobject\n is an array, the native \nArray.prototype.forEach\n function is called.\nIn this case the keys are the indices of the array.\n\n\nExample:\n\n\nimport { object } from \nlaxar\n;\nobject.forEach( { name: Peter, age: 12 }, ( value, key ) =\n {\n   console.log( `${key} = ${value}\\n` );\n} );\n// =\n\n// name = Peter\n// age = 12\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobject\n\n\nObject\n\n\nthe object to run the iterator function on\n\n\n\n\n\n\niteratorFunction\n\n\nFunction\n\n\nthe iterator function to run on each key-value pair\n\n\n\n\n\n\n\n\npath( obj, thePath, optionalDefault )\n\n\nFinds a property in a nested object structure by a given path. A path is a string of keys, separated\nby a dot from each other, used to traverse that object and find the value of interest. An additional\ndefault is returned, if otherwise the value would yield \nundefined\n.\n\n\nNote that \npath()\n must only be used in situations where all path segments are also valid\nJavaScript identifiers, and should never be used with user-specified paths:\n\n\n\n\nthere is no mechanism to escape '.' in path segments; a dot always separates keys,\n\n\nan empty string as a path segment will abort processing and return the entire sub-object under the\n   respective position. For historical reasons, the path interpretation differs from that performed by\n   \n#setPath()\n.\n\n\n\n\nExample:\n\n\nimport\n \n{\n \nobject\n \n}\n \nfrom\n \nlaxar\n;\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.two\n \n);\n \n// =\n 3\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.three\n \n);\n \n// =\n undefined\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.three\n,\n \n42\n \n);\n \n// =\n 42\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \none.\n \n);\n \n// =\n { two: 3 }\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \n \n);\n \n// =\n { one: { two: 3 } }\n\n\nobject\n.\npath\n(\n \n{\n \none\n:\n \n{\n \ntwo\n:\n \n3\n \n}\n \n},\n \n.\n \n);\n \n// =\n { one: { two: 3 } }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj\n\n\nObject\n\n\nthe object to traverse\n\n\n\n\n\n\nthePath\n\n\nString\n\n\nthe path to search for\n\n\n\n\n\n\noptionalDefault\n\n\n*\n\n\nthe value to return instead of \nundefined\n if nothing is found\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe value at the given path\n\n\n\n\n\n\n\n\nsetPath( obj, path, value )\n\n\nSets a property in a nested object structure at a given path to a given value. A path is a string of\nkeys, separated by a dot from each other, used to traverse that object and find the place where the\nvalue should be set. Any missing subtrees along the path are created.\n\n\nNote that \nsetPath()\n must only be used in situations where all path segments are also valid\nJavaScript identifiers, and should never be used with user-specified paths:\n\n\n\n\nthere is no mechanism to escape '.' in path segments; a dot will always create separate keys,\n\n\nan empty string as a path segment will create an empty string key in the object graph where missing.\n   For historical reasons, this path interpretation differs from that performed by #path (see there).\n\n\n\n\nExample:\n\n\nimport\n \n{\n \nobject\n \n}\n \nfrom\n \nlaxar\n;\n\n\nobject\n.\nsetPath\n(\n \n{},\n \nname.first\n,\n \nPeter\n \n);\n \n// =\n { name: { first: \nPeter\n } }\n\n\nobject\n.\nsetPath\n(\n \n{},\n \npets.1\n,\n \nHamster\n \n);\n \n// =\n { pets: [ null, \nHamster\n ] }\n\n\nobject\n.\nsetPath\n(\n \n{},\n \n,\n \nHamster\n \n);\n \n// =\n { \n: \nHamster\n } }\n\n\nobject\n.\nsetPath\n(\n \n{},\n \n.\n,\n \nHamster\n \n);\n \n// =\n { \n: { \n: \nHamster\n } } }\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobj\n\n\nObject\n\n\nthe object to modify\n\n\n\n\n\n\npath\n\n\nString\n\n\nthe path to set a value at\n\n\n\n\n\n\nvalue\n\n\n*\n\n\nthe value to set at the given path\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe full object (for chaining)\n\n\n\n\n\n\n\n\ndeepClone( object )\n\n\nReturns a deep clone of the given object. Note that the current implementation is intended to be used\nfor simple object literals only. There is no guarantee that cloning objects instantiated via\nconstructor function works and cyclic references will lead to endless recursion.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nobject\n\n\n*\n\n\nthe object to clone\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe clone\n\n\n\n\n\n\n\n\ntabulate( fn, keys )\n\n\nCreates a lookup table from a function and a list of inputs to the function.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfn\n\n\nFunction\n\n\nThe callback to apply to all inputs\n\n\n\n\n\n\nkeys\n\n\nArray.\nString\n, \nArray.\nNumber\n, \nArray.\nBoolean\n\n\nThe keys for the lookup table, and inputs to the function.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nAn object mapping the given keys to their values under \nfn\n.", 
            "title": "object"
        }, 
        {
            "location": "/api/utilities.object/#contents", 
            "text": "Module Members   options()  forEach()  path()  setPath()  deepClone()  tabulate()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/utilities.object/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/utilities.object/#parameters", 
            "text": "Property  Type  Description      obj  Object  the options object to use as source, may be  null  or  undefined    defaults  Object  the defaults to take missing properties from", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.object/#returns", 
            "text": "Type  Description      Object  the completed options object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.object/#parameters_1", 
            "text": "Property  Type  Description      object  Object  the object to run the iterator function on    iteratorFunction  Function  the iterator function to run on each key-value pair", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.object/#parameters_2", 
            "text": "Property  Type  Description      obj  Object  the object to traverse    thePath  String  the path to search for    optionalDefault  *  the value to return instead of  undefined  if nothing is found", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.object/#returns_1", 
            "text": "Type  Description      *  the value at the given path", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.object/#parameters_3", 
            "text": "Property  Type  Description      obj  Object  the object to modify    path  String  the path to set a value at    value  *  the value to set at the given path", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.object/#returns_2", 
            "text": "Type  Description      *  the full object (for chaining)", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.object/#parameters_4", 
            "text": "Property  Type  Description      object  *  the object to clone", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.object/#returns_3", 
            "text": "Type  Description      *  the clone", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.object/#parameters_5", 
            "text": "Property  Type  Description      fn  Function  The callback to apply to all inputs    keys  Array. String ,  Array. Number ,  Array. Boolean  The keys for the lookup table, and inputs to the function.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.object/#returns_4", 
            "text": "Type  Description      Object  An object mapping the given keys to their values under  fn .", 
            "title": "Returns"
        }, 
        {
            "location": "/api/tooling.pages/", 
            "text": "pages\n\n\nA module for compatibility with old LaxarJS tooling.\n\n\nContents\n\n\nTypes\n\n\n\n\nPagesTooling\n\n\nPagesTooling.enable()\n\n\nPagesTooling.disable()\n\n\nPagesTooling.current()\n\n\nPagesTooling.addListener()\n\n\nPagesTooling.removeListener()\n\n\n\n\n\n\n\n\nTypes\n\n\nPagesTooling\n\n\nPagesTooling.enable()\n\n\nStart collecting page/composition data.\n\n\nPagesTooling.disable()\n\n\nStop collecting page/composition data.\n\n\nPagesTooling.current()\n\n\nAccess the current page information.\nEverything is returned as a copy, sothis object cannot be used to modify the host application.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe current page information, with the following properties:\n- \npageDefinitions\n {Object} both the original as well as the expanded/flattened page model for each available page\n- \ncompositionDefinitions\n {Object} both the original as well as the expanded/flattened composition model for each composition of any available page\n- \nwidgetDescriptors\n {Object} the widget descriptor for each widget that was referenced\n- \npageReference\n {String} the reference for the current page, to lookup page/composition definitions\n\n\n\n\n\n\n\n\nPagesTooling.addListener( callback )\n\n\nAdd a listener function to be notified whenever the page information changes.\nAs a side-effect, this also automatically enables collecting page/composition data.\nEach listener will be delivered its own copy of the page information.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\nThe listener to add. Will be called with the current page information whenever that changes.\n\n\n\n\n\n\n\n\nPagesTooling.removeListener( callback )\n\n\nRemove a page information listener function.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\nThe listener to remove", 
            "title": "pages"
        }, 
        {
            "location": "/api/tooling.pages/#contents", 
            "text": "Types   PagesTooling  PagesTooling.enable()  PagesTooling.disable()  PagesTooling.current()  PagesTooling.addListener()  PagesTooling.removeListener()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/tooling.pages/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/tooling.pages/#returns", 
            "text": "Type  Description      Object  the current page information, with the following properties: -  pageDefinitions  {Object} both the original as well as the expanded/flattened page model for each available page -  compositionDefinitions  {Object} both the original as well as the expanded/flattened composition model for each composition of any available page -  widgetDescriptors  {Object} the widget descriptor for each widget that was referenced -  pageReference  {String} the reference for the current page, to lookup page/composition definitions", 
            "title": "Returns"
        }, 
        {
            "location": "/api/tooling.pages/#parameters", 
            "text": "Property  Type  Description      callback  Function  The listener to add. Will be called with the current page information whenever that changes.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/tooling.pages/#parameters_1", 
            "text": "Property  Type  Description      callback  Function  The listener to remove", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.plain_adapter/", 
            "text": "plain_adapter\n\n\nModule for the plain widget adapter factory.\nIn LaxarJS \nplain\n widgets are defined as widgets without dependency to a specific view library or\nframwork, and instead would be implemented using simple DOM access and manipulation.\n\n\nA developer will never call any of the API of this module.\nThe documentation solely exists as a blueprint for custom widget adapters and to explain certain concepts.\n\n\nContents\n\n\nModule Members\n\n\n\n\nbootstrap()\n\n\n\n\nTypes\n\n\n\n\nPlainAdapterFactory\n\n\nPlainAdapterFactory.create()\n\n\n\n\n\n\n\n\nModule Members\n\n\nbootstrap( artifacts, services, anchorElement )\n\n\nInitializes the adapter module and returns a factory for plain widgets.\nNote that the plain adapter doesn't need all the provided arguments, but they are listed here for\ndocumentation purposes.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nartifacts\n\n\nObject\n\n\nthe artifacts available to this adapter factory\n\n\n\n\n\n\nartifacts.widgets\n\n\nObject\n\n\nall widgets, that are implemented in the adapter's technology\n\n\n\n\n\n\nartifacts.controls\n\n\nObject\n\n\nall controls, that are implemented in the adapter's technology\n\n\n\n\n\n\nservices\n\n\nObject\n\n\na selection of services adapter implementations may need to fulfill their task\n\n\n\n\n\n\nservices.adapterUtilities\n\n\nAdapterUtilities\n\n\ncommon utilities, that may be useful to a widget adapter\n\n\n\n\n\n\nservices.artifactProvider\n\n\nArtifactProvider\n\n\nthe artifact provider instance\n\n\n\n\n\n\nservices.configuration\n\n\nConfiguration\n\n\naccess to the application configuration\n\n\n\n\n\n\nservices.globalEventBus\n\n\nEventBus\n\n\nthe global event bus. Note that an adapter should not sent any events by itself. It may instead be necessary that the adapter makes the event bus globally available to its widgets (for example like the AngularJS 1.x adapter), or that it registers an inspector\n\n\n\n\n\n\nservices.heartbeat\n\n\nHeartbeat\n\n\nthe heartbeat instance. Depending on the underlying view technology (like AngularJS 1.x) it may be important to get notified when to re-render the user interface. For that reason an adapter can register a callback at the heartbeat, that gets called after all events of the current cycle were processed\n\n\n\n\n\n\nservices.log\n\n\nLog\n\n\nthe global log instance\n\n\n\n\n\n\nservices.storage\n\n\nStorageFactory\n\n\nthe global storage factory api\n\n\n\n\n\n\nservices.tooling\n\n\nTooling\n\n\naccess to the tooling api\n\n\n\n\n\n\nanchorElement\n\n\nHTMLElement\n\n\nthe DOM node the laxar application is bootstrapped on. An adapter should never try to access DOM nodes that are not the \nanchorElement\n or any of its children, since they are not under control of this LaxarJS application.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPlainAdapterFactory\n\n\nthe factory for plain widget adapters\n\n\n\n\n\n\n\n\nTypes\n\n\nPlainAdapterFactory\n\n\nA factory for plain widget adapters.\n\n\nPlainAdapterFactory.create( environment )\n\n\nCreates a new adapter instance for the given widget environment.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenvironment\n\n\nObject\n\n\nthe environment for the widget to create and manage\n\n\n\n\n\n\nenvironment.anchorElement\n\n\nHTMLElement\n\n\nthe DOM node that the widget's DOM fragment should be inserted into\n\n\n\n\n\n\nenvironment.name\n\n\nString\n\n\nthe name of the widget to load, exactly as specified by the widget descriptor\n\n\n\n\n\n\nenvironment.services\n\n\nwidget_services\n\n\nthe services for this widget instance\n\n\n\n\n\n\nenvironment.provideServices\n\n\nFunction\n\n\na function that the adapter must call with a map of all to-be-injected services, just before creating the controller\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nObject\n\n\nthe adapter instance", 
            "title": "plain_adapter"
        }, 
        {
            "location": "/api/runtime.plain_adapter/#contents", 
            "text": "Module Members   bootstrap()   Types   PlainAdapterFactory  PlainAdapterFactory.create()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.plain_adapter/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/runtime.plain_adapter/#parameters", 
            "text": "Property  Type  Description      artifacts  Object  the artifacts available to this adapter factory    artifacts.widgets  Object  all widgets, that are implemented in the adapter's technology    artifacts.controls  Object  all controls, that are implemented in the adapter's technology    services  Object  a selection of services adapter implementations may need to fulfill their task    services.adapterUtilities  AdapterUtilities  common utilities, that may be useful to a widget adapter    services.artifactProvider  ArtifactProvider  the artifact provider instance    services.configuration  Configuration  access to the application configuration    services.globalEventBus  EventBus  the global event bus. Note that an adapter should not sent any events by itself. It may instead be necessary that the adapter makes the event bus globally available to its widgets (for example like the AngularJS 1.x adapter), or that it registers an inspector    services.heartbeat  Heartbeat  the heartbeat instance. Depending on the underlying view technology (like AngularJS 1.x) it may be important to get notified when to re-render the user interface. For that reason an adapter can register a callback at the heartbeat, that gets called after all events of the current cycle were processed    services.log  Log  the global log instance    services.storage  StorageFactory  the global storage factory api    services.tooling  Tooling  access to the tooling api    anchorElement  HTMLElement  the DOM node the laxar application is bootstrapped on. An adapter should never try to access DOM nodes that are not the  anchorElement  or any of its children, since they are not under control of this LaxarJS application.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.plain_adapter/#returns", 
            "text": "Type  Description      PlainAdapterFactory  the factory for plain widget adapters", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.plain_adapter/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.plain_adapter/#parameters_1", 
            "text": "Property  Type  Description      environment  Object  the environment for the widget to create and manage    environment.anchorElement  HTMLElement  the DOM node that the widget's DOM fragment should be inserted into    environment.name  String  the name of the widget to load, exactly as specified by the widget descriptor    environment.services  widget_services  the services for this widget instance    environment.provideServices  Function  a function that the adapter must call with a map of all to-be-injected services, just before creating the controller", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.plain_adapter/#returns_1", 
            "text": "Type  Description      Object  the adapter instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.storage/", 
            "text": "storage\n\n\nModule providing the StorageApi factory.\n\n\nWidgets and activities can access their StorageApi instance by requesting the injection\n\naxStorage\n, or use\n\naxGlobalStorage\n for shared items.\n\n\nAs such, in most cases only the \nStorageApi\n documentation is relevant.\n\n\nContents\n\n\nTypes\n\n\n\n\n\n\nStorageApi\n\n\n\n\nStorageApi.getItem()\n\n\nStorageApi.setItem()\n\n\nStorageApi.removeItem()\n\n\n\n\n\n\n\n\nStorageFactory\n\n\n\n\nStorageFactory.getLocalStorage()\n\n\nStorageFactory.getSessionStorage()\n\n\nStorageFactory.getApplicationLocalStorage()\n\n\nStorageFactory.getApplicationSessionStorage()\n\n\n\n\n\n\n\n\nTypes\n\n\nStorageApi\n\n\nProvides a convenient API over the browser's \nwindow.localStorage\n and \nwindow.sessionStorage\n objects.\nIf a browser doesn't support \nweb storage\n, a warning is logged to the\n\nconsole\n (if available) and a non-persistent in-memory store will be used instead. Note that this can\nfor example also happen when using Mozilla Firefox with cookies disabled and as such isn't limited to\nolder browsers.\n\n\nAdditionally, in contrast to plain \nweb storage\n access, non-string values will be automatically passed\nthrough JSON (de-) serialization on storage or retrieval. All keys will be prepended with a combination\nof a fixed (\nax.\n) and an application-specific namespace (configured using \nstoragePrefix\n with fallback\nto \nname\n) to avoid naming clashes with other (LaxarJS) web applications running on the same host and\nport. All \nStorageApi\n accessor methods should be called without any namespace as it is\nprepended automatically.\n\n\nStorageApi.getItem( key )\n\n\nRetrieves a \nvalue\n by \nkey\n from the store. JSON deserialization will automatically be applied.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\nthe key of the item to retrieve (without namespace prefix)\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe value or \nnull\n if it doesn't exist in the store\n\n\n\n\n\n\n\n\nStorageApi.setItem( key, value )\n\n\nSets a \nvalue\n for a \nkey\n. The value must be JSON serializable. An existing value will be overwritten.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\nthe key of the item to set (without namespace prefix)\n\n\n\n\n\n\nvalue\n\n\n*\n\n\nthe new value to set\n\n\n\n\n\n\n\n\nStorageApi.removeItem( key )\n\n\nRemoves the value associated with \nkey\n from the store.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nString\n\n\nthe key of the item to remove (without namespace prefix)\n\n\n\n\n\n\n\n\nStorageFactory\n\n\nThe API returned by the module's \ncreate\n function.\n\n\nStorageFactory.getLocalStorage( namespace )\n\n\nReturns a local storage object for a specific local namespace.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace\n\n\nString\n\n\nthe namespace to prepend to keys\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe local storage object\n\n\n\n\n\n\n\n\nStorageFactory.getSessionStorage( namespace )\n\n\nReturns a session storage object for a specific local namespace.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace\n\n\nString\n\n\nthe namespace to prepend to keys\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe session storage object\n\n\n\n\n\n\n\n\nStorageFactory.getApplicationLocalStorage()\n\n\nReturns the local storage object for application scoped keys. This is equivalent to\n\nstorage.getLocalStorage( 'app' )\n.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe application local storage object\n\n\n\n\n\n\n\n\nStorageFactory.getApplicationSessionStorage()\n\n\nReturns the session storage object for application scoped keys. This is equivalent to\n\nstorage.getSessionStorage( 'app' )\n.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageApi\n\n\nthe application session storage object", 
            "title": "storage"
        }, 
        {
            "location": "/api/runtime.storage/#contents", 
            "text": "Types    StorageApi   StorageApi.getItem()  StorageApi.setItem()  StorageApi.removeItem()     StorageFactory   StorageFactory.getLocalStorage()  StorageFactory.getSessionStorage()  StorageFactory.getApplicationLocalStorage()  StorageFactory.getApplicationSessionStorage()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.storage/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.storage/#parameters", 
            "text": "Property  Type  Description      key  String  the key of the item to retrieve (without namespace prefix)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.storage/#returns", 
            "text": "Type  Description      *  the value or  null  if it doesn't exist in the store", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.storage/#parameters_1", 
            "text": "Property  Type  Description      key  String  the key of the item to set (without namespace prefix)    value  *  the new value to set", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.storage/#parameters_2", 
            "text": "Property  Type  Description      key  String  the key of the item to remove (without namespace prefix)", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.storage/#parameters_3", 
            "text": "Property  Type  Description      namespace  String  the namespace to prepend to keys", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.storage/#returns_1", 
            "text": "Type  Description      StorageApi  the local storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.storage/#parameters_4", 
            "text": "Property  Type  Description      namespace  String  the namespace to prepend to keys", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.storage/#returns_2", 
            "text": "Type  Description      StorageApi  the session storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.storage/#returns_3", 
            "text": "Type  Description      StorageApi  the application local storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.storage/#returns_4", 
            "text": "Type  Description      StorageApi  the application session storage object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.storage_mock/", 
            "text": "storage_mock\n\n\nAllows to instantiate a mock implementations of \nStorage\n, compatible to the \"axGlobalStorage\"\ninjection. For the widget-specific \"axStorage\" injection, refer to the \nwidget_services_storage_mock\n\nmodule.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nStorageMock\n\n\n{StorageMock}\n\n\n{StorageMock}.- unknown -\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate()\n\n\nCreates a storage mock that does not actually change the browser's local- or session-storage.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nStorageMock\n\n\na fresh mock instance\n\n\n\n\n\n\n\n\nTypes\n\n\nStorageMock\n\n\n\n\nextends \n{Storage}\n\n\n\n\nA mock for \nStorage\n that does not actually change the browser's local- or session-storage.\nInstances of this mock are compatible to the \"axGlobalStorage\" injection.\n\n\nDo not confuse this with the {@AxStorageMock}, which is compatible to the \"axStorage\" injection offered\nby the widget services.\n\n\nNote that the mock does perform JSON transformations of the value objects, just like the actual Storage.\n\n\n{StorageMock}\n\n\n{StorageMock}.- unknown - \nObject\n\n\nProvides access to the backing stores of the storage mock.\n\n\nHas a \nlocal\n and a \nsession\n property, each of which has spies for \ngetItem\n/\nsetItem\n/\nremoveItem\n.\nThe \nlocal\n and \nsession\n properties also provide direct access to their respective backing \nstore\n\nobjects, accessible in this manner:\n\n\nimport\n \n{\n \ncreateAxGlobalStorageMock\n \n}\n \nfrom\n \nlaxar/laxar-widget-service-mocks\n;\n\n\nconst\n \nstorageMock\n \n=\n \ncreateAxGlobalStorageMock\n();\n\n\nstorageMock\n.\ngetLocalStorage\n(\n \nmyNs\n \n).\nsetItem\n(\n \nk\n,\n \nv\n \n);\n\n\nexpect\n(\n \nstorageMock\n.\nmockBackends\n.\nlocal\n.\nmyNs\n.\nk\n \n).\ntoEqual\n(\n \nv\n \n);\n  \n// note the JSON transform", 
            "title": "storage_mock"
        }, 
        {
            "location": "/api/testing.storage_mock/#contents", 
            "text": "Module Members   create()   Types   StorageMock  {StorageMock}  {StorageMock}.- unknown -", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.storage_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.storage_mock/#returns", 
            "text": "Type  Description      StorageMock  a fresh mock instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.storage_mock/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/utilities.string/", 
            "text": "string\n\n\nUtilities for dealing with strings.\n\n\nIt can be imported as \nstring\n from 'laxar';\n\n\nContents\n\n\nModule Members\n\n\n\n\nDEFAULT_FORMATTERS\n\n\nformat()\n\n\ncreateFormatter()\n\n\n\n\nModule Members\n\n\nDEFAULT_FORMATTERS \nObject\n\n\nA map of all available default format specifiers to their respective formatter function.\nThe following specifiers are available:\n\n\n\n\n%d\n / \n%i\n: Format the given numeric value as integer. Decimal places are removed\n\n\n\n\n%f\n: Format the given numeric value as floating point value. This specifier supports precision as\n  sub-specifier (e.g. \n%.2f\n for 2 decimal places)\n\n\n\n\n\n\n%s\n: use simple string serialization using \ntoString\n\n\n\n\n%o\n: Format complex objects using \nJSON.stringify\n\n\n\n\nformat( string, optionalIndexedReplacements, optionalNamedReplacements )\n\n\nSubstitutes all unescaped placeholders in the given string for a given indexed or named value.\nA placeholder is written as a pair of brackets around the key of the placeholder. An example of an\nindexed placeholder is \n[0]\n and a named placeholder would look like this \n[replaceMe]\n. If no\nreplacement for a key exists, the placeholder will simply not be substituted.\n\n\nSome examples:\n\n\nimport\n \n{\n \nstring\n \n}\n \nfrom\n \nlaxar\n;\n\n\nstring\n.\nformat\n(\n \nHello [0], how do you like [1]?\n,\n \n[\n \nPeter\n,\n \nCheeseburgers\n \n]\n \n);\n\n\n// =\n \nHello Peter, how do you like Cheeseburgers?\n\n\n\nstring\n.\nformat\n(\n \nHello [name] and [partner], how do you like [0]?\n,\n \n[\n \nPizza\n \n],\n \n{\n\n   \nname\n:\n \nHans\n,\n\n   \npartner\n:\n \nRoswita\n\n\n}\n \n);\n\n\n// =\n \nHello Hans and Roswita, how do you like Pizza?\n\n\n\n\n\n\nIf a pair of brackets should not be treated as a placeholder, the opening bracket must be escaped by\nbackslashes. To get an actual backslash in a JavaScript string literal, which is then treated as\nan escape symbol, it needs to be written as double backslash:\n\n\nimport\n \n{\n \nstring\n \n}\n \nfrom\n \nlaxar\n;\n\n\nstring\n.\nformat\n(\n \nA [something] should eventually only have \\\\[x].\n,\n \n{\n\n   \nsomething\n:\n \nchecklist\n\n\n}\n \n);\n\n\n// =\n \nA checklist should eventually only have [x].\n\n\n\n\n\n\nA placeholder key can be any character string besides \n[\n, \n]\n and \n:\n to keep parsing simple and fast.\nBy using \n:\n as separator it is possible to provide a type specifier for string serialization or to add\na custom mapping function. Type specifiers always begin with \n%\n and end with the specifier type.\nBuiltin specifiers and their corresponding formatter functions are defined as \nDEFAULT_FORMATTERS\n.\n\n\nWhen no specifier is provided, by default \n%s\n is assumed.\n\n\nExample:\n\n\nimport\n \n{\n \nstring\n \n}\n \nfrom\n \nlaxar\n;\n\n\nstring\n.\nformat\n(\n \nHello [0:%s], you owe me [1:%.2f] euros.\n,\n \n[\n \nPeter\n,\n \n12.1243\n \n]\n \n);\n\n\n// =\n \nHello Peter, you owe me 12.12 euros.\n\n\n\n\n\n\nMapping function names should be composed from alphanumeric characters, like regular JavaScript\nidentifiers. They can be registered using \n#createFormatter()\n:\n\n\nimport\n \n{\n \nstring\n \n}\n \nfrom\n \nlaxar\n;\n\n\nconst\n \nformat\n \n=\n \nstring\n.\ncreateFormatter\n(\n \nnull\n,\n \n{\n\n   \ndouble\n:\n \nx\n \n=\n \n2\n*\nx\n,\n\n   \nflip\n:\n \ns\n \n=\n \ns\n.\nsplit\n(\n \n \n).\nreverse\n().\njoin\n(\n \n \n)\n\n\n}\n \n);\n\n\nformat\n(\n \nHello [0:%s:flip], you owe me [1:double:%.2f] euros.\n,\n \n[\n \nPeter\n,\n \n12\n \n]\n \n);\n\n\n// =\n \nHello reteP, you owe me 24.00 euros.\n\n\n\n\n\n\nCurrently there are no builtin mapping functions.\n\n\nIf a type specifier is used that does not exist, an exception is thrown. In contrast to that the use of\nan unknown mapping function results in a no-op. This allows to use filter-like functions that transform\nmarked values within a specific context (for example, performing anonymization during analytics logging),\nwithout modifying the value in other contexts (local debug loggign).\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstring\n\n\nString\n\n\nthe string to replace placeholders in\n\n\n\n\n\n\noptionalIndexedReplacements\n\n\nArray\n\n\nan optional array of indexed replacements\n\n\n\n\n\n\noptionalNamedReplacements\n\n\nObject\n\n\nan optional map of named replacements\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe string with placeholders substituted for their according replacements\n\n\n\n\n\n\n\n\ncreateFormatter( typeFormatters, optionalValueMappers )\n\n\nCreates a new format function having the same api as \n#format()\n. If the first argument is\nomitted or \nnull\n, the default formatters for type specifiers are used. Otherwise only the provided map\nof specifiers is available to the returned format function. Each key of the map is a specifier character\nwhere the \n%\n is omitted and the value is the formatting function. A formatting function receives the\nvalue to format (i.e. serialize) and the sub-specifier (if any) as arguments. For example for the format\nspecifier \n%.2f\n the sub-specifier would be \n.2\n where for \n%s\n it would simply be the empty string.\n\n\nExample:\n\n\nconst\n \nformat\n \n=\n \nstring\n.\ncreateFormatter\n(\n \n{\n\n   \nm\n:\n \nfunction\n(\n \nvalue\n \n)\n \n{\n\n      \nreturn\n \nvalue\n.\namount\n \n+\n \n \n \n+\n \nvalue\n.\ncurrency\n;\n\n   \n},\n\n   \np\n:\n \nfunction\n(\n \nvalue\n,\n \nsubSpecifier\n \n)\n \n{\n\n      \nreturn\n \nMath\n.\npow\n(\n \nvalue\n,\n \nparseInt\n(\n \nsubSpecifier\n,\n \n10\n \n)\n \n);\n\n   \n}\n\n\n}\n \n);\n\n\n\nformat\n(\n \nYou owe me [0:%m].\n,\n \n[\n \n{\n \namount\n:\n \n12\n,\n \ncurrency\n:\n \nEUR\n \n}\n \n]\n \n);\n\n\n// =\n \nYou owe me 12 EUR.\n\n\n\nformat\n(\n \n[0]^3 = [0:%3p]\n,\n \n[\n \n2\n \n]\n \n);\n\n\n// =\n \n2^3 = 8\n\n\n\n\n\n\nThe second argument is completely additional to the behavior of the default \n#format()\n\nfunction. Here a map from mapping function id to actual mapping function can be passed in. Whenever the\nid of a mapping function is found within the placeholder, that mapping function is called with the\ncurrent value and its return value is either passed to the next mapping function or rendered\ninstead of the placeholder if there are no more mapping function ids or type specifiers within the\nplaceholder string.\n\n\nconst\n \nformat\n \n=\n \nstring\n.\ncreateFormatter\n(\n \nnull\n,\n \n{\n\n   \nflip\n:\n \nfunction\n(\n \nvalue\n \n)\n \n{\n\n      \nreturn\n \n(\n \n \n+\n \ns\n \n).\nsplit\n(\n \n \n).\nreverse\n().\njoin\n(\n \n \n);\n\n   \n},\n\n   \ndouble\n:\n \nfunction\n(\n \nvalue\n \n)\n \n{\n\n      \nreturn\n \nvalue\n \n*\n \n2\n;\n\n   \n}\n\n\n}\n \n);\n\n\n\nformat\n(\n \nHello [0:%s:flip], you owe me [1:double:%.2f] euros.\n,\n \n[\n \nPeter\n,\n \n12\n \n]\n \n);\n\n\n// =\n \nHello reteP, you owe me 24.00 euros.\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntypeFormatters\n\n\nObject\n\n\nmap from format specifier (single letter without leading \n%\n) to formatting function\n\n\n\n\n\n\noptionalValueMappers\n\n\nObject\n\n\nmap from mapping identifier to mapping function\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nFunction\n\n\na function having the same api as \n#format()", 
            "title": "string"
        }, 
        {
            "location": "/api/utilities.string/#contents", 
            "text": "Module Members   DEFAULT_FORMATTERS  format()  createFormatter()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/utilities.string/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/utilities.string/#parameters", 
            "text": "Property  Type  Description      string  String  the string to replace placeholders in    optionalIndexedReplacements  Array  an optional array of indexed replacements    optionalNamedReplacements  Object  an optional map of named replacements", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.string/#returns", 
            "text": "Type  Description      String  the string with placeholders substituted for their according replacements", 
            "title": "Returns"
        }, 
        {
            "location": "/api/utilities.string/#parameters_1", 
            "text": "Property  Type  Description      typeFormatters  Object  map from format specifier (single letter without leading  % ) to formatting function    optionalValueMappers  Object  map from mapping identifier to mapping function", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/utilities.string/#returns_1", 
            "text": "Type  Description      Function  a function having the same api as  #format()", 
            "title": "Returns"
        }, 
        {
            "location": "/api/tooling.tooling/", 
            "text": "tooling\n\n\nAccepts static debug information from \nlaxar-loader/debug-info\n and listens on the debug event bus to\nsupply development tools with the current state of the LaxarJS instance and bootstrapping items:\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nAxTooling\n\n\nAxTooling.forItem()\n\n\nAxTooling.registerDebugInfo()\n\n\nAxTooling.registerItem()\n\n\nAxTooling.onChange()\n\n\nAxTooling.unsubscribe()\n\n\nAxTooling.pages\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate()\n\n\nExposes inspection data from laxarjs services to development tools\n\n\nTypes\n\n\nAxTooling\n\n\nAxTooling.forItem( itemMeta )\n\n\nGet an \n#AxTooling\n interface for the given bootstrapping item.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nitemMeta\n\n\nItemMeta\n\n\nan object identifying the bootstrapping item\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxTooling\n\n\na tooling API for the given bootstrapping item\n\n\n\n\n\n\n\n\nAxTooling.registerDebugInfo( debugInfo )\n\n\nRegister a debug info object or callback with the tooling instance. Debug information can be generated\nwith \nlaxar-loader/debug-info\n and may be in the form a function accepting a callback.\nIf debug information is needed, the function will be called to load it asynchronously.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndebugInfo\n\n\nObject\n, \nFunction\n\n\na debug information callback or object\n\n\n\n\n\n\n\n\nAxTooling.registerItem( itemMeta )\n\n\nRegister a bootstrapping item with the tooling instance.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nitemMeta\n\n\nItemMeta\n\n\nan object identifying the bootstrapping item\n\n\n\n\n\n\n\n\nAxTooling.onChange( callback )\n\n\nRegister a function to be called when the composition of active observed items changes.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\na function to call with updated debug information\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxTooling\n\n\nthe tooling instance\n\n\n\n\n\n\n\n\nAxTooling.unsubscribe( callback )\n\n\nUnsubscribe a registered \n#AxTooling.onChange\n callback\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\na function that was previously passed to \n#AxTooling.onChange\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxTooling\n\n\nthe tooling instance\n\n\n\n\n\n\n\n\nAxTooling.pages \nPagesTooling\n\n\nA \nPagesTooling\n interface to the \nAxTooling\n instance.", 
            "title": "tooling"
        }, 
        {
            "location": "/api/tooling.tooling/#contents", 
            "text": "Module Members   create()   Types   AxTooling  AxTooling.forItem()  AxTooling.registerDebugInfo()  AxTooling.registerItem()  AxTooling.onChange()  AxTooling.unsubscribe()  AxTooling.pages", 
            "title": "Contents"
        }, 
        {
            "location": "/api/tooling.tooling/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/tooling.tooling/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/tooling.tooling/#parameters", 
            "text": "Property  Type  Description      itemMeta  ItemMeta  an object identifying the bootstrapping item", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/tooling.tooling/#returns", 
            "text": "Type  Description      AxTooling  a tooling API for the given bootstrapping item", 
            "title": "Returns"
        }, 
        {
            "location": "/api/tooling.tooling/#parameters_1", 
            "text": "Property  Type  Description      debugInfo  Object ,  Function  a debug information callback or object", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/tooling.tooling/#parameters_2", 
            "text": "Property  Type  Description      itemMeta  ItemMeta  an object identifying the bootstrapping item", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/tooling.tooling/#parameters_3", 
            "text": "Property  Type  Description      callback  Function  a function to call with updated debug information", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/tooling.tooling/#returns_1", 
            "text": "Type  Description      AxTooling  the tooling instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/tooling.tooling/#parameters_4", 
            "text": "Property  Type  Description      callback  Function  a function that was previously passed to  #AxTooling.onChange", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/tooling.tooling/#returns_2", 
            "text": "Type  Description      AxTooling  the tooling instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/", 
            "text": "widget_services\n\n\nFactory for the services that are available to the controller of a widget, regardless of the underlying\nview framework.\n\n\nContents\n\n\nModule Members\n\n\n\n\naxAreaHelper\n\n\naxAssets\n\n\naxConfiguration\n\n\naxContext\n\n\naxControls\n\n\naxDebugEventBus\n\n\naxEventBus\n\n\naxFeatures\n\n\naxFlowService\n\n\naxGlobalEventBus\n\n\naxGlobalLog\n\n\naxGlobalStorage\n\n\naxHeartbeat\n\n\naxI18n\n\n\naxId()\n\n\naxLog\n\n\naxStorage\n\n\naxTooling\n\n\naxVisibility\n\n\n\n\nTypes\n\n\n\n\n\n\nAxContext\n\n\n\n\nAxContext.eventBus\n\n\nAxContext.features\n\n\nAxContext.id()\n\n\nAxContext.log\n\n\nAxContext.widget\n\n\n\n\n\n\n\n\nAxAreaHelper\n\n\n\n\nAxAreaHelper.isVisible()\n\n\nAxAreaHelper.fullName()\n\n\nAxAreaHelper.localName()\n\n\nAxAreaHelper.register()\n\n\n\n\n\n\n\n\nAxAssets\n\n\n\n\nAxAssets.url()\n\n\nAxAssets.forTheme()\n\n\nAxAssets.urlForTheme()\n\n\n\n\n\n\n\n\nAxStorage\n\n\n\n\nAxStorage.local\n\n\nAxStorage.session\n\n\n\n\n\n\n\n\nAxEventBus\n\n\n\n\n\n\nModule Members\n\n\naxAreaHelper \nAxAreaHelper\n\n\nAllows to manage the widget's areas.\n\n\naxAssets \nAxAssets\n\n\nProvides access to the widget's assets.\n\n\naxConfiguration \nConfiguration\n\n\nInterface to the full configuration the application was bootstrapped with.\n\n\naxContext \nAxContext\n\n\nCombines essential widget services with some instance information to be passed around en bloc.\n\n\naxControls \nControlLoader\n\n\nProvides access to implementation modules of the controls used by the widget.\n\n\naxDebugEventBus \nAxEventBus\n\n\nProvides access to a super-global EventBus shared by Laxar instances.\n\n\naxEventBus \nAxEventBus\n\n\nEvent bus instance specifically enriched for the widget instance.\n\n\naxFeatures \nObject\n\n\nThe features the widget was configured with.\nIts structure depends on the schema defined in the widget descriptor (\nwidget.json\n).\n\n\naxFlowService \nFlowService\n\n\nAllows to generate URLs based on navigation targets or place IDs, in order to create links.\n\n\naxGlobalEventBus \nEventBus\n\n\nThe global event bus instance of the application.\n\n\nThe widget-specific \naxEventBus\n should always be prefered over this, since subscriptions\nto the global event bus will not be cleaned up automatically as clients are destroyed, which\ncan lead to severe memory leaks.\nA valid use case could be an activity that needs to add an inspector to the event bus in order\nto provide debuggig information about application events, or to log specific events without\nstopping on page navigation.\n\n\naxGlobalLog \nLogger\n\n\nAllows to log messages, taking into account the configured log level.\n\n\naxGlobalStorage \nStorageFactory\n\n\nThe global storage factory allows to share storage items across widgets.\n\n\naxHeartbeat \nHeartbeat\n\n\nThe heartbeat instance allows to perform actions such as dirty checking after each event\nbus cycle.\n\n\naxI18n \nAxI18n\n\n\nI18n API that allows to localize values depending on the locale configured for the widget.\n\n\naxId( localUniqueId )\n\n\nA function that generates page-wide unique IDs based on IDs that are unique within the scope\nof a widget.\n\n\nA common use case is the connection of a \nlabel\n HTML element and an \ninput\n element via \nfor\n\nand \nid\n attributes.\nTo avoid collisions, IDs should \nalways\n be generated using this service.\n\n\nExample:\n\n\n// ... inject `axId`, get reference to `widgetDom` (depends on integration technology) ...\n\n\nwidgetDom\n.\nquerySelector\n(\n \nlabel\n \n).\nsetAttribute\n(\n \nfor\n,\n \naxId\n(\n \nmyField\n \n)\n \n);\n\n\nwidgetDom\n.\nquerySelector\n(\n \ninput\n \n).\nsetAttribute\n(\n \nid\n,\n \naxId\n(\n \nmyField\n \n)\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlocalUniqueId\n\n\nString\n\n\nan identifier that is unique within a widget\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nan identifier that is unique for the current page\n\n\n\n\n\n\n\n\naxLog \nLogger\n\n\nThe widget logger instance.\nSimilar to \n#axGlobalLog\n, but adds the name of the widget as prefix and the widget ID\nas suffix to every log message.\n\n\naxStorage \nAxStorage\n\n\nPreconfigured storage API for a widget: all keys are namespaced using the widget ID,\nin order to limit item visibility to this specific instance.\n\n\naxTooling \nAxTooling\n\n\nAccess to the tooling provider API.\n\n\naxVisibility \nAxVisibility\n\n\nVisibility services for a widget instance.\n\n\nTypes\n\n\nAxContext\n\n\nThis object encapsulates widget context information and provides access to the most important widget\nspecific service instances.\nMost commonly this is used when working with\n\nLaxarJS Patterns\n.\n\n\nAxContext.eventBus \nAxEventBus\n\n\nThe event bus instance of the widget. This is the same as \n#axEventBus\n.\n\n\nAxContext.features \nObject\n\n\nThe configured features of the widget. This is the same as \n#axFeatures\n.\n\n\nAxContext.id()\n\n\nThe unique id generator function. This is the same as \n#axId\n.\n\n\nAxContext.log \nAxLog\n\n\nThe widget local log instance. This is the same as \n#axLog\n.\n\n\nAxContext.widget \nObject\n\n\nSome information regarding the widget instance.\n\n\nThe following fields are available:\n\n\n\n\narea\n: full name of the area the widget is located in\n\n\nid\n: the unique id of the widget on the page\n\n\npath\n: path of the widget that was used to reference it in the according page or composition.\n   This is not the actual path on the file system, but most probably an alias known by the used\n   module loader.\n\n\n\n\nAxAreaHelper\n\n\nAxAreaHelper.isVisible( fullAreaName )\n\n\nQuery if a given widget area is currently visible by accessing the underlying area status through\nthe page controller. Can be used to determine the current visibility state of an area without\nhaving to constantly observe visibility events.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfullAreaName\n\n\nString\n\n\nthe global name of the area\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBoolean\n\n\nthe current visibility state of the given area\n\n\n\n\n\n\n\n\nAxAreaHelper.fullName( localAreaName )\n\n\nLooks up the global name of a widget area within a widget, as generated by LaxarJS.\nThis is the reverse of \n#AxAreaHelper.localName()\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlocalAreaName\n\n\nString\n\n\nthe widget-local name of the area\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe globally valid name of the area\n\n\n\n\n\n\n\n\nAxAreaHelper.localName( fullAreaName )\n\n\nReturns the local part of a global area name.\nThis is the reverse of \n#AxAreaHelper.fullName()\n.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfullAreaName\n\n\nString\n\n\nthe global name of the area\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe name of the area as it is known to the widget\n\n\n\n\n\n\n\n\nAxAreaHelper.register( localAreaName, element )\n\n\nRegisters a DOM element as area of a widget with the area helper.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlocalAreaName\n\n\nString\n\n\nthe widget-local name of the area\n\n\n\n\n\n\nelement\n\n\nHTMLElement\n\n\nthe element to register as widget area\n\n\n\n\n\n\n\n\nAxAssets\n\n\nNote:\n This service is a function with the \n#AxAssets.url()\n, \n#AxAssets.forTheme()\n and\n\n#AxAssets.urlForTheme()\n functions as properties.\n\n\nResolves an asset located directly in the widget folder or a subfolder of it.\nValid assets are all non-binary files like JSON or text files.\nFor binary files there exists the \n#AxAssets.url\n function.\n\n\nExample:\n\n\n// ... inject `axAssets` ...\n\n\naxAssets\n(\n \ndata.json\n \n).\nthen\n(\n \nfileContent\n \n=\n \n{\n \n...\n \n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nname of the asset to resolve\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\npromise for the asset\n\n\n\n\n\n\n\n\nAxAssets.url( name )\n\n\nResolves the absolute url to the given asset located directly in the widget folder or a subfolder of\nit.\nThis can then be safely used in e.g. \nvideo\n or \nimg\n tags.\n\n\nExample:\n\n\n// ... inject `axAssets`, find `img` in DOM ...\n\n\naxAssets\n.\nurl\n(\n \ntux.jpg\n \n).\nthen\n(\n \nurl\n \n=\n \n{\n \nimg\n.\nsrc\n \n=\n \nurl\n;\n \n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nname of the asset the url should be returned of\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\npromise for the url\n\n\n\n\n\n\n\n\nAxAssets.forTheme( name )\n\n\nResolves an asset from one of the \n*.theme\n subfolders of the widget.\nThe folder from which the asset is taken, depends on the selected theme and the availability of the\nfile within that theme (See\n\nhere\n for\nfurther information on theme asset lookup).\nValid assets are all non-binary files like JSON or text files.\nFor binary files there exists the \n#AxAssets.urlForTheme\n function.\n\n\nExample:\n\n\n// ... inject `axAssets` ...\n\n\naxAssets\n.\nforTheme\n(\n \nsome-template.html\n \n).\nthen\n(\n \ntemplate\n \n=\n \n{\n \n...\n \n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nname of the asset to resolve\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\npromise for the asset\n\n\n\n\n\n\n\n\nAxAssets.urlForTheme( name )\n\n\nResolves the absolute url to the given asset from one of the \n*.theme\n subfolders of the widget.\nThis can then be safely used in e.g. \nvideo\n or \nimg\n tags.\nThe folder from which the asset is taken, depends on the selected theme and the availability of the\nfile within that theme (See\n\nhere\n for\nfurther information on theme asset lookup).\n\n\nExample:\n\n\n// ... inject `axAssets`, find `img` in DOM ...\n\n\naxAssets\n.\nurlForTheme\n(\n \nicon.jpg\n \n).\nthen\n(\n \nurl\n \n=\n \n{\n \nimg\n.\nsrc\n \n=\n \nurl\n;\n \n}\n \n);\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nname of the asset the url should be returned of\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\npromise for the url\n\n\n\n\n\n\n\n\nAxStorage\n\n\nReady to use storage API for a single widget instance.\nAll keys are namespaced by the widget id to limit visibility to this specific instance.\n\n\nAxStorage.local \nStorageApi\n\n\nAn instance of the storage api using the persistent \nwindow.localStorage\n.\n\n\nAxStorage.session \nStorageApi\n\n\nAn instance of the storage api using the non-persistent \nwindow.sessionStorage\n.\n\n\nAxEventBus\n\n\nThis is an extension of the global \nEventBus\n by widget specific information\nand tasks.\nFor example a combination of the widget's name and its id is always used as subscriber and sender\nid.\nHence for example \nEventBus.publishAndGatherReplies\n\nworks without passing in any options.\n\n\nAdditionally all subscriptions of a widget are removed as soon as the widget itself is destroyed.\nSo in practice a widget will receive no further events after the \nendLifecycleRequest\n event\nprocessing has finished.\n\n\nThe documentation for the events bus api can be found \nhere\n.", 
            "title": "widget_services"
        }, 
        {
            "location": "/api/runtime.widget_services/#contents", 
            "text": "Module Members   axAreaHelper  axAssets  axConfiguration  axContext  axControls  axDebugEventBus  axEventBus  axFeatures  axFlowService  axGlobalEventBus  axGlobalLog  axGlobalStorage  axHeartbeat  axI18n  axId()  axLog  axStorage  axTooling  axVisibility   Types    AxContext   AxContext.eventBus  AxContext.features  AxContext.id()  AxContext.log  AxContext.widget     AxAreaHelper   AxAreaHelper.isVisible()  AxAreaHelper.fullName()  AxAreaHelper.localName()  AxAreaHelper.register()     AxAssets   AxAssets.url()  AxAssets.forTheme()  AxAssets.urlForTheme()     AxStorage   AxStorage.local  AxStorage.session     AxEventBus", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.widget_services/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters", 
            "text": "Property  Type  Description      localUniqueId  String  an identifier that is unique within a widget", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns", 
            "text": "Type  Description      String  an identifier that is unique for the current page", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_1", 
            "text": "Property  Type  Description      fullAreaName  String  the global name of the area", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns_1", 
            "text": "Type  Description      Boolean  the current visibility state of the given area", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_2", 
            "text": "Property  Type  Description      localAreaName  String  the widget-local name of the area", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns_2", 
            "text": "Type  Description      String  the globally valid name of the area", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_3", 
            "text": "Property  Type  Description      fullAreaName  String  the global name of the area", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns_3", 
            "text": "Type  Description      String  the name of the area as it is known to the widget", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_4", 
            "text": "Property  Type  Description      localAreaName  String  the widget-local name of the area    element  HTMLElement  the element to register as widget area", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_5", 
            "text": "Property  Type  Description      name  String  name of the asset to resolve", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns_4", 
            "text": "Type  Description      Promise  promise for the asset", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_6", 
            "text": "Property  Type  Description      name  String  name of the asset the url should be returned of", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns_5", 
            "text": "Type  Description      Promise  promise for the url", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_7", 
            "text": "Property  Type  Description      name  String  name of the asset to resolve", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns_6", 
            "text": "Type  Description      Promise  promise for the asset", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services/#parameters_8", 
            "text": "Property  Type  Description      name  String  name of the asset the url should be returned of", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services/#returns_7", 
            "text": "Type  Description      Promise  promise for the url", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.widget_services_area_helper_mock/", 
            "text": "widget_services_area_helper_mock\n\n\nAllows to instantiate a mock implementations of \nAxAreaHelper\n, compatible to the \"axAreaHelper\"\nwidget service injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nModule Members\n\n\ncreate( context )\n\n\nCreates a mock for the widget-specific \"axAreaHelper\" injection.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontext\n\n\nAxContext\n\n\nan object with a \nwidget.id\n property\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxAreaHelper\n\n\nan \naxAreaHelper\n-compatible mock object", 
            "title": "widget_services_area_helper_mock"
        }, 
        {
            "location": "/api/testing.widget_services_area_helper_mock/#contents", 
            "text": "Module Members   create()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.widget_services_area_helper_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.widget_services_area_helper_mock/#parameters", 
            "text": "Property  Type  Description      context  AxContext  an object with a  widget.id  property", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_area_helper_mock/#returns", 
            "text": "Type  Description      AxAreaHelper  an  axAreaHelper -compatible mock object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/", 
            "text": "widget_services_assets_mock\n\n\nAllows instantiate a mock implementations of \nAxAssets\n, compatible to the \"axAssets\" injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nAxAssetsMock\n\n\nAxAssetsMock.mock()\n\n\nAxAssetsMock.mockUrl()\n\n\nAxAssetsMock.mockForTheme()\n\n\nAxAssetsMock.mockUrlForTheme()\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( artifactAssets={}, artifactName='mock-widget' )\n\n\nCreates a mock for the \"axAssets\" injection of a widget.\n\n\nUsually the mock is created from a complete, generated assets entry, as described for the \nAxAssets\n\nservice.\n\n\nconst\n \nartifactAssets\n \n=\n \n{\n\n   \nmyMessages.json\n:\n \n{\n \ncontent\n:\n \n{\nyo\n:42}\n \n},\n\n   \ndefault.theme\n:\n \n{\n\n       \nsome.png\n:\n \n{\n \nurl\n:\n \n/path/to/some.png\n \n}\n\n   \n}\n\n\n};\n\n\n\n\n\n\nAssets are usually retrieved by the widget under test through the \naxAssets\n injection, or\nprogrammatically like this:\n\n\nimport\n \n{\n \ncreateAxAssetsMock\n \n}\n \nfrom\n \nlaxar/laxar-widget-service-mocks\n;\n\n\nconst\n \naxAssetsMock\n \n=\n \ncreateAxAssetsMock\n(\n \nartifactAssets\n,\n \nother.theme\n \n);\n\n\nconsole\n.\nlog\n(\n \nJSON\n.\nparse\n(\n \naxAssetsMock\n(\n \nmyMessages.json\n \n)\n \n)\n \n);\n  \n// output: { yo: 42 }\n\n\nconsole\n.\nlog\n(\n \nassetsMock\n.\nurlForTheme\n(\n \nsome.png\n \n)\n \n);\n  \n// output: \n/path/to/some.png\n\n\n\n\n\n\nFrom the test, the mock may be inspected using jasmine:\n\n\nimport\n \n{\n \ncreateAxAssetsMock\n \n}\n \nfrom\n \nlaxar/laxar-widget-service-mocks\n;\n\n\nconst\n \naxAssetsMock\n \n=\n \ncreateAxAssetsMock\n(\n \nartifactAssets\n \n);\n\n\n// ...\n\n\nexpect\n(\n \naxAssetsMock\n \n).\ntoHaveBeenCalledWith\n(\n \nmyMessages.json\n \n);\n\n\nexpect\n(\n \naxAssetsMock\n.\nurl\n \n).\ntoHaveBeenCalledWith\n(\n \n/some/url\n \n);\n\n\n\n\n\n\nThe specified assets/themedAssets may be replaced afterwards using the \n.mock...\n methods.\nInstead of a complete entry, a user-defined entry containing just \nassets\n and/or \nthemedAssets\n may be\nused instead. Also, instead of the \"default.theme\", a custom theme may be passed. In this case, make sure\nthat the mock entry passed to \ncreate\n reflects this. Or use the mock\n\n\nimport\n \n{\n \ncreateAxAssetsMock\n \n}\n \nfrom\n \nlaxar/laxar-widget-service-mocks\n;\n\n\nconst\n \naxAssetsMock\n \n=\n \ncreateAxAssetsMock\n(\n \nartifactAssets\n,\n \nother.theme\n \n);\n\n\nconsole\n.\nlog\n(\n \nassetsMock\n.\nurlForTheme\n(\n \nsome.png\n \n)\n \n);\n  \n// output: null\n\n\naxAssetsMock\n.\nmock\n(\n \nmyMessages.json\n,\n \n{\nyo\n: 7}\n \n);\n\n\naxAssetsMock\n.\nmockUrlForTheme\n(\n \nsome.png\n,\n \n/path/to/some/other.png\n \n);\n\n\nconsole\n.\nlog\n(\n \nJSON\n.\nparse\n(\n \naxAssetsMock\n(\n \nmyMessages.json\n \n)\n \n)\n \n);\n  \n// output: { yo: 7 }\n\n\nconsole\n.\nlog\n(\n \nassetsMock\n.\nurlForTheme\n(\n \nsome.png\n \n)\n \n);\n  \n// output: \n/path/to/some/other.png\n\n\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nartifactAssets={}\n\n\nObject\n\n\nthe assets entry to base the mock on\n\n\n\n\n\n\ntheme='default.theme'\n\n\nString\n\n\nthe theme name to use. For portability, keeping the default is recommended.\n\n\n\n\n\n\nartifactName='mock-widget'\n\n\nString\n\n\nthe artifact name, only relevant for error messages\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxAssetsMock\n\n\na mock of \naxAssets\n that can be spied and/or mocked with additional assets\n\n\n\n\n\n\n\n\nTypes\n\n\nAxAssetsMock\n\n\n\n\nextends \nAxAssets\n\n\n\n\nAn AxAssets-compatible mock.\n\n\nSee \n#create\n for usage details.\n\n\nAxAssetsMock.mock( path, content )\n\n\nMock a regular asset.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nString\n\n\nthe asset path to mock\n\n\n\n\n\n\ncontent\n\n\nString\n\n\nthe asset contents that the mock should provide. Omit to discard the asset content.\n\n\n\n\n\n\n\n\nAxAssetsMock.mockUrl( path, url )\n\n\nMock a regular asset URL.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nString\n\n\nthe asset path to mock\n\n\n\n\n\n\nurl\n\n\nString\n\n\nthe asset URL to provide. Omit to discard the asset URL.\n\n\n\n\n\n\n\n\nAxAssetsMock.mockForTheme( path, content )\n\n\nMock an asset for the current theme.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nString\n\n\nthe theme-dependent asset path to mock\n\n\n\n\n\n\ncontent\n\n\nString\n\n\nthe asset content to provide. Omit to discard the asset content.\n\n\n\n\n\n\n\n\nAxAssetsMock.mockUrlForTheme( path, url )\n\n\nMock an asset URL for the current theme.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nString\n\n\nthe theme-dependent asset path to mock\n\n\n\n\n\n\nurl\n\n\nString\n\n\nthe asset URL to provide. Omit to discard the asset URL.", 
            "title": "widget_services_assets_mock"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#contents", 
            "text": "Module Members   create()   Types   AxAssetsMock  AxAssetsMock.mock()  AxAssetsMock.mockUrl()  AxAssetsMock.mockForTheme()  AxAssetsMock.mockUrlForTheme()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#parameters", 
            "text": "Property  Type  Description      artifactAssets={}  Object  the assets entry to base the mock on    theme='default.theme'  String  the theme name to use. For portability, keeping the default is recommended.    artifactName='mock-widget'  String  the artifact name, only relevant for error messages", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#returns", 
            "text": "Type  Description      AxAssetsMock  a mock of  axAssets  that can be spied and/or mocked with additional assets", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#parameters_1", 
            "text": "Property  Type  Description      path  String  the asset path to mock    content  String  the asset contents that the mock should provide. Omit to discard the asset content.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#parameters_2", 
            "text": "Property  Type  Description      path  String  the asset path to mock    url  String  the asset URL to provide. Omit to discard the asset URL.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#parameters_3", 
            "text": "Property  Type  Description      path  String  the theme-dependent asset path to mock    content  String  the asset content to provide. Omit to discard the asset content.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_assets_mock/#parameters_4", 
            "text": "Property  Type  Description      path  String  the theme-dependent asset path to mock    url  String  the asset URL to provide. Omit to discard the asset URL.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/", 
            "text": "widget_services_i18n\n\n\nFactory for i18n widget service instances.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\n\n\nAxI18n\n\n\n\n\nAxI18n.forFeature()\n\n\n\n\n\n\n\n\nAxI18nHandler\n\n\n\n\nAxI18nHandler.localize()\n\n\nAxI18nHandler.update()\n\n\nAxI18nHandler.languageTag()\n\n\nAxI18nHandler.track()\n\n\nAxI18nHandler.format()\n\n\nAxI18nHandler.whenLocaleChanged()\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( context, configuration, optionalOptions )\n\n\nCreates a widget-specific helper for \ndidChangeLocale\n events.\n\n\nThe helper automatically observes the any changes to the locale that was configured under the \ni18n\n\nfeature, and can be asked for localization based on that locale. It also allows to \ntrack\n the current\nlanguage tag for all observed locale topics under the object \ni18n.tags\n. This object can be used to set\nup value bindings and/or watchers so that other components may react to locale-changes in a data-driven\nway.\n\n\nThe i18n helper is an \nAxI18nHandler\n for the feauture \"i18n\" by default, but allows to create\nhandlers for other feature-paths using the \nforFeature\n method.\nUsing \nrelease\n, it is possible to free the eventBus subscription held by an i18n helper instance and by\nall feature-handlers created by it.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontext\n\n\nAxContext\n\n\nthe widget context/scope that the handler should work with. It uses the \neventBus\n property there with which it can do the event handling\n\n\n\n\n\n\nconfiguration\n\n\nAxConfiguration\n\n\nthe (global) configuration to use for supplying a default locale if the widget does not have an 'i18n' feature\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nthe fallback language tag to use when no localization is available for a locale's current language tag\n\n\n\n\n\n\noptionalOptions.fallback\n\n\nString\n\n\nthe fallback language tag to use when no localization is available for a locale's current language tag\n\n\n\n\n\n\noptionalOptions.strict\n\n\nBoolean\n\n\nif \ntrue\n, localizations are only used if the language tags exactly match the current locale's tag (after normalizing case and dash/underscore). If \nfalse\n (default), specific requests can be satisfied by general localizations (e.g. a translation for 'en' may be used when missing 'en_GB' was requested).\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxI18n\n\n\nan i18n instance\n\n\n\n\n\n\n\n\nTypes\n\n\nAxI18n\n\n\nAn i18n instance allows to create \n#AxI18nHandler\n instances for any feature, but is itself also\nan i18n handler for the feature \ni18n\n.\nSo if the widget using the \naxI18n\n injection uses the recommended\nname \ni18n\n for the localization feature, use this directly with the i18n handler API.\n\n\nAxI18n.forFeature( featurePath )\n\n\nCreates and returns an i18n handler for the loclization configuration under the given\n\nfeature path\n.\nThe configuration value is expected to be an object with the key \nlocale\n that is configured with the\nlocale to use in the widget instance.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfeaturePath\n\n\nString\n\n\nthe feature path localization configuration can be found at\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxI18nHandler\n\n\nthe i18n handler for the given feature path\n\n\n\n\n\n\n\n\nAxI18nHandler\n\n\nAxI18nHandler.localize( i18nValue, optionalFallbackValue, languageTag )\n\n\nLocalize the given internationalized object using the given languageTag.\n\n\nIf i18n is configured to be \nstrict\n, the currently active language tag is used to lookup a\ntranslation.\nIf nothing is found, the \nlanguageTag\n argument is tried.\nIf still nothing is found, \nundefined\n is returned.\n\n\nIn the case \nstrict\n is set to \nfalse\n, the behavior is the same as in \nstrict\n mode if an exact\nlocalization is available.\nIf not, the language tag is successively generalized by stripping off the rightmost sub-tags\nuntil a localization is found.\nEventually, a fallback (default: 'en') is used.\nThis behavior is especially useful for controls (such as a datepicker), where we cannot\nanticipate all required language tags, as they may be app-specific.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ni18nValue\n\n\n*\n\n\na possibly internationalized value:\n- when passing a primitive value, it is returned as-is\n- when passing an object, the languageTag is used as a key within that object\n\n\n\n\n\n\noptionalFallbackValue\n\n\n*\n\n\na value to use if no localization is available for the given language tag\n\n\n\n\n\n\nlanguageTag\n\n\nString\n\n\na language tag to override the current locale tag. Only available in \nstrict\n mode\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n*\n\n\nthe localized value if found, the fallback (or \nundefined\n) otherwise\n\n\n\n\n\n\n\n\nAxI18nHandler.update( languageTag )\n\n\nUpdates the language tag for the configured locale by emitting the according \nchangeLocaleRequest\n\nevent.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguageTag\n\n\nString\n\n\nthe language tag to propagate\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\nthe promise of the event cycle\n\n\n\n\n\n\n\n\nAxI18nHandler.languageTag()\n\n\nReturns the language tag set for the configured locale.\nIf no tag is available, \nundefined\n is returned.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe active language tag or \nundefined\n\n\n\n\n\n\n\n\nAxI18nHandler.track( property=trackingProperty )\n\n\nReferences the current i18n state as an object under the given property of the context.\n\n\nIf this method is not used, changes to the locale are still observed by the handler, but not\ntracked on the context object. Use this to react to locale-changes in a data-driven fashion, for\nexample by using an AngularJS watcher.\n\n\nBy default, the i18n state is stored under the feature path used to create this i18n handler (\"i18n\"\nfor the default handler provided by the \"axI18n\" widget service injection).\n\n\nThe tracking structure stored under the property is an object that has two properties:\n\n\n- `locale` is the constant locale topic that was configured for the tracked feature\n- `tags` is an object mapping all locale names to their normalized current language tag\n\n\n\n\n\nNote that tracked language tags are \nnormalized\n, i.e. converted to lowercase with underscores (\n_\n)\nreplaced by dashes (\n-\n).\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nproperty=trackingProperty\n\n\nString\n\n\nname of the context property to store the state under, defaults to the feature path\n\n\n\n\n\n\n\n\nAxI18nHandler.format( i18nValue, optionalIndexedReplacements, optionalNamedReplacements )\n\n\nFormat an i18n value, by first localizing it and then applying substitutions.\n\n\nThese are equivalent:\n\n\n\n\nstring.format( axI18n.localize( i18nValue ), numericArgs, namedArgs )\n\n\naxI18n.format( i18nValue, numericArgs, namedArgs )\n.\n\n\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ni18nValue\n\n\nString\n\n\nthe value to localize and then format\n\n\n\n\n\n\noptionalIndexedReplacements\n\n\nArray\n\n\nreplacements for any numeric placeholders in the localized value\n\n\n\n\n\n\noptionalNamedReplacements\n\n\nObject\n\n\nreplacements for any named placeholders in the localized value\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nString\n\n\nthe formatted string after localization\n\n\n\n\n\n\n\n\nAxI18nHandler.whenLocaleChanged( callback )\n\n\nRegisters a callback that is called whenever the new valid locale was received via event.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\nthe function to call on locale change", 
            "title": "widget_services_i18n"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#contents", 
            "text": "Module Members   create()   Types    AxI18n   AxI18n.forFeature()     AxI18nHandler   AxI18nHandler.localize()  AxI18nHandler.update()  AxI18nHandler.languageTag()  AxI18nHandler.track()  AxI18nHandler.format()  AxI18nHandler.whenLocaleChanged()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#parameters", 
            "text": "Property  Type  Description      context  AxContext  the widget context/scope that the handler should work with. It uses the  eventBus  property there with which it can do the event handling    configuration  AxConfiguration  the (global) configuration to use for supplying a default locale if the widget does not have an 'i18n' feature    optionalOptions  Object  the fallback language tag to use when no localization is available for a locale's current language tag    optionalOptions.fallback  String  the fallback language tag to use when no localization is available for a locale's current language tag    optionalOptions.strict  Boolean  if  true , localizations are only used if the language tags exactly match the current locale's tag (after normalizing case and dash/underscore). If  false  (default), specific requests can be satisfied by general localizations (e.g. a translation for 'en' may be used when missing 'en_GB' was requested).", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#returns", 
            "text": "Type  Description      AxI18n  an i18n instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#parameters_1", 
            "text": "Property  Type  Description      featurePath  String  the feature path localization configuration can be found at", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#returns_1", 
            "text": "Type  Description      AxI18nHandler  the i18n handler for the given feature path", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#parameters_2", 
            "text": "Property  Type  Description      i18nValue  *  a possibly internationalized value: - when passing a primitive value, it is returned as-is - when passing an object, the languageTag is used as a key within that object    optionalFallbackValue  *  a value to use if no localization is available for the given language tag    languageTag  String  a language tag to override the current locale tag. Only available in  strict  mode", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#returns_2", 
            "text": "Type  Description      *  the localized value if found, the fallback (or  undefined ) otherwise", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#parameters_3", 
            "text": "Property  Type  Description      languageTag  String  the language tag to propagate", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#returns_3", 
            "text": "Type  Description      Promise  the promise of the event cycle", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#returns_4", 
            "text": "Type  Description      String  the active language tag or  undefined", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#parameters_4", 
            "text": "Property  Type  Description      property=trackingProperty  String  name of the context property to store the state under, defaults to the feature path", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#parameters_5", 
            "text": "Property  Type  Description      i18nValue  String  the value to localize and then format    optionalIndexedReplacements  Array  replacements for any numeric placeholders in the localized value    optionalNamedReplacements  Object  replacements for any named placeholders in the localized value", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#returns_5", 
            "text": "Type  Description      String  the formatted string after localization", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_i18n/#parameters_6", 
            "text": "Property  Type  Description      callback  Function  the function to call on locale change", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_storage_mock/", 
            "text": "widget_services_storage_mock\n\n\nAllows to instantiate a mock implementations of \nAxStorage\n, compatible to the \"axStorage\" injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nAxStorageMock\n\n\nAxStorageMock.mockBackends\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate()\n\n\nCreates a mock for the \naxStorage\n injection of a widget.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxStorageMock\n\n\na mock of \naxStorage\n that can be spied and/or mocked with additional items\n\n\n\n\n\n\n\n\nTypes\n\n\nAxStorageMock\n\n\n\n\nextends \nAxStorage\n\n\n\n\nThe AxStorageMock provides the same API as AxStorage, with the additional property\n\n#mockBackends\n to inspect and/or simulate mock values in the storage backend.\n\n\nAxStorageMock.mockBackends \nundefined\n\n\nProvides access to the backing stores for \nlocal\n and \nsession\n storage.\n\n\nContains \nlocal\n and \nsession\n store properties. The stores are plain objects whose properties\nreflect any setItem/removeItem operations. When properties are set on a store, they are observed\nby \ngetItem\n calls on the corresponding axStorage API.", 
            "title": "widget_services_storage_mock"
        }, 
        {
            "location": "/api/testing.widget_services_storage_mock/#contents", 
            "text": "Module Members   create()   Types   AxStorageMock  AxStorageMock.mockBackends", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.widget_services_storage_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.widget_services_storage_mock/#returns", 
            "text": "Type  Description      AxStorageMock  a mock of  axStorage  that can be spied and/or mocked with additional items", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.widget_services_storage_mock/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/", 
            "text": "widget_services_visibility\n\n\nFactory for i18n widget service instances.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nAxVisibility\n\n\nAxVisibility.isVisible()\n\n\nAxVisibility.onHide()\n\n\nAxVisibility.onShow()\n\n\nAxVisibility.onChange()\n\n\nAxVisibility.track()\n\n\nAxVisibility.updateAreaVisibility()\n\n\nAxVisibility.updateWidgetVisibility()\n\n\nAxVisibility.unsubscribe()\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( context, areaHelper )\n\n\nCreates a widget-specific helper for \ndidChangeAreaVisibility\n events.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontext\n\n\nAxContext\n\n\nthe widget context/scope that the handler should work with. It uses the \neventBus\n property there with which it can do the event handling. The visibility handler will set the boolean context property \nisVisible\n which can be used to determine the visibility state of the entire widget, e.g. for use in templates.\n\n\n\n\n\n\nareaHelper\n\n\nAxAreaHelper\n\n\nan area helper to qualify/unqualify names for this widget's areas\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibility\n\n\na visibility handler instance\n\n\n\n\n\n\n\n\nTypes\n\n\nAxVisibility\n\n\nAxVisibility.isVisible()\n\n\nQuery the current visibility state.\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBoolean\n\n\nthis current visibility status as determined through eventBus events\n\n\n\n\n\n\n\n\nAxVisibility.onHide( callback )\n\n\nRegisters a callback to be run when this widget becomes hidden.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\na callback to be invoked whenever the widget becomes visible, with a boolean argument indicating the new visibility state (\nfalse\n). The callback will \nnot\n be invoked for the start value (\nfalse\n).\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibility\n\n\nthis instance for chaining\n\n\n\n\n\n\n\n\nAxVisibility.onShow( callback )\n\n\nRegisters a callback to be run when this widget becomes visbile.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\na callback to be invoked whenever the widget becomes visible, with a boolean argument indicating the new visibility state (\ntrue\n).\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibility\n\n\nthis instance for chaining\n\n\n\n\n\n\n\n\nAxVisibility.onChange( callback )\n\n\nRegisters a callback for changes to this widget's visibility.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\na callback to be invoked whenever the widget visibility changes, with a boolean argument indicating the new visibility state. The callback will \nnot\n be invoked for the start value (\nfalse\n).\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibility\n\n\nthis instance for chaining\n\n\n\n\n\n\n\n\nAxVisibility.track( property )\n\n\nStarts tracking visibility as a property on the context.\n\n\nCalling this repeatedly with different property names will stop previous properties from receiving\nfurther updates, but will not remove previously set tracking properties from the context object.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nproperty\n\n\nString\n\n\nthe name of the context property to maintain\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibility\n\n\nthis instance for chaining\n\n\n\n\n\n\n\n\nAxVisibility.updateAreaVisibility( visibilityByLocalArea, optionalOptions )\n\n\nTriggers a visibility change to the given area. The visibility of the area and its nested areas is\nre-evaluated over the event bus. Use this to implement e.g. tabbing/accordion/expander widgets.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvisibilityByLocalArea\n\n\nObject\n\n\nA mapping of local area names (without the widget ID) to their new visibility state (Boolean). Areas that are omitted here are left as is. Areas that have not been set at all just assume the visibility state of the containing area.\n\n\n\n\n\n\noptionalOptions\n\n\nObject\n\n\nAdditional options\n\n\n\n\n\n\noptionalOptions.overrideContainer\n\n\nObject\n\n\nAllows the specified areas to become visible even if the widget's container area is not visible.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPromise\n\n\na promise that is resolved (without a value) when the visibility change was applied\n\n\n\n\n\n\n\n\nAxVisibility.updateWidgetVisibility( visible )\n\n\nTriggers a visibility change the widget itself and all its areas, always overriding its container\nvisibility with the given value.\nThis simplifies implementing popup/popover/layer widgets, which always live in an invisible container\narea, but need to show/hide all their owned areas.\n\n\nTo control the visibility of individual areas, use #updateAreaVisibility\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvisible\n\n\nBoolean\n\n\nThe new visibility state of the widget.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibility\n\n\nthis instance for chaining\n\n\n\n\n\n\n\n\nAxVisibility.unsubscribe( callback )\n\n\nRemove the given callback (registered through one or more of the on... methods) from any subscriptions.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallback\n\n\nFunction\n\n\na callback that was previously registered using any of the \non...\n methods. It will be removed from all registrations. Passing an unknown callback has no effect.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibility\n\n\nthis instance for chaining", 
            "title": "widget_services_visibility"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#contents", 
            "text": "Module Members   create()   Types   AxVisibility  AxVisibility.isVisible()  AxVisibility.onHide()  AxVisibility.onShow()  AxVisibility.onChange()  AxVisibility.track()  AxVisibility.updateAreaVisibility()  AxVisibility.updateWidgetVisibility()  AxVisibility.unsubscribe()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters", 
            "text": "Property  Type  Description      context  AxContext  the widget context/scope that the handler should work with. It uses the  eventBus  property there with which it can do the event handling. The visibility handler will set the boolean context property  isVisible  which can be used to determine the visibility state of the entire widget, e.g. for use in templates.    areaHelper  AxAreaHelper  an area helper to qualify/unqualify names for this widget's areas", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns", 
            "text": "Type  Description      AxVisibility  a visibility handler instance", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_1", 
            "text": "Type  Description      Boolean  this current visibility status as determined through eventBus events", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters_1", 
            "text": "Property  Type  Description      callback  Function  a callback to be invoked whenever the widget becomes visible, with a boolean argument indicating the new visibility state ( false ). The callback will  not  be invoked for the start value ( false ).", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_2", 
            "text": "Type  Description      AxVisibility  this instance for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters_2", 
            "text": "Property  Type  Description      callback  Function  a callback to be invoked whenever the widget becomes visible, with a boolean argument indicating the new visibility state ( true ).", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_3", 
            "text": "Type  Description      AxVisibility  this instance for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters_3", 
            "text": "Property  Type  Description      callback  Function  a callback to be invoked whenever the widget visibility changes, with a boolean argument indicating the new visibility state. The callback will  not  be invoked for the start value ( false ).", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_4", 
            "text": "Type  Description      AxVisibility  this instance for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters_4", 
            "text": "Property  Type  Description      property  String  the name of the context property to maintain", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_5", 
            "text": "Type  Description      AxVisibility  this instance for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters_5", 
            "text": "Property  Type  Description      visibilityByLocalArea  Object  A mapping of local area names (without the widget ID) to their new visibility state (Boolean). Areas that are omitted here are left as is. Areas that have not been set at all just assume the visibility state of the containing area.    optionalOptions  Object  Additional options    optionalOptions.overrideContainer  Object  Allows the specified areas to become visible even if the widget's container area is not visible.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_6", 
            "text": "Type  Description      Promise  a promise that is resolved (without a value) when the visibility change was applied", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters_6", 
            "text": "Property  Type  Description      visible  Boolean  The new visibility state of the widget.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_7", 
            "text": "Type  Description      AxVisibility  this instance for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#parameters_7", 
            "text": "Property  Type  Description      callback  Function  a callback that was previously registered using any of the  on...  methods. It will be removed from all registrations. Passing an unknown callback has no effect.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/runtime.widget_services_visibility/#returns_8", 
            "text": "Type  Description      AxVisibility  this instance for chaining", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.widget_services_visibility_mock/", 
            "text": "widget_services_visibility_mock\n\n\nAllows to instantiate a mock implementations of \nAxVisibility\n, compatible to the \"axVisibility\"\nwidet service injection.\n\n\nContents\n\n\nModule Members\n\n\n\n\ncreate()\n\n\n\n\nTypes\n\n\n\n\nAxVisibilityMock\n\n\nAxVisibilityMock.mockShow()\n\n\nAxVisibilityMock.mockHide()\n\n\n\n\n\n\n\n\nModule Members\n\n\ncreate( context )\n\n\nCreates a mock for the widget-specific \"axVisibility\" injection.\n\n\nParameters\n\n\n\n\n\n\n\n\nProperty\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncontext\n\n\nAxContext\n\n\nan object with an \neventBus\n and a \nwidget.area\n.\n\n\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nAxVisibilityMock\n\n\nan \naxVisibility\n-compatible mock object\n\n\n\n\n\n\n\n\nTypes\n\n\nAxVisibilityMock\n\n\n\n\nextends \nAxMock\n\n\n\n\nA mock version of \nAxVisibility\n, the widget-specific \"axVisibility\" injection.\n\n\nThe mock:\n\n\n\n\nspies on the regular methods,\n\n\nturns the update-methods into no-ops (but you can still inspect their spies),\n\n\noffers additional \nmockShow\n and \nmockHide\n methods, which internally use the context (mock) event bus\n  to allow testing features that involve \ntrack/onShow/onHide/onChange/unsubscribe\n.\n  If the (mock) event bus has a flush method, using \nmockShow\n and \nmockHide\n will automatically flush.\n\n\n\n\nAxVisibilityMock.mockShow()\n\n\nSimulates the widget's containing area becoming visible.\nFlushes the underlying event bus mock as a side-effect.\n\n\nAxVisibilityMock.mockHide()\n\n\nSimulates the widget's containing area becoming hidden.\nFlushes the underlying event bus mock as a side-effect.", 
            "title": "widget_services_visibility_mock"
        }, 
        {
            "location": "/api/testing.widget_services_visibility_mock/#contents", 
            "text": "Module Members   create()   Types   AxVisibilityMock  AxVisibilityMock.mockShow()  AxVisibilityMock.mockHide()", 
            "title": "Contents"
        }, 
        {
            "location": "/api/testing.widget_services_visibility_mock/#module-members", 
            "text": "", 
            "title": "Module Members"
        }, 
        {
            "location": "/api/testing.widget_services_visibility_mock/#parameters", 
            "text": "Property  Type  Description      context  AxContext  an object with an  eventBus  and a  widget.area .", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/testing.widget_services_visibility_mock/#returns", 
            "text": "Type  Description      AxVisibilityMock  an  axVisibility -compatible mock object", 
            "title": "Returns"
        }, 
        {
            "location": "/api/testing.widget_services_visibility_mock/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/contributing/styleguide/", 
            "text": "LaxarJS Coding Styles\n\n\nThese are basic coding style guidelines for use with LaxarJS.\nTheir purpose is to warrant consistency across the code base, so that developers do not need to mentally \"switch gears\" when working on different parts of the code.\n\n\nJavaScript\n\n\nMost of the LaxarJS code base is written in JavaScript, so this language takes up the bulk of the coding styles.\n\n\n1. Use the editorconfig\n\n\nLaxarJS comes with an \n.editorconfig\n that automatically sets up \nmany popular editors\n to work with our coding style.\nIf your editor does not support this configuration out-of-the box, you should configure it manually before creating a pull request.\n\n\n2. Use eslint\n\n\nLaxarJS comes with an \n.eslintrc\n that encodes most of the LaxarJS code formatting rules and allows you to check them automatically using \neslint\n.\nYou should configure your editor to use this file when working with the LaxarJS code base.\nPull Requests that violate eslint rules cannot be accepted.\n\n\n3. Prefer Functions to Create Objects (not \nnew\n).\n\n\nWhen using classes with prototypes, it is often difficult to tell if instance methods need to be called directly on an instance (so that \nthis\n is available), or if they can be passed around as callbacks for use with \nthen\n, \nmap\n, \nfilter\n and so on.\nAlso, the properties defined on \nthis\n are not safe against undesired modification.\nBecause of this, and because inheritance is very hard to get right in JavaScript, the recommended way to create objects is by defining a closure that returns the new object or, in most cases, an API to that object.\nFor example, rather than defining a constructor function \nMyService\n, have your ES2015-module provide a factory function \ncreateMyService\n like shown here:\n\n\n/** ...JSDoc... */\n\n\nfunction\n \ncreateMyService\n()\n \n{\n\n\n   \nconst\n \napi\n \n=\n \n{\n\n      \nqueryValue\n,\n\n      \n// ...\n\n   \n};\n\n\n   \nlet\n \nmyPrivateValue\n \n=\n \n17\n;\n\n\n   \n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n   \n/** ...JSDoc... */\n\n   \nfunction\n \nqueryValue\n()\n \n{\n \n/* ... */\n \n}\n\n\n   \n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n   \nreturn\n \napi\n;\n\n\n\n}\n\n\n\n\n\n\nThis format ensures that anyone looking at the code can see the structure of the return value without having to go through the implementation.\n\n\nIn some simple cases, you do not need any imperative initialization logic for your object and just want to provide access to a bunch of methods.\nTo do this, you can omit the intermediate variable \napi\n and return the API exports right away.\n\n\n/** ...JSDoc... */\n\n\nfunction\n \ncreateMyService\n()\n \n{\n\n\n   \nreturn\n \n{\n\n      \ncalculateValue\n,\n\n      \n// ...\n\n   \n};\n\n\n   \n///////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n   \n/** ...JSDoc... */\n\n   \nfunction\n \ncalculateValue\n()\n \n{\n \n/* ... */\n \n}\n\n\n\n}\n\n\n\n\n\n\nJSON\n\n\nBecause JSON is a subset of JavaScript, the same formatting rules apply.\nBut since string literals cannot span multiple lines and cannot be broken up in JSON, the maximum line length may be violated to encode a JSON string that has to be long.\n\n\nMarkdown\n\n\nTo keep Git diffs readable, in Markdown you should use one line per sentence.\nThe maximum line length may be ignored here.\nEach headline (except for the document title) should be preceded by two blank lines.", 
            "title": "LaxarJS Coding Styles"
        }, 
        {
            "location": "/contributing/styleguide/#laxarjs-coding-styles", 
            "text": "These are basic coding style guidelines for use with LaxarJS.\nTheir purpose is to warrant consistency across the code base, so that developers do not need to mentally \"switch gears\" when working on different parts of the code.", 
            "title": "LaxarJS Coding Styles"
        }, 
        {
            "location": "/contributing/styleguide/#javascript", 
            "text": "Most of the LaxarJS code base is written in JavaScript, so this language takes up the bulk of the coding styles.", 
            "title": "JavaScript"
        }, 
        {
            "location": "/contributing/styleguide/#1-use-the-editorconfig", 
            "text": "LaxarJS comes with an  .editorconfig  that automatically sets up  many popular editors  to work with our coding style.\nIf your editor does not support this configuration out-of-the box, you should configure it manually before creating a pull request.", 
            "title": "1. Use the editorconfig"
        }, 
        {
            "location": "/contributing/styleguide/#2-use-eslint", 
            "text": "LaxarJS comes with an  .eslintrc  that encodes most of the LaxarJS code formatting rules and allows you to check them automatically using  eslint .\nYou should configure your editor to use this file when working with the LaxarJS code base.\nPull Requests that violate eslint rules cannot be accepted.", 
            "title": "2. Use eslint"
        }, 
        {
            "location": "/contributing/styleguide/#3-prefer-functions-to-create-objects-not-new", 
            "text": "When using classes with prototypes, it is often difficult to tell if instance methods need to be called directly on an instance (so that  this  is available), or if they can be passed around as callbacks for use with  then ,  map ,  filter  and so on.\nAlso, the properties defined on  this  are not safe against undesired modification.\nBecause of this, and because inheritance is very hard to get right in JavaScript, the recommended way to create objects is by defining a closure that returns the new object or, in most cases, an API to that object.\nFor example, rather than defining a constructor function  MyService , have your ES2015-module provide a factory function  createMyService  like shown here:  /** ...JSDoc... */  function   createMyService ()   { \n\n    const   api   =   { \n       queryValue , \n       // ... \n    }; \n\n    let   myPrivateValue   =   17 ; \n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////// \n\n    /** ...JSDoc... */ \n    function   queryValue ()   {   /* ... */   } \n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////// \n\n    return   api ;  }   This format ensures that anyone looking at the code can see the structure of the return value without having to go through the implementation.  In some simple cases, you do not need any imperative initialization logic for your object and just want to provide access to a bunch of methods.\nTo do this, you can omit the intermediate variable  api  and return the API exports right away.  /** ...JSDoc... */  function   createMyService ()   { \n\n    return   { \n       calculateValue , \n       // ... \n    }; \n\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////// \n\n    /** ...JSDoc... */ \n    function   calculateValue ()   {   /* ... */   }  }", 
            "title": "3. Prefer Functions to Create Objects (not new)."
        }, 
        {
            "location": "/contributing/styleguide/#json", 
            "text": "Because JSON is a subset of JavaScript, the same formatting rules apply.\nBut since string literals cannot span multiple lines and cannot be broken up in JSON, the maximum line length may be violated to encode a JSON string that has to be long.", 
            "title": "JSON"
        }, 
        {
            "location": "/contributing/styleguide/#markdown", 
            "text": "To keep Git diffs readable, in Markdown you should use one line per sentence.\nThe maximum line length may be ignored here.\nEach headline (except for the document title) should be preceded by two blank lines.", 
            "title": "Markdown"
        }, 
        {
            "location": "/manuals/", 
            "text": "Manuals\n\n\nBefore starting with the manuals, make sure that you know \nwhat LaxarJS is about\n, and that you are familiar with the \ncore concepts\n.\nIf you're already in the process of developing your first widgets and want to know which programmatic APIs are provided by LaxarJS, have a look at the \nAPI docs\n.\n\n\nFor developers coming from previous LaxarJS major versions, there is an \nupgrade guide\n to ease the transition.\n\n\nBasic Manuals\n\n\n\n\nWidgets and Activities\n\n\n\n\nLearn about the central building blocks of a LaxarJS application, and the basics on \nintegration technologies\n.\n\n\n\n\nWriting Pages\n\n\n\n\nA step-by-step introduction to writing layouts and pages for a LaxarJS application.\n\n\n\n\nInstalling Third Party Widgets\n\n\n\n\nLearn how to integrate and leverage existing widgets and activities.\n\n\n\n\nFlow and Places\n\n\n\n\nCreating a flow through the pages and make the addressable as places.\n\n\n\n\nWidget Services\n\n\n\n\nServices that are offered as injections to all widgets regardless of their technology.\n\n\n\n\nEvents\n\n\n\n\nHow to communicate between widgets using topics on the event bus.\n\n\n\n\nThe \n\"plain\"\n Integration Technology\n\n\n\n\nEven without any fancy MVC framework, you can create useful widgets and activities.\n\n\n\n\nConfiguration\n\n\n\n\nDocuments the LaxarJS configuration API which can be used to configure widgets, and the built-in configuration options.\n\n\n\n\nProviding Controls\n\n\n\n\nHow to create reusable, interactive elements that support themes.\n\n\n\n\nInfrastructure and Tools\n\n\n\n\nWhat happens when a LaxarJS application starts, and how its assets are prepared.\n\n\n\n\nUpgrading LaxarJS\n\n\n\n\nA migration guide helping to upgrade applications from earlier versions of LaxarJS.\n\n\nAdvanced Manuals\n\n\n\n\nCreating an Application from Scratch\n\n\n\n\nLearn what is \nactually required\n in a LaxarJS project.\n\n\n\n\nAsset Lookup and the Artifacts Bundle\n\n\n\n\nHow CSS, HTML and other static assets are resolved and loaded.\n\n\n\n\nCreating Themes\n\n\n\n\nHow to create a custom, pluggable style for your widgets and applications.\n\n\n\n\nWriting Compositions\n\n\n\n\nWhen simple pages are not enough.\n\n\n\n\nInternationalization (i18n)\n\n\n\n\nExplains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.\n\n\n\n\nVisibility Events\n\n\n\n\nIntroduces visibility events for improving performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.\n\n\n\n\nCreating an Adapter for a new Widget Technology\n\n\n\n\nLearn how to adapt any MVC technology for creating LaxarJS widgets.", 
            "title": "Overview"
        }, 
        {
            "location": "/manuals/#manuals", 
            "text": "Before starting with the manuals, make sure that you know  what LaxarJS is about , and that you are familiar with the  core concepts .\nIf you're already in the process of developing your first widgets and want to know which programmatic APIs are provided by LaxarJS, have a look at the  API docs .  For developers coming from previous LaxarJS major versions, there is an  upgrade guide  to ease the transition.", 
            "title": "Manuals"
        }, 
        {
            "location": "/manuals/#basic-manuals", 
            "text": "Widgets and Activities   Learn about the central building blocks of a LaxarJS application, and the basics on  integration technologies .   Writing Pages   A step-by-step introduction to writing layouts and pages for a LaxarJS application.   Installing Third Party Widgets   Learn how to integrate and leverage existing widgets and activities.   Flow and Places   Creating a flow through the pages and make the addressable as places.   Widget Services   Services that are offered as injections to all widgets regardless of their technology.   Events   How to communicate between widgets using topics on the event bus.   The  \"plain\"  Integration Technology   Even without any fancy MVC framework, you can create useful widgets and activities.   Configuration   Documents the LaxarJS configuration API which can be used to configure widgets, and the built-in configuration options.   Providing Controls   How to create reusable, interactive elements that support themes.   Infrastructure and Tools   What happens when a LaxarJS application starts, and how its assets are prepared.   Upgrading LaxarJS   A migration guide helping to upgrade applications from earlier versions of LaxarJS.", 
            "title": "Basic Manuals"
        }, 
        {
            "location": "/manuals/#advanced-manuals", 
            "text": "Creating an Application from Scratch   Learn what is  actually required  in a LaxarJS project.   Asset Lookup and the Artifacts Bundle   How CSS, HTML and other static assets are resolved and loaded.   Creating Themes   How to create a custom, pluggable style for your widgets and applications.   Writing Compositions   When simple pages are not enough.   Internationalization (i18n)   Explains how to leverage the LaxarJS event bus and APIs when writing internationalized applications.   Visibility Events   Introduces visibility events for improving performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.   Creating an Adapter for a new Widget Technology   Learn how to adapt any MVC technology for creating LaxarJS widgets.", 
            "title": "Advanced Manuals"
        }, 
        {
            "location": "/manuals/asset_lookup/", 
            "text": "Assets and the Artifacts Bundle\n\n\n\u00ab return to the manuals\n\n\nWidgets and controls depend on various non-JavaScript resources which have to be loaded into the browser somehow.\nThese resources are also called \nassets\n.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\nCreating Themes\n\n\nInfrastructure and Tools\n\n\n\n\nBecause of the LaxarJS themes feature, the specific set of HTML/CSS assets used by any widget or control always depend on the application where it is used.\n\n\nIn order to avoid excessive configuration, assets are automatically resolved based on their path in the directory tree of an application.\n\n\nTypes of Assets handled by LaxarJS\n\n\nFor \nwidgets\n, LaxarJS manages the following assets:\n\n\n\n\n\n\nthe \nwidget.json\n \ndescriptor\n, which describes the widget features\n\n\n\n\n\n\nthe \nHTML template\n which defines the widget markup, and may be overwritten by the theme\n\n\n\n\n\n\nthe \nCSS stylesheet\n refining the presentation of the widget, which is often overwritten by the theme, but which may also be missing completely\n\n\n\n\n\n\nFor \nactivities\n, LaxarJS only manages the \nwidget.json\n descriptor, since activities have no presentation.\n\n\nFor \ncontrols\n, LaxarJS manages the \ncontrol.json\n descriptor, and the theme-dependent CSS stylesheet (if any).\nControls may sometimes choose to load HTML assets (preferably using webpack), but these are not covered by the theming mechanism.\n\n\nFor \nlayouts\n, LaxarJS manages the \nlayout.json\n descriptor along with HTML template and CSS stylesheet (if any).\nBoth may be overridden by the application theme.\n\n\nFor \nthemes\n, LaxarJS processes the \ntheme.json\n and the global CSS stylesheet.\n\n\nWhy Centralized Asset Handling?\n\n\nSince LaxarJS widgets and controls may use JavaScript import- or require-calls, they could try to include their assets themselves, for example by using the webpack raw-loader.\nThis would also allow for simple automatic minification using \nwebpack -P\n.\nHowever, we chose a different approach for the following reasons:\n\n\n\n\n\n\nThe runtime needs access to the \nwidget.json\n to resolve the controller module, while only the actual configuration values for a specific widget instance are relevant to the corresponding controller instance.\n  For this reason, the runtime should take care of reading the widget descriptor and pass the preprocessed configuration to each widget instance.\n  Also, we want to validate the feature configuration of widgets and compositions at build-time, which is only only possible if LaxarJS handles loading of widget descriptors and page definitions.\n\n\n\n\n\n\nThe LaxarJS runtime knows when a widget is actually being displayed, and will only then instantiate the corresponding HTML template.\n  This reduces memory consumption and improves render performance.\n\n\n\n\n\n\nThe CSS should be loaded \nen bloc\n using a single, optimized stylesheet right on application entry.\n  Deferring load of styles to the time where individual widgets are instantiated produces jitter and visual noise.\n  Often, the page will look broken until the various CSS fragments have been loaded.\n\n\n\n\n\n\nThe LaxarJS bundle needs to select assets based on the application \ntheme\n, and based on which assets of a given artifact are available in which theme.\n\n\n\n\n\n\nFor these reasons, LaxarJS takes care of selecting and loading assets.\nBy using the \nlaxar-loader\n for webpack, fast development iterations as well as comprehensive optimization during production are still available.\n\n\nThe Artifacts Bundle\n\n\nDuring application development, the LaxarJS runtime needs to know if HTML and CSS are available for a given artifact, and \u2013 if they are \u2013 from where to load them.\nThe straightforward approach for this is to query each possible location using an HTTP-request (starting with the application theme, and falling back to the default theme), and to use the first resource that is available.\nHowever, this may considerably slow down loading the application, and will lead to a lot of ugly and confusing HTTP-404 errors in the browser console.\n\n\nIdeally, the runtime would \njust know\n what assets are available so it could simply load the best matching variant, or skip loading completely for assets that are missing.\n\n\nFortunately, using the laxar-loader allows to do precisely this:\nIt has the knowledge that is needed to determine which artifacts and assets are actually used, and produces an \nartifacts\n bundle which can be passed to LaxarJS \ncreate\n.\nThe bundle is then used both internally by the runtime and made available as the \naxAssets\n injection to widgets.\n\n\nAssets by Artifact Type\n\n\nHaving explained the general asset loading mechanism, the following sections go into detail on the individual artifact types and their asset locations.\n\n\nLooking up the Theme CSS\n\n\nThe laxar-loader is parameterized with a list of themes to include in its lookup chain.\nNo matter what themes are specified, the \ndefault.theme\n is always added as a final entry to the resulting list.\n\n\nTo load the CSS for the theme itself, the loader simply checks each theme \nT\n and looks for its CSS under \napplication/themes/T.theme/css/theme.css\n, using the first theme that is available.\n\n\nLooking up Widget CSS and HTML Templates\n\n\nFor widget CSS styles and HTML templates, the laxar-loader first checks if a version is available within the theme directory.\nThis means that you cannot only customize the CSS for a widget \nW\n installed under \napplication/widgets/W\n by placing a stylesheet at \ntheme-folder\n/widgets/W/css/W.css\n but that you can also override the HTML at \ntheme-folder\n/widgets/W/W.html\n.\n\n\nWhen nothing was found among the assets bundled with the theme, the assets bundled with the widget are checked:\nFor a widget installed under \nnode_modules/W/\n, the paths \nnode_modules/W/T.theme/css/W.css\n and \nnode_modules/W/T.theme/W.html\n respectively will be checked when using a theme \nT\n.\nNote that both locations (theme-bundled and artifact-bundled) are respected, no matter if a widget was installed using npm or locally under \napplication/widgets/\n.\n\n\nIf nothing was found for the application theme for a given widget, the \ndefault.theme\n folder within the widget itself is used.\nNote that CSS and HTML files are treated separately:\nYou can choose to override the CSS but not the HTML or vice versa.\n\n\nLooking up CSS for a Control\n\n\nControls take care of their own HTML loading (if required at all), so the choice of theme has no effect here.\nThe CSS styling of a control however is theme-specific.\nFor a control named \n\"C\"\n in its \ncontrol.json\n descriptor, it works as follows:\nBefore looking for the default theme in \ncontrol-path\n/default.theme/css/C.css\n, LaxarJS looks for a theme override in \ntheme-path\n/controls/C/css/C.css\n.\nHere, the \ntheme-path\n refers to the folder containing your global theme, and the \ncontrol-path\n is the same path that widgets specify in their \nwidget.json\n descriptor to include a control.\nHave a look at the \nmanual on controls\n for details.\n\n\nLooking up CSS and HTML for a Layout\n\n\nThemes are intended to be reusable across applications.\nBecause layouts are highly specific to an application, usually their CSS and HTML assets live \nwithin the layout's folder\n of the application, with styling for all relevant themes.\nHowever, like with widgets it is possible to style application layouts externally using the sub-folder \nlayouts\n of the theme in use.\nFor lookup, the same process as for widgets is used:\nFirst, LaxarJS searches the theme itself, then the theme folder within the layout, before finally falling back to the default theme.", 
            "title": "Assets and the Artifacts Bundle"
        }, 
        {
            "location": "/manuals/asset_lookup/#assets-and-the-artifacts-bundle", 
            "text": "\u00ab return to the manuals  Widgets and controls depend on various non-JavaScript resources which have to be loaded into the browser somehow.\nThese resources are also called  assets .  Preliminary readings:   Widgets and Activities  Creating Themes  Infrastructure and Tools   Because of the LaxarJS themes feature, the specific set of HTML/CSS assets used by any widget or control always depend on the application where it is used.  In order to avoid excessive configuration, assets are automatically resolved based on their path in the directory tree of an application.", 
            "title": "Assets and the Artifacts Bundle"
        }, 
        {
            "location": "/manuals/asset_lookup/#types-of-assets-handled-by-laxarjs", 
            "text": "For  widgets , LaxarJS manages the following assets:    the  widget.json   descriptor , which describes the widget features    the  HTML template  which defines the widget markup, and may be overwritten by the theme    the  CSS stylesheet  refining the presentation of the widget, which is often overwritten by the theme, but which may also be missing completely    For  activities , LaxarJS only manages the  widget.json  descriptor, since activities have no presentation.  For  controls , LaxarJS manages the  control.json  descriptor, and the theme-dependent CSS stylesheet (if any).\nControls may sometimes choose to load HTML assets (preferably using webpack), but these are not covered by the theming mechanism.  For  layouts , LaxarJS manages the  layout.json  descriptor along with HTML template and CSS stylesheet (if any).\nBoth may be overridden by the application theme.  For  themes , LaxarJS processes the  theme.json  and the global CSS stylesheet.", 
            "title": "Types of Assets handled by LaxarJS"
        }, 
        {
            "location": "/manuals/asset_lookup/#why-centralized-asset-handling", 
            "text": "Since LaxarJS widgets and controls may use JavaScript import- or require-calls, they could try to include their assets themselves, for example by using the webpack raw-loader.\nThis would also allow for simple automatic minification using  webpack -P .\nHowever, we chose a different approach for the following reasons:    The runtime needs access to the  widget.json  to resolve the controller module, while only the actual configuration values for a specific widget instance are relevant to the corresponding controller instance.\n  For this reason, the runtime should take care of reading the widget descriptor and pass the preprocessed configuration to each widget instance.\n  Also, we want to validate the feature configuration of widgets and compositions at build-time, which is only only possible if LaxarJS handles loading of widget descriptors and page definitions.    The LaxarJS runtime knows when a widget is actually being displayed, and will only then instantiate the corresponding HTML template.\n  This reduces memory consumption and improves render performance.    The CSS should be loaded  en bloc  using a single, optimized stylesheet right on application entry.\n  Deferring load of styles to the time where individual widgets are instantiated produces jitter and visual noise.\n  Often, the page will look broken until the various CSS fragments have been loaded.    The LaxarJS bundle needs to select assets based on the application  theme , and based on which assets of a given artifact are available in which theme.    For these reasons, LaxarJS takes care of selecting and loading assets.\nBy using the  laxar-loader  for webpack, fast development iterations as well as comprehensive optimization during production are still available.", 
            "title": "Why Centralized Asset Handling?"
        }, 
        {
            "location": "/manuals/asset_lookup/#the-artifacts-bundle", 
            "text": "During application development, the LaxarJS runtime needs to know if HTML and CSS are available for a given artifact, and \u2013 if they are \u2013 from where to load them.\nThe straightforward approach for this is to query each possible location using an HTTP-request (starting with the application theme, and falling back to the default theme), and to use the first resource that is available.\nHowever, this may considerably slow down loading the application, and will lead to a lot of ugly and confusing HTTP-404 errors in the browser console.  Ideally, the runtime would  just know  what assets are available so it could simply load the best matching variant, or skip loading completely for assets that are missing.  Fortunately, using the laxar-loader allows to do precisely this:\nIt has the knowledge that is needed to determine which artifacts and assets are actually used, and produces an  artifacts  bundle which can be passed to LaxarJS  create .\nThe bundle is then used both internally by the runtime and made available as the  axAssets  injection to widgets.", 
            "title": "The Artifacts Bundle"
        }, 
        {
            "location": "/manuals/asset_lookup/#assets-by-artifact-type", 
            "text": "Having explained the general asset loading mechanism, the following sections go into detail on the individual artifact types and their asset locations.", 
            "title": "Assets by Artifact Type"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-the-theme-css", 
            "text": "The laxar-loader is parameterized with a list of themes to include in its lookup chain.\nNo matter what themes are specified, the  default.theme  is always added as a final entry to the resulting list.  To load the CSS for the theme itself, the loader simply checks each theme  T  and looks for its CSS under  application/themes/T.theme/css/theme.css , using the first theme that is available.", 
            "title": "Looking up the Theme CSS"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-widget-css-and-html-templates", 
            "text": "For widget CSS styles and HTML templates, the laxar-loader first checks if a version is available within the theme directory.\nThis means that you cannot only customize the CSS for a widget  W  installed under  application/widgets/W  by placing a stylesheet at  theme-folder /widgets/W/css/W.css  but that you can also override the HTML at  theme-folder /widgets/W/W.html .  When nothing was found among the assets bundled with the theme, the assets bundled with the widget are checked:\nFor a widget installed under  node_modules/W/ , the paths  node_modules/W/T.theme/css/W.css  and  node_modules/W/T.theme/W.html  respectively will be checked when using a theme  T .\nNote that both locations (theme-bundled and artifact-bundled) are respected, no matter if a widget was installed using npm or locally under  application/widgets/ .  If nothing was found for the application theme for a given widget, the  default.theme  folder within the widget itself is used.\nNote that CSS and HTML files are treated separately:\nYou can choose to override the CSS but not the HTML or vice versa.", 
            "title": "Looking up Widget CSS and HTML Templates"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-css-for-a-control", 
            "text": "Controls take care of their own HTML loading (if required at all), so the choice of theme has no effect here.\nThe CSS styling of a control however is theme-specific.\nFor a control named  \"C\"  in its  control.json  descriptor, it works as follows:\nBefore looking for the default theme in  control-path /default.theme/css/C.css , LaxarJS looks for a theme override in  theme-path /controls/C/css/C.css .\nHere, the  theme-path  refers to the folder containing your global theme, and the  control-path  is the same path that widgets specify in their  widget.json  descriptor to include a control.\nHave a look at the  manual on controls  for details.", 
            "title": "Looking up CSS for a Control"
        }, 
        {
            "location": "/manuals/asset_lookup/#looking-up-css-and-html-for-a-layout", 
            "text": "Themes are intended to be reusable across applications.\nBecause layouts are highly specific to an application, usually their CSS and HTML assets live  within the layout's folder  of the application, with styling for all relevant themes.\nHowever, like with widgets it is possible to style application layouts externally using the sub-folder  layouts  of the theme in use.\nFor lookup, the same process as for widgets is used:\nFirst, LaxarJS searches the theme itself, then the theme folder within the layout, before finally falling back to the default theme.", 
            "title": "Looking up CSS and HTML for a Layout"
        }, 
        {
            "location": "/manuals/providing_controls/", 
            "text": "Controls and Libraries\n\n\n\u00ab return to the manuals\n\n\nIn LaxarJS, any non-trivial HTML element, \nHTML5 Web Component\n or \nAngularJS directive\n is considered a \ncontrol\n.\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nTo provide their business logic, widgets and activities often depend on \nlibraries,\n which might be created by third parties or simply be used to share common functionality. Examples of libraries commonly used by LaxarJS widgets include:\n\n\n\n\nmoment.js\n\n\nLaxarJS Patterns\n\n\njQuery\n\n\n\n\nOn the other hand, here are some examples of controls:\n\n\n\n\na select box\n\n\na tab control\n\n\na \ndate picker\n\n\nan \naccordion control\n\n\n\n\nLaxarJS helps when developing a custom control by managing and loading its JavaScript implementation module, as well as its theme-dependent CSS stylesheet for you.\nIf (and only if) you \nuse\n a control in one or more widgets, LaxarJS will load its CSS according to the current \ntheme\n, just like with widgets and layouts.\nWhen you remove the control from your widget, or the widget from your page, its code and assets will no longer increase your application footprint.\nThis allows you to create and distribute large libraries of controls without fear of application bloat.\n\n\nCreating or Integrating a Control\n\n\nThe exact structure of a control depends on the integration technology that is used to create the control and to integrate it into the application.\nThroughout this manual, we use the \n\"angular\"\n integration technology for our examples.\nNote that controls can only be used by widgets that use the same integration technology.\nThe only exception is the built-in integration technology \n\"plain\"\n, which can be used by any widget, but may be difficult to use correctly from some widget integration technologies.\nThe \nplain adapter documentation\n explains how these controls are used.\n\n\nCreating an \nangular\n Control using a Directive\n\n\nLaxarJS does not care whether your control is installed through npm or Bower, or if it is located somewhere else within your project, as long as its \ncontrol.json\n descriptor can be found by the laxar loader (for webpack).\nLet us try to create a control \nmy-clock-control\n that displays a digital clock to the user.\n\n\nControls Directory\n\n\nFirst, choose a location for your control within your application, such as \napplication/controls/my-clock\n.\nThe path \napplication/controls/\n is the \ncontrols-root\n, and can be overwritten by creating a \nlaxar.config.js\n with \npaths.controls\n export.\n\n\nThe Control Descriptor\n\n\nJust like widgets, controls have a small JSON descriptor \n(control.json)\n which instructs the runtime on how to load the control, and where to look for styles.\nHere is the descriptor for our clock control:\n\n\n{\n\n   \nname\n:\n \nmy-clock-control\n,\n\n   \nintegration\n:\n \n{\n\n      \ntechnology\n:\n \nangular\n\n   \n}\n\n\n}\n\n\n\n\n\n\nTo ensure compatibility between each widget and its controls, both must use the same \nintegration technology\n.\nThe technology \n\"plain\"\n is supported for controls out-of-the-box, and other technologies can be added through \nadapters\n, such as the \nlaxar-angular-adapter\n.\nThe \nname\n allows the LaxarJS runtime to load the correct implementation module and the right CSS styles.\nSo even if using a folder of a different name, or a control installed from npm, the runtime would still be able to load the control.\n\n\nAngularJS Directive\n\n\nNow let us create the AngularJS module for the control, in \napplication/controls/my-clock-control/my-clock-control.js\n:\n\n\ndefine\n(\n \n[\n \nangular\n,\n \ntext!./my-clock-control.html\n \n],\n \nfunction\n(\n \nng\n,\n \nclockTemplate\n \n)\n \n{\n\n   \nuse strict\n;\n\n\n   \nvar\n \nmodule\n \n=\n \nng\n.\nmodule\n(\n \nmyClockControl\n,\n \n[]\n \n);\n\n\n   \nmodule\n.\nfilter\n(\n \nmyClockDigits\n,\n \nfunction\n()\n \n{\n\n      \nreturn\n \nfunction\n(\n \nnumber\n \n)\n \n{\n\n         \nreturn\n \n(\n \nnumber\n \n \n10\n \n?\n \n0\n \n:\n \n \n)\n \n+\n \nnumber\n;\n\n      \n}\n\n   \n}\n \n);\n\n\n   \nreturn\n \nmodule\n.\ndirective\n(\n \nmyClock\n,\n \n[\n \n$timeout\n,\n \nfunction\n(\n \n$timeout\n \n)\n \n{\n\n      \nreturn\n \n{\n\n         \nrestrict\n:\n \nE\n,\n\n         \ntemplate\n:\n \nclockTemplate\n,\n\n         \nlink\n:\n \nfunction\n(\n \n$scope\n \n)\n \n{\n\n            \ntick\n();\n\n            \nfunction\n \ntick\n()\n \n{\n\n               \n$scope\n.\ndate\n \n=\n \nnew\n \nDate\n();\n\n               \n$timeout\n(\n \ntick\n,\n \n1000\n \n);\n\n            \n}\n\n         \n}\n\n      \n};\n\n\n   \n}\n \n]\n \n);\n\n\n\n}\n \n);\n\n\n\n\n\n\nWe use a prefix \n(my)\n for the control and for the filter- and directive-names to avoid collisions with other controls and directives, as well as future HTML elements.\n\n\nAngularJS Template\n\n\nLet us create a simple template at \napplication/controls/my-clock-control/my-clock-control.html\n.\n\n\nspan\n \nclass\n=\nmy-clock\n\n   {{ date.getHours() | myClockDigits }}:{{ date.getMinutes() | myClockDigits }}:{{ date.getSeconds() | myClockDigits }}\n\n/\nspan\n\n\n\n\n\n\nIt is recommended to use the control name as a prefix for any custom CSS classes as shown here, to avoid collision with other controls and libraries.\n\n\nThe CSS Style Sheet\n\n\nTo automatically load your CSS depending on the theme, it has to be placed into a sub-directory \ndefault.theme/css\n of your require path and its file name must correspond to the control descriptor.\nIn case of the clock control, the correct path would be \napplication/controls/my-clock-control/default.theme/my-clock-control.css\n.\n\n\n.\nmy-clock\n \n{\n\n   \nfont-family\n:\n \nTimes New Roman\n,\n \nserif\n;\n\n   \nfont-weight\n:\n \nbold\n;\n\n   \nfont-size\n:\n \n36\npx\n;\n\n   \nborder\n:\n \n3\npx\n \ndouble\n \nblack\n;\n\n   \npadding\n:\n \n3\npx\n;\n\n\n}\n\n\n\n\n\n\nNot that for controls, \ntheme folders\n are only used for stylesheets, not for templates.\n\n\nUsing a Control from a Widget\n\n\nAny widget that uses our clock should declare its dependency using \ncontrols\n entry in its \nwidget.json\n:\n\n\ncontrols\n:\n \n[\n \nmy-clock-control\n \n],\n\n\n\n\n\n\nThis allows the runtime to load control module and to register the AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application.\n\n\nTo actually get the control onto the screen, you have to reference it from your widget's HTML template:\n\n\nh3\nMy Widget, now with 100% more 24h-clock!\n/\nh3\n\n\nmy-clock\n/\nmy-clock\n\n\n\n\n\n\nAfter adding your widget to a page, you may inspect your timepiece in the browser:\n\n\n\n\nCreating or Integrating a Library\n\n\nAdding custom libraries is even simpler than adding controls, because usually they do not need to load theme-specific CSS or to have their AngularJS modules managed by the \nlaxar-angular-adapter\n -- if they do, try turning them into controls or activities respectively.\nJust put the library somewhere within your project (preferably using npm) and make sure that it can be resolved and loaded by webpack.", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#controls-and-libraries", 
            "text": "\u00ab return to the manuals  In LaxarJS, any non-trivial HTML element,  HTML5 Web Component  or  AngularJS directive  is considered a  control .\nWhile widgets and activities deal with business logic, controls handle the technical details of user interaction.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities   To provide their business logic, widgets and activities often depend on  libraries,  which might be created by third parties or simply be used to share common functionality. Examples of libraries commonly used by LaxarJS widgets include:   moment.js  LaxarJS Patterns  jQuery   On the other hand, here are some examples of controls:   a select box  a tab control  a  date picker  an  accordion control   LaxarJS helps when developing a custom control by managing and loading its JavaScript implementation module, as well as its theme-dependent CSS stylesheet for you.\nIf (and only if) you  use  a control in one or more widgets, LaxarJS will load its CSS according to the current  theme , just like with widgets and layouts.\nWhen you remove the control from your widget, or the widget from your page, its code and assets will no longer increase your application footprint.\nThis allows you to create and distribute large libraries of controls without fear of application bloat.", 
            "title": "Controls and Libraries"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-control", 
            "text": "The exact structure of a control depends on the integration technology that is used to create the control and to integrate it into the application.\nThroughout this manual, we use the  \"angular\"  integration technology for our examples.\nNote that controls can only be used by widgets that use the same integration technology.\nThe only exception is the built-in integration technology  \"plain\" , which can be used by any widget, but may be difficult to use correctly from some widget integration technologies.\nThe  plain adapter documentation  explains how these controls are used.", 
            "title": "Creating or Integrating a Control"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-an-angular-control-using-a-directive", 
            "text": "LaxarJS does not care whether your control is installed through npm or Bower, or if it is located somewhere else within your project, as long as its  control.json  descriptor can be found by the laxar loader (for webpack).\nLet us try to create a control  my-clock-control  that displays a digital clock to the user.", 
            "title": "Creating an angular Control using a Directive"
        }, 
        {
            "location": "/manuals/providing_controls/#controls-directory", 
            "text": "First, choose a location for your control within your application, such as  application/controls/my-clock .\nThe path  application/controls/  is the  controls-root , and can be overwritten by creating a  laxar.config.js  with  paths.controls  export.", 
            "title": "Controls Directory"
        }, 
        {
            "location": "/manuals/providing_controls/#the-control-descriptor", 
            "text": "Just like widgets, controls have a small JSON descriptor  (control.json)  which instructs the runtime on how to load the control, and where to look for styles.\nHere is the descriptor for our clock control:  { \n    name :   my-clock-control , \n    integration :   { \n       technology :   angular \n    }  }   To ensure compatibility between each widget and its controls, both must use the same  integration technology .\nThe technology  \"plain\"  is supported for controls out-of-the-box, and other technologies can be added through  adapters , such as the  laxar-angular-adapter .\nThe  name  allows the LaxarJS runtime to load the correct implementation module and the right CSS styles.\nSo even if using a folder of a different name, or a control installed from npm, the runtime would still be able to load the control.", 
            "title": "The Control Descriptor"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-directive", 
            "text": "Now let us create the AngularJS module for the control, in  application/controls/my-clock-control/my-clock-control.js :  define (   [   angular ,   text!./my-clock-control.html   ],   function (   ng ,   clockTemplate   )   { \n    use strict ; \n\n    var   module   =   ng . module (   myClockControl ,   []   ); \n\n    module . filter (   myClockDigits ,   function ()   { \n       return   function (   number   )   { \n          return   (   number     10   ?   0   :     )   +   number ; \n       } \n    }   ); \n\n    return   module . directive (   myClock ,   [   $timeout ,   function (   $timeout   )   { \n       return   { \n          restrict :   E , \n          template :   clockTemplate , \n          link :   function (   $scope   )   { \n             tick (); \n             function   tick ()   { \n                $scope . date   =   new   Date (); \n                $timeout (   tick ,   1000   ); \n             } \n          } \n       }; \n\n    }   ]   );  }   );   We use a prefix  (my)  for the control and for the filter- and directive-names to avoid collisions with other controls and directives, as well as future HTML elements.", 
            "title": "AngularJS Directive"
        }, 
        {
            "location": "/manuals/providing_controls/#angularjs-template", 
            "text": "Let us create a simple template at  application/controls/my-clock-control/my-clock-control.html .  span   class = my-clock \n   {{ date.getHours() | myClockDigits }}:{{ date.getMinutes() | myClockDigits }}:{{ date.getSeconds() | myClockDigits }} / span   It is recommended to use the control name as a prefix for any custom CSS classes as shown here, to avoid collision with other controls and libraries.", 
            "title": "AngularJS Template"
        }, 
        {
            "location": "/manuals/providing_controls/#the-css-style-sheet", 
            "text": "To automatically load your CSS depending on the theme, it has to be placed into a sub-directory  default.theme/css  of your require path and its file name must correspond to the control descriptor.\nIn case of the clock control, the correct path would be  application/controls/my-clock-control/default.theme/my-clock-control.css .  . my-clock   { \n    font-family :   Times New Roman ,   serif ; \n    font-weight :   bold ; \n    font-size :   36 px ; \n    border :   3 px   double   black ; \n    padding :   3 px ;  }   Not that for controls,  theme folders  are only used for stylesheets, not for templates.", 
            "title": "The CSS Style Sheet"
        }, 
        {
            "location": "/manuals/providing_controls/#using-a-control-from-a-widget", 
            "text": "Any widget that uses our clock should declare its dependency using  controls  entry in its  widget.json :  controls :   [   my-clock-control   ],   This allows the runtime to load control module and to register the AngularJS module during bootstrapping.\nAdditionally this causes the control CSS to be loaded from the correct theme, and to be bundled when creating a release-version of your application.  To actually get the control onto the screen, you have to reference it from your widget's HTML template:  h3 My Widget, now with 100% more 24h-clock! / h3  my-clock / my-clock   After adding your widget to a page, you may inspect your timepiece in the browser:", 
            "title": "Using a Control from a Widget"
        }, 
        {
            "location": "/manuals/providing_controls/#creating-or-integrating-a-library", 
            "text": "Adding custom libraries is even simpler than adding controls, because usually they do not need to load theme-specific CSS or to have their AngularJS modules managed by the  laxar-angular-adapter  -- if they do, try turning them into controls or activities respectively.\nJust put the library somewhere within your project (preferably using npm) and make sure that it can be resolved and loaded by webpack.", 
            "title": "Creating or Integrating a Library"
        }, 
        {
            "location": "/manuals/creating_themes/", 
            "text": "Creating Themes\n\n\n\u00ab return to the manuals\n\n\nSometimes you would like to use \none widget\n in \ntwo or more applications\n.\nFor this, usually you want the widget to \nbehave identically\n, but \nlook differently\n.\nAlternatively, sometimes you would like to offer the same application in different appearances.\nLaxarJS has the concept of \nthemes\n to help you achieve these things.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\n\n\nWhy Themes?\n\n\nLaxarJS ships with a so-called \ndefault.theme\n, which is actually just \nBootstrap CSS\n together with \nFont Awesome\n and a few additional classes.\nThere are several ways to add your own styles.\n\n\nFrom Ad-Hoc Styles to Theme Folders\u2026\n\n\nUsually, you will need to add some CSS classes of your own.\nFor example, the vast majority of web application needs some styling for the page background and positioning, or some custom header- and footer-areas.\nTo include such \nad-hoc styles\n, you \ncould\n simply add a CSS file of your own to the project, and load it from the \ndebug.html\n and \nindex.html\n files using the \nlink\n tag.\nHowever, it is better to add these styles to your main application layout instead, into a sub-folder called \ndefault.theme/css\n.\n\n\nThe \nbenefit\n of using such a \ntheme folder\n is that\n\n\n\n\n\n\nyour CSS will be \nbundled and compressed\n together with Bootstrap CSS (no additional \nlink\n tag needed) and that\n\n\n\n\n\n\nyou can support different \nthemes\n simply by adding more \n.theme\n folders.\n\n\n\n\n\n\nDue to the first point, using theme folders is useful and recommended \neven\n if you only use (and maybe customize) the default theme.\n\n\n\u2026and to Custom Themes\n\n\nAs soon as you use multiple page layouts, the previous approach does not really scale anymore:\nyou would have to duplicate your global styles to all of them.\nIn these cases, \ncreating your own theme\n is definitely recommended.\nA detailed explanation of \ncreating a theme\n is given below.\n\n\nA Note on SCSS\n\n\nWhen using theme folders or entire themes, the LaxarJS loader (used by webpack) will only ever look at \n.css\n files in \ncss\n sub-folders by default.\nHowever, it is entirely \nup to you\n which (if any) CSS authoring tools you would like to use.\nYou simply need to configure your widget to load you stylesheet from a different file that has the appropriate extension.\nDo this by adding a \nstyleSource\n attribute to the widget descriptor, and by setting its value to a path that is relative to the theme folder.\n\n\nThe LaxarJS team uses SCSS to create themes, and the default-theme is based on the SCSS version of Bootstrap.\nUsing this approach makes it very easy to create a custom theme just by changing some Bootstrap SCSS variables.\nAlso, by using SCSS variables defined in the theme, widgets and controls can provide a consistent appearance.\nAfter explaining themes in general, further down we give instructions on \ncreating an SCSS theme\n.\n\n\n\n\nCreating Your Own Theme\n\n\nLet us create our own theme for an existing application, the \nLaxarJS ShopDemo\n.\nThe ShopDemo uses the LaxarJS-branded \n\"cube.theme\"\n, which is implemented by augmenting Bootstrap with some changes and custom additions, such as the circle icons used with the headlines.\n\n\n\n\nAbove:\n The LaxarJS ShopDemo using the \ncube\n theme\n\n\nHowever, the demo also works with just the default theme, provided by LaxarJS UiKit, although admittedly it does not look quite as pretty:\n\n\n\n\nAbove:\n The LaxarJS ShopDemo using the \ndefault\n theme\n\n\nA Custom Theme Using Plain CSS\n\n\nSince all applications seem to offer a \"dark\" look these days, let us try to achieve this for our shop application.\nFortunately, there are several collections of nice bootstrap themes available for free.\nOn the site \nBootswatch\n for example, you will find the theme \ndarkly\n, which looks like it might work for us.\n\n\nThe only thing that is actually \nrequired\n for a theme to work are a configuration entry and a CSS file in the right place.\nPut the pre-built \ndarkly CSS\n into the right place, which is \napplication/themes/darkly.theme/css/theme.css\n.\nThe \ntheme-root\n (\napplication/themes/\n by default) can be changed in LaxarJS projects by setting the export \npaths.themes\n of the file \nlaxar.config.js\n.\nAdd a \ndescriptor\n containing the canonical name of the theme:\n\n\n// application/themes/darkly.theme/theme.json\n\n\n{\n\n   \nname\n:\n \ndarkly.theme\n\n\n}\n\n\n\n\n\n\nTo use the new theme, make sure to load it along with the application artifacts, by updating the artifacts-import, usually found in the \ninit.js\n of the project:\n\n\nimport\n \nartifacts\n \nfrom\n \nlaxar-loader/artifacts?flow=main\ntheme=darkly\n;\n\n\n\n\n\n\nIn the LaxarJS bootstrapping configuration (usually also part of the \ninit.js\n), set the configuration property \ntheme\n to \n\"darkly\"\n:\n\n\nimport\n \n{\n \ncreate\n \n}\n \nfrom\n \nlaxar\n;\n\n\nconst\n \nadapters\n \n=\n \n[\n \n/* ... */\n \n];\n\n\ncreate\n(\n \nadapters\n,\n \nartifacts\n,\n \n{\n\n   \n// ... more configuration ...\n\n   \ntheme\n:\n \ndarkly\n\n\n}\n \n);\n\n\n\n\n\n\nThis causes the LaxarJS runtime to use the new theme.\n\n\nBecause the ShopDemo uses \nFont Awesome\n, we need to add an import to the top of our CSS file for that as well:\n\n\n@\nimport\n \nurl\n(\n//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css\n)\n;\n\n\n\n\n\n\nBefore opening the application in the browser, make sure to restart the development server, so that the new files are picked up.\nAnd \nvoil\u00e0\n, we have a dark web shop:\n\n\n\n\nAbove:\n The all-new ShopDemo using the \ndarkly\n theme, hopefully not for any shady business\n\n\nOf course, there are still some rough spots that need additional work:\nFor example, the widget headers look much better using the original LaxarJS demo theme.\n\n\nLet's fix that by \noverriding widget styles\n from the theme:\nFor each widget whose styles you want to override, create a stylesheet.\nThe path relative to your \ndarkly.theme\n directory is as follows: \n./widgets/\nname\n/\nstyleSource\n, where \nname\n and \nstyleSource\n are determined by the corresponding fields of the \nwidget.json\n descriptor of each widget.\nIf a descriptor does not specify a \nstyleSource\n, it defaults to \ncss/\nname\n.css\n.\n\n\nHere are some suggestions for a nicer look, to be put under \napplication/themes/darkly.theme/widgets/\n:\n\n\n\n\narticle-browser-widget\n: \narticle-browser-widget/scss/article-browser-widget.scss\n\n\n\n\nAs you can see by the path, this widget uses \nSCSS\n to generate its stylesheet.\n  Here we color the icon, the headline to match the logo, and the currently selected article to match the details widget.\n\n\n.article-browser-widget\n \n{\n\n   \n// Customize header and icon color:\n\n   \nh3\n \ni\n \n{\n\n      \ncolor\n:\n \n#F90\n;\n\n   \n}\n\n   \nth\n \n{\n\n     \nbackground-color\n:\n \n#F90\n;\n\n     \ncolor\n:\n \n#222222\n;\n\n   \n}\n\n\n   \n// highlight the selected article:\n\n   \ntr\n.selected\n \ntd\n \n{\n\n     \nfont-weight\n:\n \nbold\n;\n\n     \nbackground\n:\n \n#3498DB\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\n\narticle-teaser-widget\n: \narticle-teaser-widget/scss/article-teaser-widget.scss\n\n\n\n\nHere we color the icon and the headline to match the button.\n\n\n.article-teaser-widget\n \n{\n\n   \nh3\n \ni\n \n{\n\n      \ncolor\n:\n \n#3498DB\n;\n\n   \n}\n\n\n   \nh4\n \n{\n\n      \nbackground-color\n:\n \n#3498DB\n;\n\n      \npadding\n:\n \n8px\n;\n\n   \n}\n\n\n}\n\n\n\n\n\n\n\n\nshopping-cart-widget\n: \nshopping-cart-widget/scss/shopping-cart-widget.scss\n\n\n\n\nAgain, we color the icon and the headline to match the button.\n\n\n.shopping-cart-widget\n \n{\n\n   \nh3\n \ni\n \n{\n\n      \ncolor\n:\n \n#00bc8c\n;\n\n   \n}\n\n\n   \nth\n \n{\n\n      \nbackground-color\n:\n \n#00bc8c\n;\n\n   \n}\n\n\n   \n.app-increase-quantity\n \n{\n\n      \ntext-align\n:\n \nright\n \n!\nimportant\n;\n\n   \n}\n\n\n   \n.app-increase-buttons\n \n{\n\n      \npadding\n:\n \n0\n;\n\n      \npadding-top\n:\n \n6px\n;\n\n      \nwidth\n:\n \n40px\n;\n\n\n      \nbutton\n \n{\n\n         \npadding\n:\n \n0\n;\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nOf course, we do not want users to download an additional CSS file for each widget that we use.\nInstead, we use \nwebpack -P\n to create an optimized bundle, which we may load from the \nindex.html\n.\n\n\n\n\nOf course, there are still some areas of improvements to this way of styling widgets.\nFor example, if we would like to change the shade of blue that is used in our theme, we would have to update multiple source code locations.\nIt would be better to have some way to define these values in our theme and reuse them from individual widgets.\n\n\n\n\nAdding a Theme using SCSS\n\n\nTo support centralized variables, you can use a \ncompiles-to-CSS\n language such as \nSCSS/SASS\n or \nless\n.\nJust like widgets, themes can specify an alternate stylesheet location using their \ntheme.json\n descriptor.\nFortunately, an SCSS-version of the darkly theme is \nalready available\n, and can be installed using \nnpm\n.\n\n\nThe \nSCSS for our theme\n is little more than a couple of imports.\n\n\nJust make sure to adjust the webpack configuration of the project (\nwebpack.config.js\n) to add all the import paths needed by your theme's SCSS.\nThe \ndefault.theme\n and the \ncube.theme\n each have \nsass-options.js\n that you can use as an example.\n\n\nThe advantage of using an SCSS-based theme is that we can now write concise widget styles using central variables.\nAs an example, the SCSS file for the \narticle-browser-widget\n now becomes:\n\n\n@import\n \nvariables_all\n;\n\n\n\n.article-browser-widget\n \n{\n\n\n  \nh3\n \ni\n \n{\n\n    \ncolor\n:\n \n$\napp-color-logo\n;\n\n  \n}\n\n\n  \nth\n \n{\n\n    \nbackground-color\n:\n \n$\napp-color-logo\n;\n\n    \ncolor\n:\n \n$\nbody-bg\n;\n\n  \n}\n\n\n  \ntr\n.selected\n \ntd\n \n{\n\n    \nfont-weight\n:\n \nbold\n;\n\n    \nbackground\n:\n \n$\nbrand-info\n;\n\n  \n}\n\n\n}\n\n\n\n\n\n\nWhich CSS framework and tool chain to use (and if any) is ultimately up to you.\nThe \nshop demo on GitHub\n contains the \ncube.theme\n styles as well as \ndefault.theme\n styles.\n\n\nThe Bootstrap framework incurs some degree of boilerplate, but makes it relatively easy to reuse widgets across applications, and to find controls that work with your theme out of the box.\n\n\nHow the Runtime Finds CSS\n\n\nAs mentioned above, the LaxarJS runtime and loaders do not care \nhow\n you create your stylesheet.\nHowever, these tools need to find it, so it is important \nwhere\n the CSS files are.\nFor details on how CSS and other assets are loaded, have a look at the \nasset lookup manual\n.\n\n\nIn general, the lookup order goes like this:\n\n\n\n\nIf there are \ntheme-specified styles\n for an artifact (bundled with the application theme in use), then use those,\n\n\nif there are \ntheme-specified styles\n for an artifact (bundled with the artifact itself), then use those,\n\n\nelse if there are \ndefault styles\n for an artifact then use those,\n\n\nelse load \nnothing\n.\n\n\n\n\nOf course, \nload nothing\n means that it is completely fine for a widget not to have any CSS styles.", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#creating-themes", 
            "text": "\u00ab return to the manuals  Sometimes you would like to use  one widget  in  two or more applications .\nFor this, usually you want the widget to  behave identically , but  look differently .\nAlternatively, sometimes you would like to offer the same application in different appearances.\nLaxarJS has the concept of  themes  to help you achieve these things.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Writing Pages", 
            "title": "Creating Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#why-themes", 
            "text": "LaxarJS ships with a so-called  default.theme , which is actually just  Bootstrap CSS  together with  Font Awesome  and a few additional classes.\nThere are several ways to add your own styles.", 
            "title": "Why Themes?"
        }, 
        {
            "location": "/manuals/creating_themes/#from-ad-hoc-styles-to-theme-folders", 
            "text": "Usually, you will need to add some CSS classes of your own.\nFor example, the vast majority of web application needs some styling for the page background and positioning, or some custom header- and footer-areas.\nTo include such  ad-hoc styles , you  could  simply add a CSS file of your own to the project, and load it from the  debug.html  and  index.html  files using the  link  tag.\nHowever, it is better to add these styles to your main application layout instead, into a sub-folder called  default.theme/css .  The  benefit  of using such a  theme folder  is that    your CSS will be  bundled and compressed  together with Bootstrap CSS (no additional  link  tag needed) and that    you can support different  themes  simply by adding more  .theme  folders.    Due to the first point, using theme folders is useful and recommended  even  if you only use (and maybe customize) the default theme.", 
            "title": "From Ad-Hoc Styles to Theme Folders\u2026"
        }, 
        {
            "location": "/manuals/creating_themes/#and-to-custom-themes", 
            "text": "As soon as you use multiple page layouts, the previous approach does not really scale anymore:\nyou would have to duplicate your global styles to all of them.\nIn these cases,  creating your own theme  is definitely recommended.\nA detailed explanation of  creating a theme  is given below.", 
            "title": "\u2026and to Custom Themes"
        }, 
        {
            "location": "/manuals/creating_themes/#a-note-on-scss", 
            "text": "When using theme folders or entire themes, the LaxarJS loader (used by webpack) will only ever look at  .css  files in  css  sub-folders by default.\nHowever, it is entirely  up to you  which (if any) CSS authoring tools you would like to use.\nYou simply need to configure your widget to load you stylesheet from a different file that has the appropriate extension.\nDo this by adding a  styleSource  attribute to the widget descriptor, and by setting its value to a path that is relative to the theme folder.  The LaxarJS team uses SCSS to create themes, and the default-theme is based on the SCSS version of Bootstrap.\nUsing this approach makes it very easy to create a custom theme just by changing some Bootstrap SCSS variables.\nAlso, by using SCSS variables defined in the theme, widgets and controls can provide a consistent appearance.\nAfter explaining themes in general, further down we give instructions on  creating an SCSS theme .", 
            "title": "A Note on SCSS"
        }, 
        {
            "location": "/manuals/creating_themes/#creating-your-own-theme", 
            "text": "Let us create our own theme for an existing application, the  LaxarJS ShopDemo .\nThe ShopDemo uses the LaxarJS-branded  \"cube.theme\" , which is implemented by augmenting Bootstrap with some changes and custom additions, such as the circle icons used with the headlines.   Above:  The LaxarJS ShopDemo using the  cube  theme  However, the demo also works with just the default theme, provided by LaxarJS UiKit, although admittedly it does not look quite as pretty:   Above:  The LaxarJS ShopDemo using the  default  theme", 
            "title": "Creating Your Own Theme"
        }, 
        {
            "location": "/manuals/creating_themes/#a-custom-theme-using-plain-css", 
            "text": "Since all applications seem to offer a \"dark\" look these days, let us try to achieve this for our shop application.\nFortunately, there are several collections of nice bootstrap themes available for free.\nOn the site  Bootswatch  for example, you will find the theme  darkly , which looks like it might work for us.  The only thing that is actually  required  for a theme to work are a configuration entry and a CSS file in the right place.\nPut the pre-built  darkly CSS  into the right place, which is  application/themes/darkly.theme/css/theme.css .\nThe  theme-root  ( application/themes/  by default) can be changed in LaxarJS projects by setting the export  paths.themes  of the file  laxar.config.js .\nAdd a  descriptor  containing the canonical name of the theme:  // application/themes/darkly.theme/theme.json  { \n    name :   darkly.theme  }   To use the new theme, make sure to load it along with the application artifacts, by updating the artifacts-import, usually found in the  init.js  of the project:  import   artifacts   from   laxar-loader/artifacts?flow=main theme=darkly ;   In the LaxarJS bootstrapping configuration (usually also part of the  init.js ), set the configuration property  theme  to  \"darkly\" :  import   {   create   }   from   laxar ;  const   adapters   =   [   /* ... */   ];  create (   adapters ,   artifacts ,   { \n    // ... more configuration ... \n    theme :   darkly  }   );   This causes the LaxarJS runtime to use the new theme.  Because the ShopDemo uses  Font Awesome , we need to add an import to the top of our CSS file for that as well:  @ import   url ( //maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css ) ;   Before opening the application in the browser, make sure to restart the development server, so that the new files are picked up.\nAnd  voil\u00e0 , we have a dark web shop:   Above:  The all-new ShopDemo using the  darkly  theme, hopefully not for any shady business  Of course, there are still some rough spots that need additional work:\nFor example, the widget headers look much better using the original LaxarJS demo theme.  Let's fix that by  overriding widget styles  from the theme:\nFor each widget whose styles you want to override, create a stylesheet.\nThe path relative to your  darkly.theme  directory is as follows:  ./widgets/ name / styleSource , where  name  and  styleSource  are determined by the corresponding fields of the  widget.json  descriptor of each widget.\nIf a descriptor does not specify a  styleSource , it defaults to  css/ name .css .  Here are some suggestions for a nicer look, to be put under  application/themes/darkly.theme/widgets/ :   article-browser-widget :  article-browser-widget/scss/article-browser-widget.scss   As you can see by the path, this widget uses  SCSS  to generate its stylesheet.\n  Here we color the icon, the headline to match the logo, and the currently selected article to match the details widget.  .article-browser-widget   { \n    // Customize header and icon color: \n    h3   i   { \n       color :   #F90 ; \n    } \n    th   { \n      background-color :   #F90 ; \n      color :   #222222 ; \n    } \n\n    // highlight the selected article: \n    tr .selected   td   { \n      font-weight :   bold ; \n      background :   #3498DB ; \n    }  }    article-teaser-widget :  article-teaser-widget/scss/article-teaser-widget.scss   Here we color the icon and the headline to match the button.  .article-teaser-widget   { \n    h3   i   { \n       color :   #3498DB ; \n    } \n\n    h4   { \n       background-color :   #3498DB ; \n       padding :   8px ; \n    }  }    shopping-cart-widget :  shopping-cart-widget/scss/shopping-cart-widget.scss   Again, we color the icon and the headline to match the button.  .shopping-cart-widget   { \n    h3   i   { \n       color :   #00bc8c ; \n    } \n\n    th   { \n       background-color :   #00bc8c ; \n    } \n\n    .app-increase-quantity   { \n       text-align :   right   ! important ; \n    } \n\n    .app-increase-buttons   { \n       padding :   0 ; \n       padding-top :   6px ; \n       width :   40px ; \n\n       button   { \n          padding :   0 ; \n       } \n    }  }   Of course, we do not want users to download an additional CSS file for each widget that we use.\nInstead, we use  webpack -P  to create an optimized bundle, which we may load from the  index.html .   Of course, there are still some areas of improvements to this way of styling widgets.\nFor example, if we would like to change the shade of blue that is used in our theme, we would have to update multiple source code locations.\nIt would be better to have some way to define these values in our theme and reuse them from individual widgets.", 
            "title": "A Custom Theme Using Plain CSS"
        }, 
        {
            "location": "/manuals/creating_themes/#adding-a-theme-using-scss", 
            "text": "To support centralized variables, you can use a  compiles-to-CSS  language such as  SCSS/SASS  or  less .\nJust like widgets, themes can specify an alternate stylesheet location using their  theme.json  descriptor.\nFortunately, an SCSS-version of the darkly theme is  already available , and can be installed using  npm .  The  SCSS for our theme  is little more than a couple of imports.  Just make sure to adjust the webpack configuration of the project ( webpack.config.js ) to add all the import paths needed by your theme's SCSS.\nThe  default.theme  and the  cube.theme  each have  sass-options.js  that you can use as an example.  The advantage of using an SCSS-based theme is that we can now write concise widget styles using central variables.\nAs an example, the SCSS file for the  article-browser-widget  now becomes:  @import   variables_all ;  .article-browser-widget   { \n\n   h3   i   { \n     color :   $ app-color-logo ; \n   } \n\n   th   { \n     background-color :   $ app-color-logo ; \n     color :   $ body-bg ; \n   } \n\n   tr .selected   td   { \n     font-weight :   bold ; \n     background :   $ brand-info ; \n   }  }   Which CSS framework and tool chain to use (and if any) is ultimately up to you.\nThe  shop demo on GitHub  contains the  cube.theme  styles as well as  default.theme  styles.  The Bootstrap framework incurs some degree of boilerplate, but makes it relatively easy to reuse widgets across applications, and to find controls that work with your theme out of the box.", 
            "title": "Adding a Theme using SCSS"
        }, 
        {
            "location": "/manuals/creating_themes/#how-the-runtime-finds-css", 
            "text": "As mentioned above, the LaxarJS runtime and loaders do not care  how  you create your stylesheet.\nHowever, these tools need to find it, so it is important  where  the CSS files are.\nFor details on how CSS and other assets are loaded, have a look at the  asset lookup manual .  In general, the lookup order goes like this:   If there are  theme-specified styles  for an artifact (bundled with the application theme in use), then use those,  if there are  theme-specified styles  for an artifact (bundled with the artifact itself), then use those,  else if there are  default styles  for an artifact then use those,  else load  nothing .   Of course,  load nothing  means that it is completely fine for a widget not to have any CSS styles.", 
            "title": "How the Runtime Finds CSS"
        }, 
        {
            "location": "/manuals/project_from_scratch/", 
            "text": "Creating a Project from Scratch\n\n\n\u00ab return to the manuals\n\n\nThis manual is intended for experts that desire \nfull control\n over their application setup.\nIn general, using \nthe generator\n is recommended instead of performing a manual application setup.\n\n\nThis guide will cover only the absolute basics for creating a LaxarJS project from scratch.\nIt does not explain how to setup \nBabel\n for ES2015 or how to add \nintegration technology adapters\n for using MVC frameworks.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\nFlow and Places\n\n\n\n\nThe npm Project\n\n\nYou will need to create a Node.js project with webpack and basic webpack loaders.\nAlso needed are \nlaxar\n, \nlaxar-uikit\n (for the \ndefault.theme\n) and the \nlaxar-loader\n to load LaxarJS artifacts using webpack.\n\n\nmkdir my-app\n\n\ncd my-app\n\n\nnpm init\n\n\nnpm install --save-dev \\\n\n\n   webpack style-loader css-loader file-loader \\\n\n\n   laxar laxar-uikit laxar-loader\n\n\n\n\n\n\nHaving taken care of this, let us first look into providing a minimal set of LaxarJS application artifacts, and then add the required infrastructure to run them.\n\n\nApplication Artifacts\n\n\nThe only application artifacts that are absolutely required are a \nflow\n, an empty \npage\n and a very basic \nlayout\n.\nAfterwards, you will want to add widgets as well, as explained in the \nmanual on widgets\n.\n\n\nLayout\n\n\nHere, two files are required:\n\n\n\n\na \nlayout.json\n descriptor:\n\n\n\n\n// my-app/application/layouts/base/layout.json\n\n\n{\n \nname\n:\n \nbase\n \n}\n\n\n\n\n\n\n\n\nand an HTML template:\n\n\n\n\n!-- my-app/application/layouts/base/default.theme/base.html --\n\n\nh1\nWelcome to your own LaxarJS setup!\n/\nh1\n\n\ndiv\n \ndata-ax-widget-area\n=\ncontent\n/\ndiv\n\n\n\n\n\n\nOf course, the name \n(\"base\")\n is up to you.\n\n\nPage\n\n\nNow, let use create a page called \n\"home\"\n using the \nbase\n layout:\n\n\n// my-app/application/pages/home.json\n\n\n{\n\n   \nlayout\n:\n \nbase\n,\n\n   \nareas\n:\n \n{\n\n      \ncontent\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nFlow\n\n\nHere is the minimal routing setup:\n\n\n// my-app/application/flows/main.json\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nhome\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/\n \n],\n\n         \npage\n:\n \nhome\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nProject Scaffolding\n\n\nHaving created a minimal application, we still need to take care of some mundane plumbing that is required to actually get it running in your web browser.\n\n\nThe init.js Entry Point\n\n\nCreate an \ninit.js\n containing the application \nbootstrapping code:\n\n\n// my-app/init.js\n\n\nrequire\n(\n \nlaxar/dist/polyfills\n \n);\n \n// optional\n\n\nconst\n \nadapters\n \n=\n \n[];\n\n\nconst\n \nartifacts\n \n=\n \nrequire\n(\n \nlaxar-loader/artifacts?flow=main\ntheme=default\n \n);\n\n\nconst\n \nconfiguration\n \n=\n \n{\n\n   \n// more diagnostics than the default (\nINFO\n):\n\n   \nlogging\n:\n \n{\n \nthreshold\n:\n \nTRACE\n \n},\n\n   \nrouter\n:\n \n{\n \nnavigo\n:\n \n{\n \nuseHash\n:\n \ntrue\n \n}\n \n}\n\n\n};\n\n\n\nrequire\n(\n \nlaxar\n \n).\ncreate\n(\n \nadapters\n,\n \nartifacts\n,\n \nconfiguration\n \n)\n\n   \n.\nflow\n(\n \nmain\n,\n \ndocument\n.\nquerySelector\n(\n \n[data-ax-page]\n \n)\n \n)\n\n   \n.\nbootstrap\n();\n\n\n\n\n\n\nThe name of this file is up to you, but \ninit\n is what our generator uses.\n\n\nHTML Entry\n\n\nSome HTML code is required for actually loading the application in your browser, let's call it \nmy-app/index.html\n:\n\n\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n!-- ... title, meta, favicon as you wish ... --\n/\nhead\n\n\nbody\n\n   \ndiv\n \ndata-ax-page\n/\ndiv\n\n   \nscript\n \nsrc\n=\nbuild/init.bundle.js\n/\nscript\n\n\n/\nbody\n\n\n/\nhtml\n\n\n\n\n\n\nNote that \ndata-ax-page\n is an arbitrary attribute used by \ninit.js\n to identify the anchor for the LaxarJS flow.\nInstead, you could also use an ID or some other unambiguous way of selecting the desired container element.\n\n\nWebpack Configuration\n\n\nTo actually generate the \ninit.bundle.js\n that was referenced in the HTML entry, let us create a basic webpack configuration.\nMost of this is not specific to LaxarJS, except the alias-definition for the \ndefault.theme\n.\n\n\n// my-app/webpack.config.js\n\n\nconst\n \npath\n \n=\n \nrequire\n(\n \npath\n \n);\n\n\nmodule\n.\nexports\n \n=\n \n{\n\n   \nentry\n:\n \n{\n \ninit\n:\n \n./init.js\n \n},\n\n\n   \noutput\n:\n \n{\n\n      \npath\n:\n \npath\n.\nresolve\n(\n \n__dirname\n,\n \n`./build/`\n \n),\n\n      \npublicPath\n:\n \n/build/\n,\n\n      \nfilename\n:\n \n[name].bundle.js\n,\n\n      \nchunkFilename\n:\n \n[name].bundle.js\n\n   \n},\n\n\n   \nresolve\n:\n \n{\n\n      \nalias\n:\n \n{\n\n         \ndefault.theme\n:\n \nlaxar-uikit/themes/default.theme\n\n      \n}\n\n   \n},\n\n\n   \nmodule\n:\n \n{\n\n      \nrules\n:\n \n[\n\n         \n{\n\n            \ntest\n:\n \n/\\.(gif|jpe?g|png|ttf|woff2?|svg|eot|otf)(\\?.*)?$/\n,\n\n            \nloader\n:\n \nfile-loader\n\n         \n},\n\n         \n{\n\n            \ntest\n:\n \n/\\.css$/\n,\n\n            \nloader\n:\n \nstyle-loader!css-loader\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n};\n\n\n\n\n\n\nNow you can build your javascript bundle using \n./node_modules/.bin/webpack\n.\nAdd \n-P\n for a minified, production-ready version.\n\n\nOptional: Webpack development Server\n\n\nThis is not specific to LaxarJS, but too useful to simply skip:\n\n\nnpm install --save-dev webpack-dev-server\n\n\n./node_modules/.bin/webpack-dev-server\n\n\n\n\n\n\nThis will serve and incrementally rebuild your application as you make changes.\nWhen launching the web server and visiting \nhttp://localhost:8080\n, you should see the message \nWelcome to your own LaxarJS setup!\n, which means it is time to go ahead and \ncreate some widgets\n.\n\n\nOptional: Developer Tools Support\n\n\nTo use the \nLaxarJS Developer Tools Addon\n for Google Chrome, you will need to add a line to the \ninit.js\n:\n\n\n// my-app/init.js\n\n\n// ... polyfills, adapters, configuration, artifacts, ...\n\n\n\nrequire\n(\n \nlaxar\n \n).\ncreate\n(\n \nadapters\n,\n \nartifacts\n,\n \nconfiguration\n \n)\n\n   \n.\ntooling\n(\n \nrequire\n(\n \nlaxar-loader/debug-info?flow=main\ntheme=default\n \n)\n \n)\n\n   \n// .flow( ... )\n\n   \n// .bootstrap();\n\n\n\n\n\n\nThis feature is \nopt-in\n to avoid involuntary exposure of your application's inner workings, and to minimize performance and load-time overhead when tools are not actually needed.\n\n\nNext Steps\n\n\nOf course, you are going to add widgets, usually using one or several technology adapters, which can also be installed using npm.\nThen, you may want to setup transpilation using \nBabel\n, and possibly separate CSS bundling using the webpack \nExtractCssPlugin\n.\nAgain, have a look at existing projects, such as the \nLaxarJS ShopDemo\n for guidance, and/or consult the docs for the respective tools.", 
            "title": "Creating a Project from Scratch"
        }, 
        {
            "location": "/manuals/project_from_scratch/#creating-a-project-from-scratch", 
            "text": "\u00ab return to the manuals  This manual is intended for experts that desire  full control  over their application setup.\nIn general, using  the generator  is recommended instead of performing a manual application setup.  This guide will cover only the absolute basics for creating a LaxarJS project from scratch.\nIt does not explain how to setup  Babel  for ES2015 or how to add  integration technology adapters  for using MVC frameworks.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Writing Pages  Flow and Places", 
            "title": "Creating a Project from Scratch"
        }, 
        {
            "location": "/manuals/project_from_scratch/#the-npm-project", 
            "text": "You will need to create a Node.js project with webpack and basic webpack loaders.\nAlso needed are  laxar ,  laxar-uikit  (for the  default.theme ) and the  laxar-loader  to load LaxarJS artifacts using webpack.  mkdir my-app  cd my-app  npm init  npm install --save-dev \\     webpack style-loader css-loader file-loader \\     laxar laxar-uikit laxar-loader   Having taken care of this, let us first look into providing a minimal set of LaxarJS application artifacts, and then add the required infrastructure to run them.", 
            "title": "The npm Project"
        }, 
        {
            "location": "/manuals/project_from_scratch/#application-artifacts", 
            "text": "The only application artifacts that are absolutely required are a  flow , an empty  page  and a very basic  layout .\nAfterwards, you will want to add widgets as well, as explained in the  manual on widgets .", 
            "title": "Application Artifacts"
        }, 
        {
            "location": "/manuals/project_from_scratch/#layout", 
            "text": "Here, two files are required:   a  layout.json  descriptor:   // my-app/application/layouts/base/layout.json  {   name :   base   }    and an HTML template:   !-- my-app/application/layouts/base/default.theme/base.html --  h1 Welcome to your own LaxarJS setup! / h1  div   data-ax-widget-area = content / div   Of course, the name  (\"base\")  is up to you.", 
            "title": "Layout"
        }, 
        {
            "location": "/manuals/project_from_scratch/#page", 
            "text": "Now, let use create a page called  \"home\"  using the  base  layout:  // my-app/application/pages/home.json  { \n    layout :   base , \n    areas :   { \n       content :   [] \n    }  }", 
            "title": "Page"
        }, 
        {
            "location": "/manuals/project_from_scratch/#flow", 
            "text": "Here is the minimal routing setup:  // my-app/application/flows/main.json  { \n    places :   { \n       home :   { \n          patterns :   [   /   ], \n          page :   home \n       } \n    }  }", 
            "title": "Flow"
        }, 
        {
            "location": "/manuals/project_from_scratch/#project-scaffolding", 
            "text": "Having created a minimal application, we still need to take care of some mundane plumbing that is required to actually get it running in your web browser.", 
            "title": "Project Scaffolding"
        }, 
        {
            "location": "/manuals/project_from_scratch/#the-initjs-entry-point", 
            "text": "Create an  init.js  containing the application  bootstrapping code:  // my-app/init.js  require (   laxar/dist/polyfills   );   // optional  const   adapters   =   [];  const   artifacts   =   require (   laxar-loader/artifacts?flow=main theme=default   );  const   configuration   =   { \n    // more diagnostics than the default ( INFO ): \n    logging :   {   threshold :   TRACE   }, \n    router :   {   navigo :   {   useHash :   true   }   }  };  require (   laxar   ). create (   adapters ,   artifacts ,   configuration   ) \n    . flow (   main ,   document . querySelector (   [data-ax-page]   )   ) \n    . bootstrap ();   The name of this file is up to you, but  init  is what our generator uses.", 
            "title": "The init.js Entry Point"
        }, 
        {
            "location": "/manuals/project_from_scratch/#html-entry", 
            "text": "Some HTML code is required for actually loading the application in your browser, let's call it  my-app/index.html :  !DOCTYPE html  html  head !-- ... title, meta, favicon as you wish ... -- / head  body \n    div   data-ax-page / div \n    script   src = build/init.bundle.js / script  / body  / html   Note that  data-ax-page  is an arbitrary attribute used by  init.js  to identify the anchor for the LaxarJS flow.\nInstead, you could also use an ID or some other unambiguous way of selecting the desired container element.", 
            "title": "HTML Entry"
        }, 
        {
            "location": "/manuals/project_from_scratch/#webpack-configuration", 
            "text": "To actually generate the  init.bundle.js  that was referenced in the HTML entry, let us create a basic webpack configuration.\nMost of this is not specific to LaxarJS, except the alias-definition for the  default.theme .  // my-app/webpack.config.js  const   path   =   require (   path   );  module . exports   =   { \n    entry :   {   init :   ./init.js   }, \n\n    output :   { \n       path :   path . resolve (   __dirname ,   `./build/`   ), \n       publicPath :   /build/ , \n       filename :   [name].bundle.js , \n       chunkFilename :   [name].bundle.js \n    }, \n\n    resolve :   { \n       alias :   { \n          default.theme :   laxar-uikit/themes/default.theme \n       } \n    }, \n\n    module :   { \n       rules :   [ \n          { \n             test :   /\\.(gif|jpe?g|png|ttf|woff2?|svg|eot|otf)(\\?.*)?$/ , \n             loader :   file-loader \n          }, \n          { \n             test :   /\\.css$/ , \n             loader :   style-loader!css-loader \n          } \n       ] \n    }  };   Now you can build your javascript bundle using  ./node_modules/.bin/webpack .\nAdd  -P  for a minified, production-ready version.", 
            "title": "Webpack Configuration"
        }, 
        {
            "location": "/manuals/project_from_scratch/#optional-webpack-development-server", 
            "text": "This is not specific to LaxarJS, but too useful to simply skip:  npm install --save-dev webpack-dev-server  ./node_modules/.bin/webpack-dev-server   This will serve and incrementally rebuild your application as you make changes.\nWhen launching the web server and visiting  http://localhost:8080 , you should see the message  Welcome to your own LaxarJS setup! , which means it is time to go ahead and  create some widgets .", 
            "title": "Optional: Webpack development Server"
        }, 
        {
            "location": "/manuals/project_from_scratch/#optional-developer-tools-support", 
            "text": "To use the  LaxarJS Developer Tools Addon  for Google Chrome, you will need to add a line to the  init.js :  // my-app/init.js  // ... polyfills, adapters, configuration, artifacts, ...  require (   laxar   ). create (   adapters ,   artifacts ,   configuration   ) \n    . tooling (   require (   laxar-loader/debug-info?flow=main theme=default   )   ) \n    // .flow( ... ) \n    // .bootstrap();   This feature is  opt-in  to avoid involuntary exposure of your application's inner workings, and to minimize performance and load-time overhead when tools are not actually needed.", 
            "title": "Optional: Developer Tools Support"
        }, 
        {
            "location": "/manuals/project_from_scratch/#next-steps", 
            "text": "Of course, you are going to add widgets, usually using one or several technology adapters, which can also be installed using npm.\nThen, you may want to setup transpilation using  Babel , and possibly separate CSS bundling using the webpack  ExtractCssPlugin .\nAgain, have a look at existing projects, such as the  LaxarJS ShopDemo  for guidance, and/or consult the docs for the respective tools.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/manuals/adapters/", 
            "text": "Creating an Adapter for a new Widget Technology\n\n\n\u00ab return to the manuals\n\n\nLaxarJS widgets can be created in various integration technologies:\nWhile \nour own widgets\n are often written in \nAngularJS\n, this should not prevent you from using an (MVC) framework of your choice, such as \nReact\n, \nVue.JS\n, \nAngular 2\n or maybe even \nKnockout\n.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\nWidget Services\n\n\nInfrastructure and Tools\n\n\n\n\nCombining Integration Technologies\n\n\nBecause widgets communicate through the event bus only, you could rewrite any widget within your application in any framework you like, and none of the other widgets would be any the wiser.\nThis is a great way to upgrade step-by-step from an older technology to newer tools, because only a single widget at a time is at risk, not your entire application.\n\n\nOf course, to achieve a great user experience, you do not want to include an excessive number of frameworks and libraries into your application:\nAs you add libraries, page load times will increase and with it user satisfaction will suffer.\nHowever, LaxarJS does not want you to be locked into using any specific implementation technology for your widgets.\nIf used appropriately, \ncustom widget adapters\n can make it easier by leaps and bounds to integrate with legacy code or third-party widgets, simply helping you to be more productive.\n\n\nEven if you are not interested in writing your own widget adapter, reading this manual is a good way to gain an in-depth understanding of the LaxarJS widget life cycle.\n\n\nThe Role of Widget Adapters\n\n\nThe \nInfrastructure and Tools\n manual explains how the page controller sets up widgets and activities when entering a page.\nSince that is a somewhat simplified explanation, let us look into it in more detail:\n\n\n\n\n\n\nAfter entering a page, the \npage controller\n has a single static model of all areas on a page, and for each area, a model of its configured widgets.\n  The composition parameter names have long been substituted by their values, feature configuration has been expanded, defaults have been applied, and unique widget IDs have been generated.\n\n\n\n\n\n\nFor each configured widget instance, the page controller asks the \nwidget loader\n to provide it with a widget adapter for that instance, in order to manage the widget throughout its life cycle.\n  The widget's descriptor (the \nwidget.json\n), its assets (HTML/CSS) and the JavaScript controller module (AMD, CommonJS or ES6) have already been loaded as part of the artifacts bundle, when entering the application.\n\n\n\n\n\n\nNow, the widget loader provides \nwidget services\n for injection into the widget controller.\n  This includes the widget-specific event bus instance, which automatically sets the \nsender\n on publish, and which automatically removes subscriptions when the page containing a widget is destroyed.\n  Widget services are instantiated lazily using ECMAScript 5 dynamic properties, so that they will only be created when they are actually injected.\n\n\n\n\n\n\nNow all that is left to do is kicking off the widget controller with the injections, and then loading and instantiating the widget template.\n  Both of these steps are performed by the adapter, and specific to the implementation technology of the widget.\n  For example, the \n\"angular\"\n adapter for AngularJS v1, creates a new \nScope\n and adds it to the widget services, then instantiates the controller using the AngularJS \n$controller\n service, so that regular AngularJS injections are available as well.\n\n\n\n\n\n\nAs soon as the widget becomes visible (usually right away, but possibly only after its containing popup/tab/panel/... is shown), the template is retrieved.\n  For \n\"angular\"\n, it is linked to the new scope, and inserted into the page DOM.\n  Other adapters may perform their own value binding magic, or simply use a technology-specific API for passing the template HTML to the widget controller.\n\n\n\n\n\n\nThe Integration Technology API\n\n\nEach widget integration technology is implemented as a module with these properties:\n\n\n\n\n\n\nThe module field \ntechnology\n is a string that identifies the widget adapter technology, such as \n\"angular\"\n or \n\"react\"\n.\n  It is compared to the \nintegration.technology\n field of each widget descriptor to determine which adapter must be used for each widget in the application.\n\n\n\n\n\n\nThe module method \nbootstrap\n prepares the adapter for an entire LaxarJS bootstrapping instance.\n  The method receives an object with one array property for \nwidgets\n and one for \ncontrols\n.\n  Each entry of these arrays has a \ndescriptor\n (the contents of \nwidget.json\n and \ncontrol.json\n respectively), and a \nmodule\n containing the technology-dependent implementation code.\n  As a second argument, \nbootstrap\n receives selected \nservices\n from the LaxarJS runtime, only some of which may be required to implement an individual adapter:\n\n\n\n\n\n\nglobalEventBus\n is the application-wide \nAxEventBus\n instance, which is the same as the \naxGlobalEventBus\n widget service injection,\n\n\n\n\n\n\nconfiguration\n is the application-wide \nAxConfiguration\n instance,\n\n\n\n\n\n\nheartbeat\n is the application-wide \nAxHeartbeat\n instance,\n\n\n\n\n\n\nlog\n is the application-wide \nAxLog\n instance which is the same as the \naxGlobalEventBus\n widget service injection,\n\n\n\n\n\n\nstorage\n is the application-wide \nAxStorage\n instance, which is the same as the \naxGlobalStorage\n widget service injection.\n\n\n\n\n\n\n\n\n\n\nThe \nbootstrap\n method returns an \nadapter factory\n object which is used to create individual adapter instances for the live widgets.\nThe adapter factory is an object with two methods:\n\n\n\n\n\n\ncreate\n: the actual factory method to create an adapter for a given widget instance.\n  Each widget instance has its own adapter instance, so that the adapter is free to maintain state information specific to its widget, as may be required by the integration technology.\n  For each widget to be instantiated, \ncreate\n is called with an \nenvironment\n containing the \nwidgetName\n, the containing DOM \nanchorElement\n, the widget \nservices\n, and a \nprovideService\n callback.\n  Details \non the environment\n are given below.\n\n\n\n\n\n\nserviceDecorators\n (optional):\n  Usually, services passed to \ncreate\n can be used \nas-is\n, without technology-specific changes.\n  However, some technologies may need to modify individual services.\n  For these cases, adapter factories may specify so-called \nservice decorators\n by returning a map of service names to decorator functions from this method. Each decorator will be called with the original injection (such as \naxContext\n, \naxId\n etc.) when its injection is requested. Decorators may then decide to return a modified injection or a completely new object.\n\n\n\n\n\n\nThe API of the widget modules themselves depends on the integration technology, but usually there is a method to instantiate a controller for a given widget instance, and possibly a list of injections and/or a method to set up a view. Here are some examples:\n\n\n\n\n\n\nFor the \n\"plain\"\n integration, the widget module must have a method \ncreate\n to instantiate the controller, and optionally an array  \ninjections\n to specify services required by the widget, such as \n\"axEventBus\"\n.\n  These injections are used as arguments to \ncreate\n in the order that they are listed in \ninjections\n.\n\n\n\n\n\n\nFor the \n\"angular\"\n integration\n, the widget module simply exports the name of the AngularJS module for the widget, so that controllers can be instantiated by using the AngularJS \n$controller\n service.\n\n\n\n\n\n\nAll \"global\" state of the adapter should be encapsulated in the return value of the \nbootstrap\n method, so that multiple LaxarJS applications may coexist in the same JavaScript environment, each with their own adapter factories, without hurting each other.\n\n\nBefore going into details on API returned by \ncreate\n, let us have a look at the environment that is provided by the widget loader.\n\n\nThe Widget Loader Environment\n\n\nBefore creating an adapter for an individual widget instance, the widget loader collects all required information and bundles it into an \nenvironment\n object.\nThe environment has the following properties:\n\n\n\n\n\n\nThe \nwidgetName\n is the name of the widget to instantiate, exactly as it is written in the \nname\n property of the widget descriptor.\n  The widget adapter can use this to lookup the widget's descriptor and module among the modules it was bootstrapped with.\n\n\n\n\n\n\nThe \nanchorElement\n is a standard \nHTMLElement\n meant to receive all of the widget's user interface.\n  If the adapter uses a templating system, the instantiated HTML template should be appended to this anchor.\n  Before passing the element to the adapter, the widget loader sets the ID-attribute to the widget ID, which is useful to identify a widget instance within the DOM.\n  The widget loader also adds a CSS class which should be used by the widget's stylesheet to restrict style definitions to the widget.\n  If necessary, widgets or adapters may manipulate DOM outside of their anchor, for example to show an popup-like overlay.\n  If they do, they are responsible for cleanup, and they should \nnever\n modify the DOM of other widgets.\n\n\n\n\n\n\nThe \nservices\n object contains all services that may be injected into a widget.\n  It offers access to global APIs, but also services specifically adapted for individual widget instances.\n  Since the list is rather long and mostly relevant for widget authors, the services are described in their own \ndocument\n.\n\n\n\n\n\n\nFinally, \nprovideServices\n is a callback function that the widget adapter \nmust call right before instantiating\n the widget controller.\n  It is required for tests using \nLaxarJS Mocks\n to get access to the final set of widget services, which is dependent on the widget instance as well as on the technology.\n  The services must be passed as an object, where keys are the injection names requested by the widget, and the values are the corresponding service properties.\n  The object may contain additional services that were not actually requested by the widget, but the adapter should take care not to evaluate their properties.\n  For example, if a widget does not actually use \naxVisibility\n, it probably does not wish to create event bus subscriptions for visibility changes, as accessing axVisibility entails.\n  An adapter that does not need to add custom injections can simply pass the \nservices\n object from the environment.\n  For hints on the correct implementation, have a look at the \nexisting adapter implementations\n listed below.\n  Note that because the \nview\n has not been setup at this point in time, the adapter should not yet manipulate the anchor element, nor make it available to the widget controller.\n\n\n\n\n\n\nCreated from this environment, the new widget adapter instance prepares additional technology-specific injections as needed, calls the \nprovideServices\n hook, and instantiates the widget controller.\nThen it returns an API that allows for further manipulation by the widget loader.\n\n\nThe Widget Adapter API\n\n\nAll widget adapter instances produced by \ncreate\n must implement the following three methods, to support creation and destruction of controller and view:\n\n\n\n\n\n\ndomAttachTo\n: called with a widget area as the first argument, and an optional (template) HTML string as the second argument.\n  The adapter is supposed to instantiate the template in a manner appropriate for the implementation technology, and to associate it with the widget controller.\n  Depending on the technology, this may happen through binding, for example through the \n$scope\n injection created by the adapter for \n\"angular\"\n.\n  Alternatively, the adapter may call some technology-specific API of the controller and pass the instantiated widget DOM.\n  The instantiated template should be appended to the anchor element, which in turn should be appended to the widget area element.\n  If there is no template, as is usually the case with activities or sometimes with very simple widgets that only need CSS, the value \nnull\n is passed as the second parameter.\n  In this case, it is up to the widget adapter to decide if the anchor should be added to the DOM anyway, usually based on whether the type is \nwidget\n or \nactivity\n.\n\n\n\n\n\n\ndomDetach\n: the counterpart to \ndomAttachTo\n, this method is used to remove the view from the containing widget area, temporarily or permanently.\n  The widget adapter may tear down the template completely, or keep it \"warm\" for reattachment.\n  LaxarJS may ask widget adapters to detach their DOM and later to attach it again, for example to suspend the widget views within a \"popup\" layer while that layer is closed.\n  If an adapter cannot reliably destroy and rebuild its view, it should do nothing, and simply ignore subsequent calls to \ndomAttachTo\n.\n\n\n\n\n\n\ndestroy\n: called only once when a widget instance is removed, usually because the user is navigating away from a page.\n  It is not guaranteed that \nany\n of the other methods has been called at this point in time, but \ndestroy\n is supposed to tidy up everything that has been done so far.\n  The adapter can assume that the other methods will not be called after this.\n  Adapters that do not need to perform cleanup work may omit this property.\n\n\n\n\n\n\nExisting Adapter Implementations\n\n\nFor practical examples of user-defined widget adapters, have a look at the following adapter implementations.\nThe adapters are sorted by their implementation complexity, from simple to complex.\n\n\n\n\nReact adapter\n for the \n\"react\"\n technology\n\n\nVue.JS adapter\n for the \n\"vue\"\n technology\n\n\nAngularJS v1 adapter\n for the \n\"angular\"\n technology\n\n\nAngular v2 adapter\n for the \n\"angular2\"\n technology\n\n\n\n\nAlso, there is the adapter for \n\"plain\"\n, which is part of the LaxarJS Core code base:\n\n\n\n\nplain adapter\n for the \n\"plain\"\n technology\n\n\n\n\nUsing a Custom Adapter in a Project\n\n\nTo use any integration technology other than \"plain\", the corresponding adapter module must be passed to the LaxarJS \ncreate\n method.\nThis means that when working on a project that was created by the \nLaxarJS Yeoman generator\n, the \ninit.js\n must load the corresponding module, wrap it in an array and pass that array as the first parameter (\nadapters\n) to \ncreate\n.\nFinally, the widgets written for this integration technology must state so in their \nwidget.json\n descriptor, by specifying the adapter \ntechnology\n as their own \nintegration.technology\n string.", 
            "title": "Creating an Adapter for a new Widget Technology"
        }, 
        {
            "location": "/manuals/adapters/#creating-an-adapter-for-a-new-widget-technology", 
            "text": "\u00ab return to the manuals  LaxarJS widgets can be created in various integration technologies:\nWhile  our own widgets  are often written in  AngularJS , this should not prevent you from using an (MVC) framework of your choice, such as  React ,  Vue.JS ,  Angular 2  or maybe even  Knockout .  Preliminary readings:   Widgets and Activities  Widget Services  Infrastructure and Tools", 
            "title": "Creating an Adapter for a new Widget Technology"
        }, 
        {
            "location": "/manuals/adapters/#combining-integration-technologies", 
            "text": "Because widgets communicate through the event bus only, you could rewrite any widget within your application in any framework you like, and none of the other widgets would be any the wiser.\nThis is a great way to upgrade step-by-step from an older technology to newer tools, because only a single widget at a time is at risk, not your entire application.  Of course, to achieve a great user experience, you do not want to include an excessive number of frameworks and libraries into your application:\nAs you add libraries, page load times will increase and with it user satisfaction will suffer.\nHowever, LaxarJS does not want you to be locked into using any specific implementation technology for your widgets.\nIf used appropriately,  custom widget adapters  can make it easier by leaps and bounds to integrate with legacy code or third-party widgets, simply helping you to be more productive.  Even if you are not interested in writing your own widget adapter, reading this manual is a good way to gain an in-depth understanding of the LaxarJS widget life cycle.", 
            "title": "Combining Integration Technologies"
        }, 
        {
            "location": "/manuals/adapters/#the-role-of-widget-adapters", 
            "text": "The  Infrastructure and Tools  manual explains how the page controller sets up widgets and activities when entering a page.\nSince that is a somewhat simplified explanation, let us look into it in more detail:    After entering a page, the  page controller  has a single static model of all areas on a page, and for each area, a model of its configured widgets.\n  The composition parameter names have long been substituted by their values, feature configuration has been expanded, defaults have been applied, and unique widget IDs have been generated.    For each configured widget instance, the page controller asks the  widget loader  to provide it with a widget adapter for that instance, in order to manage the widget throughout its life cycle.\n  The widget's descriptor (the  widget.json ), its assets (HTML/CSS) and the JavaScript controller module (AMD, CommonJS or ES6) have already been loaded as part of the artifacts bundle, when entering the application.    Now, the widget loader provides  widget services  for injection into the widget controller.\n  This includes the widget-specific event bus instance, which automatically sets the  sender  on publish, and which automatically removes subscriptions when the page containing a widget is destroyed.\n  Widget services are instantiated lazily using ECMAScript 5 dynamic properties, so that they will only be created when they are actually injected.    Now all that is left to do is kicking off the widget controller with the injections, and then loading and instantiating the widget template.\n  Both of these steps are performed by the adapter, and specific to the implementation technology of the widget.\n  For example, the  \"angular\"  adapter for AngularJS v1, creates a new  Scope  and adds it to the widget services, then instantiates the controller using the AngularJS  $controller  service, so that regular AngularJS injections are available as well.    As soon as the widget becomes visible (usually right away, but possibly only after its containing popup/tab/panel/... is shown), the template is retrieved.\n  For  \"angular\" , it is linked to the new scope, and inserted into the page DOM.\n  Other adapters may perform their own value binding magic, or simply use a technology-specific API for passing the template HTML to the widget controller.", 
            "title": "The Role of Widget Adapters"
        }, 
        {
            "location": "/manuals/adapters/#the-integration-technology-api", 
            "text": "Each widget integration technology is implemented as a module with these properties:    The module field  technology  is a string that identifies the widget adapter technology, such as  \"angular\"  or  \"react\" .\n  It is compared to the  integration.technology  field of each widget descriptor to determine which adapter must be used for each widget in the application.    The module method  bootstrap  prepares the adapter for an entire LaxarJS bootstrapping instance.\n  The method receives an object with one array property for  widgets  and one for  controls .\n  Each entry of these arrays has a  descriptor  (the contents of  widget.json  and  control.json  respectively), and a  module  containing the technology-dependent implementation code.\n  As a second argument,  bootstrap  receives selected  services  from the LaxarJS runtime, only some of which may be required to implement an individual adapter:    globalEventBus  is the application-wide  AxEventBus  instance, which is the same as the  axGlobalEventBus  widget service injection,    configuration  is the application-wide  AxConfiguration  instance,    heartbeat  is the application-wide  AxHeartbeat  instance,    log  is the application-wide  AxLog  instance which is the same as the  axGlobalEventBus  widget service injection,    storage  is the application-wide  AxStorage  instance, which is the same as the  axGlobalStorage  widget service injection.      The  bootstrap  method returns an  adapter factory  object which is used to create individual adapter instances for the live widgets.\nThe adapter factory is an object with two methods:    create : the actual factory method to create an adapter for a given widget instance.\n  Each widget instance has its own adapter instance, so that the adapter is free to maintain state information specific to its widget, as may be required by the integration technology.\n  For each widget to be instantiated,  create  is called with an  environment  containing the  widgetName , the containing DOM  anchorElement , the widget  services , and a  provideService  callback.\n  Details  on the environment  are given below.    serviceDecorators  (optional):\n  Usually, services passed to  create  can be used  as-is , without technology-specific changes.\n  However, some technologies may need to modify individual services.\n  For these cases, adapter factories may specify so-called  service decorators  by returning a map of service names to decorator functions from this method. Each decorator will be called with the original injection (such as  axContext ,  axId  etc.) when its injection is requested. Decorators may then decide to return a modified injection or a completely new object.    The API of the widget modules themselves depends on the integration technology, but usually there is a method to instantiate a controller for a given widget instance, and possibly a list of injections and/or a method to set up a view. Here are some examples:    For the  \"plain\"  integration, the widget module must have a method  create  to instantiate the controller, and optionally an array   injections  to specify services required by the widget, such as  \"axEventBus\" .\n  These injections are used as arguments to  create  in the order that they are listed in  injections .    For the  \"angular\"  integration , the widget module simply exports the name of the AngularJS module for the widget, so that controllers can be instantiated by using the AngularJS  $controller  service.    All \"global\" state of the adapter should be encapsulated in the return value of the  bootstrap  method, so that multiple LaxarJS applications may coexist in the same JavaScript environment, each with their own adapter factories, without hurting each other.  Before going into details on API returned by  create , let us have a look at the environment that is provided by the widget loader.", 
            "title": "The Integration Technology API"
        }, 
        {
            "location": "/manuals/adapters/#the-widget-loader-environment", 
            "text": "Before creating an adapter for an individual widget instance, the widget loader collects all required information and bundles it into an  environment  object.\nThe environment has the following properties:    The  widgetName  is the name of the widget to instantiate, exactly as it is written in the  name  property of the widget descriptor.\n  The widget adapter can use this to lookup the widget's descriptor and module among the modules it was bootstrapped with.    The  anchorElement  is a standard  HTMLElement  meant to receive all of the widget's user interface.\n  If the adapter uses a templating system, the instantiated HTML template should be appended to this anchor.\n  Before passing the element to the adapter, the widget loader sets the ID-attribute to the widget ID, which is useful to identify a widget instance within the DOM.\n  The widget loader also adds a CSS class which should be used by the widget's stylesheet to restrict style definitions to the widget.\n  If necessary, widgets or adapters may manipulate DOM outside of their anchor, for example to show an popup-like overlay.\n  If they do, they are responsible for cleanup, and they should  never  modify the DOM of other widgets.    The  services  object contains all services that may be injected into a widget.\n  It offers access to global APIs, but also services specifically adapted for individual widget instances.\n  Since the list is rather long and mostly relevant for widget authors, the services are described in their own  document .    Finally,  provideServices  is a callback function that the widget adapter  must call right before instantiating  the widget controller.\n  It is required for tests using  LaxarJS Mocks  to get access to the final set of widget services, which is dependent on the widget instance as well as on the technology.\n  The services must be passed as an object, where keys are the injection names requested by the widget, and the values are the corresponding service properties.\n  The object may contain additional services that were not actually requested by the widget, but the adapter should take care not to evaluate their properties.\n  For example, if a widget does not actually use  axVisibility , it probably does not wish to create event bus subscriptions for visibility changes, as accessing axVisibility entails.\n  An adapter that does not need to add custom injections can simply pass the  services  object from the environment.\n  For hints on the correct implementation, have a look at the  existing adapter implementations  listed below.\n  Note that because the  view  has not been setup at this point in time, the adapter should not yet manipulate the anchor element, nor make it available to the widget controller.    Created from this environment, the new widget adapter instance prepares additional technology-specific injections as needed, calls the  provideServices  hook, and instantiates the widget controller.\nThen it returns an API that allows for further manipulation by the widget loader.", 
            "title": "The Widget Loader Environment"
        }, 
        {
            "location": "/manuals/adapters/#the-widget-adapter-api", 
            "text": "All widget adapter instances produced by  create  must implement the following three methods, to support creation and destruction of controller and view:    domAttachTo : called with a widget area as the first argument, and an optional (template) HTML string as the second argument.\n  The adapter is supposed to instantiate the template in a manner appropriate for the implementation technology, and to associate it with the widget controller.\n  Depending on the technology, this may happen through binding, for example through the  $scope  injection created by the adapter for  \"angular\" .\n  Alternatively, the adapter may call some technology-specific API of the controller and pass the instantiated widget DOM.\n  The instantiated template should be appended to the anchor element, which in turn should be appended to the widget area element.\n  If there is no template, as is usually the case with activities or sometimes with very simple widgets that only need CSS, the value  null  is passed as the second parameter.\n  In this case, it is up to the widget adapter to decide if the anchor should be added to the DOM anyway, usually based on whether the type is  widget  or  activity .    domDetach : the counterpart to  domAttachTo , this method is used to remove the view from the containing widget area, temporarily or permanently.\n  The widget adapter may tear down the template completely, or keep it \"warm\" for reattachment.\n  LaxarJS may ask widget adapters to detach their DOM and later to attach it again, for example to suspend the widget views within a \"popup\" layer while that layer is closed.\n  If an adapter cannot reliably destroy and rebuild its view, it should do nothing, and simply ignore subsequent calls to  domAttachTo .    destroy : called only once when a widget instance is removed, usually because the user is navigating away from a page.\n  It is not guaranteed that  any  of the other methods has been called at this point in time, but  destroy  is supposed to tidy up everything that has been done so far.\n  The adapter can assume that the other methods will not be called after this.\n  Adapters that do not need to perform cleanup work may omit this property.", 
            "title": "The Widget Adapter API"
        }, 
        {
            "location": "/manuals/adapters/#existing-adapter-implementations", 
            "text": "For practical examples of user-defined widget adapters, have a look at the following adapter implementations.\nThe adapters are sorted by their implementation complexity, from simple to complex.   React adapter  for the  \"react\"  technology  Vue.JS adapter  for the  \"vue\"  technology  AngularJS v1 adapter  for the  \"angular\"  technology  Angular v2 adapter  for the  \"angular2\"  technology   Also, there is the adapter for  \"plain\" , which is part of the LaxarJS Core code base:   plain adapter  for the  \"plain\"  technology", 
            "title": "Existing Adapter Implementations"
        }, 
        {
            "location": "/manuals/adapters/#using-a-custom-adapter-in-a-project", 
            "text": "To use any integration technology other than \"plain\", the corresponding adapter module must be passed to the LaxarJS  create  method.\nThis means that when working on a project that was created by the  LaxarJS Yeoman generator , the  init.js  must load the corresponding module, wrap it in an array and pass that array as the first parameter ( adapters ) to  create .\nFinally, the widgets written for this integration technology must state so in their  widget.json  descriptor, by specifying the adapter  technology  as their own  integration.technology  string.", 
            "title": "Using a Custom Adapter in a Project"
        }, 
        {
            "location": "/manuals/events/", 
            "text": "Events and Publish-Subscribe\n\n\n\u00ab return to the manuals\n\n\nThe key concept that distinguishes LaxarJS applications from other web applications is the \npublish-subscribe\n (or \npub/sub)\n architecture.\nThis approach allows to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nLaxarJS consistently uses the term \nevents\n rather than \nmessages\n, to point out two key aspects of its pub/sub-approach:\n\n\n\n\n\n\nevents convey information about \nwhat happened\n (rather than \nwho is receiver\n),\n\n\n\n\n\n\ndelivery is always \nasynchronous\n (using an \nevent loop\n).\n\n\n\n\n\n\nFor these reasons, you may also think of this pattern as a variation on the \nHollywood principle\n (\"Don't call us, we'll call you\").\n\n\nFor efficient processing, LaxarJS technology adapters tie into the change detection of their respective frameworks.\nFor example, the \n\"angular\"\n adapter triggers an AngularJS \n$digest\n-cycle after events were delivered.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.\n\n\nThe Event Bus\n\n\nAll events are published to and delivered by the \nevent bus\n:\nThe event bus manages \nname-based\n (aka \ntopic-based)\n \nevent subscriptions\n for all interested widgets and activities (the \nsubscribers)\n:\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.\n\n\nEach event has a \nname\n containing a summary of what happened, and a \npayload\n carrying additional information.\n\n\nEvent Names\n\n\nEvent names summarize \nwhat happened\n, possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.\n\n\nAn event name is a string, formed by a sequence of one or more \ntopics\n that are separated by \n.\n (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more \nsub-topics\n separated by \n-\n (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by\n\n\n\n\neither\n an upper case letter followed by a sequence of upper case letters and numbers\n\n\nor\n a lower case letter followed by a sequence of mixed case letters and numbers\n\n\n\n\nThese rules also exist as a formal \ngrammar\n for thorough people.\n\n\nThese are examples for \nvalid\n event names:\n\n\n\n\ndidReplace.myShoppingCart\n\n\ntakeActionRequest.searchArticles\n\n\ndidTakeAction.searchArticles.SUCCESS\n\n\nwillEndLifecycle\n\n\ndidValidate.popup-user2\n\n\n\n\nInvalid\n event names include:\n\n\n\n\nDidReplace.myShoppingCart\n: \ninvalid,\n first topic starts upper case but contains lower case letters\n\n\n.searchArticles.SUCCESS\n: \ninvalid,\n empty topic is not allowed\n\n\ndidUpdate.1up\n: \ninvalid\n, topic must not start with a number\n\n\n\n\nNaming Best Practices and Event Patterns\n\n\nGood event names start with a very general \nverb-based first topic\n, broadly describing \nwhat\n happened.\nThat topic is often followed by a more specific \nobject-based second topic\n, describing \nwhere\n (or \nto what\n) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event \ndidValidate.popup-user2\n informs all interested subscribers, that the second user has been validated by a widget \nwithin a popup\n.\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a \nmodal third topic\n, broadly describing \nhow\n something happened (e.g. to communicate an outcome such as \nSUCCESS\n or \nERROR\n).\n\n\nOf course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.\n\n\nIt is recommended wherever possible for widgets to use one or more of the established \nevent patterns\n:\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few \ncore patterns\n are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project \nLaxarJS Patterns\n.\nEven if not using the LaxarJS Patterns \nlibrary\n, widget authors are very much encouraged to use its \nevent vocabularies\n whenever meaningful.\n\n\nEvent Payload\n\n\nAn event does not only have a name, but also a \npayload\n.\nAny JavaScript object that can be directly represented as \nJSON\n can be used as a payload.\nThis allows for the object to contain instances of \nstring\n, \narray\n, \nnumber\n, \nboolean\n and \nobject\n, including \nnull\n.\nOn the other hand, it excludes\nundefined\n, \nDate\n, \nRegExp\n and custom classes.\n\n\nThe event bus will \ncreate a copy\n of the payload \nfor each subscriber\n that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.\n\n\nHowever, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache), if required.\n\n\n\n\nTwo-Way Communication or the Request/Will/Did Mechanism\n\n\nSometimes a widget wants some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about \nwho\n actually performs the request, but it is interested in \nwhen\n the request has been fully processed by all respondents, and what is the outcome.\n\n\nAs an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a \nCAPTCHA\n.\nAnother widget offering a \n\"Complete Sign-Up\"\n button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective sign-up details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the aforementioned CAPTCHA-using widget.\n\n\nUsing the \nRequest/Will/Did\n mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:\n\n\n\n\n\n\nThe individual widgets are \nconfigured\n on the page to work with a common \nregistrationForm\n resource.\n   On instantiation, the input widgets offering validation subscribe to \nvalidateRequest\n events for this resource.\n\n\n\n\n\n\nWhen the user activates the \nComplete Sign-Up\n button, the registration widget issues a \nvalidateRequest.registrationForm\n event, indicating that\n\n\n\n\na validation has been requested \n(what happened)\n and\n\n\nit concerns the resource \nregistrationForm\n \n(where\n it happened).\n\n\n\n\n\n\n\n\nThe registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.\n\n\n\n\n\n\nDuring delivery, the input widgets supporting validation receive the request and publish a \nwillValidate.registrationForm\n event to indicate that\n\n\n\n\na validation has been initiated \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n.\n\n\n\n\n\n\n\n\nEach widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either \ndidValidate.registrationForm.SUCCESS\n or \ndidValidate.registrationForm.ERROR\n conveying that\n\n\n\n\na validation has been performed \n(what)\n and\n\n\nthat it concerns the \nregistrationForm\n resource \n(where)\n and\n\n\nthe way the validation turned out \n(how)\n.\n\n\n\n\n\n\n\n\nOnce all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the \nsign-up\n REST request may be performed.\n\n\n\n\n\n\nThis mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its \n\"didValidate\"\n events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.\n\n\nValidation and other patterns are described in the following section.\n\n\n\n\nPattern Reference\n\n\nA few event patterns are supported directly by LaxarJS, while others are described in the \nLaxarJS Patterns\n library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.\n\n\n\n\nCore Patterns\n\n\nThe core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.\n\n\nPage Lifecycle\n\n\nAfter all widget controllers have been instantiated, the runtime publishes a \nbeginLifecycleRequest\n event.\nWidgets that need to publish events on page load should do so \nafter\n receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.\n\n\nBefore \nnavigating\n away from a page, the runtime publishes the \nendLifecycleRequest\n event.\nWidgets that need to save state to a service should respond with a \nwillEndLifecycle\n event, perform their housekeeping and publish an \ndidEndLifecycle\n when done.\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbeginLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that publishing of events is safe now\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nthe lifecycle ID (currently, this is always \n\"default\"\n)\n\n\n\n\n\n\nwillBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer page rendering (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidBeginLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page rendering may commence (not recommended)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nendLifecycleRequest.{lifecycleId}\n\n\n\n\npublished by the runtime to tell widgets that the page is about to be destroyed\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\nwillEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities to defer tear down of the page (if necessary)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\ndidEndLifecycle.{lifecycleId}\n\n\n\n\npublished by widgets and activities when page tear down may commence (after deferring it)\n\n\n\n\n\n\n\n\nlifecycleId\n\n\nsee above\n\n\n\n\n\n\n\n\n\n\nNavigation\n\n\nWidgets and activities may initiate navigation using a \nnavigateRequest.{target}\n event, substituting an actual navigation target instead of the placeholder \n{target}\n.\nThe event is interpreted by the LaxarJS runtime as follows:\n\n\n\n\nif \ntarget\n is \n\"_self\"\n, the runtime will simply propagate its place-parameters by publishing a \ndidNavigate\n event right away\n\n\nif \ntarget\n is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place\n\n\notherwise, if \ntarget\n is a place within the flow definition, the runtime will initiate navigation to that place\n\n\notherwise, nothing will happen.\n\n\n\n\nWhen \ninitiating navigation\n, the LaxarJS runtime will:\n\n\n\n\nextract any place parameters from the event payload of the request event\n\n\npublish a \nwillNavigate.{target}\n event with the corresponding target and parameters\n\n\npublish an \nendLifecycle\n event and wait for any respondents\n\n\nperform navigation by destroying the current page and loading the page associated with the new place\n\n\npublish a \nbeginLifecycle\n event and wait for any respondents\n\n\npublish a \ndidNavigate.{target}\n event, with the corresponding target and parameters as well as the resolved place\n\n\n\n\nHere is the summary of navigation events:\n\n\n\n\n\n\n\n\nEvent name\n\n\nPayload Attribute\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnavigateRequest.{target}\n\n\n\n\npublished by widgets and activities to indicate that a navigation has been requested\n\n\n\n\n\n\n\n\ntarget\n\n\nthe navigation target (used in the payload \nas well as\n in the event name)\n\n\n\n\n\n\n\n\ndata\n\n\na map from place parameter names to parameter values\n\n\n\n\n\n\nwillNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has started\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\ndidNavigate.{target}\n\n\n\n\npublished by the runtime to indicate that navigation has finished\n\n\n\n\n\n\n\n\ntarget\n, \ndata\n\n\nsee above\n\n\n\n\n\n\n\n\nplace\n\n\nthe actual place that was navigated to, now the current place\n\n\n\n\n\n\n\n\nMore information on navigation is available in the \n\"Flow and Places\" manual\n.\n\n\nLocales and i18n\n\n\nEvents related to locales are described in the \n\"i18n\" manual\n.\n\n\nMore Patterns\n\n\nThe patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the \nLaxarJS Patterns documentation\n.\n\n\nEvent Reference\n\n\nPossibly the most important API provided by LaxarJS to widgets is the event bus.\nThis section lists the exact details of using the event bus, and explains how events should be named.\n\n\nThe Event Bus API\n\n\nThe event bus is injected into widget as \naxEventBus\n.\nIt is also available as the \neventBus\n property of the \naxContext\n injection (or \n$scope\n in AngularJS).\nIt has essential methods that allow to implement all patterns mentioned above.\n\n\n\n\nsubscribe( eventPattern, callback [, options] )\n\n\n\n\nCreates a subscription on the event bus.\n\n\n- The `eventPattern` is a prefix for events to subscribe to:\nEvents that start with the given sequence of (sub-)topics will be handled by this subscription.\nFor example, a subscription to the pattern `didSave` will be triggered for the event `didSave.myDocument` as well as for the event `didSave.preferences-main`.\nMost of the time, widgets are only interested in very specific events related to resources they work with or actions they handle, so they use patterns such as `didReplace.someResource` where `someResource` is given by the page configuration.\n\n- The `callback` is the function which will be called to process any matching events.\nEvent subscription callbacks receive two arguments:\n\n    + The `event` is this subscriber\ns copy of the payload, as published by the sender of the event.\n    + The `meta` object contains additional information about the event, in particular the `sender` (identified by a string) and the `name` (under which the event was published).\n\n  - The `options` are usually not required for widgets:\n Using `options.subscriberId`, the subscriber can identify itself to the event bus.\n The LaxarJS runtime decorates each widget\ns event bus so that this option is already set correctly.\n\n\n\n\n\nThe method \nsubscribe\n does not return a value.\n\n\n\n\npublish( eventName, payload [, options ] )\n\n\n\n\nPublishes an event to all interested subscribers.\n  Delivery is \nasynchronous\n: control is returned to the caller immediately, and delivery of all scheduled events will be performed afterwards in batch.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.\n\n\n- The `eventName` is used to identify matching subscribers.\nIt is matched against the `eventPattern` of any subscriptions.\n\n- The `payload` will be delivered as the `event` parameter to any matching subscriber callbacks.\nIt is copied right away, making it safe to modify afterwards.\n\n- The `options` are usually not required for widgets:\nBy setting `options.deliverToSender` to `false`, widgets can ignore their own events, which can sometimes be necessary to avoid loops.\n\n\n\n\n\nThe method \npublish\n returns a promise that is resolved after the event has been processed by all matching subscribers.\n\n\n\n\npublishAndGatherReplies( requestEventName, payload [, options ] )\n\n\n\n\nPublishes a \nrequest event\n, gathers all \nwill\n-responses during delivery and then waits for all outstanding \ndid\n-responses.\n  The parameters \npayload\n and \noptions\n are equivalent to the regular \npublish\n-method.\n  Returns a promise that is resolved when all \ndid\n-responses have been received.\n\n\nThis information should help to get started with the event bus and intentionally omits a lot of details.\nFor full information, refer to the \nEventBus API documentation\n.\n\n\n\n\nEvent Name Grammar\n\n\nThis is the formal grammar for event names, in \nEBNF\n:\n\n\nevent-name\n \n::\n=\n \ntopic-id\n \n[\n \n.\n \ntopic-id\n \n]\n*\n\n\ntopic-id\n \n::=\n \nsub-topic-id\n \n[\n \n-\n \nsub-topic-id\n \n]\n*\n\n\nsub-topic-id\n \n::=\n \n[\na-z\n][\n+\na-zA-Z0-9\n]\n*\n \n|\n \n[\nA-Z\n][\n+\nA-Z0-9\n]\n*", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#events-and-publish-subscribe", 
            "text": "\u00ab return to the manuals  The key concept that distinguishes LaxarJS applications from other web applications is the  publish-subscribe  (or  pub/sub)  architecture.\nThis approach allows to isolate building blocks such as widgets and activities by moving the coupling from implementation (no module imports, no service contracts) to configuration (of event topics).  Preliminary readings:   LaxarJS Core Concepts   LaxarJS consistently uses the term  events  rather than  messages , to point out two key aspects of its pub/sub-approach:    events convey information about  what happened  (rather than  who is receiver ),    delivery is always  asynchronous  (using an  event loop ).    For these reasons, you may also think of this pattern as a variation on the  Hollywood principle  (\"Don't call us, we'll call you\").  For efficient processing, LaxarJS technology adapters tie into the change detection of their respective frameworks.\nFor example, the  \"angular\"  adapter triggers an AngularJS  $digest -cycle after events were delivered.\nThis allows the web browser to batch event-handling with other operations that modify screen contents.", 
            "title": "Events and Publish-Subscribe"
        }, 
        {
            "location": "/manuals/events/#the-event-bus", 
            "text": "All events are published to and delivered by the  event bus :\nThe event bus manages  name-based  (aka  topic-based)   event subscriptions  for all interested widgets and activities (the  subscribers) :\nSubscribers specify an event name pattern that tells the event bus which kinds of \"thing that happened\" they are interested in.\nWhen an event is published to the event bus, it is kept in an event queue, to be delivered asynchronously.\nDuring event delivery, each event name is matched against each subscription, and each matching event is delivered by running the associated callback.  Each event has a  name  containing a summary of what happened, and a  payload  carrying additional information.", 
            "title": "The Event Bus"
        }, 
        {
            "location": "/manuals/events/#event-names", 
            "text": "Event names summarize  what happened , possibly with some additional context.\nThey follow a hierarchical structure that is used to pattern-match against subscriptions during delivery.  An event name is a string, formed by a sequence of one or more  topics  that are separated by  .  (the full stop, U+002E).\nEach topic is a string, made up from a sequence of one or more  sub-topics  separated by  -  (the hyphen-minus, U+00AF).\nSub-Topics are strings, formed by   either  an upper case letter followed by a sequence of upper case letters and numbers  or  a lower case letter followed by a sequence of mixed case letters and numbers   These rules also exist as a formal  grammar  for thorough people.  These are examples for  valid  event names:   didReplace.myShoppingCart  takeActionRequest.searchArticles  didTakeAction.searchArticles.SUCCESS  willEndLifecycle  didValidate.popup-user2   Invalid  event names include:   DidReplace.myShoppingCart :  invalid,  first topic starts upper case but contains lower case letters  .searchArticles.SUCCESS :  invalid,  empty topic is not allowed  didUpdate.1up :  invalid , topic must not start with a number", 
            "title": "Event Names"
        }, 
        {
            "location": "/manuals/events/#naming-best-practices-and-event-patterns", 
            "text": "Good event names start with a very general  verb-based first topic , broadly describing  what  happened.\nThat topic is often followed by a more specific  object-based second topic , describing  where  (or  to what ) something happened.\nSometimes, this second topic is broken down into sub-topics that allow to \"zoom in\" on the event details.\nFor example, the event  didValidate.popup-user2  informs all interested subscribers, that the second user has been validated by a widget  within a popup .\nThis information can now be used to show validation messages at the appropriate location.\nSometimes there is a  modal third topic , broadly describing  how  something happened (e.g. to communicate an outcome such as  SUCCESS  or  ERROR ).  Of course, nothing prevents senders to break these rules and use any structure for their event names as long as they conform to the grammar.\nBut for best interoperability between widgets and activities, not only should the general structure of event names be observed.  It is recommended wherever possible for widgets to use one or more of the established  event patterns :\nThese patterns consist of event vocabularies and minimal associated semantics that have been identified during the development of LaxarJS.\nA few  core patterns  are baked right into the LaxarJS runtime, and these are listed below.\nOther useful patterns are described in the separate project  LaxarJS Patterns .\nEven if not using the LaxarJS Patterns  library , widget authors are very much encouraged to use its  event vocabularies  whenever meaningful.", 
            "title": "Naming Best Practices and Event Patterns"
        }, 
        {
            "location": "/manuals/events/#event-payload", 
            "text": "An event does not only have a name, but also a  payload .\nAny JavaScript object that can be directly represented as  JSON  can be used as a payload.\nThis allows for the object to contain instances of  string ,  array ,  number ,  boolean  and  object , including  null .\nOn the other hand, it excludes undefined ,  Date ,  RegExp  and custom classes.  The event bus will  create a copy  of the payload  for each subscriber  that gets the event delivered.\nThis improves decoupling and robustness, because events are \"fire and forget\":\nA widget may publish some resource through an event and afterwards immediately modify its contents, but all subscribers are guaranteed to receive the original event.  However, this also means that you should only publish resources that are at most ~100 kilobyte in size.\nFor larger resources, it is recommended to only transfer a URL so that interested widgets may receive the content from a server (or the browser cache), if required.", 
            "title": "Event Payload"
        }, 
        {
            "location": "/manuals/events/#two-way-communication-or-the-requestwilldid-mechanism", 
            "text": "Sometimes a widget wants some other widget or activity on the page to perform some action.\nThis might be a longer running action such as a search or some server side validation.\nThe requesting widget does not care about  who  actually performs the request, but it is interested in  when  the request has been fully processed by all respondents, and what is the outcome.  As an example, consider a multi-part user sign-up process, where each of several widgets allows the user to enter and validate some of the information such as email address, payment information or a  CAPTCHA .\nAnother widget offering a  \"Complete Sign-Up\"  button would be responsible for the overall process of submitting the registration resource to a REST service and navigating to a different page.\nBefore hitting the registration service, this widget would ask all input widgets to validate their respective sign-up details in order to provide immediate feedback to the user.\nSome of the widgets might have to query their own validation services though, such as the aforementioned CAPTCHA-using widget.  Using the  Request/Will/Did  mechanism, such functionality can be achieved without the registration widget having to know any of the participant widgets:    The individual widgets are  configured  on the page to work with a common  registrationForm  resource.\n   On instantiation, the input widgets offering validation subscribe to  validateRequest  events for this resource.    When the user activates the  Complete Sign-Up  button, the registration widget issues a  validateRequest.registrationForm  event, indicating that   a validation has been requested  (what happened)  and  it concerns the resource  registrationForm   (where  it happened).     The registration widget may now disable its button and start showing an activity indicator to help the user recognize that an action is in progress.    During delivery, the input widgets supporting validation receive the request and publish a  willValidate.registrationForm  event to indicate that   a validation has been initiated  (what)  and  that it concerns the  registrationForm  resource  (where) .     Each widget will either call its registration service to respond asynchronously, or publish a response directly if it can validate locally.\n   The response is either  didValidate.registrationForm.SUCCESS  or  didValidate.registrationForm.ERROR  conveying that   a validation has been performed  (what)  and  that it concerns the  registrationForm  resource  (where)  and  the way the validation turned out  (how) .     Once all responses have been collected and there were no validation errors, the registration form will be notified (through a promise) and the  sign-up  REST request may be performed.    This mechanism allows any of the widgets on the page may be removed or replaced without any of the other widgets having to know.\nNew widgets may be added at any time, and will work as long as they support the validation pattern.\nFor example, the message display widget could be added to gather and display validation messages to the user, simply by hooking it up to the same resource and processing its  \"didValidate\"  events.\nEven if some widgets do not support the validation pattern, they can still be used, only that their validation would have to be handled by the server upon submission of the registration form.  Validation and other patterns are described in the following section.", 
            "title": "Two-Way Communication or the Request/Will/Did Mechanism"
        }, 
        {
            "location": "/manuals/events/#pattern-reference", 
            "text": "A few event patterns are supported directly by LaxarJS, while others are described in the  LaxarJS Patterns  library.\nHave a good look at all of them before coming up with your own patterns, in order to maximize the synergy of your widgets, especially when aiming for reuse.", 
            "title": "Pattern Reference"
        }, 
        {
            "location": "/manuals/events/#core-patterns", 
            "text": "The core event patterns allow widgets to interact with the LaxarJS runtime.\nThey are related to initialization of pages and navigation between them.", 
            "title": "Core Patterns"
        }, 
        {
            "location": "/manuals/events/#page-lifecycle", 
            "text": "After all widget controllers have been instantiated, the runtime publishes a  beginLifecycleRequest  event.\nWidgets that need to publish events on page load should do so  after  receiving this event, ensuring that all receivers have been set up when their events are delivered.\nA will/did-response may be used by widgets to defer rendering of the page until they have been initialized, which is usually not recommended.  Before  navigating  away from a page, the runtime publishes the  endLifecycleRequest  event.\nWidgets that need to save state to a service should respond with a  willEndLifecycle  event, perform their housekeeping and publish an  didEndLifecycle  when done.     Event name  Payload Attribute  Description      beginLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that publishing of events is safe now     lifecycleId  the lifecycle ID (currently, this is always  \"default\" )    willBeginLifecycle.{lifecycleId}   published by widgets and activities to defer page rendering (not recommended)     lifecycleId  see above    didBeginLifecycle.{lifecycleId}   published by widgets and activities when page rendering may commence (not recommended)     lifecycleId  see above    endLifecycleRequest.{lifecycleId}   published by the runtime to tell widgets that the page is about to be destroyed     lifecycleId  see above    willEndLifecycle.{lifecycleId}   published by widgets and activities to defer tear down of the page (if necessary)     lifecycleId  see above    didEndLifecycle.{lifecycleId}   published by widgets and activities when page tear down may commence (after deferring it)     lifecycleId  see above", 
            "title": "Page Lifecycle"
        }, 
        {
            "location": "/manuals/events/#navigation", 
            "text": "Widgets and activities may initiate navigation using a  navigateRequest.{target}  event, substituting an actual navigation target instead of the placeholder  {target} .\nThe event is interpreted by the LaxarJS runtime as follows:   if  target  is  \"_self\" , the runtime will simply propagate its place-parameters by publishing a  didNavigate  event right away  if  target  is one of the targets configured for the current place (in the flow definition), the runtime will initiate navigation to the corresponding place  otherwise, if  target  is a place within the flow definition, the runtime will initiate navigation to that place  otherwise, nothing will happen.   When  initiating navigation , the LaxarJS runtime will:   extract any place parameters from the event payload of the request event  publish a  willNavigate.{target}  event with the corresponding target and parameters  publish an  endLifecycle  event and wait for any respondents  perform navigation by destroying the current page and loading the page associated with the new place  publish a  beginLifecycle  event and wait for any respondents  publish a  didNavigate.{target}  event, with the corresponding target and parameters as well as the resolved place   Here is the summary of navigation events:     Event name  Payload Attribute  Description      navigateRequest.{target}   published by widgets and activities to indicate that a navigation has been requested     target  the navigation target (used in the payload  as well as  in the event name)     data  a map from place parameter names to parameter values    willNavigate.{target}   published by the runtime to indicate that navigation has started     target ,  data  see above    didNavigate.{target}   published by the runtime to indicate that navigation has finished     target ,  data  see above     place  the actual place that was navigated to, now the current place     More information on navigation is available in the  \"Flow and Places\" manual .", 
            "title": "Navigation"
        }, 
        {
            "location": "/manuals/events/#locales-and-i18n", 
            "text": "Events related to locales are described in the  \"i18n\" manual .", 
            "title": "Locales and i18n"
        }, 
        {
            "location": "/manuals/events/#more-patterns", 
            "text": "The patterns described so far are used mainly for widgets to interact with the LaxarJS runtime.\nFor application patterns that help widgets to interact with each other, refer to the  LaxarJS Patterns documentation .", 
            "title": "More Patterns"
        }, 
        {
            "location": "/manuals/events/#event-reference", 
            "text": "Possibly the most important API provided by LaxarJS to widgets is the event bus.\nThis section lists the exact details of using the event bus, and explains how events should be named.", 
            "title": "Event Reference"
        }, 
        {
            "location": "/manuals/events/#the-event-bus-api", 
            "text": "The event bus is injected into widget as  axEventBus .\nIt is also available as the  eventBus  property of the  axContext  injection (or  $scope  in AngularJS).\nIt has essential methods that allow to implement all patterns mentioned above.   subscribe( eventPattern, callback [, options] )   Creates a subscription on the event bus.  - The `eventPattern` is a prefix for events to subscribe to:\nEvents that start with the given sequence of (sub-)topics will be handled by this subscription.\nFor example, a subscription to the pattern `didSave` will be triggered for the event `didSave.myDocument` as well as for the event `didSave.preferences-main`.\nMost of the time, widgets are only interested in very specific events related to resources they work with or actions they handle, so they use patterns such as `didReplace.someResource` where `someResource` is given by the page configuration.\n\n- The `callback` is the function which will be called to process any matching events.\nEvent subscription callbacks receive two arguments:\n\n    + The `event` is this subscriber s copy of the payload, as published by the sender of the event.\n    + The `meta` object contains additional information about the event, in particular the `sender` (identified by a string) and the `name` (under which the event was published).\n\n  - The `options` are usually not required for widgets:\n Using `options.subscriberId`, the subscriber can identify itself to the event bus.\n The LaxarJS runtime decorates each widget s event bus so that this option is already set correctly.  The method  subscribe  does not return a value.   publish( eventName, payload [, options ] )   Publishes an event to all interested subscribers.\n  Delivery is  asynchronous : control is returned to the caller immediately, and delivery of all scheduled events will be performed afterwards in batch.\n  The event payload is cloned immediately so that the caller is free to modify it right after publishing.\n  Returns a promise that is resolved after the event has been delivered to all subscribers.  - The `eventName` is used to identify matching subscribers.\nIt is matched against the `eventPattern` of any subscriptions.\n\n- The `payload` will be delivered as the `event` parameter to any matching subscriber callbacks.\nIt is copied right away, making it safe to modify afterwards.\n\n- The `options` are usually not required for widgets:\nBy setting `options.deliverToSender` to `false`, widgets can ignore their own events, which can sometimes be necessary to avoid loops.  The method  publish  returns a promise that is resolved after the event has been processed by all matching subscribers.   publishAndGatherReplies( requestEventName, payload [, options ] )   Publishes a  request event , gathers all  will -responses during delivery and then waits for all outstanding  did -responses.\n  The parameters  payload  and  options  are equivalent to the regular  publish -method.\n  Returns a promise that is resolved when all  did -responses have been received.  This information should help to get started with the event bus and intentionally omits a lot of details.\nFor full information, refer to the  EventBus API documentation .", 
            "title": "The Event Bus API"
        }, 
        {
            "location": "/manuals/events/#event-name-grammar", 
            "text": "This is the formal grammar for event names, in  EBNF :  event-name   :: =   topic-id   [   .   topic-id   ] *  topic-id   ::=   sub-topic-id   [   -   sub-topic-id   ] *  sub-topic-id   ::=   [ a-z ][ + a-zA-Z0-9 ] *   |   [ A-Z ][ + A-Z0-9 ] *", 
            "title": "Event Name Grammar"
        }, 
        {
            "location": "/manuals/flow_and_places/", 
            "text": "Flow and Places\n\n\n\u00ab return to the manuals\n\n\nEvery application that has more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a \nflow\n that determines which page is rendered based on a given URL, and how other pages are \nrelated\n to the current location.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nConfiguration\n\n\nWriting Pages\n\n\n\n\nThe Flow\n\n\nThe flow is the top-level artifact that ties together all parts of a LaxarJS application:\nit defines what pages are reachable, which in turn determines the set of widgets and controls that are loaded as part of an application.\nBefore bootstrapping your application, you must specify \nwhich\n flow to use in your application.\nThe default flow configured by the Yeoman generator is called \n\"main\"\n.\nAdding more flows allows you to create several \"perspectives\" onto your application, automatically picking pages and widgets from your project as needed.\nFor example, you could have a flow to present to new visitors, a second flow for registered users, and a third flow to implement a back-office tool.\n\n\nEach flow is specified using a \nflow definition file\n in JSON format, and it primarily consists of a set of named \nplaces\n.\n\n\nPlaces\n\n\nEach \nplace\n is either associated with a specific \npage\n to be rendered when entering that place, or it is a redirect to another place.\n\n\nTo determine which place is active when navigating to an application, the browser URL is matched against each place's \npatterns\n until a match is found.\nThis process is called \nrouting\n.\nThese patterns are also used to \ngenerate URLs\n to create link between pages, and to update the browser URL when performing event-based navigation.\n\n\nFor the actual pattern matching and routing, LaxarJS uses with the micro-library \nNavigo\n and its routing pattern syntax, which should be familiar to users of frameworks such as AngularJS or React and their routing solutions.\n\n\nLet us start with an example for a simple flow definition file that we call \nmain.json\n:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nindex\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/\n \n],\n\n         \nredirectTo\n:\n \ndetails\n\n      \n},\n\n\n      \ndetails\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/details/:item\n,\n \n/details\n \n],\n\n         \npage\n:\n \nfirst_page\n\n      \n},\n\n\n      \nteam\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/team\n \n],\n\n         \nredirectToPath\n:\n \n/details/team\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nA flow definition is always a JSON object with the top-level property \nplaces\n, which in turn is a map.\nEach entry of that map consists of the place's \nID\n as key and a \nplace definition\n as value.\n\n\nThe ID is a non-empty alphanumeric string that identifies a place within an application.\nIt is used to reference places when creating links or to perform event-based navigation.\n\n\nPlace Patterns\n\n\nEach place definition has a non-empty list of URL-patterns, specified under the key \npatterns\n.\nIn the example, the place \nindex\n has a single pattern (\n/\n), while the place \ndetails\n has two patterns: \n/details/:item\n with the named parameter \nitem\n filled in by the router, and \n/details\n which will not set the \nitem\n parameter when navigated to.\nIf no patterns are specified, a place with ID \n$some-id\n will automatically be assigned the patterns list \n[ \"/$some-id\" ]\n, which will only match a slash followed by the exact place ID.\n\n\nThe syntax for URL patterns ultimately depends on what the router (Navigo) deems valid.\nIt is \nstrongly recommended\n to always start patterns with a \nleading slash\n, as relative paths will quickly break down in most setups.\nAlso note that each list of patterns should start with a \nreversible\n pattern, as explained in the next section.\nNote that regular-expression patterns, while in principle supported by Navigo, are currently not available for use in a LaxarJS flow definition, both because they are not reversible, and because there is no JSON notation for them.\n\n\nApart from its patterns, a place has either a \npage\n entry, a \nredirectTo\n or a \nredirectToPath\n entry.\nThe first determines that the corresponding page will be looked up relative to the pages directory of your application and instantiated when entering the place, while the latter makes it a redirect to another place specified by ID or full path, respectively.\nIn the example, the place \nindex\n specifies a redirect to the place \ndetails\n, while the place \nteam\n specifies a direct redirect to the path \n/details/team\n.\nYou can use redirects to support legacy URLs in your application and to forward them to actual pages, or provide shortcuts for otherwise complex paths.\n\n\nApplication may also enable \nquery-strings\n using the configuration key \nrouter.query.enabled\n.\nQuery parameters are never used for routing, but carry \noptional parameter values\n that may be useful to widgets on a page.\nBecause query parameters are optional, each place may specify an object containing \ndefaultParameters\n, that are published with navigation events if no matching query parameter was passed.\nNote that regular place parameters always override query parameters of the same name.\n\n\nReverse Routing\n\n\nThe declarative routing configuration used by LaxarJS is a bit more restrictive than free-form programmatic routing.\nOn the other hand, this notation allows applications to automatically generate URLs to any place, just from an ID and possibly a set of named parameters.\nThe widgets and activities within your application do not need to know about the URL patterns associated with their respective place, which makes them portable across pages and even application.\n\n\nTo make use of reverse routing, it is important that the first pattern for each place is \nreversible\n.\nSpecifically, any wildcard parts of the URL pattern must be \nnamed\n, so that they can be substituted for the actual parameter names by the router.\nThe pattern \n*\n that matches any path is not reversible, for example.\nAlso, Navigo regular expression patterns are not reversible, because JavaScript does not support named capturing groups in regular expressions.\nHowever, their syntax is not supported by the JSON flow definition anyway, so applications cannot use them by mistake.\nThe following pattern styles are known to work well with reverse routing:\n\n\n\n\nverbatim: \n/some/path\n\n\nnamed parameter segments \n/some/:param/:other-param\n\n\n\n\nIf query parameters are enabled, any additional parameters that are not part of the pattern to reverse will be encoded into query parameters, except if the parameter value to be encoded equals the default value of the target place.\n\n\nInitiating navigation\n\n\nTo initiate navigation, widgets have two options:\n\n\nWidgets may render regular HTML links and use the method \nconstructAbsoluteUrl\n of the \naxFlowService\n to calculate the URLs of each link based on place ID and parameters.\n\n\nAlternatively, widgets may initiate navigation by issuing a \nnavigateRequest\n event expressing the desired new location within the application and providing values for place parameters.\nHow event-based navigation works in detail can be read in the separate manual covering \nevents\n.\n\n\nIn \nHTTP/REST\n) terms, event-based navigation is used to express POST-like semantics, where an URL change is associated with an effectful user action (save, sign up, purchase, etc.), while links should always follow GET semantics so that the user can safely switch back and forth between URLs.\n\n\nEven better, neither widgets nor pages need to deal with specific place IDs, and can instead use semantic \ntargets\n to initiate navigation or to construct links, as explained in the next section.\n\n\nTargets\n\n\nUsing both events and links, it is possible to always navigate directly from place to place, simply by specifying the ID of the target place.\nHowever, this approach causes a tight coupling between the widget triggering navigation on one hand and the flow definition on the other hand, hurting reuse.\nEven more, this would smear knowledge about the navigational structure throughout the application,  making it more difficult to later change this structure.\n\n\nInstead, a widget or a page (via the feature configuration of its widgets) should specify semantic navigation \ntargets\n such as \n\"next\", \"previous\", \"details\"\n, which are then resolved based on the current place and its definition in the application flow.\nThe idea is roughly comparable to \nrelations\n in REST style architectures.\nIn LaxarJS, each place can define its own mapping from semantic target identifiers to the IDs of other places within the application flow.\n\n\nAn example:\n\n\n{\n\n   \nplaces\n:\n \n{\n\n      \nintroduction\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/introduction/:userId\n \n],\n\n         \npage\n:\n \nintroduction\n,\n\n         \ntargets\n:\n \n{\n\n            \nnext\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \ninterests\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/interests/:userId\n \n],\n\n         \npage\n:\n \ninterests\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \nintroduction\n,\n\n            \nnext\n:\n \nprofession\n,\n\n            \nhelp\n:\n \ninterestsHelp\n\n         \n}\n\n      \n},\n\n\n      \nprofession\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/profession/:userId\n \n],\n\n         \npage\n:\n \nprofession\n,\n\n         \ntargets\n:\n \n{\n\n            \nprevious\n:\n \ninterests\n,\n\n            \nhelp\n:\n \nprofessionHelp\n\n         \n}\n\n      \n},\n\n\n      \ninterestsHelp\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/interests-help/:userId\n \n],\n\n         \npage\n:\n \ninterests_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \ninterests\n\n         \n}\n\n      \n},\n\n\n      \nprofessionHelp\n:\n \n{\n\n         \npatterns\n:\n \n[\n \n/profession-help/:userId\n \n],\n\n         \npage\n:\n \nprofession_help\n,\n\n         \ntargets\n:\n \n{\n\n            \nback\n:\n \nprofession\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis flow is typical for a wizard-like application, as it allows forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called \nintroduction\n, which simply displays a page and just lets the user navigate to the \nnext\n target, which would be resolved to the place \ninterests\n.\nHere a page is displayed where the user can input his interests, such as hobbies or taste in music.\nAs we are in the middle of the wizard now, a \nprevious\n target is reachable in addition to the \nnext\n and \nhelp\n targets.\nUnsurprisingly the \nprevious\n target references the first place, \nintroduction\n.\nThe \nnext\n target instead leads us to another new place with identifier \nprofession\n.\nThe \nprofession\n place may only lead us back to the \ninterests\n place via the \nprevious\n target.\n\n\nLet us assume that our pages contain tricky input components, on which we would like to assist the user.\nThis is where the \nhelp\n target comes into play.\nBoth the \ninterests\n and the \nprofession\n page use this target, but the places behind these targets are different depending on the source page.\nThis allows you to provide contextual semantics to standard navigation controls, such as a row of back/forward/help buttons.\nReturning from the help pages is familiar, via the \nback\n target leading to the respective places.\n\n\nUsing the mechanisms introduced here, most navigation scenarios as well as integration into external applications should be possible.\nTo find out how to construct links between pages, refer to the \naxFlowService API\n.\nTo learn how to trigger event-based navigation from within widgets and activities, you should go on reading the \nevents documentation\n and learn about the \nnavigateRequest\n and \ndidNavigate\n events.", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#flow-and-places", 
            "text": "\u00ab return to the manuals  Every application that has more than one page needs a concept for navigating between these pages.\nIn LaxarJS this is achieved by a  flow  that determines which page is rendered based on a given URL, and how other pages are  related  to the current location.  Preliminary readings:   LaxarJS Core Concepts  Configuration  Writing Pages", 
            "title": "Flow and Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#the-flow", 
            "text": "The flow is the top-level artifact that ties together all parts of a LaxarJS application:\nit defines what pages are reachable, which in turn determines the set of widgets and controls that are loaded as part of an application.\nBefore bootstrapping your application, you must specify  which  flow to use in your application.\nThe default flow configured by the Yeoman generator is called  \"main\" .\nAdding more flows allows you to create several \"perspectives\" onto your application, automatically picking pages and widgets from your project as needed.\nFor example, you could have a flow to present to new visitors, a second flow for registered users, and a third flow to implement a back-office tool.  Each flow is specified using a  flow definition file  in JSON format, and it primarily consists of a set of named  places .", 
            "title": "The Flow"
        }, 
        {
            "location": "/manuals/flow_and_places/#places", 
            "text": "Each  place  is either associated with a specific  page  to be rendered when entering that place, or it is a redirect to another place.  To determine which place is active when navigating to an application, the browser URL is matched against each place's  patterns  until a match is found.\nThis process is called  routing .\nThese patterns are also used to  generate URLs  to create link between pages, and to update the browser URL when performing event-based navigation.  For the actual pattern matching and routing, LaxarJS uses with the micro-library  Navigo  and its routing pattern syntax, which should be familiar to users of frameworks such as AngularJS or React and their routing solutions.  Let us start with an example for a simple flow definition file that we call  main.json :  { \n    places :   { \n       index :   { \n          patterns :   [   /   ], \n          redirectTo :   details \n       }, \n\n       details :   { \n          patterns :   [   /details/:item ,   /details   ], \n          page :   first_page \n       }, \n\n       team :   { \n          patterns :   [   /team   ], \n          redirectToPath :   /details/team \n       } \n    }  }   A flow definition is always a JSON object with the top-level property  places , which in turn is a map.\nEach entry of that map consists of the place's  ID  as key and a  place definition  as value.  The ID is a non-empty alphanumeric string that identifies a place within an application.\nIt is used to reference places when creating links or to perform event-based navigation.", 
            "title": "Places"
        }, 
        {
            "location": "/manuals/flow_and_places/#place-patterns", 
            "text": "Each place definition has a non-empty list of URL-patterns, specified under the key  patterns .\nIn the example, the place  index  has a single pattern ( / ), while the place  details  has two patterns:  /details/:item  with the named parameter  item  filled in by the router, and  /details  which will not set the  item  parameter when navigated to.\nIf no patterns are specified, a place with ID  $some-id  will automatically be assigned the patterns list  [ \"/$some-id\" ] , which will only match a slash followed by the exact place ID.  The syntax for URL patterns ultimately depends on what the router (Navigo) deems valid.\nIt is  strongly recommended  to always start patterns with a  leading slash , as relative paths will quickly break down in most setups.\nAlso note that each list of patterns should start with a  reversible  pattern, as explained in the next section.\nNote that regular-expression patterns, while in principle supported by Navigo, are currently not available for use in a LaxarJS flow definition, both because they are not reversible, and because there is no JSON notation for them.  Apart from its patterns, a place has either a  page  entry, a  redirectTo  or a  redirectToPath  entry.\nThe first determines that the corresponding page will be looked up relative to the pages directory of your application and instantiated when entering the place, while the latter makes it a redirect to another place specified by ID or full path, respectively.\nIn the example, the place  index  specifies a redirect to the place  details , while the place  team  specifies a direct redirect to the path  /details/team .\nYou can use redirects to support legacy URLs in your application and to forward them to actual pages, or provide shortcuts for otherwise complex paths.  Application may also enable  query-strings  using the configuration key  router.query.enabled .\nQuery parameters are never used for routing, but carry  optional parameter values  that may be useful to widgets on a page.\nBecause query parameters are optional, each place may specify an object containing  defaultParameters , that are published with navigation events if no matching query parameter was passed.\nNote that regular place parameters always override query parameters of the same name.", 
            "title": "Place Patterns"
        }, 
        {
            "location": "/manuals/flow_and_places/#reverse-routing", 
            "text": "The declarative routing configuration used by LaxarJS is a bit more restrictive than free-form programmatic routing.\nOn the other hand, this notation allows applications to automatically generate URLs to any place, just from an ID and possibly a set of named parameters.\nThe widgets and activities within your application do not need to know about the URL patterns associated with their respective place, which makes them portable across pages and even application.  To make use of reverse routing, it is important that the first pattern for each place is  reversible .\nSpecifically, any wildcard parts of the URL pattern must be  named , so that they can be substituted for the actual parameter names by the router.\nThe pattern  *  that matches any path is not reversible, for example.\nAlso, Navigo regular expression patterns are not reversible, because JavaScript does not support named capturing groups in regular expressions.\nHowever, their syntax is not supported by the JSON flow definition anyway, so applications cannot use them by mistake.\nThe following pattern styles are known to work well with reverse routing:   verbatim:  /some/path  named parameter segments  /some/:param/:other-param   If query parameters are enabled, any additional parameters that are not part of the pattern to reverse will be encoded into query parameters, except if the parameter value to be encoded equals the default value of the target place.", 
            "title": "Reverse Routing"
        }, 
        {
            "location": "/manuals/flow_and_places/#initiating-navigation", 
            "text": "To initiate navigation, widgets have two options:  Widgets may render regular HTML links and use the method  constructAbsoluteUrl  of the  axFlowService  to calculate the URLs of each link based on place ID and parameters.  Alternatively, widgets may initiate navigation by issuing a  navigateRequest  event expressing the desired new location within the application and providing values for place parameters.\nHow event-based navigation works in detail can be read in the separate manual covering  events .  In  HTTP/REST ) terms, event-based navigation is used to express POST-like semantics, where an URL change is associated with an effectful user action (save, sign up, purchase, etc.), while links should always follow GET semantics so that the user can safely switch back and forth between URLs.  Even better, neither widgets nor pages need to deal with specific place IDs, and can instead use semantic  targets  to initiate navigation or to construct links, as explained in the next section.", 
            "title": "Initiating navigation"
        }, 
        {
            "location": "/manuals/flow_and_places/#targets", 
            "text": "Using both events and links, it is possible to always navigate directly from place to place, simply by specifying the ID of the target place.\nHowever, this approach causes a tight coupling between the widget triggering navigation on one hand and the flow definition on the other hand, hurting reuse.\nEven more, this would smear knowledge about the navigational structure throughout the application,  making it more difficult to later change this structure.  Instead, a widget or a page (via the feature configuration of its widgets) should specify semantic navigation  targets  such as  \"next\", \"previous\", \"details\" , which are then resolved based on the current place and its definition in the application flow.\nThe idea is roughly comparable to  relations  in REST style architectures.\nIn LaxarJS, each place can define its own mapping from semantic target identifiers to the IDs of other places within the application flow.  An example:  { \n    places :   { \n       introduction :   { \n          patterns :   [   /introduction/:userId   ], \n          page :   introduction , \n          targets :   { \n             next :   interests \n          } \n       }, \n\n       interests :   { \n          patterns :   [   /interests/:userId   ], \n          page :   interests , \n          targets :   { \n             previous :   introduction , \n             next :   profession , \n             help :   interestsHelp \n          } \n       }, \n\n       profession :   { \n          patterns :   [   /profession/:userId   ], \n          page :   profession , \n          targets :   { \n             previous :   interests , \n             help :   professionHelp \n          } \n       }, \n\n       interestsHelp :   { \n          patterns :   [   /interests-help/:userId   ], \n          page :   interests_help , \n          targets :   { \n             back :   interests \n          } \n       }, \n\n       professionHelp :   { \n          patterns :   [   /profession-help/:userId   ], \n          page :   profession_help , \n          targets :   { \n             back :   profession \n          } \n       } \n    }  }   This flow is typical for a wizard-like application, as it allows forward and backward navigation, but only sparsely jumping in between pages.\nThe first place in the example is called  introduction , which simply displays a page and just lets the user navigate to the  next  target, which would be resolved to the place  interests .\nHere a page is displayed where the user can input his interests, such as hobbies or taste in music.\nAs we are in the middle of the wizard now, a  previous  target is reachable in addition to the  next  and  help  targets.\nUnsurprisingly the  previous  target references the first place,  introduction .\nThe  next  target instead leads us to another new place with identifier  profession .\nThe  profession  place may only lead us back to the  interests  place via the  previous  target.  Let us assume that our pages contain tricky input components, on which we would like to assist the user.\nThis is where the  help  target comes into play.\nBoth the  interests  and the  profession  page use this target, but the places behind these targets are different depending on the source page.\nThis allows you to provide contextual semantics to standard navigation controls, such as a row of back/forward/help buttons.\nReturning from the help pages is familiar, via the  back  target leading to the respective places.  Using the mechanisms introduced here, most navigation scenarios as well as integration into external applications should be possible.\nTo find out how to construct links between pages, refer to the  axFlowService API .\nTo learn how to trigger event-based navigation from within widgets and activities, you should go on reading the  events documentation  and learn about the  navigateRequest  and  didNavigate  events.", 
            "title": "Targets"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/", 
            "text": "Infrastructure and Tools\n\n\n\u00ab return to the manuals\n\n\nWhat does actually happen when you navigate to a LaxarJS page using the browser?\nHow does LaxarJS load your widgets, their assets and styles?\nAnd what is the difference between the \ndebug.html\n and \nindex.html\n in the application template?\nRead on to understand the inner workings of a LaxarJS application.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\n\n\nNote:\n with LaxarJS v2.0, the grunt-based infrastructure was replaced by a webpack-based system.\nFor the previous manual, make sure to browse the \nLaxarJS v1 documentation\n.\n\n\n\n\nApplication Lifecycle\n\n\nThe \nLaxarJS Yeoman generator\n contains a \ndebug.html\n that contains the to bootstrap you application during development.\nAdditionally, there is an \nindex.html\n that shows how to run the application using optimized scripts and assets.\n\n\nIn your own application, you do not actually have to use these files:\nDepending on your setup, you may wish to copy the relevant parts into a \nRuby on Rails\n or \nDjango\n template, or into a \nJSP\n and bootstrap LaxarJS from there.\n\n\nScaffolding\n\n\nLet us dissect the startup process of a LaxarJS application based on the \ndebug.html\n, only that we have removed everything that is not absolutely required:\n\n\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n!-- ... optional: meta elements, title, favicons go here ... --\n/\nhead\n\n\nbody\n\n  \ndiv\n \ndata-ax-page\n/\ndiv\n\n\n  \n!-- ... optional: add scripts for improved source-map-support --\n\n  \nscript\n \nsrc\n=\nbuild/app.bundle.js\n/\nscript\n\n\n/\nbody\n\n\n/\nhtml\n\n\n\n\n\n\nWhat do the individual elements mean?\n\n\n\n\n\n\nThe \ndata-ax-page\n attribute is referenced by the \ninit.js\n to determine where LaxarJS will place the layout for the current page.\n\n\n\n\n\n\nThe \nscript\n element loads your application bundle based on the \ninit.js\n entry point, as configured by the \nwebpack.config.js\n.\n\n\n\n\n\n\nStartup\n\n\nSo, let us see what happens once all required JavaScript modules are available:\n\n\n\n\n\n\nThe \ninit.js\n collects all dependencies for your application and passes them to \nlaxar.create\n.\n\n\n\n\n\n\nlaxar.create().\u2026.bootstrap()\n sets up the runtime services based on your configuration, and bootstraps all technology adapters used by your application.\n\n\n\n\n\n\nIf a flow was initialized before bootstrapping (using \nlaxar.create(\u2026).flow( name, domNode )\n), it is now instantiated, and its patterns are used to set up the \nNavigo router\n.\n\n\n\n\n\n\nThe router matches the flow routing patterns against the current URL, and invokes the LaxarJS \nflow controller\n with the matching place, so that the current \npage\n is determined (possibly after following redirects).\n\n\n\n\n\n\nThe flow controller instantiates a \npage controller\n for the current page.\n\n\n\n\n\n\nThe page controller loads and inserts the page layout and instantiates the controllers for widgets and activities.\nAlso, it loads the widget HTML templates and their CSS (during development).\nWidget and activity controllers may already start to make HTTP requests if they need to, while their view is being setup.\n\n\n\n\n\n\nAfter all controllers have been instantiated, the page controller publishes the \nbeginLifecycleRequest\n event to signal that widgets may start publishing events themselves.\nThen, all widget templates are instantiated, inserted into the layout DOM and linked to their controllers' scopes.\n\n\n\n\n\n\nFinally, the page controller signals to the flow controller that navigation is complete, upon which the flow controller publishes the \ndidNavigate\n event.\nThis allows widgets to handle their URL place parameters, and from now on they may publish navigate requests for further navigation.\n\n\n\n\n\n\nFrom this point on, the LaxarJS runtime interacts only through the event bus with widgets and activities.\nThe only exception to this rule is the \npage teardown\n caused by \nnavigation\n, either \nindirectly\n through a widget, or \ndirectly\n by changing the URL in the browser.\n\n\nTeardown\n\n\nBefore navigating away from a page, widgets receive \nwillNavigate\n events.\nIf the page is actually being left (there may just have been an update to the URL parameters of the current page) an \nendLifecycleRequest\n event is published, before the widget scopes are destroyed through the regular AngularJS mechanism.\nHowever, when the user simply closes the browser window, this is not always guaranteed.\nIf navigating to a new page, the startup process (described above) is repeated, starting at step 3.\n\n\nThe Artifacts Bundle\n\n\nInternally, LaxarJS uses a single service to provide HTML, CSS and JSON assets used to instantiate widgets and controls:\nThe \nartifacts provider\n manages a bundle that was prepared by the \nlaxar-loader\n for webpack at build-time, and contains the JavaScript modules as well as CSS/HTML assets for all application artifacts.\nThis avoids additional HTTP round trips in production, as well as during development.\n\n\nWebpack and the laxar-loader\n\n\nMost modern single page applications are no longer developed using just a text editor, and instead rely on additional development- and build-tools.\nThe npm module \nlaxar-loader\n helps to load LaxarJS application artifacts that using the popular \nwebpack bundler\n.\nUsed on a flow definition, this laxar-loader will bundle up all required artifacts, by following the flow via its pages and widgets to its controls and layouts.\n\n\nLaxarJS does not actually require you to use webpack (for previous version, using RequireJS as loader was mandatory), because it does not perform module loading at runtime.\nHowever, to use a different tool chain, you will to generate the artifacts bundle yourself.\nIf you need to do so, look into the laxar-loader and its dependency \nlaxar-tooling\n for inspiration.\n\n\nRunning the Development Server\n\n\nThe excellent \nDevServer for webpack\n allows you to quickly prototype and review changes to your widget.\nDepending on the integration technology, you might even be able to \"hot-reload\" widget templates without reloading the browser window.\nFor projects created with the Yeoman generator for LaxarJS, you can run the DevServer using \nnpm start\n.", 
            "title": "Infrastructure and Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#infrastructure-and-tools", 
            "text": "\u00ab return to the manuals  What does actually happen when you navigate to a LaxarJS page using the browser?\nHow does LaxarJS load your widgets, their assets and styles?\nAnd what is the difference between the  debug.html  and  index.html  in the application template?\nRead on to understand the inner workings of a LaxarJS application.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities    Note:  with LaxarJS v2.0, the grunt-based infrastructure was replaced by a webpack-based system.\nFor the previous manual, make sure to browse the  LaxarJS v1 documentation .", 
            "title": "Infrastructure and Tools"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#application-lifecycle", 
            "text": "The  LaxarJS Yeoman generator  contains a  debug.html  that contains the to bootstrap you application during development.\nAdditionally, there is an  index.html  that shows how to run the application using optimized scripts and assets.  In your own application, you do not actually have to use these files:\nDepending on your setup, you may wish to copy the relevant parts into a  Ruby on Rails  or  Django  template, or into a  JSP  and bootstrap LaxarJS from there.", 
            "title": "Application Lifecycle"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#scaffolding", 
            "text": "Let us dissect the startup process of a LaxarJS application based on the  debug.html , only that we have removed everything that is not absolutely required:  !DOCTYPE html  html  head !-- ... optional: meta elements, title, favicons go here ... -- / head  body \n   div   data-ax-page / div \n\n   !-- ... optional: add scripts for improved source-map-support -- \n   script   src = build/app.bundle.js / script  / body  / html   What do the individual elements mean?    The  data-ax-page  attribute is referenced by the  init.js  to determine where LaxarJS will place the layout for the current page.    The  script  element loads your application bundle based on the  init.js  entry point, as configured by the  webpack.config.js .", 
            "title": "Scaffolding"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#startup", 
            "text": "So, let us see what happens once all required JavaScript modules are available:    The  init.js  collects all dependencies for your application and passes them to  laxar.create .    laxar.create().\u2026.bootstrap()  sets up the runtime services based on your configuration, and bootstraps all technology adapters used by your application.    If a flow was initialized before bootstrapping (using  laxar.create(\u2026).flow( name, domNode ) ), it is now instantiated, and its patterns are used to set up the  Navigo router .    The router matches the flow routing patterns against the current URL, and invokes the LaxarJS  flow controller  with the matching place, so that the current  page  is determined (possibly after following redirects).    The flow controller instantiates a  page controller  for the current page.    The page controller loads and inserts the page layout and instantiates the controllers for widgets and activities.\nAlso, it loads the widget HTML templates and their CSS (during development).\nWidget and activity controllers may already start to make HTTP requests if they need to, while their view is being setup.    After all controllers have been instantiated, the page controller publishes the  beginLifecycleRequest  event to signal that widgets may start publishing events themselves.\nThen, all widget templates are instantiated, inserted into the layout DOM and linked to their controllers' scopes.    Finally, the page controller signals to the flow controller that navigation is complete, upon which the flow controller publishes the  didNavigate  event.\nThis allows widgets to handle their URL place parameters, and from now on they may publish navigate requests for further navigation.    From this point on, the LaxarJS runtime interacts only through the event bus with widgets and activities.\nThe only exception to this rule is the  page teardown  caused by  navigation , either  indirectly  through a widget, or  directly  by changing the URL in the browser.", 
            "title": "Startup"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#teardown", 
            "text": "Before navigating away from a page, widgets receive  willNavigate  events.\nIf the page is actually being left (there may just have been an update to the URL parameters of the current page) an  endLifecycleRequest  event is published, before the widget scopes are destroyed through the regular AngularJS mechanism.\nHowever, when the user simply closes the browser window, this is not always guaranteed.\nIf navigating to a new page, the startup process (described above) is repeated, starting at step 3.", 
            "title": "Teardown"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#the-artifacts-bundle", 
            "text": "Internally, LaxarJS uses a single service to provide HTML, CSS and JSON assets used to instantiate widgets and controls:\nThe  artifacts provider  manages a bundle that was prepared by the  laxar-loader  for webpack at build-time, and contains the JavaScript modules as well as CSS/HTML assets for all application artifacts.\nThis avoids additional HTTP round trips in production, as well as during development.", 
            "title": "The Artifacts Bundle"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#webpack-and-the-laxar-loader", 
            "text": "Most modern single page applications are no longer developed using just a text editor, and instead rely on additional development- and build-tools.\nThe npm module  laxar-loader  helps to load LaxarJS application artifacts that using the popular  webpack bundler .\nUsed on a flow definition, this laxar-loader will bundle up all required artifacts, by following the flow via its pages and widgets to its controls and layouts.  LaxarJS does not actually require you to use webpack (for previous version, using RequireJS as loader was mandatory), because it does not perform module loading at runtime.\nHowever, to use a different tool chain, you will to generate the artifacts bundle yourself.\nIf you need to do so, look into the laxar-loader and its dependency  laxar-tooling  for inspiration.", 
            "title": "Webpack and the laxar-loader"
        }, 
        {
            "location": "/manuals/infrastructure_and_tools/#running-the-development-server", 
            "text": "The excellent  DevServer for webpack  allows you to quickly prototype and review changes to your widget.\nDepending on the integration technology, you might even be able to \"hot-reload\" widget templates without reloading the browser window.\nFor projects created with the Yeoman generator for LaxarJS, you can run the DevServer using  npm start .", 
            "title": "Running the Development Server"
        }, 
        {
            "location": "/manuals/installing_controls/", 
            "text": "Installing Controls\n\n\n\u00ab return to the manuals\n\n\nInstalling Controls works almost in the same way as \ninstalling widgets\n.\n\n\nControls Root\n\n\nThe default directory that the laxar-loader uses when looking for controls within a project is \napplication/controls/\n.\nIt can be changed by creating a file \nlaxar.config.js\n in your project and configuring the export \npaths.controls\n to a different string.\n\n\nListing Controls in the Widget Descriptor\n\n\nThe widgets of a LaxarJS application are identified by collecting them from the page definitions.\nIn turn, the controls are collected based on the \ncontrols\n entries collected from all widget descriptors.\nEach widget should specify the controls that it requires by referencing their \nname\n property.\n\n\nUsing Controls\n\n\nDepending on the integration technology used by your widget, controls will be available as components of your view framework (say, as AngularJS directives).\nControls of the technology \n\"plain\"\n are an exception and are loaded using the \naxControls\n widget service, as described by the \nmanual on the \n\"plain\"\n adapter\n.", 
            "title": "Installing Controls"
        }, 
        {
            "location": "/manuals/installing_controls/#installing-controls", 
            "text": "\u00ab return to the manuals  Installing Controls works almost in the same way as  installing widgets .", 
            "title": "Installing Controls"
        }, 
        {
            "location": "/manuals/installing_controls/#controls-root", 
            "text": "The default directory that the laxar-loader uses when looking for controls within a project is  application/controls/ .\nIt can be changed by creating a file  laxar.config.js  in your project and configuring the export  paths.controls  to a different string.", 
            "title": "Controls Root"
        }, 
        {
            "location": "/manuals/installing_controls/#listing-controls-in-the-widget-descriptor", 
            "text": "The widgets of a LaxarJS application are identified by collecting them from the page definitions.\nIn turn, the controls are collected based on the  controls  entries collected from all widget descriptors.\nEach widget should specify the controls that it requires by referencing their  name  property.", 
            "title": "Listing Controls in the Widget Descriptor"
        }, 
        {
            "location": "/manuals/installing_controls/#using-controls", 
            "text": "Depending on the integration technology used by your widget, controls will be available as components of your view framework (say, as AngularJS directives).\nControls of the technology  \"plain\"  are an exception and are loaded using the  axControls  widget service, as described by the  manual on the  \"plain\"  adapter .", 
            "title": "Using Controls"
        }, 
        {
            "location": "/manuals/installing_widgets/", 
            "text": "Installing Third Party Widgets\n\n\n\u00ab return to the manuals\n\n\nOne of \nthe advantages\n of LaxarJS is the concept of isolated, reusable widgets.\nThis begs the question as to how an existing LaxarJS widget can be added to your application.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWriting Pages\n\n\n\n\nInstalling Widgets from npm\n\n\nStarting with LaxarJS v2, the recommended way for installing third-party widgets is by using \nnpm\n or its compatible alternative, \nYarn\n.\n\n\nInstalling a widget usually becomes as simple as running:\n\n\nnpm install --save my-widget\n\n\n\n\n\n\nNow, the widget can be added to an area within your page definition:\n\n\nmyArea\n:\n \n[\n\n   \n{\n\n      \nwidget\n:\n \nmy-widget\n,\n\n      \nfeatures\n:\n \n{}\n\n   \n}\n\n\n]\n\n\n\n\n\n\nInstalling Widgets using Bower\n\n\nFor LaxarJS v1, we recommended installing widgets using \nBower\n, and this still works for LaxarJS v2.\nBesides being a simple and fast way to download a widget, Bower helps you to install and manage widget dependencies such as controls and libraries.\n\n\nHowever, it has shortcomings when widgets require additional tooling infrastructure (such babel) to run:\nFirst, Bower does not directly support pre-built packages, like npm does.\nThen, all Bower dependencies are meant to be run in the Browser, so widgets cannot indicate that they require additional tooling (such as webpack loaders) to work.\n\n\n1. Configure Webpack\n\n\nFirst, tell webpack to use \nbower_components\n and the \nbower.json\n when resolving modules.\nFor this, edit the \nresolve\n section in your \nwebpack.config.js\n:\n\n\nresolve\n:\n \n{\n\n   \nmodules\n:\n \n[\n \npath\n.\nresolve\n(\n \nnode_modules\n \n),\n \npath\n.\nresolve\n(\n \nbower_components\n \n)\n \n],\n\n   \ndescriptionFiles\n:\n \n[\n \npackage.json\n,\n \nbower.json\n \n]\n\n\n}\n\n\n\n\n\n\nTouching the webpack configuration should be needed only once, except for widgets or controls that require additional \nalias\n configuration.\nThese artifacts should come with appropriate installation instructions.\n\n\n2. Obtain Widget \n Dependencies\n\n\nAssuming that the widget has been registered as a Bower package named \nlaxar-headline-widget\n, you can install it into your project like this:\n\n\n$\n bower install --save laxar-headline-widget\n\n\n\n\n\nThis will also automatically install the latest version along with its Bower dependencies.\nTo reference this widget from a JSON page definition, set the \nwidget\n field to \n'laxar-headline-widget'\n.\nThis will cause LaxarJS to use RequireJS in order to find the widget in the \nbower_components\n folder.\n\n\nInstalling Widgets from Source\n\n\nInstalling widgets from source is a bit more involved, and usually depends on the widget in question.\n\n\n1. Obtain the Widget\n\n\nNew widgets should be installed into the widgets-root (\napplication/widgets/\n by default) just like any widgets that you create yourself.\nUsually, you will simply \nclone\n the required widgets from a Git repository, or add them as \nGit submodules\n.\n\n\nIn this example, the LaxarJS headline widget in Version 4.0.0 is obtained through \ngit submodule\n:\n\n\n$ git submodule add \n\\\n\n    https://github.com/laxarjs/ax-headline-widget.git \n\\\n\n    application/widgets/laxar-headline-widget\n$ \ncd\n application/widgets/laxar-headline-widget\n$ git checkout v4.0.0\n\n\n\n\n\nInstead of using Git, you can also simply copy a widget from another project, unpack it from a zip archive, or obtain it in any other way.\nJust make sure that the widget files are located under \napplication/widgets/\nsome-path\n, then you can use \nsome-path\n to reference the widget from your pages.\nIn the example, the path is \nlaxar-headline-widget\n.\n\n\n2. Obtain the Dependencies\n\n\nSome widgets have extra dependencies that should be listed in the \ndependencies\n section of their \npackage.json\n (or sometimes \nbower.json\n) file.\nYou should compare your widget's dependencies to those of your application, adding missing dependencies.\nIf your widget declares its dependencies, you can automate that process using \nnpm\n (or bower):\n\n\n npm install --save ./application/widgets/my-widget\n\n# or, if the widget only has bower dependencies:\n\n\n# \n bower install --save ./application/widgets/my-widget\n\n\n\n\n\n\nNote:\n This will also install the widget itself as a dependency, which is not actually needed but also should not hurt.\n\n\n3. Configure Paths for Webpack\n\n\nThe documentation of your widget should tell you if any changes need to be made to your webpack configuration.\n\n\nHaving followed these steps, you can now add the new widget to a page by specifying the path in your page configuration.", 
            "title": "Installing Third Party Widgets"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-third-party-widgets", 
            "text": "\u00ab return to the manuals  One of  the advantages  of LaxarJS is the concept of isolated, reusable widgets.\nThis begs the question as to how an existing LaxarJS widget can be added to your application.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Writing Pages", 
            "title": "Installing Third Party Widgets"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-widgets-from-npm", 
            "text": "Starting with LaxarJS v2, the recommended way for installing third-party widgets is by using  npm  or its compatible alternative,  Yarn .  Installing a widget usually becomes as simple as running:  npm install --save my-widget   Now, the widget can be added to an area within your page definition:  myArea :   [ \n    { \n       widget :   my-widget , \n       features :   {} \n    }  ]", 
            "title": "Installing Widgets from npm"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-widgets-using-bower", 
            "text": "For LaxarJS v1, we recommended installing widgets using  Bower , and this still works for LaxarJS v2.\nBesides being a simple and fast way to download a widget, Bower helps you to install and manage widget dependencies such as controls and libraries.  However, it has shortcomings when widgets require additional tooling infrastructure (such babel) to run:\nFirst, Bower does not directly support pre-built packages, like npm does.\nThen, all Bower dependencies are meant to be run in the Browser, so widgets cannot indicate that they require additional tooling (such as webpack loaders) to work.", 
            "title": "Installing Widgets using Bower"
        }, 
        {
            "location": "/manuals/installing_widgets/#1-configure-webpack", 
            "text": "First, tell webpack to use  bower_components  and the  bower.json  when resolving modules.\nFor this, edit the  resolve  section in your  webpack.config.js :  resolve :   { \n    modules :   [   path . resolve (   node_modules   ),   path . resolve (   bower_components   )   ], \n    descriptionFiles :   [   package.json ,   bower.json   ]  }   Touching the webpack configuration should be needed only once, except for widgets or controls that require additional  alias  configuration.\nThese artifacts should come with appropriate installation instructions.", 
            "title": "1. Configure Webpack"
        }, 
        {
            "location": "/manuals/installing_widgets/#2-obtain-widget-dependencies", 
            "text": "Assuming that the widget has been registered as a Bower package named  laxar-headline-widget , you can install it into your project like this:  $  bower install --save laxar-headline-widget  This will also automatically install the latest version along with its Bower dependencies.\nTo reference this widget from a JSON page definition, set the  widget  field to  'laxar-headline-widget' .\nThis will cause LaxarJS to use RequireJS in order to find the widget in the  bower_components  folder.", 
            "title": "2. Obtain Widget &amp; Dependencies"
        }, 
        {
            "location": "/manuals/installing_widgets/#installing-widgets-from-source", 
            "text": "Installing widgets from source is a bit more involved, and usually depends on the widget in question.", 
            "title": "Installing Widgets from Source"
        }, 
        {
            "location": "/manuals/installing_widgets/#1-obtain-the-widget", 
            "text": "New widgets should be installed into the widgets-root ( application/widgets/  by default) just like any widgets that you create yourself.\nUsually, you will simply  clone  the required widgets from a Git repository, or add them as  Git submodules .  In this example, the LaxarJS headline widget in Version 4.0.0 is obtained through  git submodule :  $ git submodule add  \\ \n    https://github.com/laxarjs/ax-headline-widget.git  \\ \n    application/widgets/laxar-headline-widget\n$  cd  application/widgets/laxar-headline-widget\n$ git checkout v4.0.0  Instead of using Git, you can also simply copy a widget from another project, unpack it from a zip archive, or obtain it in any other way.\nJust make sure that the widget files are located under  application/widgets/ some-path , then you can use  some-path  to reference the widget from your pages.\nIn the example, the path is  laxar-headline-widget .", 
            "title": "1. Obtain the Widget"
        }, 
        {
            "location": "/manuals/installing_widgets/#2-obtain-the-dependencies", 
            "text": "Some widgets have extra dependencies that should be listed in the  dependencies  section of their  package.json  (or sometimes  bower.json ) file.\nYou should compare your widget's dependencies to those of your application, adding missing dependencies.\nIf your widget declares its dependencies, you can automate that process using  npm  (or bower):   npm install --save ./application/widgets/my-widget # or, if the widget only has bower dependencies:  #   bower install --save ./application/widgets/my-widget   Note:  This will also install the widget itself as a dependency, which is not actually needed but also should not hurt.", 
            "title": "2. Obtain the Dependencies"
        }, 
        {
            "location": "/manuals/installing_widgets/#3-configure-paths-for-webpack", 
            "text": "The documentation of your widget should tell you if any changes need to be made to your webpack configuration.  Having followed these steps, you can now add the new widget to a page by specifying the path in your page configuration.", 
            "title": "3. Configure Paths for Webpack"
        }, 
        {
            "location": "/manuals/i18n/", 
            "text": "Internationalizing a Widget\n\n\n\u00ab return to the manuals\n\n\nIn LaxarJS, internationalization \n(i18n)\n of widgets is \noptional.\n\nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nLocales and Language Tags: I18n in LaxarJS\n\n\nLaxarJS distinguishes \nlocales\n and \nlanguage tags\n for internationalization:\nEach locale has a constant name such as \n\"default\"\n or \n\"customer\"\n as well as an \nRFC-5646\n language tag like \n\"en-US\"\n, which can change over time.\nEach locale corresponds to an audience (users, translators, admins, ...) for which a specific language tag should be used.\nIf you have only one audience (all users), using only the locale \n\"default\"\n should be fine.\n\n\nThe language tag of a given locale can be modified by activities or widgets while the application is running.\nThis is accomplished by publishing specific events from widgets that would like to set the language tag, and handling them correctly in i18n-capable widgets.\n\n\nWidgets can use the language tags received over the event bus to \nlocalize\n internationalized values.\n\nInternationalized values\n are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with \ni18n\n:\n\n\nconst\n \ni18nHtmlText\n \n=\n \n{\n\n   \nen\n:\n \nUpload \nem\nfile\n/em\n,\n\n   \nde-DE\n:\n \nem\nDatei\n/em\n hochladen\n\n\n}\n\n\n\n\n\n\nHere, the localization for Germany (\nde-DE\n) will only be used if the language tag starts with \nde-DE\n.\nFor other \nvariants\n of \nde\n (such as \nde-CH\n), the configured \nfallback tag\n (by default \nen\n) will be used.\nNote that tags are case-insensitive and that the underscore (\n'_'\n) is normalized to \n'-'\n.\n\n\nWriting an I18n-Capable Widget\n\n\nTo work with internationalized values, widgets should specify a feature \ni18n\n in their \nwidget.json\n descriptor.\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example \nen-GB\n) is usually defined by the \napplication configuration\n, and used at runtime for localization.\n\n\ni18n\n:\n \n{\n\n   \ndescription\n:\n \nWhich locale to use for displaying this widget.\n,\n\n   \ntype\n:\n \nobject\n,\n\n   \nproperties\n:\n \n{\n\n      \nlocale\n:\n \n{\n\n         \ntype\n:\n \nstring\n,\n\n         \ndescription\n:\n \nThe topic under which to expect the locale for this widget.\n,\n\n         \ndefault\n:\n \ndefault\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWith this configuration, the \nwidget service \naxI18n\n can be injected into the widget controller to localize internationalized values:\n\n\nfunction\n \nupdateView\n()\n \n{\n\n   \nview\n.\nhtmlText\n \n=\n \naxI18n\n.\nlocalize\n(\n \ni18nHtmlText\n \n);\n\n\n}\n\n\nupdateView\n();\n\n\n\n\n\n\nThe \naxI18n\n service also helps to stay up-to-date when the language tag is changed:\n\n\n   \naxI18n\n.\nwhenLocaleChanged\n(\n \nupdateView\n \n);\n\n\n\n\n\n\nThe callback passed to \nwhenLocaleChanged\n is invoked with the updated language tag.\n\n\nChanging the Language\n\n\nSometimes, you may want to offer users the functionality of switching the application language.\nThe \naxI18n.update\n method can be used for this:\n\n\nfunction\n \nonLanguageSelected\n(\n \nnewTag\n \n)\n \n{\n\n   \naxI18n\n.\nupdate\n(\n \nnewTag\n \n);\n\n\n}\n\n\n\n\n\n\nPerforming Localization in Templates\n\n\nLocalization in templates is specific to the individual integration technologies.\nThe \n\"angular\"\n adapter for AngularJS v1 provides the filter \naxLocalize\n which uses the axI18n service to provide up-to-date localizations of input values.\n\n\nAdvanced: Locale Change Events\n\n\nTo change the language tag of a locale, a widget has to publish the \nchangeLocaleRequest.{locale}\n event.\nAs described above, this can be achieved using \naxI18n.update( tag )\n.\nHowever, the \naxI18n\n service is just an abstraction over directly accessing the event bus to exchange locale change events.\n\n\nExample:\n Assuming that \naxEventBus\n was injected into a widget, to change the language tag of the locale \nmyLocale\n to \nde-DE\n, the widget controller has to do the following:\n\n\naxEventBus\n.\npublish\n(\n \nchangeLocaleRequest.myLocale\n,\n \n{\n\n   \nlocale\n:\n \nmyLocale\n,\n\n   \nlanguageTag\n:\n \nde-DE\n\n\n}\n \n);\n\n\n\n\n\n\nUsually, you would just use \naxI18n.update( 'de-DE' )\n to achieve the same effect.\n\n\nIf a widget is interested in changes to \nmyLocale\n, it would subscribe to the corresponding \ndidChangeLocale\n-event, which is published by the LaxarJS flow-controller:\n\n\neventBus\n.\nsubscribe\n(\n \ndidChangeLocale.myLocale\n,\n \nevent\n \n=\n \n{\n\n   \naxLog\n.\ninfo\n(\n \nI have received tag [0] for locale [1]\n,\n \nevent\n.\nlanguageTag\n,\n \nevent\n.\nlocale\n \n);\n\n\n}\n \n);\n\n\n\n\n\n\nThis is what \naxI18n\n does behind the scenes to support \nlocalize\n and \nwhenLocaleChanged\n.", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#internationalizing-a-widget", 
            "text": "\u00ab return to the manuals  In LaxarJS, internationalization  (i18n)  of widgets is  optional. \nRead on if you are interested in writing widgets that support multiple languages, and even switching languages without reloading the page.  Preliminary readings:   Widgets and Activities", 
            "title": "Internationalizing a Widget"
        }, 
        {
            "location": "/manuals/i18n/#locales-and-language-tags-i18n-in-laxarjs", 
            "text": "LaxarJS distinguishes  locales  and  language tags  for internationalization:\nEach locale has a constant name such as  \"default\"  or  \"customer\"  as well as an  RFC-5646  language tag like  \"en-US\" , which can change over time.\nEach locale corresponds to an audience (users, translators, admins, ...) for which a specific language tag should be used.\nIf you have only one audience (all users), using only the locale  \"default\"  should be fine.  The language tag of a given locale can be modified by activities or widgets while the application is running.\nThis is accomplished by publishing specific events from widgets that would like to set the language tag, and handling them correctly in i18n-capable widgets.  Widgets can use the language tags received over the event bus to  localize  internationalized values. Internationalized values  are JSON-Objects which contain an entry for each supported language tag.\nBy convention, variables and properties that contain internationalized values are prefixed with  i18n :  const   i18nHtmlText   =   { \n    en :   Upload  em file /em , \n    de-DE :   em Datei /em  hochladen  }   Here, the localization for Germany ( de-DE ) will only be used if the language tag starts with  de-DE .\nFor other  variants  of  de  (such as  de-CH ), the configured  fallback tag  (by default  en ) will be used.\nNote that tags are case-insensitive and that the underscore ( '_' ) is normalized to  '-' .", 
            "title": "Locales and Language Tags: I18n in LaxarJS"
        }, 
        {
            "location": "/manuals/i18n/#writing-an-i18n-capable-widget", 
            "text": "To work with internationalized values, widgets should specify a feature  i18n  in their  widget.json  descriptor.\nIt allows page authors to configure the name of the locale (e.g. \"customer\") to be used by this widget.\nThe actual language tag associated with that locale (for example  en-GB ) is usually defined by the  application configuration , and used at runtime for localization.  i18n :   { \n    description :   Which locale to use for displaying this widget. , \n    type :   object , \n    properties :   { \n       locale :   { \n          type :   string , \n          description :   The topic under which to expect the locale for this widget. , \n          default :   default \n       } \n    }  }   With this configuration, the  widget service  axI18n  can be injected into the widget controller to localize internationalized values:  function   updateView ()   { \n    view . htmlText   =   axI18n . localize (   i18nHtmlText   );  }  updateView ();   The  axI18n  service also helps to stay up-to-date when the language tag is changed:      axI18n . whenLocaleChanged (   updateView   );   The callback passed to  whenLocaleChanged  is invoked with the updated language tag.", 
            "title": "Writing an I18n-Capable Widget"
        }, 
        {
            "location": "/manuals/i18n/#changing-the-language", 
            "text": "Sometimes, you may want to offer users the functionality of switching the application language.\nThe  axI18n.update  method can be used for this:  function   onLanguageSelected (   newTag   )   { \n    axI18n . update (   newTag   );  }", 
            "title": "Changing the Language"
        }, 
        {
            "location": "/manuals/i18n/#performing-localization-in-templates", 
            "text": "Localization in templates is specific to the individual integration technologies.\nThe  \"angular\"  adapter for AngularJS v1 provides the filter  axLocalize  which uses the axI18n service to provide up-to-date localizations of input values.", 
            "title": "Performing Localization in Templates"
        }, 
        {
            "location": "/manuals/i18n/#advanced-locale-change-events", 
            "text": "To change the language tag of a locale, a widget has to publish the  changeLocaleRequest.{locale}  event.\nAs described above, this can be achieved using  axI18n.update( tag ) .\nHowever, the  axI18n  service is just an abstraction over directly accessing the event bus to exchange locale change events.  Example:  Assuming that  axEventBus  was injected into a widget, to change the language tag of the locale  myLocale  to  de-DE , the widget controller has to do the following:  axEventBus . publish (   changeLocaleRequest.myLocale ,   { \n    locale :   myLocale , \n    languageTag :   de-DE  }   );   Usually, you would just use  axI18n.update( 'de-DE' )  to achieve the same effect.  If a widget is interested in changes to  myLocale , it would subscribe to the corresponding  didChangeLocale -event, which is published by the LaxarJS flow-controller:  eventBus . subscribe (   didChangeLocale.myLocale ,   event   =   { \n    axLog . info (   I have received tag [0] for locale [1] ,   event . languageTag ,   event . locale   );  }   );   This is what  axI18n  does behind the scenes to support  localize  and  whenLocaleChanged .", 
            "title": "Advanced: Locale Change Events"
        }, 
        {
            "location": "/manuals/configuration/", 
            "text": "LaxarJS Configuration in an Application\n\n\n\u00ab return to the manuals\n\n\nLaxarJS has a built-in configuration API which is available to libraries and widgets through the \naxConfiguration\n injection.\nNot to be confused with the \nlaxar.config.js\n which is only used at build-time by tools such as the laxar-loader, \nthis\n configuration is designed to be used at application run time.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nWhat is LaxarJS Configuration Used for?\n\n\nFirst, the configuration is used to customize the behavior of a LaxarJS bootstrapping instance.\nThis includes deployment-specific options such as the log-level, so you may want to prepare the configuration outside of the \ninit.js\n\n\nWhen writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration, placed in the page definitions.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.\n\n\nIn other cases, LaxarJS itself needs to be configured, for example to determine the theme, flow, available locales and so on.\nThe \nLaxarJS Core\n configuration options are listed below.\n\n\nConfiguration Structure\n\n\nConfiguration keys are simple attribute paths, reflecting the hierarchical configuration structure.\nThe configuration is passed to LaxarJS \ncreate\n when launching your application instance, usually in the \ninit.js\n:\n\n\nconst\n \nlaxar\n \n=\n \nrequire\n(\n \nlaxar\n \n);\n\n\nconst\n \nadapters\n \n=\n \n[\n \n/*...*/\n \n];\n\n\nconst\n \nartifacts\n \n=\n \nrequire\n(\n \nlaxar-loadert/artifacts?flow=main\n \n);\n\n\nconst\n \nconfiguration\n \n=\n \n{\n\n   \n// ... other configuration options, e.g. logging level ...\n\n   \nname\n:\n \nMy App\n,\n\n   \ndescription\n:\n \nA well-configured application\n,\n\n   \ntheme\n:\n \ndefault\n,\n\n   \nlogging\n:\n \n{\n\n      \nlevel\n:\n \nWARN\n\n   \n}\n\n\n};\n\n\n\nlaxar\n.\ncreate\n(\n \nadapters\n,\n \nartifacts\n,\n \nconfiguration\n \n)\n\n   \n.\nflow\n(\n \nmain\n,\n \ndocument\n.\nquerySelector\n(\n \n/*...*/\n \n)\n \n)\n\n   \n.\nbootstrap\n();\n\n\n\n\n\n\nLibraries, widgets and activities may define their own configuration keys, but must always use the \nlib.\n prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example, \nLaxarJS UiKit\n controls use the prefix \nlib.laxar-uikit.controls\n for their configuration options.\nKeys without the \nlib.\n-prefix are used by \nLaxarJS Core\n.\n\n\nThe Configuration Service\n\n\nThe LaxarJS configuration is exposed as the widget service injection \naxConfiguration\n with a single method \nget( key, fallback )\n.\nThe \nkey\n-parameter is the path within the configuration object (passed to \nlaxar.create\n), and the (optional) \nfallback\n is returned as a default value if the key was not set in the configuration.\n\n\nFor example, let us assume that the controller of a \n\"plain\"\n activity called \nmy-activity\n wants to enable some kind of compatibility behavior for a special \nfoo\n environment by exposing a Boolean configuration \nfooMode\n.\nBy default, the option should be disabled, as compatibility with foo involves jumping through some hoops.\n\n\nThe widget implementation module would then access the option like this:\n\n\nexport\n \nconst\n \ninjections\n \n=\n \n[\n \naxConfiguration\n \n];\n\n\nexport\n \nfunction\n \ncreate\n(\n \nconfiguration\n \n)\n \n{\n\n   \nconst\n \nrespectFoo\n \n=\n \nconfiguration\n.\nget\n(\n \nwidgets.my-activity.fooMode\n,\n \nfalse\n \n);\n\n   \nif\n(\n \nrespectFoo\n \n)\n \n{\n\n      \n// ... jump though some hoops ...\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe corresponding configuration block to enable foo-compatibility would then look like this:\n\n\nconst\n \nconfiguration\n \n=\n \n{\n\n   \n// ... other configuration options, e.g. logging level ...\n\n   \nwidgets\n:\n \n{\n\n      \nmy-activity\n:\n \n{\n\n         \nfooMode\n:\n \ntrue\n\n      \n}\n\n   \n}\n\n\n};\n\n\n// ... laxar.create ...\n\n\n\n\n\n\nNo special magic is attached to the \nwidgets\n sub-key of the configuration, except that it is never used by LaxarJS core or libraries.\n\n\nTesting a Module that Uses Configuration\n\n\nTo simplify testing, \nLaxarJS Mocks\n always uses a mock configuration instance when loading widgets in spec-tests.\nRefer to the \nConfiguration Mock API docs\n or to the [LaxarJS Mocks API docs] for details.\n\n\nAvailable Configuration Keys\n\n\nThe following configuration options are defined by \nLaxarJS Core\n.\n\n\n\n\n\n\n\n\nKey\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\n'unnamed'\n\n\nThe name of the LaxarJS application\n\n\n\n\n\n\ndescription\n\n\n''\n\n\nA short application description\n\n\n\n\n\n\ntheme\n\n\n'default'\n\n\nWhich theme to use for the application. The suffix \n.theme\n is added automatically.\n\n\n\n\n\n\ncontrols.*\n\n\nnull\n\n\nSub-configuration for use by controls (using the artifact name as second-level key is recommended).\n\n\n\n\n\n\neventBusTimeoutMs\n\n\n120000\n\n\nThe maximum delay (in milliseconds) to wait for a \ndid...\n event to be published, after it was announced by a \nwill...\n event.\n\n\n\n\n\n\ni18n.locales\n\n\n{ 'default': 'en' }\n\n\nWhich language tag to use for the default locale, and possibly for other locales.\n\n\n\n\n\n\nlogging.instanceId\n\n\ntrue\n\n\nIf set to a function, that function is used to calculate the value of the INST log tag. If set to \ntrue\n (default), the current UNIX time stamp plus a small random offset is used. If set to \nfalse\n, no INST log-tag is generated.\n\n\n\n\n\n\nlogging.levels\n\n\n{}\n\n\nAdditional log levels with name and severity, for example \n{ NOTICE: 350 }\n. The predefined severities reach from \n100\n for \nTRACE\n to \n600\n for \nFATAL\n.\n\n\n\n\n\n\nlogging.threshold\n\n\n'INFO'\n\n\nThe log level which is required for messages to be logged (one of \nTRACE\n, \nDEBUG\n, \nINFO\n, \nWARN\n, \nERROR\n or \nFATAL\n)\n\n\n\n\n\n\nrouter.navigo.useHash\n\n\nfalse\n\n\nSelects if the Navigo router uses hash-based URLs for navigation (\ntrue\n), or path-based URLs that rely on the \npushState\n browser feature (\nfalse\n).\n\n\n\n\n\n\nrouter.base\n\n\nnull\n\n\nOverride the document base \nhref\n for routing.\n\n\n\n\n\n\nrouter.query.enabled\n\n\nfalse\n\n\nIf \ntrue\n, query parameters are automatically transformed into additional place parameters and vice versa.\n\n\n\n\n\n\nstoragePrefix\n\n\nnull\n\n\nAllows to set a prefix for local- and session-storage keys when using \nlaxar.storage\n. If \nnull\n, a prefix is generated based on the configured \nname\n.\n\n\n\n\n\n\nwidgets.*\n\n\nnull\n\n\nSub-configuration for use by widgets and activities (using the artifact name as second-level key is recommended).", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#laxarjs-configuration-in-an-application", 
            "text": "\u00ab return to the manuals  LaxarJS has a built-in configuration API which is available to libraries and widgets through the  axConfiguration  injection.\nNot to be confused with the  laxar.config.js  which is only used at build-time by tools such as the laxar-loader,  this  configuration is designed to be used at application run time.  Preliminary readings:   Widgets and Activities", 
            "title": "LaxarJS Configuration in an Application"
        }, 
        {
            "location": "/manuals/configuration/#what-is-laxarjs-configuration-used-for", 
            "text": "First, the configuration is used to customize the behavior of a LaxarJS bootstrapping instance.\nThis includes deployment-specific options such as the log-level, so you may want to prepare the configuration outside of the  init.js  When writing widgets, it is generally recommended to avoid global configuration options in favor of widget feature configuration, placed in the page definitions.\nSometimes however, a single setting must be respected across a large number of widgets:\nFor example, all widgets should use the same validation trigger (on change vs. on focus-out) to guarantee a consistent user experience.  In other cases, LaxarJS itself needs to be configured, for example to determine the theme, flow, available locales and so on.\nThe  LaxarJS Core  configuration options are listed below.", 
            "title": "What is LaxarJS Configuration Used for?"
        }, 
        {
            "location": "/manuals/configuration/#configuration-structure", 
            "text": "Configuration keys are simple attribute paths, reflecting the hierarchical configuration structure.\nThe configuration is passed to LaxarJS  create  when launching your application instance, usually in the  init.js :  const   laxar   =   require (   laxar   );  const   adapters   =   [   /*...*/   ];  const   artifacts   =   require (   laxar-loadert/artifacts?flow=main   );  const   configuration   =   { \n    // ... other configuration options, e.g. logging level ... \n    name :   My App , \n    description :   A well-configured application , \n    theme :   default , \n    logging :   { \n       level :   WARN \n    }  };  laxar . create (   adapters ,   artifacts ,   configuration   ) \n    . flow (   main ,   document . querySelector (   /*...*/   )   ) \n    . bootstrap ();   Libraries, widgets and activities may define their own configuration keys, but must always use the  lib.  prefix, followed by a suitable module identifier (e.g. the name of the library vendor) to avoid name collisions.\nFor example,  LaxarJS UiKit  controls use the prefix  lib.laxar-uikit.controls  for their configuration options.\nKeys without the  lib. -prefix are used by  LaxarJS Core .", 
            "title": "Configuration Structure"
        }, 
        {
            "location": "/manuals/configuration/#the-configuration-service", 
            "text": "The LaxarJS configuration is exposed as the widget service injection  axConfiguration  with a single method  get( key, fallback ) .\nThe  key -parameter is the path within the configuration object (passed to  laxar.create ), and the (optional)  fallback  is returned as a default value if the key was not set in the configuration.  For example, let us assume that the controller of a  \"plain\"  activity called  my-activity  wants to enable some kind of compatibility behavior for a special  foo  environment by exposing a Boolean configuration  fooMode .\nBy default, the option should be disabled, as compatibility with foo involves jumping through some hoops.  The widget implementation module would then access the option like this:  export   const   injections   =   [   axConfiguration   ];  export   function   create (   configuration   )   { \n    const   respectFoo   =   configuration . get (   widgets.my-activity.fooMode ,   false   ); \n    if (   respectFoo   )   { \n       // ... jump though some hoops ... \n    }  }   The corresponding configuration block to enable foo-compatibility would then look like this:  const   configuration   =   { \n    // ... other configuration options, e.g. logging level ... \n    widgets :   { \n       my-activity :   { \n          fooMode :   true \n       } \n    }  };  // ... laxar.create ...   No special magic is attached to the  widgets  sub-key of the configuration, except that it is never used by LaxarJS core or libraries.", 
            "title": "The Configuration Service"
        }, 
        {
            "location": "/manuals/configuration/#testing-a-module-that-uses-configuration", 
            "text": "To simplify testing,  LaxarJS Mocks  always uses a mock configuration instance when loading widgets in spec-tests.\nRefer to the  Configuration Mock API docs  or to the [LaxarJS Mocks API docs] for details.", 
            "title": "Testing a Module that Uses Configuration"
        }, 
        {
            "location": "/manuals/configuration/#available-configuration-keys", 
            "text": "The following configuration options are defined by  LaxarJS Core .     Key  Default  Description      name  'unnamed'  The name of the LaxarJS application    description  ''  A short application description    theme  'default'  Which theme to use for the application. The suffix  .theme  is added automatically.    controls.*  null  Sub-configuration for use by controls (using the artifact name as second-level key is recommended).    eventBusTimeoutMs  120000  The maximum delay (in milliseconds) to wait for a  did...  event to be published, after it was announced by a  will...  event.    i18n.locales  { 'default': 'en' }  Which language tag to use for the default locale, and possibly for other locales.    logging.instanceId  true  If set to a function, that function is used to calculate the value of the INST log tag. If set to  true  (default), the current UNIX time stamp plus a small random offset is used. If set to  false , no INST log-tag is generated.    logging.levels  {}  Additional log levels with name and severity, for example  { NOTICE: 350 } . The predefined severities reach from  100  for  TRACE  to  600  for  FATAL .    logging.threshold  'INFO'  The log level which is required for messages to be logged (one of  TRACE ,  DEBUG ,  INFO ,  WARN ,  ERROR  or  FATAL )    router.navigo.useHash  false  Selects if the Navigo router uses hash-based URLs for navigation ( true ), or path-based URLs that rely on the  pushState  browser feature ( false ).    router.base  null  Override the document base  href  for routing.    router.query.enabled  false  If  true , query parameters are automatically transformed into additional place parameters and vice versa.    storagePrefix  null  Allows to set a prefix for local- and session-storage keys when using  laxar.storage . If  null , a prefix is generated based on the configured  name .    widgets.*  null  Sub-configuration for use by widgets and activities (using the artifact name as second-level key is recommended).", 
            "title": "Available Configuration Keys"
        }, 
        {
            "location": "/manuals/plain_adapter/", 
            "text": "The \n\"plain\"\n Integration Technology\n\n\n\u00ab return to the manuals\n\n\nWhile LaxarJS allows you to adapt external MVC frameworks for writing widgets, sometimes that is not actually needed.\nEspecially when creating activities, often there is no reason to use something like Angular or Vue.js.\nThe \n\"plain\n\" technology is for widgets that simply rely on what the browser has to offer.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nWidgets Services\n\n\n\n\nWhen to Use the \n\"plain\"\n Technology?\n\n\nThe \n\"plain\"\n integration technology is supported by LaxarJS out-of-the-box without having to add any adapter to a project.\nThis minimizes the \nfootprint\n of widgets -- great if they are to be used from projects that may already be using one or more integration technologies.\nAlso, a reduced number of dependencies will likely improve \ncompatibility.\n\nFor example, if a widget relies on \n\"angular2\"\n, it might not work within projects that use upcoming major versions of Angular.\n\n\nAlso, \n\"plain\"\n is a great choice for \nactivities:\n\nThese do not benefit as much from MVC frameworks, except maybe from their utility services (such as \n$http\n provided by AngularJS).\n\n\nFinally, using \n\"plain\"\n may be the best option if you are interfacing with the DOM directly, for example when\n\n\n\n\nyou would like to mainly use \ncanvas\n, \nvideo\n or even \nWebGL\n for your UI,\n\n\nyou would like to programmatically manipulate the DOM, using custom animations or maybe \nD3\n charts.\n\n\n\n\nIn these use cases, even well-designed view frameworks sometimes just get in the way.\n\n\nWhen to Avoid the \n\"plain\"\n Technology?\n\n\nWhen \ndevelopment speed\n of your project is of more concern than raw download or execution speed, you may want to refrain from using the \n\"plain\"\n adapter.\nThis is especially true for widgets containing \ncomplex business UI\n with a lot of form controls, tables, show/hide animations and so on -- these view frameworks exist for a reason.\n\n\nAlso, if you are sure that all of your projects will be created with, say, Vue.JS in the near future, it may be much simpler to just stick with it.\n\n\nFinally, if you are adding some functionality to an existing project, you should probably simply use whatever most of the project is using, even more so if that functionality is not intended for reuse.\n\n\nCreating a \n\"plain\"\n Activity\n\n\nTo keep things simple, let us create an activity that simply logs a message as soon as it receives the \nbeginLifecycleRequest\n event.\n\n\nFor an activity, you just need two files:\n\n\n\n\nthe \nwidget.json\n descriptor,\n\n\nthe controller implementation module.\n\n\n\n\nIn the widget descriptor, make sure to set \nintegration.technology\n to \n\"plain\"\n and \nintegration.type\n to \n\"widget\"\n.\nAlso, pick a \nname\n; we will use \n\"my-activity\"\n for this example of a \nwidget.json\n:\n\n\n{\n\n   \nname\n:\n \nmy-activity\n,\n\n   \nintegration\n:\n \n{\n\n      \ntype\n:\n \nactivity\n,\n\n      \ntechnology\n:\n \nplain\n\n   \n}\n\n\n}\n\n\n\n\n\n\nYou can also add a \nfeatures\n configuration schema, which we will skip here, as it is not specific to the integration technology that is used.\n\n\nNext, create your implementation module, \nmy-activity.js\n:\n\n\nexport\n \nconst\n \ninjections\n \n=\n \n[\n \naxEventBus\n,\n \naxLog\n \n];\n\n\nexport\n \nfunction\n \ncreate\n(\n \neventBus\n,\n \nlog\n \n)\n \n{\n\n   \neventBus\n.\nsubscribe\n(\n \nbeginLifecycleRequest\n,\n \n()\n \n=\n \n{\n\n      \nlog\n.\nwarn\n(\n \nOK, now what?!\n \n);\n\n   \n}\n \n);\n\n\n}\n\n\n\n\n\n\nThat is it: activity modules just need to export their named \ninjections\n along with a \ncreate\n function that has a matching signature.\n\n\nCreating a \n\"plain\"\n Widget\n\n\nLet us now explain how to create a widget by using the following example:\nWe will display a simple text along with a counter.\nFor some reason, we will increment the counter anytime the user clicks on the page.\n\n\nAgain, we start with a \nwidget.json\n descriptor.\nThis time, let us throw in a feature configuration schema as well:\n\n\n{\n\n   \nname\n:\n \nmy-widget\n,\n\n\n   \nintegration\n:\n \n{\n\n      \ntype\n:\n \nwidget\n,\n\n      \ntechnology\n:\n \nplain\n\n   \n},\n\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nlabel\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \ntext\n:\n \n{\n \ntype\n:\n \nstring\n,\n \ndefault\n:\n \nClick Me!\n \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n\n}\n\n\n\n\n\n\nThe HTML Template\n\n\nPut your template under \ndefault.theme/my-widget.html\n, just like you would do for other technologies:\n\n\nh1\nMy Widget says \nspan\n \nclass\n=\nmy-widget-label\n/\nspan\n/\nh1\n\n\n\n\n\n\nNote that since this is a plain widget, \nno preprocessing\n or interpolation of values takes place.\n\n\nThe CSS stylesheet\n\n\nUnless you use a custom theme for your new widget, LaxarJS will be looking for styles in \ndefault.theme/css/my-widget.css\n:\n\n\n.\nmy-widget\n \nh1\n \n{\n\n   \nfont-style\n:\n \nitalic\n;\n\n\n}\n\n\n\n\n\n\nStyles work exactly as they do for other integration technologies, including the ability to namespace by the widget name, as shown here.\nIf your widget does not need custom styles, simply omit the file.\n\n\nThe Widget Controller\n\n\nWhat is missing now is connecting feature configuration and widget template from within the implementation module \nmy-widget.js\n:\n\n\nexport\n \nconst\n \ninjections\n \n=\n \n[\n \naxWithDom\n,\n \naxFeatures\n,\n \naxEventBus\n \n];\n\n\nexport\n \nfunction\n \ncreate\n(\n \nwithDom\n,\n \nfeatures\n,\n \neventBus\n \n)\n \n{\n\n   \nlet\n \nnumClicks\n \n=\n \n0\n;\n\n   \ndocument\n.\nbody\n.\naddEventListener\n(\n \nclick\n,\n \nhandleClick\n \n);\n\n   \neventBus\n.\nsubscribe\n(\n \nendLifecycleRequest\n,\n \n()\n \n=\n \n{\n\n      \ndocument\n.\nbody\n.\nremoveEventListener\n(\n \nclick\n,\n \nhandleClick\n \n);\n\n   \n}\n \n);\n\n   \nreturn\n \n{\n \nonDomAvailable\n:\n \nrender\n \n};\n\n\n   \nfunction\n \nhandleClick\n()\n \n{\n\n      \n++\nnumClicks\n;\n\n      \nrender\n();\n\n   \n}\n\n\n   \nfunction\n \nrender\n()\n \n{\n\n      \nwithDom\n(\n \ndom\n \n=\n \n{\n\n         \ndom\n.\nquerySelector\n(\n \n.label\n \n).\ntextContent\n \n=\n \nnumClicks\n \n===\n \n0\n \n?\n\n            \nfeatures\n.\nlabel\n.\ntext\n \n:\n\n            \n`Clicked \n${\nnumClicks\n}\n times`\n;\n\n      \n}\n \n);\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe controller looks similar to that of an activity, except for the additional return statement and for the injection \naxWithDom\n that the \n\"plain\"\n technology adapter makes available for widgets only.\n\n\n\n\n\n\nthe \nonDomAvailable\n method returned by the widget's \ncreate\n function will be called as soon as the widget DOM was inserted into the page for the first time.\n  If your widget is part of an initially hidden widget area such as a popup window, \nonDomAvailable\n may be called much later than \ncreate\n, or never.\n\n\n\n\n\n\nthe \naxWithDom\n hook guards its callback against the DOM being unavailable while a widget's container area is hidden.\n  The callback will only be executed if the widget DOM is actually attached to the page.\n\n\n\n\n\n\nIf \nrender\n was run only during \nonDomAvailable\n, the \naxWithDom\n injection would not be needed.\nHowever, \nrender\n may be run anytime the user clicks anywhere within the document body.\nGuarding \nrender\n in this way ensures that we do not run into \nnull\n-reference problems in case our containing widget area is hidden.\n\n\nCreating a \n\"plain\"\n Control\n\n\nWhile controls for other technologies directly integrate with their respective component model, using a plain control offers little over directly using \nimport\n (or \nrequire\n) to add a UI library such as the \nDrop Tooltip\n or the \nVelocity Animations Engine\n to your widget.\n\n\nStill, wrapping libraries in \n\"plain\"\n controls has two benefits:\n\n\n\n\nLaxarJS will \nautomatically load their CSS stylesheet\n taking into account the application theme,\n\n\ncontrols for \n\"plain\"\n can be used by widgets written in \nany integration technologies\n.\n\n\n\n\nThis also makes it worthwhile to create controls \njust for styling\n, effectively giving you \nCSS components\n that are loaded as needed by the widgets within your application, and can be overwritten per theme.\n\n\nSo, whenever you create or integrate a non-trivial piece of UI, consider wrapping it as a \nplain\n control, in particular if there are associated CSS styles.\n\n\nThe Control Descriptor\n\n\nLike widgets, controls need a \ncontrol.json\n descriptor containing their \nname\n and \nintegration.technology\n.\n\n\nThe Control Implementation Module\n\n\nLaxarJS does not impose restrictions on control implementation modules, except that they must be named as determined by the descriptor.\nWhatever you \nexport\n from your control module will be accessible from widgets using your control.\nUsually, you should export some kind of constructor or a \ncreate\n function that widget authors can then invoke with a DOM node and/or customization options.\n\n\nThe Control Stylesheet\n\n\nLaxarJS will automatically bundle CSS styles for controls \nif\n they are located in the right place.\nUsing the \ndefault.theme\n, styles for a control \nmy-control\n would be read from the control folder under \ndefault.theme/css/my-control.css\n.\nNote that controls do not receive themed HTML.\nHowever, they can use \nimport\n or \nrequire\n to load HTML through the \nraw-loader\n provided by webpack.\n\n\nAccessing a Control from a Widget\n\n\nWidgets of any implementation technology can use the \naxControls\n injections to obtain their control implementation modules.\nUsing \naxControls.provide( name )\n, they can obtain the modules by \nname\n like in the \ncontrols\n section of their widget descriptor.\n\n\nMore Information\n\n\n\n\nAPI: \naxControls\n widget service\n\n\nManual: Providing Controls", 
            "title": "The <code>&quot;plain&quot;</code> Integration Technology"
        }, 
        {
            "location": "/manuals/plain_adapter/#the-plain-integration-technology", 
            "text": "\u00ab return to the manuals  While LaxarJS allows you to adapt external MVC frameworks for writing widgets, sometimes that is not actually needed.\nEspecially when creating activities, often there is no reason to use something like Angular or Vue.js.\nThe  \"plain \" technology is for widgets that simply rely on what the browser has to offer.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Widgets Services", 
            "title": "The \"plain\" Integration Technology"
        }, 
        {
            "location": "/manuals/plain_adapter/#when-to-use-the-plain-technology", 
            "text": "The  \"plain\"  integration technology is supported by LaxarJS out-of-the-box without having to add any adapter to a project.\nThis minimizes the  footprint  of widgets -- great if they are to be used from projects that may already be using one or more integration technologies.\nAlso, a reduced number of dependencies will likely improve  compatibility. \nFor example, if a widget relies on  \"angular2\" , it might not work within projects that use upcoming major versions of Angular.  Also,  \"plain\"  is a great choice for  activities: \nThese do not benefit as much from MVC frameworks, except maybe from their utility services (such as  $http  provided by AngularJS).  Finally, using  \"plain\"  may be the best option if you are interfacing with the DOM directly, for example when   you would like to mainly use  canvas ,  video  or even  WebGL  for your UI,  you would like to programmatically manipulate the DOM, using custom animations or maybe  D3  charts.   In these use cases, even well-designed view frameworks sometimes just get in the way.", 
            "title": "When to Use the \"plain\" Technology?"
        }, 
        {
            "location": "/manuals/plain_adapter/#when-to-avoid-the-plain-technology", 
            "text": "When  development speed  of your project is of more concern than raw download or execution speed, you may want to refrain from using the  \"plain\"  adapter.\nThis is especially true for widgets containing  complex business UI  with a lot of form controls, tables, show/hide animations and so on -- these view frameworks exist for a reason.  Also, if you are sure that all of your projects will be created with, say, Vue.JS in the near future, it may be much simpler to just stick with it.  Finally, if you are adding some functionality to an existing project, you should probably simply use whatever most of the project is using, even more so if that functionality is not intended for reuse.", 
            "title": "When to Avoid the \"plain\" Technology?"
        }, 
        {
            "location": "/manuals/plain_adapter/#creating-a-plain-activity", 
            "text": "To keep things simple, let us create an activity that simply logs a message as soon as it receives the  beginLifecycleRequest  event.  For an activity, you just need two files:   the  widget.json  descriptor,  the controller implementation module.   In the widget descriptor, make sure to set  integration.technology  to  \"plain\"  and  integration.type  to  \"widget\" .\nAlso, pick a  name ; we will use  \"my-activity\"  for this example of a  widget.json :  { \n    name :   my-activity , \n    integration :   { \n       type :   activity , \n       technology :   plain \n    }  }   You can also add a  features  configuration schema, which we will skip here, as it is not specific to the integration technology that is used.  Next, create your implementation module,  my-activity.js :  export   const   injections   =   [   axEventBus ,   axLog   ];  export   function   create (   eventBus ,   log   )   { \n    eventBus . subscribe (   beginLifecycleRequest ,   ()   =   { \n       log . warn (   OK, now what?!   ); \n    }   );  }   That is it: activity modules just need to export their named  injections  along with a  create  function that has a matching signature.", 
            "title": "Creating a \"plain\" Activity"
        }, 
        {
            "location": "/manuals/plain_adapter/#creating-a-plain-widget", 
            "text": "Let us now explain how to create a widget by using the following example:\nWe will display a simple text along with a counter.\nFor some reason, we will increment the counter anytime the user clicks on the page.  Again, we start with a  widget.json  descriptor.\nThis time, let us throw in a feature configuration schema as well:  { \n    name :   my-widget , \n\n    integration :   { \n       type :   widget , \n       technology :   plain \n    }, \n\n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          label :   { \n             type :   object , \n             properties :   { \n                text :   {   type :   string ,   default :   Click Me!   } \n             } \n          } \n       } \n    }  }", 
            "title": "Creating a \"plain\" Widget"
        }, 
        {
            "location": "/manuals/plain_adapter/#the-html-template", 
            "text": "Put your template under  default.theme/my-widget.html , just like you would do for other technologies:  h1 My Widget says  span   class = my-widget-label / span / h1   Note that since this is a plain widget,  no preprocessing  or interpolation of values takes place.", 
            "title": "The HTML Template"
        }, 
        {
            "location": "/manuals/plain_adapter/#the-css-stylesheet", 
            "text": "Unless you use a custom theme for your new widget, LaxarJS will be looking for styles in  default.theme/css/my-widget.css :  . my-widget   h1   { \n    font-style :   italic ;  }   Styles work exactly as they do for other integration technologies, including the ability to namespace by the widget name, as shown here.\nIf your widget does not need custom styles, simply omit the file.", 
            "title": "The CSS stylesheet"
        }, 
        {
            "location": "/manuals/plain_adapter/#the-widget-controller", 
            "text": "What is missing now is connecting feature configuration and widget template from within the implementation module  my-widget.js :  export   const   injections   =   [   axWithDom ,   axFeatures ,   axEventBus   ];  export   function   create (   withDom ,   features ,   eventBus   )   { \n    let   numClicks   =   0 ; \n    document . body . addEventListener (   click ,   handleClick   ); \n    eventBus . subscribe (   endLifecycleRequest ,   ()   =   { \n       document . body . removeEventListener (   click ,   handleClick   ); \n    }   ); \n    return   {   onDomAvailable :   render   }; \n\n    function   handleClick ()   { \n       ++ numClicks ; \n       render (); \n    } \n\n    function   render ()   { \n       withDom (   dom   =   { \n          dom . querySelector (   .label   ). textContent   =   numClicks   ===   0   ? \n             features . label . text   : \n             `Clicked  ${ numClicks }  times` ; \n       }   ); \n    }  }   The controller looks similar to that of an activity, except for the additional return statement and for the injection  axWithDom  that the  \"plain\"  technology adapter makes available for widgets only.    the  onDomAvailable  method returned by the widget's  create  function will be called as soon as the widget DOM was inserted into the page for the first time.\n  If your widget is part of an initially hidden widget area such as a popup window,  onDomAvailable  may be called much later than  create , or never.    the  axWithDom  hook guards its callback against the DOM being unavailable while a widget's container area is hidden.\n  The callback will only be executed if the widget DOM is actually attached to the page.    If  render  was run only during  onDomAvailable , the  axWithDom  injection would not be needed.\nHowever,  render  may be run anytime the user clicks anywhere within the document body.\nGuarding  render  in this way ensures that we do not run into  null -reference problems in case our containing widget area is hidden.", 
            "title": "The Widget Controller"
        }, 
        {
            "location": "/manuals/plain_adapter/#creating-a-plain-control", 
            "text": "While controls for other technologies directly integrate with their respective component model, using a plain control offers little over directly using  import  (or  require ) to add a UI library such as the  Drop Tooltip  or the  Velocity Animations Engine  to your widget.  Still, wrapping libraries in  \"plain\"  controls has two benefits:   LaxarJS will  automatically load their CSS stylesheet  taking into account the application theme,  controls for  \"plain\"  can be used by widgets written in  any integration technologies .   This also makes it worthwhile to create controls  just for styling , effectively giving you  CSS components  that are loaded as needed by the widgets within your application, and can be overwritten per theme.  So, whenever you create or integrate a non-trivial piece of UI, consider wrapping it as a  plain  control, in particular if there are associated CSS styles.", 
            "title": "Creating a \"plain\" Control"
        }, 
        {
            "location": "/manuals/plain_adapter/#the-control-descriptor", 
            "text": "Like widgets, controls need a  control.json  descriptor containing their  name  and  integration.technology .", 
            "title": "The Control Descriptor"
        }, 
        {
            "location": "/manuals/plain_adapter/#the-control-implementation-module", 
            "text": "LaxarJS does not impose restrictions on control implementation modules, except that they must be named as determined by the descriptor.\nWhatever you  export  from your control module will be accessible from widgets using your control.\nUsually, you should export some kind of constructor or a  create  function that widget authors can then invoke with a DOM node and/or customization options.", 
            "title": "The Control Implementation Module"
        }, 
        {
            "location": "/manuals/plain_adapter/#the-control-stylesheet", 
            "text": "LaxarJS will automatically bundle CSS styles for controls  if  they are located in the right place.\nUsing the  default.theme , styles for a control  my-control  would be read from the control folder under  default.theme/css/my-control.css .\nNote that controls do not receive themed HTML.\nHowever, they can use  import  or  require  to load HTML through the  raw-loader  provided by webpack.", 
            "title": "The Control Stylesheet"
        }, 
        {
            "location": "/manuals/plain_adapter/#accessing-a-control-from-a-widget", 
            "text": "Widgets of any implementation technology can use the  axControls  injections to obtain their control implementation modules.\nUsing  axControls.provide( name ) , they can obtain the modules by  name  like in the  controls  section of their widget descriptor.  More Information   API:  axControls  widget service  Manual: Providing Controls", 
            "title": "Accessing a Control from a Widget"
        }, 
        {
            "location": "/manuals/upgrade_guide/", 
            "text": "Upgrading LaxarJS\n\n\nThe LaxarJS packages use \nsemantic versioning\n, so as long as you upgrade \nwithin\n a major version of LaxarJS or one of the associated libraries and widgets, you should not have any problems.\n\n\nOf course, sometimes minor changes introduce bugs or new, (hopefully) better way to do things within applications.\nTo get the full details of what happens between versions, consult the \nchangelogs\n.\nA \nCHANGELOG.md\n file is maintained in each of our repositories, and accessible from the \ndocumentation site\n.\nWhenever a change comes with associated upgrade information, the changelog will mention this, and contain a pointer to the relevant GitHub issue.\nNote however, that sometimes individual changelog entries may be reverted or made obsolete by later changes.\n\n\nKeeping in mind that only the changelogs contain the complete upgrade information with all the gritty details, this guide tries to give you the big picture of what happened between major versions.\nIt also tries to give a short rationale for each change, so that you know why we think the upgrade effort is justified.\n\n\nMigration Guide: LaxarJS v1.x to LaxarJS v2.x\n\n\nUnder the hood, LaxarJS v2 is a \nmajor refactoring\n of LaxarJS.\nIn the process of this refactoring, \nAngularJS was removed\n as a core dependency, and stateful APIs such as logging were changed to become \ninjectable services.\n\nThis improves testability, and allows technology adapters to freely intercept and modify widget injections.\nIt also enables multiple LaxarJS applications to run alongside each other within a single browser window.\n\n\nFortunately, for existing widgets, not that much has changed:\nAngularJS widgets now require an adapter (see below), and some APIs that were previously accessed as properties of the LaxarJS object will now need to be injected into the widget controller.\n\n\nCleaning up widget spec tests may require a little more work, since \nLaxarJS Mocks\n was cleaned up significantly.\n\n\nMajor Versions in Lockstep\n\n\nThe following libraries have their \nmajor version locked\n to that of \nLaxarJS Core\n itself:\n\n\n\n\nnpm: laxar-mocks\n\n\nnpm: laxar-patterns\n\n\nnpm: laxar-tooling\n\n\nnpm: laxar-loader\n\n\nnpm: laxar-infrastructure\n\n\nnpm: laxar-react-adapter\n\n\nnpm: laxar-vue-adapter\n\n\nnpm: laxar-angular-adapter\n\n\nnpm: laxar-angular2-adapter\n\n\nnpm: laxar-uikit\n\n\n\n\nThis means, that for these libraries\u2026\n\n\n\n\ntheir v2.0 is released (roughly) around the same time as LaxarJS Core v2.0,\n\n\ntheir v2.0 is compatible with LaxarJS Core v2.0.\n\n\n\n\nFor other packages, especially widgets and controls, this is not true.\nWhen in doubt, always consult the \npackage.json\n of the respective artifact.\n\n\nTooling: npm and webpack\n\n\nThis should not affect widgets and activities too much directly, but will require to rebuild some project infrastructure and configuration.\n\n\nLaxarJS v1 projects used:\n\n\n\n\nBower\n to obtain front end application artifacts,\n\n\nRequireJS\n to load modules,\n\n\nnpm, Grunt, grunt-laxar\n and various grunt plugins to obtain and run the project build pipeline.\n\n\n\n\nFor LaxarJS v2, we wanted to support pre-built artifacts whose sources may be written in ES2015 or other \"compile-to-js\" languages, as well as artifacts that add dependencies to the development toolchain.\n\n\nBower is not really a good fit for pre-built artifacts, as it is always \nbacked by sources\n on GitHub.\nRather than adding more \"build repositories\", we chose to switch to npm for front end artifacts, which was already required for the tooling infrastructure anyway.\nIn order to integrate seamlessly with workflows using \nES2015\n and \nSCSS\n, we switched from a collection of custom grunt tasks to a build infrastructure based around \nwebpack\n.\n\n\nSo, the new list of tools looks like this:\n\n\n\n\nnpm\n to obtain front end artifacts as well as build-time dependencies\n\n\nwebpack\n and its loaders (especially the \nlaxar-loader\n) to load and bundle artifacts\n\n\n\n\nThis saves us a lot of work maintaining grunt plugins: laxar-tooling and laxar-loader are much smaller than grunt-laxar.\nIt also makes custom build setups much simpler, as it unlocks the full array of \nwebpack plugins\n for loading widgets, controls and their assets.\nWhere needed, it is of course still possible\n\n\nMore Information:\n\n\n\n\nManual: Infrastructure and Tools\n\n\nManual: Installing Widgets\n\n\nwebpack website\n\n\nnpm: laxar-loader\n\n\nnpm: laxar-tooling\n\n\n\n\nJSON Schema now Processed \nat build-time\n\n\nLaxarJS feature configuration for widgets, activities and compositions is no longer processed at runtime, but while loading the application artifacts using the \nlaxar-loader\n for webpack.\nThis allows us to replace the \njjv\n validator with the \najv\n validator which is more actively maintained, more feature-rich and apparently more performant.\nSimultaneously we save on bundle size and startup time, as neither the validator nor any widget schema instances need to be loaded or interpreted within the browser.\n\n\nNote that LaxarJS deviates from standard JSON schema in two respects.\nThis was the case with jjv, and we ported the deviations to ajv:\n\n\n\n\n\"additionalProperties\": false\n is default for all schemas of \n\"type\": \"object\"\n,\n\n\n\"format\"\n allows for the LaxarJS specific value \n\"topic\"\n, and checks it,\n\n\ndefaults for features (first level of widget/composition schema) are inferred if they are of type \n\"array\"\n or \n\"object\"\n,\n\n\nsupport for \n${topic:\u2026}\n and \n${features.\u2026}\n syntax in compositions, before applying format checks.\n\n\n\n\nMore Information:\n\n\n\n\nManual: Widgets and Activities\n\n\najv website\n\n\n\n\nAngularJS Support Moved to Standalone Adapter Project\n\n\nThe LaxarJS runtime no longer depends on functionality provided by AngularJS.\nWriting widgets using AngularJS works just like before, you just need to:\n\n\n\n\nadd the \nlaxar-angular-adapter\n to your project:\n\n\n\n\nconsole\n  npm install --save laxar-angular-adapter`\n\n\n\n\npass it to \ncreate\n using the \nadapters\n option.\n\n\n\n\nMore Information:\n\n\n\n\nAPI: \nlaxar.create\n\n\n\n\nAngularJS: axLayout Control Removed\n\n\nBecause layouts are now first-class items in widget areas, directly embedding them in widgets unnecessarily complicates the implementation of both widgets and runtime.\nWidgets should simply offer \nwidget areas,\n which can then be configured by the page to contain layouts.\n\n\nMore Information:\n\n\n\n\nGitHub: LaxarJS/laxar#272\n\n\n\n\nAngularJS: ngSanitize no longer loaded by default\n\n\nNot every application needs \nangular-sanitize\n to secure dynamically loaded HTML.\nIf you are using a widget that relies on ngSanitize, you need to manually install \nangular-sanitize\n and load it from the corresponding widget or control.\n\n\nMore Information:\n\n\n\n\nGitHub: LaxarJS/laxar-angular-adapter#41\n\n\n\n\nApplication Configuration: \nwindow.laxar\n is No More\n\n\nLaxarJS is no longer using a global object property for configuration.\nThis improves testability and allows to run multiple LaxarJS instances side-by-side.\nPass your configuration values to \ncreate\n instead, using the last parameter (\nconfiguration\n).\n\n\nMore Information:\n\n\n\n\nAPI: \nlaxar.create\n\n\n\n\nArtifact Directory Defaults Changed\n\n\nWith the new tooling infrastructure, \nall artifact types\n (themes, flows, pages, layouts, widgets, controls) will be expected to reside within the respective sub-folders of \napplication/\n within your project.\nPreviously, widgets, controls and themes were expected to reside in sub-folders of \nincludes/\n.\nThis behavior can be customized by creating a \nlaxar.config.js\n in your project and exporting the corresponding \npaths.flows\n, \npaths.pages\n and so on from there.\n\n\nMore Information:\n\n\n\n\nlaxar-loader Manual\n\n\n\n\nStyles/Templates for Widgets/Controls Lookup \nby Name Only\n\n\nPreviously, LaxarJS used several heuristics to derive the \nname\n of activities/widgets, layouts, controls or themes from their file system path segment.\nThe name is needed to find the JavaScript implementation module, CSS stylesheet and HTML template (for widgets and layouts) of an artifact.\n\n\nNow, widgets and controls must always provide a descriptor (\nwidget.json\n, \ncontrol.json\n) with a \nname\n property.\nThat name is then used to load the implementation module from the directory of the descriptor, as well as themed assets from the appropriate sub-directories.\nHere, the \nresolve\n configuration of webpack comes into play, which allows projects using Angular 2 or Vue.js to transparently load implementations from \n.ts\n or \n.vue\n files.\n\n\nUsing explicit names instead of incidental file system locations makes artifacts robust against being moved, and for being used in different contexts.\nIt also eliminates confusion regarding the name of directories and files when styling artifacts from within a theme.\n\n\nAn exception is made for loading the implementation module of widgets that have a \npackage.json\n:\nTo allow these widgets to be pre-compiled from \"compile-to-js\" languages, they may use the \n\"browser\"\n field of their \npackage.json\n to specify the location of their implementation module.\n\n\nMore Information:\n\n\n\n\nAssets and the Artifacts Bundle\n\n\n\n\nSeveral LaxarJS APIs moved to Injectable Services\n\n\nPreviously, LaxarJS offered several stateful APIs as part of its exported API.\nThese were replaced by injectable widget services as follows:\n\n\n\n\nlaxar.configuration\n -\n \naxConfiguration\n\n\nlaxar.log\n -\n \naxLog\n\n\nlaxar.i18n\n -\n \naxI18n\n\n\nlaxar.storage\n -\n \naxStorage\n\n\n\n\nThis change improves testability and allows to run multiple instances of LaxarJS on the same page.\nDuring your transition to LaxarJS v2, you can use the \ndist/laxar-compatibility.js\n entry point, which adds shims for the missing APIs.\nNote that the compatibility entry point is intended only for use during a migration and not part of the official API.\nThis means that it \nmay be removed\n in upcoming minor versions.\n\n\nThe stateless utility APIs \nassert\n, \nobject\n and \nstring\n are not affected by this change.\n\n\nMore Information:\n\n\n\n\nAPI: Widget Services\n\n\nAPI: Widget Service Mocks\n for testing\n\n\n\n\nFlow Definition: Format Changed\n\n\nThe flow definition files have a new format that clearly distinguishes between place IDs and URL mappings.\nThis also allows to map multiple URL patterns to the same place, and to specify place parameter values for redirects.\n\n\nAlso, the syntax for routing pattern definition has changed slightly, as LaxarJS now uses \nNavigo\n for routing.\n\n\nMore Information:\n\n\n\n\nManual: Flow and Places\n\n\nGitHub: LaxarJS/laxar#432\n\n\nGitHub: LaxarJS/laxar#381\n\n\n\n\nFlow Definition: Removed entryPoint / exitPoint features\n\n\nThese features were hard-to-explain in manuals as they cater to a very narrow set of integration use cases.\nEntry points can be replaced by using \nentry pages\n containing an activity that fires navigation events.\nExit points can be replaced by simply adding an activity that invokes the external API previously triggered by the exit point.\n\n\nMore Information:\n\n\n\n\nManual: Flow and Places\n\n\nGitHub: LaxarJS/laxar#392\n\n\n\n\nFlow: Default Router Changed from Angular $route to Navigo\n\n\nBecause AngularJS was removed from LaxarJS core, we no longer use AngularJS \n$route\n for routing.\nRather than creating our own standalone routing library, LaxarJS now depends on the \nNavigo\n routing microlibrary.\nWe also evaluated \npage.js\n by visionmedia, but due to the recent lack of project activity we think that Navigo is the right choice for now.\nIn the near-future, we plan on making routers pluggable.\nThis will be especially useful if your UI framework comes with a router anyway.\n\n\nMore Information:\n\n\n\n\nManual: Flow and Places\n\n\nhttps://www.npmjs.com/package/navigo\n\n\n\n\naxFlowService: constructPath, constructAnchor removed\n\n\nThe methods \nconstructPath\n and \nconstructAnchor\n were removed because they are not portable across routing setups using hash-based and path-based navigation.\nYou should always use \nconstructAbsoluteUrl\n to create links within a LaxarJS application.\n\n\nMore Information:\n\n\n\n\nManual: Infrastructure and Tools\n\n\nManual: Assets and the Artifacts Bundle\n\n\nwebpack website\n\n\n\n\naxFlowService: No More Trailing \n'_'\n\n\nWhen \ngenerating\n URLs where values of trailing parameters are missing, this no longer results in trailing underscores.\nMake sure to structure your routing patterns to handle these URLs, or avoid them by always populating the respective place parameters.\n\n\nMore Information:\n\n\n\n\nGitHub LaxarJS/laxar#389\n\n\n\n\nPage Definition: builtin areas now use \nax\n prefix\n\n\nThe builtin/auto-generated widget areas (\nactivities\n, \npopups\n, \npopovers\n) were renamed (to \naxActivities\n, \naxPopups\n, \naxPopovers\n) to draw attention to the fact that they are automatically provided by LaxarJS.\nHopefully, this saves new developers from wasting time looking for the responsible layout.\n\n\nMore Information:\n\n\n\n\nManual: Writing Pages\n\n\nGitHub LaxarJS/laxar#461\n\n\n\n\nWidget Descriptor: new \nstyleSource\n and \ntemplateSource\n\n\nPreviously, SCSS had to be integrated by using the \ngrunt-laxar-compass\n package, which required generated CSS to be committed to version control.\nNow, SCSS can be processed by setting the \nstyleSource\n attribute of the widget.json descriptor.\nThis allows for arbitrary compile-to-css languages (such as LESS).\n\n\nAlso, the grunt plugin was notoriously unreliable in watching transitive SCSS import dependencies, which is no longer the case when using webpack with the \nsass-loader\n.\nThe Yeoman Generator generates appropriate webpack dependencies and configuration out-of-the-box.\n\n\nAdditionally, \ntemplateSource\n can be used to preprocess widget HTML templates.\nThis allows to use HTML generators such as \npug\n to preprocess widget templates.\n\n\nMore Information:\n\n\n\n\nManual: Flow and Places\n\n\nwebpack website\n\n\n\n\naxVisibility: new widget service injection\n\n\nDealing with visibility events in LaxarJS v1 was too much voodoo.\nThe new \naxVisibility\n widget injection hopefully simplifies things.\nTo deal with visibility, the new injection is recommended over LaxarJS Patterns \nvisibility\n and over using the event bus directly.\n\n\nMore Information:\n\n\n\n\nManual: Visibility Events\n\n\nAPI: \naxVisibility\n widget service\n\n\nAPI: \naxVisibility\n mock\n for testing\n\n\nGitHub: LaxarJS/laxar#333\n\n\n\n\naxI18n: new widget service injection\n\n\nDealing with internationalization has been further simplified and detangled from AngularJS by the new \naxI18n\n injection.\nAlso, the new injection is instantiated per bootstrapping instance, so that multiple LaxarJS applications can coexist in a browser window, and even use different locales.\nTo deal with i18n, the new injection is recommended over LaxarJS Patterns \ni18n\n and over using the event bus directly.\n\n\nMore Information:\n\n\n\n\nManual: I18n\n\n\nAPI: \naxI18n\n widget service\n\n\nAPI: \naxI18n\n mock\n for testing\n\n\nGitHub: LaxarJS/laxar#332\n\n\nGitHub: LaxarJS/laxar#333\n\n\nGitHub: LaxarJS/laxar#429\n\n\n\n\nReplace \nrequire.toUrl()\n using \naxAssets\n\n\nLaxarJS no longer depends on RequireJS, and it is not recommended to mix RequireJS with webpack either.\nSome widgets may use the \ntoUrl\n-method provided by RequireJS for generating absolute URLs.\nAs this method constructs URLs at runtime, it is not supported by webpack.\n\n\nYou may wish to use webpack to pre-bundle smaller assets within a reusable widget that has its own \npackage.json\n and build-setup.\nIn general, it is recommended to use the \naxAssets\n injection instead.\n\n\nMore Information:\n\n\n\n\nManual: Assets and the Artifacts Bundle\n\n\nManual: Infrastructure and Tools\n\n\nAPI: \naxAssets\n widget service\n\n\nAPI: \naxAssets\n Mock\n\n\nwebpack website\n\n\n\n\naxEventBus: removed methods: \nunsubscribe\n, \nsetMediator\n, \nsetErrorHandler\n\n\nThe LaxarJS event bus no longer allows to register a mediator, as this feature was never used.\nConfiguring a custom error handler was removed from the public API as well, with its use case (testing) supported by a pre-configured event bus mock.\n\n\nUsing \nunsubscribe\n was usually not required except when using the \naxGlobalEventBus\n injection.\nTo cancel an event bus subscription, you must now use the callback returned by \naxEventBus.subscribe\n.\nThis avoids possible problems with trying to using the old \nunsubscribe\n on decorated subscriber functions.\n\n\nMore Information:\n\n\n\n\nManual: Assets and the Artifacts Bundle\n\n\nManual: Infrastructure and Tools\n\n\nAPI: \naxAssets\n widget service\n\n\nAPI: \naxAssets\n Mock\n\n\n\n\nWidget adapter API changed\n\n\nThe widget adapter API was rewritten to make adapters more powerful.\nThe two most important changes:\n\n\n\n\ncreating an adapter for a widget instance may now be asynchronous\n\n\nwidget adapters may now freely intercept and modify widget service injections\n\n\n\n\nMore Information:\n\n\n\n\nManual: Creating Widget Adapters\n\n\nAPI: the \"plain\" Widget Adapter\n\n\nGitHub: LaxarJS/laxar#413\n\n\nGitHub: LaxarJS/laxar#398\n\n\nGitHub: LaxarJS/laxar#397\n\n\nGitHub: LaxarJS/laxar#396\n\n\nGitHub: LaxarJS/laxar#390\n\n\nGitHub: LaxarJS/laxar#358\n\n\nGitHub: LaxarJS/laxar#337\n\n\nGitHub: LaxarJS/laxar#281\n\n\n\n\nLaxarJS Mocks: Static HTML Test Runner is No More\n\n\nBecause widget dependencies are no longer loaded at runtime by RequireJS, the recommended setup for testing widgets using LaxarJS Mocks has changed significantly:\n\n\n\n\nno more copy/paste of HTML spec runner files\n\n\nuse the laxar-mocks/spec-loader for webpack to precompile widget dependencies\n\n\nno more need to declare \"missing\" CSS assets of controls\n\n\nrun tests on the command-line using karma and karma-webpack\n\n\nrun tests within the browser using the webpack-jasmine-html-runner-plugin\n\n\n\n\nMore Information:\n\n\n\n\nLaxarJS Mocks Manual\n\n\nLaxarJS Mocks Manual: Setup\n\n\nLaxarJS Mocks API\n\n\n\n\nLaxarJS Mocks: Use \naxMocks.widget.setupForWidget\n\n\nTo clarify that test fixtures are now provided automatically and in advance (e.g. by the LaxarJS Mocks spec-loader for webpack), the testbed should now be created using \nsetupForWidget\n.\n\n\n\n\nLaxarJS Mocks API: setupForWidget\n\n\n\n\nLaxarJS Mocks: \naxMocks.widget.teardown\n is now Asynchronous\n\n\nTo clean up correctly after tests, LaxarJS mocks publishes the \nendLifecycleRequest\n event after each tests and allows the widget under test to perform cleanup before proceeding.\n\n\n\n\nLaxarJS Mocks API: tearDown\n\n\n\n\nLaxarJS Patterns: \npatches\n API removed\n\n\nThe deprecated \npatches\n API was removed.\nUse JSON patch instead.\n\n\n\n\nGitHub: LaxarJS/laxar-patterns#84\n\n\n\n\nLaxarJS Patterns: \nresources\n API: removed \nupdateHandler\n, \nreplaceHandler\n\n\nUse \nhandlerFor( context )\n instead (or \n$scope\n instead of context for AngularJS widgets).\n\n\n\n\nGitHub: LaxarJS/laxar-patterns#85\n\n\n\n\nLaxarJS Patterns: \nactions\n API: use Promise Rejections Correctly\n\n\nActions publisher promises are no longer rejected for actions with an ERROR outcome, caused by e.g. validation failure.\nInstead, promises will only be rejected when subscribers fail with an exception.\n\n\n\n\nGitHub: LaxarJS/laxar-patterns#54\n\n\n\n\nLaxarJS Patterns: Various Breaking Changes\n\n\nMost likey, only very few widgets are affected by the remaining breaking changes.\nConsult the Changelog for details:\n\n\n\n\nLaxarJS Patterns: Changelog\n\n\n\n\nLaxarJS UiKit: I18n Controls Removed\n\n\nThe controls contained in LaxarJS UiKit were locked to the \n\"angular\"\n integration technology.\nThe \naxLocalize\n filter for AngularJS is now included in the \nlaxar-angular-adapter\n.\n\n\n\n\nGitHub: LaxarJS/laxar-angular-adapter#38\n\n\n\n\nBrowser Support\n\n\nSupport for MS Internet Explorer 9 was dropped.\nLaxarJS v2 relies on dynamic property getters, which are not available for MSIE 8 and cannot be polyfilled.\nIn principle, MSIE 9 may still be working, but we are not actively supporting it.\n\n\nOther than that, since LaxarJS no longer directly depends on AngularJS, it may actually be possible to support more browsers than in past major versions.\n\n\nMore Information:\n\n\n\n\nGitHub: LaxarJS/laxar#349\n\n\n\n\nMigration Guide: LaxarJS v0.x to LaxarJS v1.x\n\n\nAccording to semantic versioning, minor versions starting with \nv0.\n may introduce breaking changes.\nWe tried to avoid that as much as possible during our own \nv0.x\n releases, but depending on where you start off, only some of these items will be relevant for you.\nSince LaxarJS \nv0.x\n was not used that much, this information is kept short:\n\n\n\n\n\n\nSupport for MS Internet Explorer 8 was dropped.\n\n\n\n\n\n\nThe format of \ndidUpdate\n events was changed from \"update maps\" to the standard \nJSON patch\n format.\n  When upgrading any complex application, this is probably the most work-intensive change.\n\n\n\n\n\n\nThe JSON schema format for widgets was changed from v3 to v4, with a compatibility fallback.\n\n\n\n\n\n\nThe \nlaxar.text\n helper was removed.\n\n\n\n\n\n\nLocation and naming of HTML templates and CSS stylesheets was unified across artifacts.\n\n\n\n\n\n\nSome of the name-mangling magic was removed when translating artifact names to file names or AngularJS module names.\n\n\n\n\n\n\nThe testing library built into LaxarJS core was deprecated in favor of \nLaxarJS Mocks\n.\n\n\n\n\n\n\nControls\n became a themable artifact type, with the \ncontrol.json\n as a descriptor.\n\n\n\n\n\n\nAngularJS was upgraded from 1.2.x to (at least) 1.3.x.\n\n\n\n\n\n\nFor all the details, consult the changelog.", 
            "title": "Upgrading LaxarJS"
        }, 
        {
            "location": "/manuals/upgrade_guide/#upgrading-laxarjs", 
            "text": "The LaxarJS packages use  semantic versioning , so as long as you upgrade  within  a major version of LaxarJS or one of the associated libraries and widgets, you should not have any problems.  Of course, sometimes minor changes introduce bugs or new, (hopefully) better way to do things within applications.\nTo get the full details of what happens between versions, consult the  changelogs .\nA  CHANGELOG.md  file is maintained in each of our repositories, and accessible from the  documentation site .\nWhenever a change comes with associated upgrade information, the changelog will mention this, and contain a pointer to the relevant GitHub issue.\nNote however, that sometimes individual changelog entries may be reverted or made obsolete by later changes.  Keeping in mind that only the changelogs contain the complete upgrade information with all the gritty details, this guide tries to give you the big picture of what happened between major versions.\nIt also tries to give a short rationale for each change, so that you know why we think the upgrade effort is justified.", 
            "title": "Upgrading LaxarJS"
        }, 
        {
            "location": "/manuals/upgrade_guide/#migration-guide-laxarjs-v1x-to-laxarjs-v2x", 
            "text": "Under the hood, LaxarJS v2 is a  major refactoring  of LaxarJS.\nIn the process of this refactoring,  AngularJS was removed  as a core dependency, and stateful APIs such as logging were changed to become  injectable services. \nThis improves testability, and allows technology adapters to freely intercept and modify widget injections.\nIt also enables multiple LaxarJS applications to run alongside each other within a single browser window.  Fortunately, for existing widgets, not that much has changed:\nAngularJS widgets now require an adapter (see below), and some APIs that were previously accessed as properties of the LaxarJS object will now need to be injected into the widget controller.  Cleaning up widget spec tests may require a little more work, since  LaxarJS Mocks  was cleaned up significantly.", 
            "title": "Migration Guide: LaxarJS v1.x to LaxarJS v2.x"
        }, 
        {
            "location": "/manuals/upgrade_guide/#major-versions-in-lockstep", 
            "text": "The following libraries have their  major version locked  to that of  LaxarJS Core  itself:   npm: laxar-mocks  npm: laxar-patterns  npm: laxar-tooling  npm: laxar-loader  npm: laxar-infrastructure  npm: laxar-react-adapter  npm: laxar-vue-adapter  npm: laxar-angular-adapter  npm: laxar-angular2-adapter  npm: laxar-uikit   This means, that for these libraries\u2026   their v2.0 is released (roughly) around the same time as LaxarJS Core v2.0,  their v2.0 is compatible with LaxarJS Core v2.0.   For other packages, especially widgets and controls, this is not true.\nWhen in doubt, always consult the  package.json  of the respective artifact.", 
            "title": "Major Versions in Lockstep"
        }, 
        {
            "location": "/manuals/upgrade_guide/#tooling-npm-and-webpack", 
            "text": "This should not affect widgets and activities too much directly, but will require to rebuild some project infrastructure and configuration.  LaxarJS v1 projects used:   Bower  to obtain front end application artifacts,  RequireJS  to load modules,  npm, Grunt, grunt-laxar  and various grunt plugins to obtain and run the project build pipeline.   For LaxarJS v2, we wanted to support pre-built artifacts whose sources may be written in ES2015 or other \"compile-to-js\" languages, as well as artifacts that add dependencies to the development toolchain.  Bower is not really a good fit for pre-built artifacts, as it is always  backed by sources  on GitHub.\nRather than adding more \"build repositories\", we chose to switch to npm for front end artifacts, which was already required for the tooling infrastructure anyway.\nIn order to integrate seamlessly with workflows using  ES2015  and  SCSS , we switched from a collection of custom grunt tasks to a build infrastructure based around  webpack .  So, the new list of tools looks like this:   npm  to obtain front end artifacts as well as build-time dependencies  webpack  and its loaders (especially the  laxar-loader ) to load and bundle artifacts   This saves us a lot of work maintaining grunt plugins: laxar-tooling and laxar-loader are much smaller than grunt-laxar.\nIt also makes custom build setups much simpler, as it unlocks the full array of  webpack plugins  for loading widgets, controls and their assets.\nWhere needed, it is of course still possible  More Information:   Manual: Infrastructure and Tools  Manual: Installing Widgets  webpack website  npm: laxar-loader  npm: laxar-tooling", 
            "title": "Tooling: npm and webpack"
        }, 
        {
            "location": "/manuals/upgrade_guide/#json-schema-now-processed-at-build-time", 
            "text": "LaxarJS feature configuration for widgets, activities and compositions is no longer processed at runtime, but while loading the application artifacts using the  laxar-loader  for webpack.\nThis allows us to replace the  jjv  validator with the  ajv  validator which is more actively maintained, more feature-rich and apparently more performant.\nSimultaneously we save on bundle size and startup time, as neither the validator nor any widget schema instances need to be loaded or interpreted within the browser.  Note that LaxarJS deviates from standard JSON schema in two respects.\nThis was the case with jjv, and we ported the deviations to ajv:   \"additionalProperties\": false  is default for all schemas of  \"type\": \"object\" ,  \"format\"  allows for the LaxarJS specific value  \"topic\" , and checks it,  defaults for features (first level of widget/composition schema) are inferred if they are of type  \"array\"  or  \"object\" ,  support for  ${topic:\u2026}  and  ${features.\u2026}  syntax in compositions, before applying format checks.   More Information:   Manual: Widgets and Activities  ajv website", 
            "title": "JSON Schema now Processed at build-time"
        }, 
        {
            "location": "/manuals/upgrade_guide/#angularjs-support-moved-to-standalone-adapter-project", 
            "text": "The LaxarJS runtime no longer depends on functionality provided by AngularJS.\nWriting widgets using AngularJS works just like before, you just need to:   add the  laxar-angular-adapter  to your project:   console\n  npm install --save laxar-angular-adapter`   pass it to  create  using the  adapters  option.   More Information:   API:  laxar.create", 
            "title": "AngularJS Support Moved to Standalone Adapter Project"
        }, 
        {
            "location": "/manuals/upgrade_guide/#angularjs-axlayout-control-removed", 
            "text": "Because layouts are now first-class items in widget areas, directly embedding them in widgets unnecessarily complicates the implementation of both widgets and runtime.\nWidgets should simply offer  widget areas,  which can then be configured by the page to contain layouts.  More Information:   GitHub: LaxarJS/laxar#272", 
            "title": "AngularJS: axLayout Control Removed"
        }, 
        {
            "location": "/manuals/upgrade_guide/#angularjs-ngsanitize-no-longer-loaded-by-default", 
            "text": "Not every application needs  angular-sanitize  to secure dynamically loaded HTML.\nIf you are using a widget that relies on ngSanitize, you need to manually install  angular-sanitize  and load it from the corresponding widget or control.  More Information:   GitHub: LaxarJS/laxar-angular-adapter#41", 
            "title": "AngularJS: ngSanitize no longer loaded by default"
        }, 
        {
            "location": "/manuals/upgrade_guide/#application-configuration-windowlaxar-is-no-more", 
            "text": "LaxarJS is no longer using a global object property for configuration.\nThis improves testability and allows to run multiple LaxarJS instances side-by-side.\nPass your configuration values to  create  instead, using the last parameter ( configuration ).  More Information:   API:  laxar.create", 
            "title": "Application Configuration: window.laxar is No More"
        }, 
        {
            "location": "/manuals/upgrade_guide/#artifact-directory-defaults-changed", 
            "text": "With the new tooling infrastructure,  all artifact types  (themes, flows, pages, layouts, widgets, controls) will be expected to reside within the respective sub-folders of  application/  within your project.\nPreviously, widgets, controls and themes were expected to reside in sub-folders of  includes/ .\nThis behavior can be customized by creating a  laxar.config.js  in your project and exporting the corresponding  paths.flows ,  paths.pages  and so on from there.  More Information:   laxar-loader Manual", 
            "title": "Artifact Directory Defaults Changed"
        }, 
        {
            "location": "/manuals/upgrade_guide/#stylestemplates-for-widgetscontrols-lookup-by-name-only", 
            "text": "Previously, LaxarJS used several heuristics to derive the  name  of activities/widgets, layouts, controls or themes from their file system path segment.\nThe name is needed to find the JavaScript implementation module, CSS stylesheet and HTML template (for widgets and layouts) of an artifact.  Now, widgets and controls must always provide a descriptor ( widget.json ,  control.json ) with a  name  property.\nThat name is then used to load the implementation module from the directory of the descriptor, as well as themed assets from the appropriate sub-directories.\nHere, the  resolve  configuration of webpack comes into play, which allows projects using Angular 2 or Vue.js to transparently load implementations from  .ts  or  .vue  files.  Using explicit names instead of incidental file system locations makes artifacts robust against being moved, and for being used in different contexts.\nIt also eliminates confusion regarding the name of directories and files when styling artifacts from within a theme.  An exception is made for loading the implementation module of widgets that have a  package.json :\nTo allow these widgets to be pre-compiled from \"compile-to-js\" languages, they may use the  \"browser\"  field of their  package.json  to specify the location of their implementation module.  More Information:   Assets and the Artifacts Bundle", 
            "title": "Styles/Templates for Widgets/Controls Lookup by Name Only"
        }, 
        {
            "location": "/manuals/upgrade_guide/#several-laxarjs-apis-moved-to-injectable-services", 
            "text": "Previously, LaxarJS offered several stateful APIs as part of its exported API.\nThese were replaced by injectable widget services as follows:   laxar.configuration  -   axConfiguration  laxar.log  -   axLog  laxar.i18n  -   axI18n  laxar.storage  -   axStorage   This change improves testability and allows to run multiple instances of LaxarJS on the same page.\nDuring your transition to LaxarJS v2, you can use the  dist/laxar-compatibility.js  entry point, which adds shims for the missing APIs.\nNote that the compatibility entry point is intended only for use during a migration and not part of the official API.\nThis means that it  may be removed  in upcoming minor versions.  The stateless utility APIs  assert ,  object  and  string  are not affected by this change.  More Information:   API: Widget Services  API: Widget Service Mocks  for testing", 
            "title": "Several LaxarJS APIs moved to Injectable Services"
        }, 
        {
            "location": "/manuals/upgrade_guide/#flow-definition-format-changed", 
            "text": "The flow definition files have a new format that clearly distinguishes between place IDs and URL mappings.\nThis also allows to map multiple URL patterns to the same place, and to specify place parameter values for redirects.  Also, the syntax for routing pattern definition has changed slightly, as LaxarJS now uses  Navigo  for routing.  More Information:   Manual: Flow and Places  GitHub: LaxarJS/laxar#432  GitHub: LaxarJS/laxar#381", 
            "title": "Flow Definition: Format Changed"
        }, 
        {
            "location": "/manuals/upgrade_guide/#flow-definition-removed-entrypoint-exitpoint-features", 
            "text": "These features were hard-to-explain in manuals as they cater to a very narrow set of integration use cases.\nEntry points can be replaced by using  entry pages  containing an activity that fires navigation events.\nExit points can be replaced by simply adding an activity that invokes the external API previously triggered by the exit point.  More Information:   Manual: Flow and Places  GitHub: LaxarJS/laxar#392", 
            "title": "Flow Definition: Removed entryPoint / exitPoint features"
        }, 
        {
            "location": "/manuals/upgrade_guide/#flow-default-router-changed-from-angular-route-to-navigo", 
            "text": "Because AngularJS was removed from LaxarJS core, we no longer use AngularJS  $route  for routing.\nRather than creating our own standalone routing library, LaxarJS now depends on the  Navigo  routing microlibrary.\nWe also evaluated  page.js  by visionmedia, but due to the recent lack of project activity we think that Navigo is the right choice for now.\nIn the near-future, we plan on making routers pluggable.\nThis will be especially useful if your UI framework comes with a router anyway.  More Information:   Manual: Flow and Places  https://www.npmjs.com/package/navigo", 
            "title": "Flow: Default Router Changed from Angular $route to Navigo"
        }, 
        {
            "location": "/manuals/upgrade_guide/#axflowservice-constructpath-constructanchor-removed", 
            "text": "The methods  constructPath  and  constructAnchor  were removed because they are not portable across routing setups using hash-based and path-based navigation.\nYou should always use  constructAbsoluteUrl  to create links within a LaxarJS application.  More Information:   Manual: Infrastructure and Tools  Manual: Assets and the Artifacts Bundle  webpack website", 
            "title": "axFlowService: constructPath, constructAnchor removed"
        }, 
        {
            "location": "/manuals/upgrade_guide/#axflowservice-no-more-trailing-_", 
            "text": "When  generating  URLs where values of trailing parameters are missing, this no longer results in trailing underscores.\nMake sure to structure your routing patterns to handle these URLs, or avoid them by always populating the respective place parameters.  More Information:   GitHub LaxarJS/laxar#389", 
            "title": "axFlowService: No More Trailing '_'"
        }, 
        {
            "location": "/manuals/upgrade_guide/#page-definition-builtin-areas-now-use-ax-prefix", 
            "text": "The builtin/auto-generated widget areas ( activities ,  popups ,  popovers ) were renamed (to  axActivities ,  axPopups ,  axPopovers ) to draw attention to the fact that they are automatically provided by LaxarJS.\nHopefully, this saves new developers from wasting time looking for the responsible layout.  More Information:   Manual: Writing Pages  GitHub LaxarJS/laxar#461", 
            "title": "Page Definition: builtin areas now use ax prefix"
        }, 
        {
            "location": "/manuals/upgrade_guide/#widget-descriptor-new-stylesource-and-templatesource", 
            "text": "Previously, SCSS had to be integrated by using the  grunt-laxar-compass  package, which required generated CSS to be committed to version control.\nNow, SCSS can be processed by setting the  styleSource  attribute of the widget.json descriptor.\nThis allows for arbitrary compile-to-css languages (such as LESS).  Also, the grunt plugin was notoriously unreliable in watching transitive SCSS import dependencies, which is no longer the case when using webpack with the  sass-loader .\nThe Yeoman Generator generates appropriate webpack dependencies and configuration out-of-the-box.  Additionally,  templateSource  can be used to preprocess widget HTML templates.\nThis allows to use HTML generators such as  pug  to preprocess widget templates.  More Information:   Manual: Flow and Places  webpack website", 
            "title": "Widget Descriptor: new styleSource and templateSource"
        }, 
        {
            "location": "/manuals/upgrade_guide/#axvisibility-new-widget-service-injection", 
            "text": "Dealing with visibility events in LaxarJS v1 was too much voodoo.\nThe new  axVisibility  widget injection hopefully simplifies things.\nTo deal with visibility, the new injection is recommended over LaxarJS Patterns  visibility  and over using the event bus directly.  More Information:   Manual: Visibility Events  API:  axVisibility  widget service  API:  axVisibility  mock  for testing  GitHub: LaxarJS/laxar#333", 
            "title": "axVisibility: new widget service injection"
        }, 
        {
            "location": "/manuals/upgrade_guide/#axi18n-new-widget-service-injection", 
            "text": "Dealing with internationalization has been further simplified and detangled from AngularJS by the new  axI18n  injection.\nAlso, the new injection is instantiated per bootstrapping instance, so that multiple LaxarJS applications can coexist in a browser window, and even use different locales.\nTo deal with i18n, the new injection is recommended over LaxarJS Patterns  i18n  and over using the event bus directly.  More Information:   Manual: I18n  API:  axI18n  widget service  API:  axI18n  mock  for testing  GitHub: LaxarJS/laxar#332  GitHub: LaxarJS/laxar#333  GitHub: LaxarJS/laxar#429", 
            "title": "axI18n: new widget service injection"
        }, 
        {
            "location": "/manuals/upgrade_guide/#replace-requiretourl-using-axassets", 
            "text": "LaxarJS no longer depends on RequireJS, and it is not recommended to mix RequireJS with webpack either.\nSome widgets may use the  toUrl -method provided by RequireJS for generating absolute URLs.\nAs this method constructs URLs at runtime, it is not supported by webpack.  You may wish to use webpack to pre-bundle smaller assets within a reusable widget that has its own  package.json  and build-setup.\nIn general, it is recommended to use the  axAssets  injection instead.  More Information:   Manual: Assets and the Artifacts Bundle  Manual: Infrastructure and Tools  API:  axAssets  widget service  API:  axAssets  Mock  webpack website", 
            "title": "Replace require.toUrl() using axAssets"
        }, 
        {
            "location": "/manuals/upgrade_guide/#axeventbus-removed-methods-unsubscribe-setmediator-seterrorhandler", 
            "text": "The LaxarJS event bus no longer allows to register a mediator, as this feature was never used.\nConfiguring a custom error handler was removed from the public API as well, with its use case (testing) supported by a pre-configured event bus mock.  Using  unsubscribe  was usually not required except when using the  axGlobalEventBus  injection.\nTo cancel an event bus subscription, you must now use the callback returned by  axEventBus.subscribe .\nThis avoids possible problems with trying to using the old  unsubscribe  on decorated subscriber functions.  More Information:   Manual: Assets and the Artifacts Bundle  Manual: Infrastructure and Tools  API:  axAssets  widget service  API:  axAssets  Mock", 
            "title": "axEventBus: removed methods: unsubscribe, setMediator, setErrorHandler"
        }, 
        {
            "location": "/manuals/upgrade_guide/#widget-adapter-api-changed", 
            "text": "The widget adapter API was rewritten to make adapters more powerful.\nThe two most important changes:   creating an adapter for a widget instance may now be asynchronous  widget adapters may now freely intercept and modify widget service injections   More Information:   Manual: Creating Widget Adapters  API: the \"plain\" Widget Adapter  GitHub: LaxarJS/laxar#413  GitHub: LaxarJS/laxar#398  GitHub: LaxarJS/laxar#397  GitHub: LaxarJS/laxar#396  GitHub: LaxarJS/laxar#390  GitHub: LaxarJS/laxar#358  GitHub: LaxarJS/laxar#337  GitHub: LaxarJS/laxar#281", 
            "title": "Widget adapter API changed"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-mocks-static-html-test-runner-is-no-more", 
            "text": "Because widget dependencies are no longer loaded at runtime by RequireJS, the recommended setup for testing widgets using LaxarJS Mocks has changed significantly:   no more copy/paste of HTML spec runner files  use the laxar-mocks/spec-loader for webpack to precompile widget dependencies  no more need to declare \"missing\" CSS assets of controls  run tests on the command-line using karma and karma-webpack  run tests within the browser using the webpack-jasmine-html-runner-plugin   More Information:   LaxarJS Mocks Manual  LaxarJS Mocks Manual: Setup  LaxarJS Mocks API", 
            "title": "LaxarJS Mocks: Static HTML Test Runner is No More"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-mocks-use-axmockswidgetsetupforwidget", 
            "text": "To clarify that test fixtures are now provided automatically and in advance (e.g. by the LaxarJS Mocks spec-loader for webpack), the testbed should now be created using  setupForWidget .   LaxarJS Mocks API: setupForWidget", 
            "title": "LaxarJS Mocks: Use axMocks.widget.setupForWidget"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-mocks-axmockswidgetteardown-is-now-asynchronous", 
            "text": "To clean up correctly after tests, LaxarJS mocks publishes the  endLifecycleRequest  event after each tests and allows the widget under test to perform cleanup before proceeding.   LaxarJS Mocks API: tearDown", 
            "title": "LaxarJS Mocks: axMocks.widget.teardown is now Asynchronous"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-patterns-patches-api-removed", 
            "text": "The deprecated  patches  API was removed.\nUse JSON patch instead.   GitHub: LaxarJS/laxar-patterns#84", 
            "title": "LaxarJS Patterns: patches API removed"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-patterns-resources-api-removed-updatehandler-replacehandler", 
            "text": "Use  handlerFor( context )  instead (or  $scope  instead of context for AngularJS widgets).   GitHub: LaxarJS/laxar-patterns#85", 
            "title": "LaxarJS Patterns: resources API: removed updateHandler, replaceHandler"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-patterns-actions-api-use-promise-rejections-correctly", 
            "text": "Actions publisher promises are no longer rejected for actions with an ERROR outcome, caused by e.g. validation failure.\nInstead, promises will only be rejected when subscribers fail with an exception.   GitHub: LaxarJS/laxar-patterns#54", 
            "title": "LaxarJS Patterns: actions API: use Promise Rejections Correctly"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-patterns-various-breaking-changes", 
            "text": "Most likey, only very few widgets are affected by the remaining breaking changes.\nConsult the Changelog for details:   LaxarJS Patterns: Changelog", 
            "title": "LaxarJS Patterns: Various Breaking Changes"
        }, 
        {
            "location": "/manuals/upgrade_guide/#laxarjs-uikit-i18n-controls-removed", 
            "text": "The controls contained in LaxarJS UiKit were locked to the  \"angular\"  integration technology.\nThe  axLocalize  filter for AngularJS is now included in the  laxar-angular-adapter .   GitHub: LaxarJS/laxar-angular-adapter#38", 
            "title": "LaxarJS UiKit: I18n Controls Removed"
        }, 
        {
            "location": "/manuals/upgrade_guide/#browser-support", 
            "text": "Support for MS Internet Explorer 9 was dropped.\nLaxarJS v2 relies on dynamic property getters, which are not available for MSIE 8 and cannot be polyfilled.\nIn principle, MSIE 9 may still be working, but we are not actively supporting it.  Other than that, since LaxarJS no longer directly depends on AngularJS, it may actually be possible to support more browsers than in past major versions.  More Information:   GitHub: LaxarJS/laxar#349", 
            "title": "Browser Support"
        }, 
        {
            "location": "/manuals/upgrade_guide/#migration-guide-laxarjs-v0x-to-laxarjs-v1x", 
            "text": "According to semantic versioning, minor versions starting with  v0.  may introduce breaking changes.\nWe tried to avoid that as much as possible during our own  v0.x  releases, but depending on where you start off, only some of these items will be relevant for you.\nSince LaxarJS  v0.x  was not used that much, this information is kept short:    Support for MS Internet Explorer 8 was dropped.    The format of  didUpdate  events was changed from \"update maps\" to the standard  JSON patch  format.\n  When upgrading any complex application, this is probably the most work-intensive change.    The JSON schema format for widgets was changed from v3 to v4, with a compatibility fallback.    The  laxar.text  helper was removed.    Location and naming of HTML templates and CSS stylesheets was unified across artifacts.    Some of the name-mangling magic was removed when translating artifact names to file names or AngularJS module names.    The testing library built into LaxarJS core was deprecated in favor of  LaxarJS Mocks .    Controls  became a themable artifact type, with the  control.json  as a descriptor.    AngularJS was upgraded from 1.2.x to (at least) 1.3.x.    For all the details, consult the changelog.", 
            "title": "Migration Guide: LaxarJS v0.x to LaxarJS v1.x"
        }, 
        {
            "location": "/manuals/widget_services/", 
            "text": "Widget Services\n\n\n\u00ab return to the manuals\n\n\nIn order to make developing widgets even easier, a common set of services is offered to each widget instance, regardless of its implementation technology.\nSome of these services are mere adapters to internal APIs and are mostly relevant for tooling, while others are specifically tailored to the respective widget instance, sparing the widget developer to provide context information by himself.\nA widget adapter may offer additional services specific to its implementation technology.\nFor example the AngularJS adapter allows to inject all available AngularJS services and the widget's \n$scope\n object.\n\n\nPreliminary readings:\n\n\n\n\nWidgets and Activities\n\n\n\n\nAvailable Services\n\n\nFor a list of all widget services, consult the \nwidget services API documentation\n.\n\n\nTo help you get started, the most important widget services are:\n\n\n\n\n\n\naxContext\n for passing essential instance information to libraries such as \nLaxarJS Patterns\n, also available as \n$scope\n to AngularJS widgets,\n\n\n\n\n\n\naxConfiguration\n for application configuration,\n\n\n\n\n\n\naxEventBus\n to communicate using publish/subscribe,\n\n\n\n\n\n\naxFeatures\n to access instance feature configuration,\n\n\n\n\n\n\naxFlowService\n to generate link URLs,\n\n\n\n\n\n\naxLog\n for logging.\n\n\n\n\n\n\nMocking Widget Services from Tests\n\n\nOne of the advantages that providing all widget services as injection is improved testability.\nThe \nLaxarJS Mocks\n library replaces all widget services with mock versions that do not affect the browser state and that are reset completely between test cases.\n\n\nThe \nwidget service mocks API\n is defined by LaxarJS Core, and should simplify writing non-trivial tests.\nYou can configure service mocks just before a widget controller is instantiated by passing a callback to \naxMocks.widget.whenServicesAvailable\n.\nThe \nLaxarJS Mocks API docs\n contain more detailed information.", 
            "title": "Widget Services"
        }, 
        {
            "location": "/manuals/widget_services/#widget-services", 
            "text": "\u00ab return to the manuals  In order to make developing widgets even easier, a common set of services is offered to each widget instance, regardless of its implementation technology.\nSome of these services are mere adapters to internal APIs and are mostly relevant for tooling, while others are specifically tailored to the respective widget instance, sparing the widget developer to provide context information by himself.\nA widget adapter may offer additional services specific to its implementation technology.\nFor example the AngularJS adapter allows to inject all available AngularJS services and the widget's  $scope  object.  Preliminary readings:   Widgets and Activities", 
            "title": "Widget Services"
        }, 
        {
            "location": "/manuals/widget_services/#available-services", 
            "text": "For a list of all widget services, consult the  widget services API documentation .  To help you get started, the most important widget services are:    axContext  for passing essential instance information to libraries such as  LaxarJS Patterns , also available as  $scope  to AngularJS widgets,    axConfiguration  for application configuration,    axEventBus  to communicate using publish/subscribe,    axFeatures  to access instance feature configuration,    axFlowService  to generate link URLs,    axLog  for logging.", 
            "title": "Available Services"
        }, 
        {
            "location": "/manuals/widget_services/#mocking-widget-services-from-tests", 
            "text": "One of the advantages that providing all widget services as injection is improved testability.\nThe  LaxarJS Mocks  library replaces all widget services with mock versions that do not affect the browser state and that are reset completely between test cases.  The  widget service mocks API  is defined by LaxarJS Core, and should simplify writing non-trivial tests.\nYou can configure service mocks just before a widget controller is instantiated by passing a callback to  axMocks.widget.whenServicesAvailable .\nThe  LaxarJS Mocks API docs  contain more detailed information.", 
            "title": "Mocking Widget Services from Tests"
        }, 
        {
            "location": "/manuals/widgets_and_activities/", 
            "text": "Widgets and Activities\n\n\n\u00ab return to the manuals\n\n\nWidgets and activities are the \n\"work horse\"\n of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\n\n\nIf you are already familiar with widgets, and just need a refresher on the \nwidget.json\n descriptor, skip to the \nreference section\n below.\n\n\nWidget Responsibilities\n\n\nBefore starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question: \nWhat goal does this widget help the user to accomplish?\n\nAre you thinking about a very broadly applicable, technical task such as \n\"allow the user to enter a date\"\n or \n\"allow the user to delete a data row\"\n?\nIn this case you might want to implement this functionality as a \ncontrol\n and use it \nwithin\n one or more of your widgets.\n\n\nUsually, widgets correspond to significant areas of the screen and are composed of multiple controls.\nThey are built with a \nspecific user-goal\n in mind, such as \n\"allow the user to book a flight\"\n or \n\"allow the user to review shopping cart contents\"\n.\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?\n\n\nWhen to use Activities\n\n\nActivities are \n\"invisible widgets\"\n that are used to \nfetch and manage application resources\n.\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nIf you are familiar with AngularJS, you might recognize that activities perform a role similar to AngularJS \nservices\n.\nThe advantage over services is that using activities puts the \npage author\n in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.\n\n\nActivities may also serve as a \nmediator\n between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.\n\n\nIntegration Technologies\n\n\nLaxarJS serves as a \nmiddleware layer\n that allows you to organize and connect isolated front end components to form an application.\nHowever, it has no say in how the individual widgets and their UI are implemented.\nInstead it tries to support you in using readily available frameworks such as React, Vue.JS and Angular.\nTo integrate widgets that were created in different UI technologies, a piece of glue code is needed, the so-called \nintegration technology adapter\n.\n\n\nThe only adapter included with LaxarJS Core is the adapter for the integration technology \n\"plain\"\n, which does not rely on any specific framework, but leaves it up to the widget author to choose what (if any) supporting libraries should be loaded by the widget.\nThere is a dedicated \nmanual on the \n\"plain\"\n adapter\n.\n\n\nAnother adapter offered by the LaxarJS project is the \nlaxar-angular-adapter\n supporting the integration technology \n\"angular\"\n, meaning AngularJS v1.\nBecause \n\"angular\"\n was the built-in technology for LaxarJS v1 and many developers are familiar with its basics, it is still used frequently throughout the examples in this documentation.\n\n\nCombining Integration Technologies\n\n\nYou are encouraged to evaluate different integration technologies for use in your project, especially if you are starting from scratch\nFor now, the LaxarJS project provides adapters for the technologies \nvue\n, \nangular\n (1)\n, \nreact\n,  and \nangular2\n.\nOnce familiar with the basics, feel free to \ncreate your own adapter\n.\n\n\nHowever, keep in mind that each integration technology adds to your overall application bundle size, impacting application load time and memory consumption.\nWhile mixing three view frameworks may be fine for an intranet application, online applications should generally aim for using a single integration technology, or maybe two technologies during a framework transition -- mobile users will thank you for it!\nOf course, \n\"plain\"\n is always free and does not weigh in here.\nObviously, this should always be your first choice when implementing an activity.\n\n\nHow to Create a Widget\n\n\nThe easiest way to create a widget is to use the \nLaxarJS 2 Yeoman generator\n.\nCheck out the \nREADME\n on how to obtain it, and how to use it for creating an application.\n\n\nTo create a widget with the generator simply run the following in the root directory of your application:\n\n\nyo laxarjs2:widget\n\n\n\n\n\nAfter answering all questions asked by the generator, the widget will be create in a sub-directory having its name, within the default directory for widgets (which is \napplication/widgets/\n).\nFor example, the sources for a widget named \nshopping-cart-widget\n, which is used as an example throughout this manual, can be found in the sub-directory \napplication/widgets/shopping-cart-widget\n.\n\n\nAlternatively, it's possible to choose a different directory for the widget sources by creating that directory yourself and navigating there before calling the widget generator.\nKeep in mind however, that this directory has to be a sub-directory of the application directory, and that webpack needs to be configured to search for widgets there as well.\nTo change the default widget root, you can create a file \nlaxar.config.js\n in your application directory, and use the export \npath.widgets\n to override the widget root.\nWebpack will then try to load widgets from there instead of \napplication/widgets/\n.\nHaving multiple directories for widgets is possible by \nadding the relevant directories to the module resolution directories\n, but this is out of scope of this manual.\n\n\nTo create a widget in a custom directory, start by creating a sub-directory for your new widget within the LaxarJS application.\nThe last component of the widget path is the so-called \nwidget directory\n, which uses the name of the widget itself.\nThe widget name must be unique throughout an application and should be written in lower case letters with components separated by dashes.\nWidget names always end in \n-widget\n whereas activities always end in \n-activity\n.\n\n\nTo create the actual widget, run:\n\n\ncd\n my-custom-widget-directory/shopping-cart-widget\nyo laxarjs2:widget\n\n\n\n\n\nIn the following steps, it is assumed that you used the widget name \nshopping-cart-widget\n as above.\n\n\nWidget Files\n\n\nA newly created widget contains the following files:\n\n\n\n\nwidget.json\n\n\n\n\nThis \nwidget descriptor\n contains meta-data about your widget that is used by the LaxarJS framework.\n  The descriptor contains the name of the widget and specifies both integration type (\n\"widget\"\n or \n\"activity\"\n) and integration technology (such as \n\"angular\"\n, \n\"react\"\n or \nsomething else\n).\n  Finally, the descriptor allows to describe \nconfiguration options\n of your widget features using a JSON schema, so that configuration will be validated automatically.\n\n\n\n\nshopping-cart-widget.js\n\n\n\n\nThe \nbusiness logic\n of your shopping cart (like calculating a total or changing item quantities) as a JavaScript module.\n  The precise contents of the widget module depend on the integration technology used by your widget.\n  Usually, it exports either a class constructor, or a plain factory function to create the widget instance.\n  When a widget is instantiated by the LaxarJS runtime, it is passed a set of \nwidget services\n including the \nevent bus\n, which allows for communication with other widget instances.\n\n\nNote that the file extension can also vary depending on the integration technology.\n  For example widgets written using the \n\"vue\"\n integration technology will have \n.vue\n as extension while \n\"react\"\n widgets will use \n.jsx\n.\n\n\n\n\ndefault.theme/shopping-cart-widget.html\n\n\n\n\nThe \nHTML template\n defining the \nappearance\n of your widget.\n  Again, the integration technology determines the syntax that is supported in the template, or if the template is even integrated into the controller source file and hence not present at all.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The \nBootstrap CSS\n classes are made available by the LaxarJS \ndefault.theme\n to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all) in \nyour own theme\n, but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be bundled within a single JSON file when your application is packaged for release.\n\n\n\n\ndefault.theme/css/shopping-cart-widget.css\n\n\n\n\nWidget-specific \nstyle definitions\n.\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, LaxarJS will include it within the CSS bundle when the widget is used in an application.\n\n\n\n\npackage.json\n \n(optional)\n\n\n\n\nThis file specifies the \ndependencies\n of your widget for use with \nnpm\n.\n  If you want to version and package you widget as a standalone component for use in multiple applications, this is the recommended way to describe the widget and its dependencies.\n\n\n\n\nwebpack.config.js\n \n(optional)\n\n\n\n\nWebpack configuration for this widget.\n  The main purpose of webpack in a widget context is to help when \nwriting widget specs\n, but it can also create a bundle of your widget and its own dependencies.\n\n\nLaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom \ntheme\n.\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead \nmore about themes\n once you are familiar with creating and using widgets.\n\n\nWidget Files for Testing\n\n\nThe sub folder \nspec\n contains the widget spec test and, possibly associated resources.\nWhile we recommend writing tests for your widget, note that the spec folder is not required.\nNone of these files are loaded during regular application runtime.\n\n\n\n\nspec/shopping-cart-widget.spec.js\n\n\n\n\nThis should be a \nJasmine 2\n spec test.\n  If you used the LaxarJS generator to setup your application including configuration for karma and webpack, this spec can be run on the command-line using \nkarma\n, or as an interactive HTML test in the browser, by using the \nwebpack-jasmine-html-runner-plugin\n.\n\n\nFor projects that were generated using the Yeoman generator for LaxarJS, you can start the karma test-runner for your widgets using \nnpm test\n.\n\n\nImplementing a Controller\n\n\nTo write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means\n\n\n\n\n\n\nsumming the contents of the cart\n\n\n\n\n\n\nincreasing or decreasing the quantity of individual positions within the cart.\n\n\n\n\n\n\nThroughout this example, we will be using the \nangular\n integration technology (AngularJS v1), as it is familiar to developers coming from LaxarJS v1.\nDifferent integration technologies should work in a similar fashion.\nFor more information on the AngularJS integration, consult the \nangular adapter documentation\n.\n\n\nThe Yeoman generator has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart, \nthis\n might be an appropriate starting implementation with some dummy data:\n\n\nimport\n \n*\n \nas\n \nng\n \nfrom\n \nangular\n;\n\n\n\nController\n.\n$inject\n \n=\n \n[\n \n$scope\n \n];\n\n\nfunction\n \nController\n(\n \n$scope\n \n)\n \n{\n\n   \n$scope\n.\nmodel\n \n=\n \n[\n\n      \n{\n \nlabel\n:\n \nDairy Dreams\n,\n \nprice\n:\n \n5.25\n,\n \namount\n:\n \n1\n \n},\n\n      \n{\n \nlabel\n:\n \nMilky Mocha\n,\n \nprice\n:\n \n12.75\n,\n \namount\n:\n \n3\n \n},\n\n      \n{\n \nlabel\n:\n \nFreezing Frapp\u00e9\n,\n \nprice\n:\n \n18.25\n,\n \namount\n:\n \n1\n \n}\n\n   \n];\n\n\n   \n$scope\n.\nincrement\n \n=\n \nitem\n \n=\n \n{\n\n      \n++\nitem\n.\namount\n;\n\n   \n};\n\n\n   \n$scope\n.\ndecrement\n \n=\n \nitem\n \n=\n \n{\n\n      \nitem\n.\namount\n \n=\n \nMath\n.\nmax\n(\n \n0\n,\n \nitem\n.\namount\n \n-\n \n1\n \n);\n\n   \n};\n\n\n   \n$scope\n.\ntotal\n \n=\n \nrows\n \n=\n \nrows\n.\nreduce\n(\n\n      \n(\ntotal\n,\n \nitem\n)\n \n=\n \ntotal\n \n+\n \nitem\n.\nprice\n \n*\n \nitem\n.\namount\n,\n\n      \n0\n\n   \n);\n\n\n}\n\n\n\nexport\n \nconst\n \nname\n \n=\n \nng\n.\nmodule\n(\n \nshoppingCartWidget\n,\n \n[]\n \n)\n\n   \n.\ncontroller\n(\n \nShoppingCartWidgetController\n \n).\nname\n;\n\n\n\n\n\n\nThe adapter for the integration technology \n\"angular\"\n makes it possible for a widget controller in LaxarJS to work just like any other AngularJS controller.\nOf course, things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.\n\n\nCreating a Template\n\n\nThe purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:\n\n\nh4\n \nng-bind-html\n=\nfeatures.headline.htmlText\n/\nh4\n\n\ntable\n \nclass\n=\ntable\n\n   \nthead\n\n   \ntr\n\n      \nth\nBeverage\n/\nth\n\n      \nth\n \nclass\n=\ncart-amount\nPrice\n/\nth\n\n      \nth\n \nclass\n=\ncart-price\nAmount\n/\nth\n\n      \nth\n/\nth\n\n   \n/\ntr\n\n   \n/\nthead\n\n   \ntfoot\n\n   \ntr\n\n      \nth\n \ncolspan\n=\n3\n \nclass\n=\ncart-price\n{{ total( model ) }}\n/\nth\n\n      \nth\n/\nth\n\n   \n/\ntr\n\n   \n/\ntfoot\n\n   \ntr\n \nng-repeat\n=\nitem in model\n\n      \ntd\n{{ item.label }}\n/\ntd\n\n      \ntd\n \nclass\n=\ncart-amount\n{{ item.amount }}\n/\ntd\n\n      \ntd\n \nclass\n=\ncart-price\n{{ item.price }}\n/\ntd\n\n      \ntd\n\n         \nbutton\n \nng-click\n=\ndecrement( item )\n \nclass\n=\nbtn btn-xs\n\n            \ni\n \nclass\n=\nfa fa-minus\n \n/\n/\nbutton\n\n         \nbutton\n \nng-click\n=\nincrement( item )\n \nclass\n=\nbtn btn-xs\n\n            \ni\n \nclass\n=\nfa fa-plus\n \n/\n/\nbutton\n\n      \n/\ntd\n\n   \n/\ntr\n\n\n/\ntable\n\n\n\n\n\n\nNote that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that \nmodel\n, \ndecrement\n, \nincrement\n and \ntotal\n will be available upon template instantiation.\nThe \nfeatures\n property used within the headline comes from the \nwidget configuration\n, which is described below.\n\n\nAdding Some Style\n\n\nA widget may be styled using CSS, or its more fancy variants such as LESS or SCSS.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under \ndefault.theme/css/shopping-cart-widget.css\n.\nOnce you are familiar with the basics, read the article on \ncreating themes\n for more information.\n\n\nThanks to Bootstrap CSS, this widget does not require a lot of fancy styling:\n\n\n.\nshopping-cart-widget\n \n.\ncart-amount\n,\n\n\n.\nshopping-cart-widget\n \n.\ncart-price\n \n{\n\n   \ntext-align\n:\n \nright\n;\n\n\n}\n\n\n\n\n\n\nFor best encapsulation, selectors should be prefixed with the widget class (\n.shopping-cart-widget\n) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here (\ncart-amount\n, \ncart-price\n), just as you would prefix custom HTML elements or attributes.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.\n\n\nConfiguration Options\n\n\nWhen looking at the template, you might have wondered where the \nfeatures.headline.htmlText\n came from.\nThis is a \nfeature configuration\n option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we specify a configuration option by adding a feature entry to the \nwidget.json\n:\n\n\n{\n\n   \nname\n:\n \nshopping-cart-widget\n,\n\n   \ndescription\n:\n \nAllows Users to Review and Modify Purchase Items\n,\n\n\n   \nintegration:\n \n{\n\n      \ntechnology\n:\n \nangular\n,\n\n      \ntype\n:\n \nwidget\n\n   \n},\n\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nheadline\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nhtmlText\n:\n \n{\n\n                  \ntype\n:\n \nstring\n,\n\n                  \ndescription\n:\n \nthe HTML headline content\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe \nwidget features\n are a \nJSON schema\n document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.\n\n\nNote that LaxarJS deviates from standard JSON schema in two respects:\n\n\n\n\n\n\n\"additionalProperties\": false\n is default for all schemas of \n\"type\": \"object\"\n\n  This helps to catch typing errors.\n\n\n\n\n\n\n\"format\"\n allows for the LaxarJS specific value \n\"topic\"\n, and checks it to validate event topics.\n  See the \nmanual on events\n for details on event topic syntax.\n\n\n\n\n\n\ndefaults for features (first level of widget/composition schema) are inferred if they are of type \n\"array\"\n or \n\"object\"\n.\n  This eliminates the need to repeat nested defaults on the feature-level.\n\n\n\n\n\n\nNote that using schemas is \noptional\n:\nIf a widget descriptor does not specify a schema, any configuration will be considered valid and passed to the widget controller, which can be useful for prototyping.\nHowever, it is strongly recommended to add a schema before releasing a widget or putting it into production, if only to \ndocument\n the available configuration.\n\n\nSee the \nreference section\n for a reference of the widget descriptor.\n\n\nChecking out the Result\n\n\nBefore we can take a look at the widget, we will need to integrate it into the page provided by the application template (\napplication/pages/page1.json\n).\n\n\n{\n\n   \nlayout\n:\n \none-column\n,\n\n\n   \nareas\n:\n \n{\n\n      \nactivities\n:\n \n[],\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[\n\n          \n{\n\n             \nwidget\n:\n \nshopping-cart-widget\n,\n\n             \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \nhtmlText\n:\n \nMy Shopping Cart\n\n                \n}\n\n             \n}\n\n          \n}\n\n      \n],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nI you would like to know more, there is a dedicated manual to learn more about \nwriting pages\n.\n\n\nNow we can start the \nwebpack-dev-server\n from the application root:\n\n\nnpm install \n# if you have not already\n\nnpm start\n\n\n\n\n\nNavigate to \nhttp://localhost:8080/debug.html\n to admire the fruits of your labor:\n\n\n\n\nNow that you have learned the basics in \ncreating\n widgets, take a closer look at widget \ntesting.\n\n\nTesting a Widget\n\n\nOne of the major goals of LaxarJS is to simplify the development \nand testing\n of isolated components.\nFor this reason, a basic widget test has already been prepared when using \nyo laxarjs2:widget\n.\n\n\nWriting Spec-Tests\n\n\nFor testing widgets and activities in isolation, we recommend to use the library \nLaxarJS Mocks\n, which allows to setup a test bed for widgets that were created in any integration technology.\nThere you'll also find manuals and \nan introduction\n on how to test widgets in isolation.\n\n\nRunning the Test\n\n\nThe \nLaxarJS Mocks Setup Instructions\n explain how to run widget tests from the command line using karma, or interactively using a generated HTML test runner.\nHopefully this makes it simple to set up continuous testing for your application.\n\n\n\n\nLaxarJS Widget Reference\n\n\nBuilding on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and the properties available on the \n$scope\n in case of an AngularJS widget.\n\n\nWidget Descriptor Format\n\n\nEach widget has a \nwidget.json\n file which is also called \nwidget descriptor\n.\nLaxarJS contains a \nwidget schema definition\n that defines the exact format of this file.\nThese are the most important widget properties:\n\n\n\n\nname\n\n\n\n\nThis required field contains the name of the widget, used to find its implementation module, template and stylesheet. The name must match the spelling and case of the module name (minus \n.js\n extension) exactly.\n\n\n\n\ndescription\n\n\n\n\nWhat this widget is about.\n  Ideally, this contains the main \nuser-goal\n mentioned in the first section.\n\n\n\n\nintegration\n\n\n\n\nAn object with keys \ntype\n and \ntechnology\n specifying whether this is an \nactivity\n or a \nwidget\n, and the technology the widget's controller is implemented in.\n  This was already explained \nabove\n.\n\n\n\n\nfeatures\n\n\n\n\nThe widget features.\n  This is an optional (but highly recommended) JSON schema object that documents the configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.\n\n\n\n\ncompatibility\n\n\n\n\nAn optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to \nopt in\n to breaking LaxarJS changes (similarly to the Python \nimport from future\n construct), without harming widgets that do not yet support these changes.\n\n\nIn the past, this was used to opt-in to a new event vocabulary.\n  Right now, there are no upcoming features to be activated here.\n\n\n\n\ncontrols\n\n\n\n\nAn optional list of LaxarJS controls used by this widget.\n  Each control is represented by its path, which may either be relative to the controls-root (usually \napplication/controls\n or resolvable by the module loader (webpack).\n  This allows the LaxarJS runtime to automatically load the modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to \nProviding Controls\n on loading user interface components and their resources in this manner.\n\n\n\n\ntemplateSource\n\n\n\n\nYou can load the template from a different source in order to support a preprocessing syntax such as \nMustache\n or \npug\n.\n  Simply set the \ntemplateSource\n to the respective path relative to the theme folder, such as \nshopping-cart-widget.pug\n and make sure that an appropriate (webpack) loader is installed.\n\n\n\n\nstyleSource\n\n\n\n\nInstead of CSS you can also use \nSCSS\n or \nLESS\n, by providing this entry in the \nwidget.json\n, which must be a path within the theme-folder (for example \nscss/shopping-cart-widget.scss\n).\n  Make sure that you have a (webpack) loader installed to handle the file type of your choice.\n\n\nWidget Services\n\n\nThe widget controller has access to a set of injectable widget services, which are described in detail in the \nmanual on widget services\n.\n\n\nWhen using the integration technology \n\"angular\"\n, these are passed as AngularJS controller injections, along with the AngularJS \n$scope\n.\nThe LaxarJS \nangular adapter\n puts some additional properties on the scope that simplify writing templates and controller logic:\n\n\n\n\n$scope.features\n\n\n\n\nAn alias to the \naxFeatures\n widget service injection, useful for (one-time) template bindings.\n\n\n\n\n$scope.eventBus\n\n\n\n\nAn alias to the \naxEventBus\n widget service injection, for publish/subscribe interaction.\n\n\n\n\n$scope.widget.id\n\n  A unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect \nlabel\n and \ninput\n elements in an HTML form.\n\n\n\n\nIn other integration technologies, an object with these helpers is made available through the \naxContext\n injection.", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widgets-and-activities", 
            "text": "\u00ab return to the manuals  Widgets and activities are the  \"work horse\"  of any LaxarJS application.\nThey make up the bulk of the user interface and provide all client-side application logic.  Preliminary readings:   LaxarJS Core Concepts   If you are already familiar with widgets, and just need a refresher on the  widget.json  descriptor, skip to the  reference section  below.", 
            "title": "Widgets and Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-responsibilities", 
            "text": "Before starting to implement your widget, take a moment to think and delineate its responsibilities.\nYou can do this by phrasing the question:  What goal does this widget help the user to accomplish? \nAre you thinking about a very broadly applicable, technical task such as  \"allow the user to enter a date\"  or  \"allow the user to delete a data row\" ?\nIn this case you might want to implement this functionality as a  control  and use it  within  one or more of your widgets.  Usually, widgets correspond to significant areas of the screen and are composed of multiple controls.\nThey are built with a  specific user-goal  in mind, such as  \"allow the user to book a flight\"  or  \"allow the user to review shopping cart contents\" .\nIf widgets are made too small and too generic, page definitions will be confusing and the widget configuration options become unwieldy.\nAs a rule of thumb, only very complex pages should contain more than a about a dozen widgets.\nAnd who wants to have very complex pages anyway?", 
            "title": "Widget Responsibilities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#when-to-use-activities", 
            "text": "Activities are  \"invisible widgets\"  that are used to  fetch and manage application resources .\nWithin the page, they may represent a REST API or a data store, fetching resources and performing relevant service calls (such as a form submission) upon action request.\nIf you are familiar with AngularJS, you might recognize that activities perform a role similar to AngularJS  services .\nThe advantage over services is that using activities puts the  page author  in control over instantiation and configuration:\nIndividual widget instances may each be connected to their own activity instance, or share an event bus topic with a single instance.  Activities may also serve as a  mediator  between widgets that use mutually incompatible event vocabularies (such as different resource formats).\nThis may happen when integrating a widget from a third party into an application.", 
            "title": "When to use Activities"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#integration-technologies", 
            "text": "LaxarJS serves as a  middleware layer  that allows you to organize and connect isolated front end components to form an application.\nHowever, it has no say in how the individual widgets and their UI are implemented.\nInstead it tries to support you in using readily available frameworks such as React, Vue.JS and Angular.\nTo integrate widgets that were created in different UI technologies, a piece of glue code is needed, the so-called  integration technology adapter .  The only adapter included with LaxarJS Core is the adapter for the integration technology  \"plain\" , which does not rely on any specific framework, but leaves it up to the widget author to choose what (if any) supporting libraries should be loaded by the widget.\nThere is a dedicated  manual on the  \"plain\"  adapter .  Another adapter offered by the LaxarJS project is the  laxar-angular-adapter  supporting the integration technology  \"angular\" , meaning AngularJS v1.\nBecause  \"angular\"  was the built-in technology for LaxarJS v1 and many developers are familiar with its basics, it is still used frequently throughout the examples in this documentation.", 
            "title": "Integration Technologies"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#combining-integration-technologies", 
            "text": "You are encouraged to evaluate different integration technologies for use in your project, especially if you are starting from scratch\nFor now, the LaxarJS project provides adapters for the technologies  vue ,  angular  (1) ,  react ,  and  angular2 .\nOnce familiar with the basics, feel free to  create your own adapter .  However, keep in mind that each integration technology adds to your overall application bundle size, impacting application load time and memory consumption.\nWhile mixing three view frameworks may be fine for an intranet application, online applications should generally aim for using a single integration technology, or maybe two technologies during a framework transition -- mobile users will thank you for it!\nOf course,  \"plain\"  is always free and does not weigh in here.\nObviously, this should always be your first choice when implementing an activity.", 
            "title": "Combining Integration Technologies"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#how-to-create-a-widget", 
            "text": "The easiest way to create a widget is to use the  LaxarJS 2 Yeoman generator .\nCheck out the  README  on how to obtain it, and how to use it for creating an application.  To create a widget with the generator simply run the following in the root directory of your application:  yo laxarjs2:widget  After answering all questions asked by the generator, the widget will be create in a sub-directory having its name, within the default directory for widgets (which is  application/widgets/ ).\nFor example, the sources for a widget named  shopping-cart-widget , which is used as an example throughout this manual, can be found in the sub-directory  application/widgets/shopping-cart-widget .  Alternatively, it's possible to choose a different directory for the widget sources by creating that directory yourself and navigating there before calling the widget generator.\nKeep in mind however, that this directory has to be a sub-directory of the application directory, and that webpack needs to be configured to search for widgets there as well.\nTo change the default widget root, you can create a file  laxar.config.js  in your application directory, and use the export  path.widgets  to override the widget root.\nWebpack will then try to load widgets from there instead of  application/widgets/ .\nHaving multiple directories for widgets is possible by  adding the relevant directories to the module resolution directories , but this is out of scope of this manual.  To create a widget in a custom directory, start by creating a sub-directory for your new widget within the LaxarJS application.\nThe last component of the widget path is the so-called  widget directory , which uses the name of the widget itself.\nThe widget name must be unique throughout an application and should be written in lower case letters with components separated by dashes.\nWidget names always end in  -widget  whereas activities always end in  -activity .  To create the actual widget, run:  cd  my-custom-widget-directory/shopping-cart-widget\nyo laxarjs2:widget  In the following steps, it is assumed that you used the widget name  shopping-cart-widget  as above.", 
            "title": "How to Create a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files", 
            "text": "A newly created widget contains the following files:   widget.json   This  widget descriptor  contains meta-data about your widget that is used by the LaxarJS framework.\n  The descriptor contains the name of the widget and specifies both integration type ( \"widget\"  or  \"activity\" ) and integration technology (such as  \"angular\" ,  \"react\"  or  something else ).\n  Finally, the descriptor allows to describe  configuration options  of your widget features using a JSON schema, so that configuration will be validated automatically.   shopping-cart-widget.js   The  business logic  of your shopping cart (like calculating a total or changing item quantities) as a JavaScript module.\n  The precise contents of the widget module depend on the integration technology used by your widget.\n  Usually, it exports either a class constructor, or a plain factory function to create the widget instance.\n  When a widget is instantiated by the LaxarJS runtime, it is passed a set of  widget services  including the  event bus , which allows for communication with other widget instances.  Note that the file extension can also vary depending on the integration technology.\n  For example widgets written using the  \"vue\"  integration technology will have  .vue  as extension while  \"react\"  widgets will use  .jsx .   default.theme/shopping-cart-widget.html   The  HTML template  defining the  appearance  of your widget.\n  Again, the integration technology determines the syntax that is supported in the template, or if the template is even integrated into the controller source file and hence not present at all.\n  When your widget is used on a page, LaxarJS will load this automatically and bind it to your widget controller's scope.\n  The  Bootstrap CSS  classes are made available by the LaxarJS  default.theme  to facilitate uniform styling across widgets.\n  If Bootstrap does not suit you, feel free to use a different framework (or none at all) in  your own theme , but keep in mind that this limits opportunities for widget reuse.\n  Similarly to controllers, all widget templates will be bundled within a single JSON file when your application is packaged for release.   default.theme/css/shopping-cart-widget.css   Widget-specific  style definitions .\n  Most of the time, your widget is fine just using CSS style definitions from the global application theme.\n  In this case, it can do completely without CSS folders.\n  Sometimes though, you have style definitions which are widget-specific (such as CSS animations) and should not be part of the global theme.\n  If your widget has its own CSS file, LaxarJS will include it within the CSS bundle when the widget is used in an application.   package.json   (optional)   This file specifies the  dependencies  of your widget for use with  npm .\n  If you want to version and package you widget as a standalone component for use in multiple applications, this is the recommended way to describe the widget and its dependencies.   webpack.config.js   (optional)   Webpack configuration for this widget.\n  The main purpose of webpack in a widget context is to help when  writing widget specs , but it can also create a bundle of your widget and its own dependencies.  LaxarJS supports to change the appearance of an existing widget by overriding its template or its CSS styles from within a custom  theme .\nIt is also possible to put shared style definitions (CSS classes and SCSS variables) as well as shared assets like fonts and images into that theme.\nTo get started with some simple styling, you do not have to concern yourself with themes or SCSS.\nHowever they are very useful for adapting widgets to different applications and web sites.\nRead  more about themes  once you are familiar with creating and using widgets.", 
            "title": "Widget Files"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-files-for-testing", 
            "text": "The sub folder  spec  contains the widget spec test and, possibly associated resources.\nWhile we recommend writing tests for your widget, note that the spec folder is not required.\nNone of these files are loaded during regular application runtime.   spec/shopping-cart-widget.spec.js   This should be a  Jasmine 2  spec test.\n  If you used the LaxarJS generator to setup your application including configuration for karma and webpack, this spec can be run on the command-line using  karma , or as an interactive HTML test in the browser, by using the  webpack-jasmine-html-runner-plugin .  For projects that were generated using the Yeoman generator for LaxarJS, you can start the karma test-runner for your widgets using  npm test .", 
            "title": "Widget Files for Testing"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#implementing-a-controller", 
            "text": "To write the controller for your widget, you will need to implement some business logic.\nFor a very simple shopping cart this means    summing the contents of the cart    increasing or decreasing the quantity of individual positions within the cart.    Throughout this example, we will be using the  angular  integration technology (AngularJS v1), as it is familiar to developers coming from LaxarJS v1.\nDifferent integration technologies should work in a similar fashion.\nFor more information on the AngularJS integration, consult the  angular adapter documentation .  The Yeoman generator has already created an empty controller along with some AngularJS infrastructure (module and injections).\nFor a shopping cart,  this  might be an appropriate starting implementation with some dummy data:  import   *   as   ng   from   angular ;  Controller . $inject   =   [   $scope   ];  function   Controller (   $scope   )   { \n    $scope . model   =   [ \n       {   label :   Dairy Dreams ,   price :   5.25 ,   amount :   1   }, \n       {   label :   Milky Mocha ,   price :   12.75 ,   amount :   3   }, \n       {   label :   Freezing Frapp\u00e9 ,   price :   18.25 ,   amount :   1   } \n    ]; \n\n    $scope . increment   =   item   =   { \n       ++ item . amount ; \n    }; \n\n    $scope . decrement   =   item   =   { \n       item . amount   =   Math . max (   0 ,   item . amount   -   1   ); \n    }; \n\n    $scope . total   =   rows   =   rows . reduce ( \n       ( total ,   item )   =   total   +   item . price   *   item . amount , \n       0 \n    );  }  export   const   name   =   ng . module (   shoppingCartWidget ,   []   ) \n    . controller (   ShoppingCartWidgetController   ). name ;   The adapter for the integration technology  \"angular\"  makes it possible for a widget controller in LaxarJS to work just like any other AngularJS controller.\nOf course, things will get more interesting once you use the event bus to receive shopping cart contents from somewhere else, or to signal that an order should be placed.", 
            "title": "Implementing a Controller"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#creating-a-template", 
            "text": "The purpose of creating an HTML template is to provide your widget with an appearance on the screen.\nFor anyone familiar with Bootstrap and AngularJS, most of this should not be a surprise:  h4   ng-bind-html = features.headline.htmlText / h4  table   class = table \n    thead \n    tr \n       th Beverage / th \n       th   class = cart-amount Price / th \n       th   class = cart-price Amount / th \n       th / th \n    / tr \n    / thead \n    tfoot \n    tr \n       th   colspan = 3   class = cart-price {{ total( model ) }} / th \n       th / th \n    / tr \n    / tfoot \n    tr   ng-repeat = item in model \n       td {{ item.label }} / td \n       td   class = cart-amount {{ item.amount }} / td \n       td   class = cart-price {{ item.price }} / td \n       td \n          button   ng-click = decrement( item )   class = btn btn-xs \n             i   class = fa fa-minus   / / button \n          button   ng-click = increment( item )   class = btn btn-xs \n             i   class = fa fa-plus   / / button \n       / td \n    / tr  / table   Note that the LaxarJS runtime will wrap the DOM of each widget within a single DIV container.\nThe scope of the template is the same as for the controller so that  model ,  decrement ,  increment  and  total  will be available upon template instantiation.\nThe  features  property used within the headline comes from the  widget configuration , which is described below.", 
            "title": "Creating a Template"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#adding-some-style", 
            "text": "A widget may be styled using CSS, or its more fancy variants such as LESS or SCSS.\nTo keep things simple, you can ignore SCSS and themes for now and simply write a CSS file for your widget, in our case under  default.theme/css/shopping-cart-widget.css .\nOnce you are familiar with the basics, read the article on  creating themes  for more information.  Thanks to Bootstrap CSS, this widget does not require a lot of fancy styling:  . shopping-cart-widget   . cart-amount ,  . shopping-cart-widget   . cart-price   { \n    text-align :   right ;  }   For best encapsulation, selectors should be prefixed with the widget class ( .shopping-cart-widget ) as shown here.\nLaxarJS automatically adds this class to the widget container, so there is no need to specify it in the widget template.\nIt is also recommended to prefix custom CSS classes as shown here ( cart-amount ,  cart-price ), just as you would prefix custom HTML elements or attributes.\nThis makes widget styles more robust against changes in Bootstrap or other third party CSS.", 
            "title": "Adding Some Style"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#configuration-options", 
            "text": "When looking at the template, you might have wondered where the  features.headline.htmlText  came from.\nThis is a  feature configuration  option of our widget:\nWe want to be able to control the headline text for each instance of our widget.\nFor this reason, we specify a configuration option by adding a feature entry to the  widget.json :  { \n    name :   shopping-cart-widget , \n    description :   Allows Users to Review and Modify Purchase Items , \n\n    integration:   { \n       technology :   angular , \n       type :   widget \n    }, \n\n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          headline :   { \n             type :   object , \n             properties :   { \n                htmlText :   { \n                   type :   string , \n                   description :   the HTML headline content \n                } \n             } \n          } \n       } \n    }  }   The  widget features  are a  JSON schema  document that is used by LaxarJS to verify pages.\nIt contains a property for each configurable feature, and it also allows to specify default values as needed.\nThis makes it easy to provide self-documenting customization options for your widget.  Note that LaxarJS deviates from standard JSON schema in two respects:    \"additionalProperties\": false  is default for all schemas of  \"type\": \"object\" \n  This helps to catch typing errors.    \"format\"  allows for the LaxarJS specific value  \"topic\" , and checks it to validate event topics.\n  See the  manual on events  for details on event topic syntax.    defaults for features (first level of widget/composition schema) are inferred if they are of type  \"array\"  or  \"object\" .\n  This eliminates the need to repeat nested defaults on the feature-level.    Note that using schemas is  optional :\nIf a widget descriptor does not specify a schema, any configuration will be considered valid and passed to the widget controller, which can be useful for prototyping.\nHowever, it is strongly recommended to add a schema before releasing a widget or putting it into production, if only to  document  the available configuration.  See the  reference section  for a reference of the widget descriptor.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#checking-out-the-result", 
            "text": "Before we can take a look at the widget, we will need to integrate it into the page provided by the application template ( application/pages/page1.json ).  { \n    layout :   one-column , \n\n    areas :   { \n       activities :   [], \n       header :   [], \n       content :   [ \n           { \n              widget :   shopping-cart-widget , \n              features :   { \n                 headline :   { \n                    htmlText :   My Shopping Cart \n                 } \n              } \n           } \n       ], \n       footer :   [] \n    }  }   I you would like to know more, there is a dedicated manual to learn more about  writing pages .  Now we can start the  webpack-dev-server  from the application root:  npm install  # if you have not already \nnpm start  Navigate to  http://localhost:8080/debug.html  to admire the fruits of your labor:   Now that you have learned the basics in  creating  widgets, take a closer look at widget  testing.", 
            "title": "Checking out the Result"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#testing-a-widget", 
            "text": "One of the major goals of LaxarJS is to simplify the development  and testing  of isolated components.\nFor this reason, a basic widget test has already been prepared when using  yo laxarjs2:widget .", 
            "title": "Testing a Widget"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#writing-spec-tests", 
            "text": "For testing widgets and activities in isolation, we recommend to use the library  LaxarJS Mocks , which allows to setup a test bed for widgets that were created in any integration technology.\nThere you'll also find manuals and  an introduction  on how to test widgets in isolation.", 
            "title": "Writing Spec-Tests"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#running-the-test", 
            "text": "The  LaxarJS Mocks Setup Instructions  explain how to run widget tests from the command line using karma, or interactively using a generated HTML test runner.\nHopefully this makes it simple to set up continuous testing for your application.", 
            "title": "Running the Test"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#laxarjs-widget-reference", 
            "text": "Building on top of the basics covered so far, sometimes it is helpful to know about all the options available to widget authors.\nThis section covers the details of the widget specification format and the properties available on the  $scope  in case of an AngularJS widget.", 
            "title": "LaxarJS Widget Reference"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-descriptor-format", 
            "text": "Each widget has a  widget.json  file which is also called  widget descriptor .\nLaxarJS contains a  widget schema definition  that defines the exact format of this file.\nThese are the most important widget properties:   name   This required field contains the name of the widget, used to find its implementation module, template and stylesheet. The name must match the spelling and case of the module name (minus  .js  extension) exactly.   description   What this widget is about.\n  Ideally, this contains the main  user-goal  mentioned in the first section.   integration   An object with keys  type  and  technology  specifying whether this is an  activity  or a  widget , and the technology the widget's controller is implemented in.\n  This was already explained  above .   features   The widget features.\n  This is an optional (but highly recommended) JSON schema object that documents the configurable widget features.\n  For each widget instance used on a page, LaxarJS will check the feature configuration of that instance against this schema.\n  This also allows to provide default values for configuration options.   compatibility   An optional list of new LaxarJS features that this widget is compatible with.\n  It allows individual widgets to  opt in  to breaking LaxarJS changes (similarly to the Python  import from future  construct), without harming widgets that do not yet support these changes.  In the past, this was used to opt-in to a new event vocabulary.\n  Right now, there are no upcoming features to be activated here.   controls   An optional list of LaxarJS controls used by this widget.\n  Each control is represented by its path, which may either be relative to the controls-root (usually  application/controls  or resolvable by the module loader (webpack).\n  This allows the LaxarJS runtime to automatically load the modules and CSS styles associated with these controls whenever your widget is used.\n  Refer to  Providing Controls  on loading user interface components and their resources in this manner.   templateSource   You can load the template from a different source in order to support a preprocessing syntax such as  Mustache  or  pug .\n  Simply set the  templateSource  to the respective path relative to the theme folder, such as  shopping-cart-widget.pug  and make sure that an appropriate (webpack) loader is installed.   styleSource   Instead of CSS you can also use  SCSS  or  LESS , by providing this entry in the  widget.json , which must be a path within the theme-folder (for example  scss/shopping-cart-widget.scss ).\n  Make sure that you have a (webpack) loader installed to handle the file type of your choice.", 
            "title": "Widget Descriptor Format"
        }, 
        {
            "location": "/manuals/widgets_and_activities/#widget-services", 
            "text": "The widget controller has access to a set of injectable widget services, which are described in detail in the  manual on widget services .  When using the integration technology  \"angular\" , these are passed as AngularJS controller injections, along with the AngularJS  $scope .\nThe LaxarJS  angular adapter  puts some additional properties on the scope that simplify writing templates and controller logic:   $scope.features   An alias to the  axFeatures  widget service injection, useful for (one-time) template bindings.   $scope.eventBus   An alias to the  axEventBus  widget service injection, for publish/subscribe interaction.   $scope.widget.id \n  A unique identifier for this widget within the page.\n  You can use it to generate unique DOM IDs, for example to connect  label  and  input  elements in an HTML form.   In other integration technologies, an object with these helpers is made available through the  axContext  injection.", 
            "title": "Widget Services"
        }, 
        {
            "location": "/manuals/visibility_events/", 
            "text": "Working with Visibility Events\n\n\n\u00ab return to the manuals\n\n\nVisibility events help to improve performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\nEvents and Publish/Subscribe\n\n\nWriting Pages\n\n\n\n\nNote that while this manual is rather longish, there is a \nTL;DR\n at the bottom.\n\n\nWhy Visibility Events?\n\n\nSome widgets perform \nexpensive\n operations such as:\n\n\n\n\nloading and/or display of large amounts of data\n\n\nloading and/or rendering large images and/or movies\n\n\nusing expensive controls for things like charts, animations etc.\n\n\nmeasuring DOM-elements for parameterized animations\n\n\nproviding \nwidget areas\n which may in turn host expensive widgets.\n\n\n\n\nIf a widget does one or more expensive thing, it should only do so while the widget itself is \nvisible\n to the user.\nFrequently, widgets are \nhidden\n from the user, on page entry or afterwards, due to being nested:\n\n\n\n\nwithin an invisible (closed) popup/popover\n\n\nwithin an invisible accordion area\n\n\nwithin an invisible tab area\n\n\nwithin an invisible show/hide-area.\n\n\n\n\nThe so-called \nvisibility events\n help widgets to determine whether their contents may be seen by the user.\n\n\nIf a visibility event tells a widget that it is \nhidden\n, the widget may stop performing any expensive operations.\nIf another visibility event tells a widget that it is \nvisible\n (again), that widget may not necessarily be within the visible portion of the page at that time, but might be scrolled into view at any moment.\n\n\nCaveat\n\n\nAs with all performance optimizations, be careful not to optimize overly eagerly.\nFirst, LaxarJS performs several optimizations automatically as outlined below.\nAlso, visibility events may complicate your widget implementations unnecessarily, especially in small applications.\n\n\nHowever, unfortunately optimization often \nis\n necessary: client side web-applications sometimes tend to be slow to load or to feel sluggish, especially on mobile devices.\nIf you are not satisfied with your application's performance, try to identify the heavy hitting widgets in you application and to control their behavior first.\nAlso, make sure that visibility event handling can actually help you:\nIf there are activities on your page causing tons of REST-requests, chances are that optimizing based on visibility may not help at all.\n\n\nHandling Visibility Events\n\n\nAn initial set of visibility events is published on page entry by the LaxarJS runtime, after \nbeginLifecycleRequest\n but before \ndidNavigate\n. Widgets may subsequently publish their own visibility events to signal changes to areas that they provide.\nThese changes are then propagated to nested widget areas by the runtime.\n\n\nThe following section will explain how widgets can access and utilize visibility information.\nAfterwards, details follow on \ncontrolling\n visibility through events.\n\n\nAutomatic Handling\n\n\nThe LaxarJS runtime maintains a internal visibility status flag for each widget and for each area.\nEven for the widgets that do not care about visibility at all (the majority), the runtime uses this information to determine when the widget DOM is prepared and added to the page DOM, since this may be an expensive process itself.\nWith AngularJS for example, widget HTML must be compiled and linked, creating all nested directive instances.\n\n\nNote that widget DOM is \nnot destroyed\n again after the initial attach, until the page is left by the user.\nIf a widget uses a template with a large number of bindings, it may be beneficial to \ncut off\n these bindings when invisible, for example by using \nngIf\n in an AngularJS widget (next section).\n\n\nManual Handling and Controlling using \naxVisibility\n\n\nWidgets that need to react to changes of their own visibility should use the \naxVisibility\n service injection.\nThe \naxVisibility\n injection allows to register callbacks using \nonShow\n, \nonHide\n, to query the current visibility of a widget using \nisVisible()\n, and event to \ntrack\n the visibility as a property for use in templates (e.g. on the \n$scope\n of AngularJS widgets).\n\n\nFor widgets that provide their own widget areas and need to change their visibility (accordion widgets, popup widgets, tabbing widgets) the \naxVisibility\n service provides an \nupdateAreaVisibility\n method.\n\n\nFor full information, refer to the \naxVisibility API documentation\n.\n\n\nAdvanced: Visibility Propagation over the Event Bus\n\n\nSimilar to how \naxI18n\n is an abstraction over locale change events, the \naxVisibility\n injection encapsulates \narea visibility change events\n.\nUsually you do not have to worry about these details and just use the \naxVisibility\n injection, but read on for a full understanding on how widget visibility is negotiated.\n\n\nWidget controllers can subscribe to \ndidChangeAreaVisibility.{area}.{visible}\n events.\n\n\n\n\n\n\nInstead of \narea\n, the name of the surrounding widget area should be used.\n  The event payload contains the area name as well, under an attribute \n.area\n.\n  For subscribing, this name available from the \naxContext\n injection (AngularJS: \n$scope\n) as attribute \n.widget.area\n.\n\n\n\n\n\n\nThe \nvisible\n value (\ntrue\n or \nfalse\n) confers the new visibility status of the area and is usually not pre-selected when subscribing.\n  The event payload contains this status as well , under a boolean attribute \n.visible\n.\n\n\n\n\n\n\nIn the \nHTML-template\n, \nng-if=\"isVisible\"\n may be used to toggle (portions of) the template based on visibility.\nNot that this is not useful to speed up initial rendering, due to the automatic DOM handling described above.\nThe scope-property \nisVisible\n is maintained by the visibility handler as well, so make sure to have the controller instantiate it.\n\n\nAdvanced: Controlling Visibility through Events\n\n\nMost widgets just need to \nreact\n to visibility changes.\nOther widgets \nprovide\n areas themselves, directly (like the \nlaxar-accordion-widget\n) or through embedded layouts (like the \nlaxar-popup-widget\n).\n\n\nControlling visibility of embedded areas from a widget includes two tasks:\n\n\n\n\n\n\nresponding to visibility requests for the provided widget areas\n\n\n\n\n\n\ntrigger visibility requests to inform the runtime and other widgets after actively changing an area's visibility.\n\n\n\n\n\n\nUsually, \naxVisibility\n should be used to manage this, but let us have a detailed look into both tasks.\n\n\nResponding to Visibility Requests\n\n\nInitially the LaxarJS runtime publishes \nchangeAreaVisibility.{area}.{visible}\n events for all areas directly within top-level areas, asking them to publish a visibility status for any areas provided by them.\n\n\n\n\n\n\nagain, \narea\n is the name of the widget area of interest\n\n\n\n\n\n\nvisible\n is the visibility state of the surrounding area, (\ntrue\n for all regular top-level areas, but \nfalse\n for the generated \naxPopups\n and \naxPopovers\n areas).\n\n\n\n\n\n\nWidgets that want to control their area's visibility may now respond with \ndidChangeAreaVisibility.{area}.{visible}\n events containing the actual new visibility state.\nIf there is no reply for a widget area (for example because the providing widget does not know or care about visibility events), the runtime publishes the \ndidChangeVisibility\n event itself, using the default \nvisible\n value from the request.\nNext, all directly nested areas are processed in the same manner, until \"bottom\" is reached.\n\n\nChanging Visibility of Provided Areas\n\n\nAfter a widget has modified the visibility of its provided areas, it must publish corresponding \nchangeAreaVisibilityRequest\n-Events.\nThe \nvisible\n-parameter of these events must be set to the new target value, taking into account the visibility of the surrounding area.\n\n\nNote that the widget may very well respond to its own visibility requests.\n\n\nThe basic principle of this pattern is similar to that of \ntakeActionRequest\n events:\nEven though the controlling widget knows that it is going to handle the request itself, it still starts the visibility modification with a request.\nThis informs other widgets and especially the runtime of the visibility change.\n\n\nSummary (TL;DR)\n\n\n\n\n\n\nVisibility events help to improve render times and to reduce CPU- and memory-use.\n\n\n\n\n\n\nWidgets may \nreact\n to visibility changes by processing \ndidChangeAreaVisibility\n events, directly or using the \naxVisibility\n injection.\n\n\n\n\n\n\nThe runtime publishes \ndidChangeAreaVisibility\n events before\ndidNavigate\n.\n\n\n\n\n\n\nWidgets that provide areas and that influence the visibility of those areas \nshould control\n visibility by responding to \nchangeAreaVisibilityRequest\n events.\n  Widgets that manage visibility should trigger such requests after initiating a visibility change to any of their provided areas.\n  The \naxVisibility\n injection helps to take care of these tasks as well.", 
            "title": "Working with Visibility Events"
        }, 
        {
            "location": "/manuals/visibility_events/#working-with-visibility-events", 
            "text": "\u00ab return to the manuals  Visibility events help to improve performance by allowing widgets to determine if they are visible to the user or if they currently reside in the background.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities  Events and Publish/Subscribe  Writing Pages   Note that while this manual is rather longish, there is a  TL;DR  at the bottom.", 
            "title": "Working with Visibility Events"
        }, 
        {
            "location": "/manuals/visibility_events/#why-visibility-events", 
            "text": "Some widgets perform  expensive  operations such as:   loading and/or display of large amounts of data  loading and/or rendering large images and/or movies  using expensive controls for things like charts, animations etc.  measuring DOM-elements for parameterized animations  providing  widget areas  which may in turn host expensive widgets.   If a widget does one or more expensive thing, it should only do so while the widget itself is  visible  to the user.\nFrequently, widgets are  hidden  from the user, on page entry or afterwards, due to being nested:   within an invisible (closed) popup/popover  within an invisible accordion area  within an invisible tab area  within an invisible show/hide-area.   The so-called  visibility events  help widgets to determine whether their contents may be seen by the user.  If a visibility event tells a widget that it is  hidden , the widget may stop performing any expensive operations.\nIf another visibility event tells a widget that it is  visible  (again), that widget may not necessarily be within the visible portion of the page at that time, but might be scrolled into view at any moment.", 
            "title": "Why Visibility Events?"
        }, 
        {
            "location": "/manuals/visibility_events/#caveat", 
            "text": "As with all performance optimizations, be careful not to optimize overly eagerly.\nFirst, LaxarJS performs several optimizations automatically as outlined below.\nAlso, visibility events may complicate your widget implementations unnecessarily, especially in small applications.  However, unfortunately optimization often  is  necessary: client side web-applications sometimes tend to be slow to load or to feel sluggish, especially on mobile devices.\nIf you are not satisfied with your application's performance, try to identify the heavy hitting widgets in you application and to control their behavior first.\nAlso, make sure that visibility event handling can actually help you:\nIf there are activities on your page causing tons of REST-requests, chances are that optimizing based on visibility may not help at all.", 
            "title": "Caveat"
        }, 
        {
            "location": "/manuals/visibility_events/#handling-visibility-events", 
            "text": "An initial set of visibility events is published on page entry by the LaxarJS runtime, after  beginLifecycleRequest  but before  didNavigate . Widgets may subsequently publish their own visibility events to signal changes to areas that they provide.\nThese changes are then propagated to nested widget areas by the runtime.  The following section will explain how widgets can access and utilize visibility information.\nAfterwards, details follow on  controlling  visibility through events.", 
            "title": "Handling Visibility Events"
        }, 
        {
            "location": "/manuals/visibility_events/#automatic-handling", 
            "text": "The LaxarJS runtime maintains a internal visibility status flag for each widget and for each area.\nEven for the widgets that do not care about visibility at all (the majority), the runtime uses this information to determine when the widget DOM is prepared and added to the page DOM, since this may be an expensive process itself.\nWith AngularJS for example, widget HTML must be compiled and linked, creating all nested directive instances.  Note that widget DOM is  not destroyed  again after the initial attach, until the page is left by the user.\nIf a widget uses a template with a large number of bindings, it may be beneficial to  cut off  these bindings when invisible, for example by using  ngIf  in an AngularJS widget (next section).", 
            "title": "Automatic Handling"
        }, 
        {
            "location": "/manuals/visibility_events/#manual-handling-and-controlling-using-axvisibility", 
            "text": "Widgets that need to react to changes of their own visibility should use the  axVisibility  service injection.\nThe  axVisibility  injection allows to register callbacks using  onShow ,  onHide , to query the current visibility of a widget using  isVisible() , and event to  track  the visibility as a property for use in templates (e.g. on the  $scope  of AngularJS widgets).  For widgets that provide their own widget areas and need to change their visibility (accordion widgets, popup widgets, tabbing widgets) the  axVisibility  service provides an  updateAreaVisibility  method.  For full information, refer to the  axVisibility API documentation .", 
            "title": "Manual Handling and Controlling using axVisibility"
        }, 
        {
            "location": "/manuals/visibility_events/#advanced-visibility-propagation-over-the-event-bus", 
            "text": "Similar to how  axI18n  is an abstraction over locale change events, the  axVisibility  injection encapsulates  area visibility change events .\nUsually you do not have to worry about these details and just use the  axVisibility  injection, but read on for a full understanding on how widget visibility is negotiated.  Widget controllers can subscribe to  didChangeAreaVisibility.{area}.{visible}  events.    Instead of  area , the name of the surrounding widget area should be used.\n  The event payload contains the area name as well, under an attribute  .area .\n  For subscribing, this name available from the  axContext  injection (AngularJS:  $scope ) as attribute  .widget.area .    The  visible  value ( true  or  false ) confers the new visibility status of the area and is usually not pre-selected when subscribing.\n  The event payload contains this status as well , under a boolean attribute  .visible .    In the  HTML-template ,  ng-if=\"isVisible\"  may be used to toggle (portions of) the template based on visibility.\nNot that this is not useful to speed up initial rendering, due to the automatic DOM handling described above.\nThe scope-property  isVisible  is maintained by the visibility handler as well, so make sure to have the controller instantiate it.", 
            "title": "Advanced: Visibility Propagation over the Event Bus"
        }, 
        {
            "location": "/manuals/visibility_events/#advanced-controlling-visibility-through-events", 
            "text": "Most widgets just need to  react  to visibility changes.\nOther widgets  provide  areas themselves, directly (like the  laxar-accordion-widget ) or through embedded layouts (like the  laxar-popup-widget ).  Controlling visibility of embedded areas from a widget includes two tasks:    responding to visibility requests for the provided widget areas    trigger visibility requests to inform the runtime and other widgets after actively changing an area's visibility.    Usually,  axVisibility  should be used to manage this, but let us have a detailed look into both tasks.", 
            "title": "Advanced: Controlling Visibility through Events"
        }, 
        {
            "location": "/manuals/visibility_events/#responding-to-visibility-requests", 
            "text": "Initially the LaxarJS runtime publishes  changeAreaVisibility.{area}.{visible}  events for all areas directly within top-level areas, asking them to publish a visibility status for any areas provided by them.    again,  area  is the name of the widget area of interest    visible  is the visibility state of the surrounding area, ( true  for all regular top-level areas, but  false  for the generated  axPopups  and  axPopovers  areas).    Widgets that want to control their area's visibility may now respond with  didChangeAreaVisibility.{area}.{visible}  events containing the actual new visibility state.\nIf there is no reply for a widget area (for example because the providing widget does not know or care about visibility events), the runtime publishes the  didChangeVisibility  event itself, using the default  visible  value from the request.\nNext, all directly nested areas are processed in the same manner, until \"bottom\" is reached.", 
            "title": "Responding to Visibility Requests"
        }, 
        {
            "location": "/manuals/visibility_events/#changing-visibility-of-provided-areas", 
            "text": "After a widget has modified the visibility of its provided areas, it must publish corresponding  changeAreaVisibilityRequest -Events.\nThe  visible -parameter of these events must be set to the new target value, taking into account the visibility of the surrounding area.  Note that the widget may very well respond to its own visibility requests.  The basic principle of this pattern is similar to that of  takeActionRequest  events:\nEven though the controlling widget knows that it is going to handle the request itself, it still starts the visibility modification with a request.\nThis informs other widgets and especially the runtime of the visibility change.", 
            "title": "Changing Visibility of Provided Areas"
        }, 
        {
            "location": "/manuals/visibility_events/#summary-tldr", 
            "text": "Visibility events help to improve render times and to reduce CPU- and memory-use.    Widgets may  react  to visibility changes by processing  didChangeAreaVisibility  events, directly or using the  axVisibility  injection.    The runtime publishes  didChangeAreaVisibility  events before didNavigate .    Widgets that provide areas and that influence the visibility of those areas  should control  visibility by responding to  changeAreaVisibilityRequest  events.\n  Widgets that manage visibility should trigger such requests after initiating a visibility change to any of their provided areas.\n  The  axVisibility  injection helps to take care of these tasks as well.", 
            "title": "Summary (TL;DR)"
        }, 
        {
            "location": "/manuals/writing_compositions/", 
            "text": "Writing Compositions\n\n\n\u00ab return to the manuals\n\n\nAlthough inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this may not be sufficient.\n\nCompositions\n are here to help you.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWriting Pages\n\n\n\n\nWhen to Use Compositions\n\n\nOften, a base page \nalmost works\n for all extending pages but some small things need to be adjusted per page, in order to be reused throughout the application.\nAnother scenario is reusing a set of widgets multiple times on a single page, each time with slightly different configuration.\n\n\nComposition Basics\n\n\nAll of this can be achieved by using compositions.\nThe idea behind compositions is that they combine a \nwidget-like interface\n on the outside with the internals of a \npage definition\n.\nThe widget-like interface, including a feature configuration schema, allows compositions to be embedded and parameterized by regular pages, or even by other compositions.\nThe page-like internal structure allows compositions to bundle and pre-configure several widgets and even other compositions.\nA composition definition thus has two basic properties: \nfeatures\n (like a widget) and \nareas\n (like a page).\nA third more advanced property, namely \nmergedFeatures\n, will be explained later.\n\n\nLet us start with a simple \npopup-composition\n:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n,\n\n                     \nformat\n:\n \ntopic\n,\n\n                     \naxRole\n:\n \ninlet\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-popup-widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nfinish\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe syntax of the example should be familiar to authors of widgets and pages, but also exhibits some composition-specific characteristics.\nIf you do not know the \naxRole\n and \nformat\n meta data keywords, you may ignore them, as they are not related to the compositions feature, but only used by development tools.\n\n\nComposition Features\n\n\nFirst there is the \nfeatures\n object that looks just like a features specification from a widget descriptor.\nHere you can define all the features that your composition needs to be configurable by the embedding page.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.\n\n\nComposition Expansion\n\n\nSecondly there is the \nareas\n map and here there is already something noteworthy: The first area is simply named \n.\n.\nAll widgets and compositions within this special area will be \nexpanded in place of each composition instance\n, within all pages embedding the composition.\nSo if we apply the composition above to the \nexample\n previously used in the \nmanual on pages\n, the second item in the area named \ncontent\n will be expanded to a configured instance of the laxar-popup-widget.\n\n\nOther non-prefixed areas (say, \n\"footer\"\n) are simply added to each embedding page, concatenating widget lists where page and composition define areas of the same name.\n\n\nFeature References and Topic Expressions\n\n\nThe two strings \n\"${features.openPopup.onActions}\"\n and \n\"${topic:closeAction}\"\n demonstrate two important features of the composition concept.\nThose strings are expressions, and evaluated by the laxar-loader at build-time, while assembling the complete page from its parts.\nThey are replaced with actual values as follows:\n\n\nThe \n\"${features.openPopup.onActions}\"\n expression is a \nreference to a feature\n defined within the \nfeatures\n object and will be replaced with the value configured by the embedding page.\nApplied to the \nexample\n, this reference will be replaced with the array value \n[ \"next\" ]\n.\n\n\nOn the other hand the \n\"${topic:closeAction}\"\n expression generates a \npage-wide unique event topic\n, a string based on the local identifier \ncloseAction\n.\nThe result could be something like \n\"popupComposition-id0+closeAction\"\n, which is in fact the ID generated for the composition itself, plus the local identifier.\n\n\nThese \ntopic expressions\n prevent naming collisions with topics of the embedding page, other compositions or multiple instances of the same composition within the same page.\nThey should always be used when there is the need to have a topic identifier that is only used within the scope of a composition.\nIn fact, it is considered a best practice for compositions to \nonly use\n either feature references or topic expressions for event topics, to avoid unintended effects and invisible side-channels on the event-bus, caused by sharing regular string topics with the embedding page, or with other compositions.\n\n\nNotice that these expressions must be written inside of string literals to be valid JSON.\nTheir replacement takes place only \nafter\n the JSON structure was evaluated by the laxar-loader, and always based on the full string.\nThus something like \n\"myPrefix${topic:closeAction}\"\n would \nnot\n be expanded when assembling the page and simply be used as is, probably violating some widget schema.\n\n\nThe assembled page thus looks similar to this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout-one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-popup-widget\n,\n\n            \nid\n:\n \npopupComposition-id0-popup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \npopupComposition-id0+closeAction\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopupComposition-id0-popup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \npopupComposition-id0+CloseAction\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nNote how also the id of the exported area was automatically adjusted to \n\"popupComposition-id0-popup.content\"\n to prevent naming clashes.\n\n\nMerged Features\n\n\nIn our example it is currently only possible to close the \nlaxar-popup-widget\n from within itself via an action event published by the \nlaxar-command-bar-widget\n.\nWhat if we additionally would like to close the popup using another action \nfrom outside\n?\nThis is where the concept of \nmerged features\n comes into play.\nMerged features allow us to concatenate feature values from two arrays, where one array is defined as a feature for the composition and the second array is defined in the \nmergedFeatures\n object.\nSyntactically this is achieved via a map under the key \nmergedFeatures\n where the key of each entry is the path to the array in the features and the value is the array to merge this value with.\n\n\nThis should become clear when looking at our adjusted example:\n\n\n{\n\n   \nfeatures\n:\n \n{\n\n      \n$schema\n:\n \nhttp://json-schema.org/draft-04/schema#\n,\n\n      \ntype\n:\n \nobject\n,\n\n      \nproperties\n:\n \n{\n\n         \nopenPopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n,\n\n                     \nformat\n:\n \ntopic\n,\n\n                     \naxRole\n:\n \ninlet\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \nclosePopup\n:\n \n{\n\n            \ntype\n:\n \nobject\n,\n\n            \nproperties\n:\n \n{\n\n               \nonActions\n:\n \n{\n\n                  \ntype\n:\n \narray\n,\n\n                  \ndefault\n:\n \n[],\n\n                  \nitems\n:\n \n{\n\n                     \ntype\n:\n \nstring\n,\n\n                     \nformat\n:\n \ntopic\n,\n\n                     \naxRole\n:\n \ninlet\n\n                  \n}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n}\n\n   \n},\n\n   \nmergedFeatures\n:\n \n{\n\n      \nclosePopup.onActions\n:\n \n[\n \n${topic:closeAction}\n \n]\n\n   \n},\n\n   \nareas\n:\n \n{\n\n      \n.\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-popup-widget\n,\n\n            \nid\n:\n \npopup\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopen\n:\n \n{\n\n                  \nonActions\n:\n \n${features.openPopup.onActions}\n\n               \n},\n\n               \nclose\n:\n \n{\n\n                  \nonActions\n:\n \n${features.closePopup.onActions}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \npopup.content\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nSay hi to the popup\n,\n\n                  \nlevel\n:\n \n4\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nclose\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n,\n\n                  \naction\n:\n \n${topic:closeAction}\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHere we added the possibility to configured close actions for the \nlaxar-popup-widget\n as feature \nclosePopup.onActions\n.\nFor this we then added an entry in the \nmergedFeatures\n map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the \nlaxar-popup-widget\n.\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the \nopenPopup.onActions\n feature.\nFor the configuration of the \nlaxar-command-bar-widget\n nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.\n\n\nAppendix:\n\n\nExemplary page from \nwriting pages\n manual\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout-one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup-composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#writing-compositions", 
            "text": "\u00ab return to the manuals  Although inheritance brings a bit of organization into pages, for bigger applications with many widgets on a page this may not be sufficient. Compositions  are here to help you.  Preliminary readings:   LaxarJS Core Concepts  Writing Pages", 
            "title": "Writing Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#when-to-use-compositions", 
            "text": "Often, a base page  almost works  for all extending pages but some small things need to be adjusted per page, in order to be reused throughout the application.\nAnother scenario is reusing a set of widgets multiple times on a single page, each time with slightly different configuration.", 
            "title": "When to Use Compositions"
        }, 
        {
            "location": "/manuals/writing_compositions/#composition-basics", 
            "text": "All of this can be achieved by using compositions.\nThe idea behind compositions is that they combine a  widget-like interface  on the outside with the internals of a  page definition .\nThe widget-like interface, including a feature configuration schema, allows compositions to be embedded and parameterized by regular pages, or even by other compositions.\nThe page-like internal structure allows compositions to bundle and pre-configure several widgets and even other compositions.\nA composition definition thus has two basic properties:  features  (like a widget) and  areas  (like a page).\nA third more advanced property, namely  mergedFeatures , will be explained later.  Let us start with a simple  popup-composition :  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string , \n                      format :   topic , \n                      axRole :   inlet \n                   } \n                } \n             } \n          } \n       } \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   laxar-popup-widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   [   ${topic:closeAction}   ] \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   laxar-command-bar-widget , \n             features :   { \n                close :   { \n                   finish :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   The syntax of the example should be familiar to authors of widgets and pages, but also exhibits some composition-specific characteristics.\nIf you do not know the  axRole  and  format  meta data keywords, you may ignore them, as they are not related to the compositions feature, but only used by development tools.", 
            "title": "Composition Basics"
        }, 
        {
            "location": "/manuals/writing_compositions/#composition-features", 
            "text": "First there is the  features  object that looks just like a features specification from a widget descriptor.\nHere you can define all the features that your composition needs to be configurable by the embedding page.\nIn this example we simply let the consumer of our composition define the action that will be used to open the popup.", 
            "title": "Composition Features"
        }, 
        {
            "location": "/manuals/writing_compositions/#composition-expansion", 
            "text": "Secondly there is the  areas  map and here there is already something noteworthy: The first area is simply named  . .\nAll widgets and compositions within this special area will be  expanded in place of each composition instance , within all pages embedding the composition.\nSo if we apply the composition above to the  example  previously used in the  manual on pages , the second item in the area named  content  will be expanded to a configured instance of the laxar-popup-widget.  Other non-prefixed areas (say,  \"footer\" ) are simply added to each embedding page, concatenating widget lists where page and composition define areas of the same name.", 
            "title": "Composition Expansion"
        }, 
        {
            "location": "/manuals/writing_compositions/#feature-references-and-topic-expressions", 
            "text": "The two strings  \"${features.openPopup.onActions}\"  and  \"${topic:closeAction}\"  demonstrate two important features of the composition concept.\nThose strings are expressions, and evaluated by the laxar-loader at build-time, while assembling the complete page from its parts.\nThey are replaced with actual values as follows:  The  \"${features.openPopup.onActions}\"  expression is a  reference to a feature  defined within the  features  object and will be replaced with the value configured by the embedding page.\nApplied to the  example , this reference will be replaced with the array value  [ \"next\" ] .  On the other hand the  \"${topic:closeAction}\"  expression generates a  page-wide unique event topic , a string based on the local identifier  closeAction .\nThe result could be something like  \"popupComposition-id0+closeAction\" , which is in fact the ID generated for the composition itself, plus the local identifier.  These  topic expressions  prevent naming collisions with topics of the embedding page, other compositions or multiple instances of the same composition within the same page.\nThey should always be used when there is the need to have a topic identifier that is only used within the scope of a composition.\nIn fact, it is considered a best practice for compositions to  only use  either feature references or topic expressions for event topics, to avoid unintended effects and invisible side-channels on the event-bus, caused by sharing regular string topics with the embedding page, or with other compositions.  Notice that these expressions must be written inside of string literals to be valid JSON.\nTheir replacement takes place only  after  the JSON structure was evaluated by the laxar-loader, and always based on the full string.\nThus something like  \"myPrefix${topic:closeAction}\"  would  not  be expanded when assembling the page and simply be used as is, probably violating some widget schema.  The assembled page thus looks similar to this:  { \n    layout :   popups/layout-one , \n    areas :   { \n       header :   [ \n          { \n             widget :   laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   laxar-command-bar-widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             widget :   laxar-popup-widget , \n             id :   popupComposition-id0-popup , \n             features :   { \n                open :   { \n                   onActions :   [   next   ] \n                }, \n                close :   { \n                   onActions :   [   popupComposition-id0+closeAction   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   laxar-html-display-widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ], \n       popupComposition-id0-popup.content :   [ \n          { \n             widget :   laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   laxar-command-bar-widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   popupComposition-id0+CloseAction \n                } \n             } \n          } \n       ] \n    }  }   Note how also the id of the exported area was automatically adjusted to  \"popupComposition-id0-popup.content\"  to prevent naming clashes.", 
            "title": "Feature References and Topic Expressions"
        }, 
        {
            "location": "/manuals/writing_compositions/#merged-features", 
            "text": "In our example it is currently only possible to close the  laxar-popup-widget  from within itself via an action event published by the  laxar-command-bar-widget .\nWhat if we additionally would like to close the popup using another action  from outside ?\nThis is where the concept of  merged features  comes into play.\nMerged features allow us to concatenate feature values from two arrays, where one array is defined as a feature for the composition and the second array is defined in the  mergedFeatures  object.\nSyntactically this is achieved via a map under the key  mergedFeatures  where the key of each entry is the path to the array in the features and the value is the array to merge this value with.  This should become clear when looking at our adjusted example:  { \n    features :   { \n       $schema :   http://json-schema.org/draft-04/schema# , \n       type :   object , \n       properties :   { \n          openPopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   items :   { \n                      type :   string , \n                      format :   topic , \n                      axRole :   inlet \n                   } \n                } \n             } \n          }, \n          closePopup :   { \n             type :   object , \n             properties :   { \n                onActions :   { \n                   type :   array , \n                   default :   [], \n                   items :   { \n                      type :   string , \n                      format :   topic , \n                      axRole :   inlet \n                   } \n                } \n             } \n          } \n       } \n    }, \n    mergedFeatures :   { \n       closePopup.onActions :   [   ${topic:closeAction}   ] \n    }, \n    areas :   { \n       . :   [ \n          { \n             widget :   laxar-popup-widget , \n             id :   popup , \n             features :   { \n                open :   { \n                   onActions :   ${features.openPopup.onActions} \n                }, \n                close :   { \n                   onActions :   ${features.closePopup.onActions} \n                } \n             } \n          } \n       ], \n       popup.content :   [ \n          { \n             widget :   laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Say hi to the popup , \n                   level :   4 \n                } \n             } \n          }, \n          { \n             widget :   laxar-command-bar-widget , \n             features :   { \n                close :   { \n                   enabled :   true , \n                   action :   ${topic:closeAction} \n                } \n             } \n          } \n       ] \n    }  }   Here we added the possibility to configured close actions for the  laxar-popup-widget  as feature  closePopup.onActions .\nFor this we then added an entry in the  mergedFeatures  map whose value is an array that has the internal generated topic as only item.\nThis enables us to now reference this feature when configuring the  laxar-popup-widget .\nInstead of creating the array with the generated topic here, we can simply reference the feature directly as it is the case for the  openPopup.onActions  feature.\nFor the configuration of the  laxar-command-bar-widget  nothing changed.\nWhen using the composition it is now possible to provide additional close actions, but since we defined an empty array as default for the feature, this is not mandatory.", 
            "title": "Merged Features"
        }, 
        {
            "location": "/manuals/writing_compositions/#appendix", 
            "text": "", 
            "title": "Appendix:"
        }, 
        {
            "location": "/manuals/writing_compositions/#exemplary-page-from-writing-pages-manual", 
            "text": "{ \n    layout :   popups/layout-one , \n    areas :   { \n       header :   [ \n          { \n             widget :   laxar-headline-widget , \n             features :   { \n                headline :   { \n                   i18nHtmlText :   Welcome! , \n                   level :   3 \n                } \n             } \n          } \n       ], \n       content :   [ \n          { \n             widget :   laxar-command-bar-widget , \n             features :   { \n                next :   { \n                   enabled :   true \n                } \n             } \n          }, \n          { \n             composition :   popup-composition , \n             features :   { \n                openPopup :   { \n                   onActions :   [   next   ] \n                } \n             } \n          } \n       ], \n       footer :   [ \n          { \n             widget :   laxar-html-display-widget , \n             features :   { \n                content :   { \n                   resource :   footerTextResource \n                } \n             } \n          } \n       ] \n    }  }", 
            "title": "Exemplary page from writing pages manual"
        }, 
        {
            "location": "/manuals/writing_pages/", 
            "text": "Writing Pages\n\n\n\u00ab return to the manuals\n\n\nPages are written in a declarative fashion using the JSON format.\nThey are defined using JSON objects whose properties will be explained in this document.\n\n\nPreliminary readings:\n\n\n\n\nLaxarJS Core Concepts\n\n\nWidgets and Activities\n\n\n\n\nLayouts and Areas\n\n\nFirst of all, a page should specify the \nlayout\n which defines the available \nwidget areas\n and how they are arranged visually when rendered by the web browser.\nIf a page is intended to be used as a base page for \ninheritance\n, the layout property should be omitted, as it is specified by the inheriting pages.\nOnly one page in an extension chain may define a layout, and deferring this choice to the bottom of the hierarchy increases flexibility.\n\n\nFor each layout, a \ndescriptor\n containing its canonical name is required:\n\n\n// application/layouts/popups/layout-one/layout.json\n\n\n{\n\n   \nname\n:\n \nlayout-one\n\n\n}\n\n\n\n\n\n\nNow let us use the following layout HTML:\n\n\n\n\n!-- application/layouts/popups/layout-one/default.theme/layout-one.html --\n\n\ndiv\n\n   \ndiv\n \nax-widget-area\n=\nheader\n/\ndiv\n\n   \ndiv\n \nax-widget-area\n=\ncontent\n/\ndiv\n\n   \ndiv\n \nax-widget-area\n=\nfooter\n/\ndiv\n\n\n/\ndiv\n\n\n\n\n\n\nThis layout defines three \nwidget areas\n that can be occupied by widgets on the page.\n\n\nConfiguring the layout is done via the \nlayout\n property of the page definition.\nIts value is a relative path within the layouts root (usually \napplication/layouts\n).\nTo fill the available areas, we add another top-level key \nareas\n parallel to \nlayout\n.\nIts value is a map, where each key is the name of a widget area defined in the layout and the values are arrays, that will later contain the widgets to render.\nHaving not added any layouts so far, we thus get the following page file:\n\n\n\n\n{\n\n   \nlayout\n:\n \npopups/layout-one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[],\n\n      \ncontent\n:\n \n[],\n\n      \nfooter\n:\n \n[]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWhen adding widgets to an area, their order determines the order in which the widgets will be rendered in the DOM.\nEach entry in the array is an object that can either reference a widget or a \ncomposition\n.\nIt thus needs to specify either \nwidget\n or \ncomposition\n as key.\nAdditionally an \nid\n property can be provided, which may be useful for debugging and is actually required for widgets providing embedded widget areas such as the  \nlaxar-details-layer-widget\n.\nIf specifying an ID, make sure that it is unique page-wide (even taking into account inheritance).\nFinally it is possible to provide the configuration for features of a widget or a composition under the key \nfeatures\n.\n\n\nHere is the example with a few basic widgets\n\n\n\n\n// application/pages/my-page.json\n\n\n{\n\n   \nlayout\n:\n \npopups/layout-one\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup-composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThe object under \nfeatures\n needs to match the schema of the corresponding widget's \nwidget.json\n descriptor.\nBefore loading a page and its widgets, LaxarJS will validate the configuration provided in the page against the widget's schema and throw an error in case one or more constraints are violated.\nLaxarJS will also fill in defaults specified by the schema.\n\n\nSpecial Purpose Widget Areas\n\n\nEven when using the most basic layout, LaxarJS always provides three special widget areas:\n\n\n\n\n\n\naxActivities\n is meant as a container for any activities on the page. You can put activities into any widget area, but since they cannot actually be rendered, there is no natural place for them. So, by convention they should be added to this area\n\n\n\n\n\n\naxPopups\n is intended as a container for widgets that appear as \nmodal popup windows.\n When such widgets become visible (e.g. upon a relevant action request), they should set the Bootstrap CSS class \nmodal-open\n on the document body. This \"greys out\" the rest of the page, with the popup widget still visible in front.\n\n\n\n\n\n\naxPopovers\n is meant to take up popover-style widgets that adjust their position depending on the currently active element to provide contextual functionality. These widgets appear in front of the page, but behind the \nmodal-open\n layer (if that is visible at the same time).\n\n\n\n\n\n\nEmbedded Layouts\n\n\nThere are use cases where it is not sufficient to reference one single-page layout and place all widgets of a page within that layout.\nSometimes more flexibility is needed.\nFor example, when trying to reuse existing layouts, it may be necessary to embedded another layout within the area of the top-level page layout.\n\n\nTo support this in a hassle-free manner, layouts are first-class citizens within areas, just like widgets or \ncompositions\n.\n\n\n{\n\n   \nlayout\n:\n \npopups/layout-one\n,\n\n   \nareas\n:\n \n{\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nlayout\n:\n \nother_layouts/small_columns\n,\n\n            \nid\n:\n \nembedded\n\n         \n},\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nembedded.left\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nsomeResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nAs seen in the example above, the key \nlayout\n should be used instead of \nwidget\n.\nIts value is - just like with the main \nlayout\n property of a page - the path of a specific layout directory relative to the layouts-root of the application.\nProviding an \nid\n is obligatory for layouts, as it is needed to reference the widget areas defined by the layout.\nUnder the assumption that the layout \nother_layouts/small_columns\n exports a widget area named \nleft\n, we can now insert widgets into it using the area name \nembedded.left\n for it.\n\n\nNote that providing \nfeatures\n to a layout entry does not lead to an error, but is simply ignored.\n\n\nInheritance\n\n\nIn every user interface there are some elements that never change across pages.\nThe easiest way to reuse these parts of a page definition is by \ninheritance.\n\nCommon widgets can be extracted into one or more base pages that have no layout.\nThe base pages can then be \nextended\n by concrete pages, defining the layout necessary to display their contents.\n\n\nValid candidate widgets to put into base pages are application headlines, informational notes in a footer area or activities that provide common tasks for all pages.\nLet us apply this to our example from above and extract the \nlaxar-headline-widget\n into a base page called \nbase-page.json\n.\n\n\n//\n \n//\n \napplication/pages/base-page.json\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nWe now can modify our original page using the keyword \nextends\n that references the base page relatively to the pages-root (usually \napplication/pages\n).\nThe parts already provided by the base page can then be deleted from the extending page:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout-one\n,\n\n   \nextends\n:\n \nbase-page\n,\n\n   \nareas\n:\n \n{\n\n      \ncontent\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-command-bar-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \nnext\n:\n \n{\n\n                  \nenabled\n:\n \ntrue\n\n               \n}\n\n            \n}\n\n         \n},\n\n         \n{\n\n            \ncomposition\n:\n \npopup-composition\n,\n\n            \nfeatures\n:\n \n{\n\n               \nopenPopup\n:\n \n{\n\n                  \nonActions\n:\n \n[\n \nnext\n \n]\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \nfooter\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-html-display-widget\n,\n\n            \nfeatures\n:\n \n{\n\n               \ncontent\n:\n \n{\n\n                  \nresource\n:\n \nfooterTextResource\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nAlso, an extending page can add widgets to an area that already contains widgets from the base page.\nWidgets added by the extending page will be appended to the corresponding area and thus appear in the DOM after the widgets from the base page.\nIf a widget of the extending page needs to appear precisely before a specific widget of the base page, this can be achieved using the keyword \ninsertBeforeId\n.\nFor this to work, it is of course necessary to specify an \nid\n property for the widget in the base page.\n\n\nLet us assume that we would like to add another additional headline in one extending page.\nWe therefore change the base page first and add an ID to the existing headline:\n\n\n{\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \nid\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n               \nheadline\n:\n \n{\n\n                  \ni18nHtmlText\n:\n \nWelcome!\n,\n\n                  \nlevel\n:\n \n3\n\n               \n}\n\n            \n}\n\n         \n}\n\n      \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nHence the page that has the need to add content can reference the given ID using \ninsertBeforeId\n like this:\n\n\n{\n\n   \nlayout\n:\n \npopups/layout-one\n,\n\n   \nextends\n:\n \nbase-page\n,\n\n   \nareas\n:\n \n{\n\n      \nheader\n:\n \n[\n\n         \n{\n\n            \nwidget\n:\n \nlaxar-headline-widget\n,\n\n            \ninsertBeforeId\n:\n \nmainHeadline\n,\n\n            \nfeatures\n:\n \n{\n\n                \nheadline\n:\n \n{\n\n                   \ni18nHtmlText\n:\n \nYou just won one billion dollar!\n\n                \n}\n\n            \n}\n\n         \n}\n\n      \n],\n\n      \ncontent\n:\n \n[\n \n ... some widgets ... \n \n],\n\n      \nfooter\n:\n \n[\n \n ... some widgets ... \n \n]\n\n   \n}\n\n\n}\n\n\n\n\n\n\nThis is all one needs to build basic pages for LaxarJS.\n\n\nDue to the intentional simplicity, inheritance is a somewhat limited way to reuse page definitions.\nIt might become necessary to split pages into smaller, possibly reusable chunks, which is the task compositions where designed for.\nSo if the need arises, read on in the manual for \nwriting compositions\n.", 
            "title": "Writing Pages"
        }, 
        {
            "location": "/manuals/writing_pages/#writing-pages", 
            "text": "\u00ab return to the manuals  Pages are written in a declarative fashion using the JSON format.\nThey are defined using JSON objects whose properties will be explained in this document.  Preliminary readings:   LaxarJS Core Concepts  Widgets and Activities", 
            "title": "Writing Pages"
        }
    ]
}